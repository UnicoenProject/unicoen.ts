/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 109);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function arrayToString(a) {
    return "[" + a.join(", ") + "]";
}

String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));

String.prototype.hashCode = function () {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i,
        key = this.toString();

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = String.prototype.seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;

        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
        case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
            k1 ^= (key.charCodeAt(i) & 0xff);

            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
};

function standardEqualsFunction(a, b) {
    return a.equals(b);
}

function standardHashCodeFunction(a) {
    return a.hashCode();
}

function Set(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Set.prototype, "length", {
    get: function () {
        var l = 0;
        for (var key in this.data) {
            if (key.indexOf("hash_") === 0) {
                l = l + this.data[key].length;
            }
        }
        return l;
    }
});

Set.prototype.add = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
        values.push(value);
        return value;
    } else {
        this.data[key] = [value];
        return value;
    }
};

Set.prototype.contains = function (value) {
    return this.get(value) != null;
};

Set.prototype.get = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
    }
    return null;
};

Set.prototype.values = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};

Set.prototype.toString = function () {
    return arrayToString(this.values());
};

function BitSet() {
    this.data = [];
    return this;
}

BitSet.prototype.add = function (value) {
    this.data[value] = true;
};

BitSet.prototype.or = function (set) {
    var bits = this;
    Object.keys(set.data).map(function (alt) {
        bits.add(alt);
    });
};

BitSet.prototype.remove = function (value) {
    delete this.data[value];
};

BitSet.prototype.contains = function (value) {
    return this.data[value] === true;
};

BitSet.prototype.values = function () {
    return Object.keys(this.data);
};

BitSet.prototype.minValue = function () {
    return Math.min.apply(null, this.values());
};

BitSet.prototype.hashCode = function () {
    var hash = new Hash();
    hash.update(this.values());
    return hash.finish();
};

BitSet.prototype.equals = function (other) {
    if (!(other instanceof BitSet)) {
        return false;
    }
    return this.hashCode() === other.hashCode();
};

Object.defineProperty(BitSet.prototype, "length", {
    get: function () {
        return this.values().length;
    }
});

BitSet.prototype.toString = function () {
    return "{" + this.values().join(", ") + "}";
};

function Map(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Map.prototype, "length", {
    get: function () {
        var l = 0;
        for (var hashKey in this.data) {
            if (hashKey.indexOf("hash_") === 0) {
                l = l + this.data[hashKey].length;
            }
        }
        return l;
    }
});

Map.prototype.put = function (key, value) {
    var hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key)) {
                var oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
        }
        entries.push({key:key, value:value});
        return value;
    } else {
        this.data[hashKey] = [{key:key, value:value}];
        return value;
    }
};

Map.prototype.containsKey = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return true;
        }
    }
    return false;
};

Map.prototype.get = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return entry.value;
        }
    }
    return null;
};

Map.prototype.entries = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};


Map.prototype.getKeys = function () {
    return this.entries().map(function(e) {
        return e.key;
    });
};


Map.prototype.getValues = function () {
    return this.entries().map(function(e) {
            return e.value;
    });
};


Map.prototype.toString = function () {
    var ss = this.entries().map(function(entry) {
        return '{' + entry.key + ':' + entry.value + '}';
    });
    return '[' + ss.join(", ") + ']';
};


function AltDict() {
    this.data = {};
    return this;
}


AltDict.prototype.get = function (key) {
    key = "k-" + key;
    if (key in this.data) {
        return this.data[key];
    } else {
        return null;
    }
};

AltDict.prototype.put = function (key, value) {
    key = "k-" + key;
    this.data[key] = value;
};

AltDict.prototype.values = function () {
    var data = this.data;
    var keys = Object.keys(this.data);
    return keys.map(function (key) {
        return data[key];
    });
};

function DoubleDict() {
    return this;
}

function Hash() {
    this.count = 0;
    this.hash = 0;
    return this;
}

Hash.prototype.update = function () {
    for(var i=0;i<arguments.length;i++) {
        var value = arguments[i];
        if (value == null)
            continue;
        if(Array.isArray(value))
            this.update.apply(value);
        else {
            var k = 0;
            switch (typeof(value)) {
                case 'undefined':
                case 'function':
                    continue;
                case 'number':
                case 'boolean':
                    k = value;
                    break;
                case 'string':
                    k = value.hashCode();
                    break;
                default:
                    value.updateHashCode(this);
                    continue;
            }
            k = k * 0xCC9E2D51;
            k = (k << 15) | (k >>> (32 - 15));
            k = k * 0x1B873593;
            this.count = this.count + 1;
            var hash = this.hash ^ k;
            hash = (hash << 13) | (hash >>> (32 - 13));
            hash = hash * 5 + 0xE6546B64;
            this.hash = hash;
        }
    }
}

Hash.prototype.finish = function () {
    var hash = this.hash ^ (this.count * 4);
    hash = hash ^ (hash >>> 16);
    hash = hash * 0x85EBCA6B;
    hash = hash ^ (hash >>> 13);
    hash = hash * 0xC2B2AE35;
    hash = hash ^ (hash >>> 16);
    return hash;
}

function hashStuff() {
    var hash = new Hash();
    hash.update.apply(arguments);
    return hash.finish();
}

DoubleDict.prototype.get = function (a, b) {
    var d = this[a] || null;
    return d === null ? null : (d[b] || null);
};

DoubleDict.prototype.set = function (a, b, o) {
    var d = this[a] || null;
    if (d === null) {
        d = {};
        this[a] = d;
    }
    d[b] = o;
};


function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t")
         .replace(/\n/g, "\\n")
         .replace(/\r/g, "\\r");
    if (escapeSpaces) {
        s = s.replace(/ /g, "\u00B7");
    }
    return s;
}

function titleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1);
    });
};

function equalArrays(a, b)
{
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a == b)
        return true;
    if (a.length != b.length)
        return false;
    for (var i = 0; i < a.length; i++) {
        if (a[i] == b[i])
            continue;
        if (!a[i].equals(b[i]))
            return false;
    }
    return true;
};

exports.Hash = Hash;
exports.Set = Set;
exports.Map = Map;
exports.BitSet = BitSet;
exports.AltDict = AltDict;
exports.DoubleDict = DoubleDict;
exports.hashStuff = hashStuff;
exports.escapeWhitespace = escapeWhitespace;
exports.arrayToString = arrayToString;
exports.titleCase = titleCase;
exports.equalArrays = equalArrays;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A token has properties: text, type, line, character position in the line
// (so we can ignore tabs), token channel, index, and source from which
// we obtained this token.

function Token() {
	this.source = null;
	this.type = null; // token type of the token
	this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
	this.start = null; // optional; return -1 if not implemented.
	this.stop = null; // optional; return -1 if not implemented.
	this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
	this.line = null; // line=1..n of the 1st character
	this.column = null; // beginning of the line at which it occurs, 0..n-1
	this._text = null; // text of the token.
	return this;
}

Token.INVALID_TYPE = 0;

// During lookahead operations, this "token" signifies we hit rule end ATN state
// and did not follow it despite needing to.
Token.EPSILON = -2;

Token.MIN_USER_TOKEN_TYPE = 1;

Token.EOF = -1;

// All tokens go to the parser (unless skip() is called in that rule)
// on a particular "channel". The parser tunes to a particular channel
// so that whitespace etc... can go to the parser on a "hidden" channel.

Token.DEFAULT_CHANNEL = 0;

// Anything on different channel than DEFAULT_CHANNEL is not parsed
// by parser.

Token.HIDDEN_CHANNEL = 1;

// Explicitly set the text for this token. If {code text} is not
// {@code null}, then {@link //getText} will return this value rather than
// extracting the text from the input.
//
// @param text The explicit text of the token, or {@code null} if the text
// should be obtained from the input along with the start and stop indexes
// of the token.

Object.defineProperty(Token.prototype, "text", {
	get : function() {
		return this._text;
	},
	set : function(text) {
		this._text = text;
	}
});

Token.prototype.getTokenSource = function() {
	return this.source[0];
};

Token.prototype.getInputStream = function() {
	return this.source[1];
};

function CommonToken(source, type, channel, start, stop) {
	Token.call(this);
	this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
	this.type = type !== undefined ? type : null;
	this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
	this.start = start !== undefined ? start : -1;
	this.stop = stop !== undefined ? stop : -1;
	this.tokenIndex = -1;
	if (this.source[0] !== null) {
		this.line = source[0].line;
		this.column = source[0].column;
	} else {
		this.column = -1;
	}
	return this;
}

CommonToken.prototype = Object.create(Token.prototype);
CommonToken.prototype.constructor = CommonToken;

// An empty {@link Pair} which is used as the default value of
// {@link //source} for tokens that do not have a source.
CommonToken.EMPTY_SOURCE = [ null, null ];

// Constructs a new {@link CommonToken} as a copy of another {@link Token}.
//
// <p>
// If {@code oldToken} is also a {@link CommonToken} instance, the newly
// constructed token will share a reference to the {@link //text} field and
// the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
// be assigned the result of calling {@link //getText}, and {@link //source}
// will be constructed from the result of {@link Token//getTokenSource} and
// {@link Token//getInputStream}.</p>
//
// @param oldToken The token to copy.
//
CommonToken.prototype.clone = function() {
	var t = new CommonToken(this.source, this.type, this.channel, this.start,
			this.stop);
	t.tokenIndex = this.tokenIndex;
	t.line = this.line;
	t.column = this.column;
	t.text = this.text;
	return t;
};

Object.defineProperty(CommonToken.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		}
		var input = this.getInputStream();
		if (input === null) {
			return null;
		}
		var n = input.size;
		if (this.start < n && this.stop < n) {
			return input.getText(this.start, this.stop);
		} else {
			return "<EOF>";
		}
	},
	set : function(text) {
		this._text = text;
	}
});

CommonToken.prototype.toString = function() {
	var txt = this.text;
	if (txt !== null) {
		txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	} else {
		txt = "<no text>";
	}
	return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
			txt + "',<" + this.type + ">" +
			(this.channel > 0 ? ",channel=" + this.channel : "") + "," +
			this.line + ":" + this.column + "]";
};

exports.Token = Token;
exports.CommonToken = CommonToken;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/*jslint smarttabs:true */

var Token = __webpack_require__(1).Token;

/* stop is not included! */
function Interval(start, stop) {
	this.start = start;
	this.stop = stop;
	return this;
}

Interval.prototype.contains = function(item) {
	return item >= this.start && item < this.stop;
};

Interval.prototype.toString = function() {
	if(this.start===this.stop-1) {
		return this.start.toString();
	} else {
		return this.start.toString() + ".." + (this.stop-1).toString();
	}
};


Object.defineProperty(Interval.prototype, "length", {
	get : function() {
		return this.stop - this.start;
	}
});

function IntervalSet() {
	this.intervals = null;
	this.readOnly = false;
}

IntervalSet.prototype.first = function(v) {
	if (this.intervals === null || this.intervals.length===0) {
		return Token.INVALID_TYPE;
	} else {
		return this.intervals[0].start;
	}
};

IntervalSet.prototype.addOne = function(v) {
	this.addInterval(new Interval(v, v + 1));
};

IntervalSet.prototype.addRange = function(l, h) {
	this.addInterval(new Interval(l, h + 1));
};

IntervalSet.prototype.addInterval = function(v) {
	if (this.intervals === null) {
		this.intervals = [];
		this.intervals.push(v);
	} else {
		// find insert pos
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// distinct range -> insert
			if (v.stop < i.start) {
				this.intervals.splice(k, 0, v);
				return;
			}
			// contiguous range -> adjust
			else if (v.stop === i.start) {
				this.intervals[k].start = v.start;
				return;
			}
			// overlapping range -> adjust and reduce
			else if (v.start <= i.stop) {
				this.intervals[k] = new Interval(Math.min(i.start, v.start), Math.max(i.stop, v.stop));
				this.reduce(k);
				return;
			}
		}
		// greater than any existing
		this.intervals.push(v);
	}
};

IntervalSet.prototype.addSet = function(other) {
	if (other.intervals !== null) {
		for (var k = 0; k < other.intervals.length; k++) {
			var i = other.intervals[k];
			this.addInterval(new Interval(i.start, i.stop));
		}
	}
	return this;
};

IntervalSet.prototype.reduce = function(k) {
	// only need to reduce if k is not the last
	if (k < this.intervalslength - 1) {
		var l = this.intervals[k];
		var r = this.intervals[k + 1];
		// if r contained in l
		if (l.stop >= r.stop) {
			this.intervals.pop(k + 1);
			this.reduce(k);
		} else if (l.stop >= r.start) {
			this.intervals[k] = new Interval(l.start, r.stop);
			this.intervals.pop(k + 1);
		}
	}
};

IntervalSet.prototype.complement = function(start, stop) {
    var result = new IntervalSet();
    result.addInterval(new Interval(start,stop+1));
    for(var i=0; i<this.intervals.length; i++) {
        result.removeRange(this.intervals[i]);
    }
    return result;
};

IntervalSet.prototype.contains = function(item) {
	if (this.intervals === null) {
		return false;
	} else {
		for (var k = 0; k < this.intervals.length; k++) {
			if(this.intervals[k].contains(item)) {
				return true;
			}
		}
		return false;
	}
};

Object.defineProperty(IntervalSet.prototype, "length", {
	get : function() {
		var len = 0;
		this.intervals.map(function(i) {len += i.length;});
		return len;
	}
});

IntervalSet.prototype.removeRange = function(v) {
    if(v.start===v.stop-1) {
        this.removeOne(v.start);
    } else if (this.intervals!==null) {
        var k = 0;
        for(var n=0; n<this.intervals.length; n++) {
            var i = this.intervals[k];
            // intervals are ordered
            if (v.stop<=i.start) {
                return;
            }
            // check for including range, split it
            else if(v.start>i.start && v.stop<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
                var x = new Interval(v.stop, i.stop);
                this.intervals.splice(k, 0, x);
                return;
            }
            // check for included range, remove it
            else if(v.start<=i.start && v.stop>=i.stop) {
                this.intervals.splice(k, 1);
                k = k - 1; // need another pass
            }
            // check for lower boundary
            else if(v.start<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
            }
            // check for upper boundary
            else if(v.stop<i.stop) {
                this.intervals[k] = new Interval(v.stop, i.stop);
            }
            k += 1;
        }
    }
};

IntervalSet.prototype.removeOne = function(v) {
	if (this.intervals !== null) {
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// intervals is ordered
			if (v < i.start) {
				return;
			}
			// check for single value range
			else if (v === i.start && v === i.stop - 1) {
				this.intervals.splice(k, 1);
				return;
			}
			// check for lower boundary
			else if (v === i.start) {
				this.intervals[k] = new Interval(i.start + 1, i.stop);
				return;
			}
			// check for upper boundary
			else if (v === i.stop - 1) {
				this.intervals[k] = new Interval(i.start, i.stop - 1);
				return;
			}
			// split existing range
			else if (v < i.stop - 1) {
				var x = new Interval(i.start, v);
				i.start = v + 1;
				this.intervals.splice(k, 0, x);
				return;
			}
		}
	}
};

IntervalSet.prototype.toString = function(literalNames, symbolicNames, elemsAreChar) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	elemsAreChar = elemsAreChar || false;
	if (this.intervals === null) {
		return "{}";
	} else if(literalNames!==null || symbolicNames!==null) {
		return this.toTokenString(literalNames, symbolicNames);
	} else if(elemsAreChar) {
		return this.toCharString();
	} else {
		return this.toIndexString();
	}
};

IntervalSet.prototype.toCharString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push("'" + String.fromCharCode(v.start) + "'");
			}
		} else {
			names.push("'" + String.fromCharCode(v.start) + "'..'" + String.fromCharCode(v.stop-1) + "'");
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toIndexString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push(v.start.toString());
			}
		} else {
			names.push(v.start.toString() + ".." + (v.stop-1).toString());
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toTokenString = function(literalNames, symbolicNames) {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		for (var j = v.start; j < v.stop; j++) {
			names.push(this.elementName(literalNames, symbolicNames, j));
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};

IntervalSet.prototype.elementName = function(literalNames, symbolicNames, a) {
	if (a === Token.EOF) {
		return "<EOF>";
	} else if (a === Token.EPSILON) {
		return "<EPSILON>";
	} else {
		return literalNames[a] || symbolicNames[a];
	}
};

exports.Interval = Interval;
exports.IntervalSet = IntervalSet;


/***/ }),
/* 3 */,
/* 4 */,
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// The basic notion of a tree has a parent, a payload, and a list of children.
//  It is the most abstract interface for all the trees used by ANTLR.
///

var Token = __webpack_require__(1).Token;
var Interval = __webpack_require__(2).Interval;
var INVALID_INTERVAL = new Interval(-1, -2);
var Utils = __webpack_require__(0);


function Tree() {
	return this;
}

function SyntaxTree() {
	Tree.call(this);
	return this;
}

SyntaxTree.prototype = Object.create(Tree.prototype);
SyntaxTree.prototype.constructor = SyntaxTree;

function ParseTree() {
	SyntaxTree.call(this);
	return this;
}

ParseTree.prototype = Object.create(SyntaxTree.prototype);
ParseTree.prototype.constructor = ParseTree;

function RuleNode() {
	ParseTree.call(this);
	return this;
}

RuleNode.prototype = Object.create(ParseTree.prototype);
RuleNode.prototype.constructor = RuleNode;

function TerminalNode() {
	ParseTree.call(this);
	return this;
}

TerminalNode.prototype = Object.create(ParseTree.prototype);
TerminalNode.prototype.constructor = TerminalNode;

function ErrorNode() {
	TerminalNode.call(this);
	return this;
}

ErrorNode.prototype = Object.create(TerminalNode.prototype);
ErrorNode.prototype.constructor = ErrorNode;

function ParseTreeVisitor() {
	return this;
}

ParseTreeVisitor.prototype.visit = function(ctx) {
 	if (Array.isArray(ctx)) {
		return ctx.map(function(child) {
            return child.accept(this);
        }, this);
	} else {
		return ctx.accept(this);
	}
};

ParseTreeVisitor.prototype.visitChildren = function(ctx) {
  return this.visit(ctx.children);
}

ParseTreeVisitor.prototype.visitTerminal = function(node) {
};

ParseTreeVisitor.prototype.visitErrorNode = function(node) {
};


function ParseTreeListener() {
	return this;
}

ParseTreeListener.prototype.visitTerminal = function(node) {
};

ParseTreeListener.prototype.visitErrorNode = function(node) {
};

ParseTreeListener.prototype.enterEveryRule = function(node) {
};

ParseTreeListener.prototype.exitEveryRule = function(node) {
};

function TerminalNodeImpl(symbol) {
	TerminalNode.call(this);
	this.parentCtx = null;
	this.symbol = symbol;
	return this;
}

TerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);
TerminalNodeImpl.prototype.constructor = TerminalNodeImpl;

TerminalNodeImpl.prototype.getChild = function(i) {
	return null;
};

TerminalNodeImpl.prototype.getSymbol = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getParent = function() {
	return this.parentCtx;
};

TerminalNodeImpl.prototype.getPayload = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getSourceInterval = function() {
	if (this.symbol === null) {
		return INVALID_INTERVAL;
	}
	var tokenIndex = this.symbol.tokenIndex;
	return new Interval(tokenIndex, tokenIndex);
};

TerminalNodeImpl.prototype.getChildCount = function() {
	return 0;
};

TerminalNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitTerminal(this);
};

TerminalNodeImpl.prototype.getText = function() {
	return this.symbol.text;
};

TerminalNodeImpl.prototype.toString = function() {
	if (this.symbol.type === Token.EOF) {
		return "<EOF>";
	} else {
		return this.symbol.text;
	}
};

// Represents a token that was consumed during resynchronization
// rather than during a valid match operation. For example,
// we will create this kind of a node during single token insertion
// and deletion as well as during "consume until error recovery set"
// upon no viable alternative exceptions.

function ErrorNodeImpl(token) {
	TerminalNodeImpl.call(this, token);
	return this;
}

ErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);
ErrorNodeImpl.prototype.constructor = ErrorNodeImpl;

ErrorNodeImpl.prototype.isErrorNode = function() {
	return true;
};

ErrorNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitErrorNode(this);
};

function ParseTreeWalker() {
	return this;
}

ParseTreeWalker.prototype.walk = function(listener, t) {
	var errorNode = t instanceof ErrorNode ||
			(t.isErrorNode !== undefined && t.isErrorNode());
	if (errorNode) {
		listener.visitErrorNode(t);
	} else if (t instanceof TerminalNode) {
		listener.visitTerminal(t);
	} else {
		this.enterRule(listener, t);
		for (var i = 0; i < t.getChildCount(); i++) {
			var child = t.getChild(i);
			this.walk(listener, child);
		}
		this.exitRule(listener, t);
	}
};
//
// The discovery of a rule node, involves sending two events: the generic
// {@link ParseTreeListener//enterEveryRule} and a
// {@link RuleContext}-specific event. First we trigger the generic and then
// the rule specific. We to them in reverse order upon finishing the node.
//
ParseTreeWalker.prototype.enterRule = function(listener, r) {
	var ctx = r.getRuleContext();
	listener.enterEveryRule(ctx);
	ctx.enterRule(listener);
};

ParseTreeWalker.prototype.exitRule = function(listener, r) {
	var ctx = r.getRuleContext();
	ctx.exitRule(listener);
	listener.exitEveryRule(ctx);
};

ParseTreeWalker.DEFAULT = new ParseTreeWalker();

exports.RuleNode = RuleNode;
exports.ErrorNode = ErrorNode;
exports.TerminalNode = TerminalNode;
exports.ErrorNodeImpl = ErrorNodeImpl;
exports.TerminalNodeImpl = TerminalNodeImpl;
exports.ParseTreeListener = ParseTreeListener;
exports.ParseTreeVisitor = ParseTreeVisitor;
exports.ParseTreeWalker = ParseTreeWalker;
exports.INVALID_INTERVAL = INVALID_INTERVAL;


/***/ }),
/* 6 */,
/* 7 */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// The following images show the relation of states and
// {@link ATNState//transitions} for various grammar constructs.
//
// <ul>
//
// <li>Solid edges marked with an &//0949; indicate a required
// {@link EpsilonTransition}.</li>
//
// <li>Dashed edges indicate locations where any transition derived from
// {@link Transition} might appear.</li>
//
// <li>Dashed nodes are place holders for either a sequence of linked
// {@link BasicState} states or the inclusion of a block representing a nested
// construct in one of the forms below.</li>
//
// <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
// any number of alternatives (one or more). Nodes without the {@code ...} only
// support the exact number of alternatives shown in the diagram.</li>
//
// </ul>
//
// <h2>Basic Blocks</h2>
//
// <h3>Rule</h3>
//
// <embed src="images/Rule.svg" type="image/svg+xml"/>
//
// <h3>Block of 1 or more alternatives</h3>
//
// <embed src="images/Block.svg" type="image/svg+xml"/>
//
// <h2>Greedy Loops</h2>
//
// <h3>Greedy Closure: {@code (...)*}</h3>
//
// <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Positive Closure: {@code (...)+}</h3>
//
// <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Optional: {@code (...)?}</h3>
//
// <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
//
// <h2>Non-Greedy Loops</h2>
//
// <h3>Non-Greedy Closure: {@code (...)*?}</h3>
//
// <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
//
// <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Optional: {@code (...)??}</h3>
//
// <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
//

var INITIAL_NUM_TRANSITIONS = 4;

function ATNState() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    // Track the transitions emanating from this ATN state.
    this.transitions = [];
    // Used to cache lookahead during parsing, not used during construction
    this.nextTokenWithinRule = null;
    return this;
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;

ATNState.serializationNames = [
            "INVALID",
            "BASIC",
            "RULE_START",
            "BLOCK_START",
            "PLUS_BLOCK_START",
            "STAR_BLOCK_START",
            "TOKEN_START",
            "RULE_STOP",
            "BLOCK_END",
            "STAR_LOOP_BACK",
            "STAR_LOOP_ENTRY",
            "PLUS_LOOP_BACK",
            "LOOP_END" ];

ATNState.INVALID_STATE_NUMBER = -1;

ATNState.prototype.toString = function() {
	return this.stateNumber;
};

ATNState.prototype.equals = function(other) {
    if (other instanceof ATNState) {
        return this.stateNumber===other.stateNumber;
    } else {
        return false;
    }
};

ATNState.prototype.isNonGreedyExitState = function() {
    return false;
};


ATNState.prototype.addTransition = function(trans, index) {
	if(index===undefined) {
		index = -1;
	}
    if (this.transitions.length===0) {
        this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {
        this.epsilonOnlyTransitions = false;
    }
    if (index===-1) {
        this.transitions.push(trans);
    } else {
        this.transitions.splice(index, 1, trans);
    }
};

function BasicState() {
	ATNState.call(this);
    this.stateType = ATNState.BASIC;
    return this;
}

BasicState.prototype = Object.create(ATNState.prototype);
BasicState.prototype.constructor = BasicState;


function DecisionState() {
	ATNState.call(this);
    this.decision = -1;
    this.nonGreedy = false;
    return this;
}

DecisionState.prototype = Object.create(ATNState.prototype);
DecisionState.prototype.constructor = DecisionState;


//  The start of a regular {@code (...)} block.
function BlockStartState() {
	DecisionState.call(this);
	this.endState = null;
	return this;
}

BlockStartState.prototype = Object.create(DecisionState.prototype);
BlockStartState.prototype.constructor = BlockStartState;


function BasicBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.BLOCK_START;
	return this;
}

BasicBlockStartState.prototype = Object.create(BlockStartState.prototype);
BasicBlockStartState.prototype.constructor = BasicBlockStartState;


// Terminal node of a simple {@code (a|b|c)} block.
function BlockEndState() {
	ATNState.call(this);
	this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
}

BlockEndState.prototype = Object.create(ATNState.prototype);
BlockEndState.prototype.constructor = BlockEndState;


// The last node in the ATN for a rule, unless that rule is the start symbol.
//  In that case, there is one transition to EOF. Later, we might encode
//  references to all calls to this rule to compute FOLLOW sets for
//  error handling.
//
function RuleStopState() {
	ATNState.call(this);
    this.stateType = ATNState.RULE_STOP;
    return this;
}

RuleStopState.prototype = Object.create(ATNState.prototype);
RuleStopState.prototype.constructor = RuleStopState;

function RuleStartState() {
	ATNState.call(this);
	this.stateType = ATNState.RULE_START;
	this.stopState = null;
	this.isPrecedenceRule = false;
	return this;
}

RuleStartState.prototype = Object.create(ATNState.prototype);
RuleStartState.prototype.constructor = RuleStartState;

// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
//  one to the loop back to start of the block and one to exit.
//
function PlusLoopbackState() {
	DecisionState.call(this);
	this.stateType = ATNState.PLUS_LOOP_BACK;
	return this;
}

PlusLoopbackState.prototype = Object.create(DecisionState.prototype);
PlusLoopbackState.prototype.constructor = PlusLoopbackState;


// Start of {@code (A|B|...)+} loop. Technically a decision state, but
//  we don't use for code generation; somebody might need it, so I'm defining
//  it for completeness. In reality, the {@link PlusLoopbackState} node is the
//  real decision-making note for {@code A+}.
//
function PlusBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
}

PlusBlockStartState.prototype = Object.create(BlockStartState.prototype);
PlusBlockStartState.prototype.constructor = PlusBlockStartState;

// The block that begins a closure loop.
function StarBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.STAR_BLOCK_START;
	return this;
}

StarBlockStartState.prototype = Object.create(BlockStartState.prototype);
StarBlockStartState.prototype.constructor = StarBlockStartState;


function StarLoopbackState() {
	ATNState.call(this);
	this.stateType = ATNState.STAR_LOOP_BACK;
	return this;
}

StarLoopbackState.prototype = Object.create(ATNState.prototype);
StarLoopbackState.prototype.constructor = StarLoopbackState;


function StarLoopEntryState() {
	DecisionState.call(this);
	this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
    this.isPrecedenceDecision = null;
    return this;
}

StarLoopEntryState.prototype = Object.create(DecisionState.prototype);
StarLoopEntryState.prototype.constructor = StarLoopEntryState;


// Mark the end of a * or + loop.
function LoopEndState() {
	ATNState.call(this);
	this.stateType = ATNState.LOOP_END;
	this.loopBackState = null;
	return this;
}

LoopEndState.prototype = Object.create(ATNState.prototype);
LoopEndState.prototype.constructor = LoopEndState;


// The Tokens rule start state linking to each lexer rule start state */
function TokensStartState() {
	DecisionState.call(this);
	this.stateType = ATNState.TOKEN_START;
	return this;
}

TokensStartState.prototype = Object.create(DecisionState.prototype);
TokensStartState.prototype.constructor = TokensStartState;

exports.ATNState = ATNState;
exports.BasicState = BasicState;
exports.DecisionState = DecisionState;
exports.BlockStartState = BlockStartState;
exports.BlockEndState = BlockEndState;
exports.LoopEndState = LoopEndState;
exports.RuleStartState = RuleStartState;
exports.RuleStopState = RuleStopState;
exports.TokensStartState = TokensStartState;
exports.PlusLoopbackState = PlusLoopbackState;
exports.StarLoopbackState = StarLoopbackState;
exports.StarLoopEntryState = StarLoopEntryState;
exports.PlusBlockStartState = PlusBlockStartState;
exports.StarBlockStartState = StarBlockStartState;
exports.BasicBlockStartState = BasicBlockStartState;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
//  3 kinds of errors: prediction errors, failed predicate errors, and
//  mismatched input errors. In each case, the parser knows where it is
//  in the input, where it is in the ATN, the rule invocation stack,
//  and what kind of problem occurred.

var PredicateTransition = __webpack_require__(11).PredicateTransition;

function RecognitionException(params) {
	Error.call(this);
	if (!!Error.captureStackTrace) {
        Error.captureStackTrace(this, RecognitionException);
	} else {
		var stack = new Error().stack;
	}
	this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    // The current {@link Token} when an error occurred. Since not all streams
    // support accessing symbols by index, we have to track the {@link Token}
    // instance itself.
    this.offendingToken = null;
    // Get the ATN state number the parser was in at the time the error
    // occurred. For {@link NoViableAltException} and
    // {@link LexerNoViableAltException} exceptions, this is the
    // {@link DecisionState} number. For others, it is the state whose outgoing
    // edge we couldn't match.
    this.offendingState = -1;
    if (this.recognizer!==null) {
        this.offendingState = this.recognizer.state;
    }
    return this;
}

RecognitionException.prototype = Object.create(Error.prototype);
RecognitionException.prototype.constructor = RecognitionException;

// <p>If the state number is not known, this method returns -1.</p>

//
// Gets the set of input symbols which could potentially follow the
// previously matched symbol at the time this exception was thrown.
//
// <p>If the set of expected tokens is not known and could not be computed,
// this method returns {@code null}.</p>
//
// @return The set of token types that could potentially follow the current
// state in the ATN, or {@code null} if the information is not available.
// /
RecognitionException.prototype.getExpectedTokens = function() {
    if (this.recognizer!==null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
        return null;
    }
};

RecognitionException.prototype.toString = function() {
    return this.message;
};

function LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {
	RecognitionException.call(this, {message:"", recognizer:lexer, input:input, ctx:null});
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
    return this;
}

LexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);
LexerNoViableAltException.prototype.constructor = LexerNoViableAltException;

LexerNoViableAltException.prototype.toString = function() {
    var symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getText((this.startIndex,this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
};

// Indicates that the parser could not decide which of two or more paths
// to take based upon the remaining input. It tracks the starting token
// of the offending input and also knows where the parser was
// in the various paths when the error. Reported by reportNoViableAlternative()
//
function NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
	ctx = ctx || recognizer._ctx;
	offendingToken = offendingToken || recognizer.getCurrentToken();
	startToken = startToken || recognizer.getCurrentToken();
	input = input || recognizer.getInputStream();
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:input, ctx:ctx});
    // Which configurations did we try at input.index() that couldn't match
	// input.LT(1)?//
    this.deadEndConfigs = deadEndConfigs;
    // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)
    this.startToken = startToken;
    this.offendingToken = offendingToken;
}

NoViableAltException.prototype = Object.create(RecognitionException.prototype);
NoViableAltException.prototype.constructor = NoViableAltException;

// This signifies any kind of mismatched input exceptions such as
// when the current input does not match the expected token.
//
function InputMismatchException(recognizer) {
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:recognizer.getInputStream(), ctx:recognizer._ctx});
    this.offendingToken = recognizer.getCurrentToken();
}

InputMismatchException.prototype = Object.create(RecognitionException.prototype);
InputMismatchException.prototype.constructor = InputMismatchException;

// A semantic predicate failed during validation. Validation of predicates
// occurs when normally parsing the alternative just like matching a token.
// Disambiguating predicate evaluation occurs when we test a predicate during
// prediction.

function FailedPredicateException(recognizer, predicate, message) {
	RecognitionException.call(this, {message:this.formatMessage(predicate,message || null), recognizer:recognizer,
                         input:recognizer.getInputStream(), ctx:recognizer._ctx});
    var s = recognizer._interp.atn.states[recognizer.state];
    var trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
    } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
    return this;
}

FailedPredicateException.prototype = Object.create(RecognitionException.prototype);
FailedPredicateException.prototype.constructor = FailedPredicateException;

FailedPredicateException.prototype.formatMessage = function(predicate, message) {
    if (message !==null) {
        return message;
    } else {
        return "failed predicate: {" + predicate + "}?";
    }
};

function ParseCancellationException() {
	Error.call(this);
	Error.captureStackTrace(this, ParseCancellationException);
	return this;
}

ParseCancellationException.prototype = Object.create(Error.prototype);
ParseCancellationException.prototype.constructor = ParseCancellationException;

exports.RecognitionException = RecognitionException;
exports.NoViableAltException = NoViableAltException;
exports.LexerNoViableAltException = LexerNoViableAltException;
exports.InputMismatchException = InputMismatchException;
exports.FailedPredicateException = FailedPredicateException;
exports.ParseCancellationException = ParseCancellationException;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var RuleContext = __webpack_require__(26).RuleContext;
var Hash = __webpack_require__(0).Hash;

function PredictionContext(cachedHashCode) {
	this.cachedHashCode = cachedHashCode;
}

// Represents {@code $} in local context prediction, which means wildcard.
// {@code//+x =//}.
// /
PredictionContext.EMPTY = null;

// Represents {@code $} in an array in full context mode, when {@code $}
// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
// {@code $} = {@link //EMPTY_RETURN_STATE}.
// /
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;

PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// Stores the computed hash code of this {@link PredictionContext}. The hash
// code is computed in parts to match the following reference algorithm.
//
// <pre>
// private int referenceHashCode() {
// int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
// //INITIAL_HASH});
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
// getParent}(i));
// }
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
// //getReturnState getReturnState}(i));
// }
//
// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
// //size()});
// return hash;
// }
// </pre>
// /

// This means only the {@link //EMPTY} context is in set.
PredictionContext.prototype.isEmpty = function() {
	return this === PredictionContext.EMPTY;
};

PredictionContext.prototype.hasEmptyPath = function() {
	return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
};

PredictionContext.prototype.hashCode = function() {
	return this.cachedHashCode;
};


PredictionContext.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};
/*
function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}
*/

// Used to cache {@link PredictionContext} objects. Its used for the shared
// context cash associated with contexts in DFA states. This cache
// can be used for both lexers and parsers.

function PredictionContextCache() {
	this.cache = {};
	return this;
}

// Add a context to the cache and return it. If the context already exists,
// return that one instead and do not add a new context to the cache.
// Protect shared cache from unsafe thread access.
//
PredictionContextCache.prototype.add = function(ctx) {
	if (ctx === PredictionContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	var existing = this.cache[ctx] || null;
	if (existing !== null) {
		return existing;
	}
	this.cache[ctx] = ctx;
	return ctx;
};

PredictionContextCache.prototype.get = function(ctx) {
	return this.cache[ctx] || null;
};

Object.defineProperty(PredictionContextCache.prototype, "length", {
	get : function() {
		return this.cache.length;
	}
});

function SingletonPredictionContext(parent, returnState) {
	var hashCode = 0;
	if(parent !== null) {
		var hash = new Hash();
		hash.update(parent, returnState);
        hashCode = hash.finish();
	}
	PredictionContext.call(this, hashCode);
	this.parentCtx = parent;
	this.returnState = returnState;
}

SingletonPredictionContext.prototype = Object.create(PredictionContext.prototype);
SingletonPredictionContext.prototype.contructor = SingletonPredictionContext;

SingletonPredictionContext.create = function(parent, returnState) {
	if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
		// someone can pass in the bits of an array ctx that mean $
		return PredictionContext.EMPTY;
	} else {
		return new SingletonPredictionContext(parent, returnState);
	}
};

Object.defineProperty(SingletonPredictionContext.prototype, "length", {
	get : function() {
		return 1;
	}
});

SingletonPredictionContext.prototype.getParent = function(index) {
	return this.parentCtx;
};

SingletonPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

SingletonPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof SingletonPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		if(this.returnState !== other.returnState)
            return false;
        else if(this.parentCtx==null)
            return other.parentCtx==null
		else
            return this.parentCtx.equals(other.parentCtx);
	}
};

SingletonPredictionContext.prototype.toString = function() {
	var up = this.parentCtx === null ? "" : this.parentCtx.toString();
	if (up.length === 0) {
		if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
			return "$";
		} else {
			return "" + this.returnState;
		}
	} else {
		return "" + this.returnState + " " + up;
	}
};

function EmptyPredictionContext() {
	SingletonPredictionContext.call(this, null, PredictionContext.EMPTY_RETURN_STATE);
	return this;
}

EmptyPredictionContext.prototype = Object.create(SingletonPredictionContext.prototype);
EmptyPredictionContext.prototype.constructor = EmptyPredictionContext;

EmptyPredictionContext.prototype.isEmpty = function() {
	return true;
};

EmptyPredictionContext.prototype.getParent = function(index) {
	return null;
};

EmptyPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

EmptyPredictionContext.prototype.equals = function(other) {
	return this === other;
};

EmptyPredictionContext.prototype.toString = function() {
	return "$";
};

PredictionContext.EMPTY = new EmptyPredictionContext();

function ArrayPredictionContext(parents, returnStates) {
	// Parent can be null only if full ctx mode and we make an array
	// from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
	// null parent and
	// returnState == {@link //EMPTY_RETURN_STATE}.
	var h = new Hash();
	h.update(parents, returnStates);
	var hashCode = h.finish();
	PredictionContext.call(this, hashCode);
	this.parents = parents;
	this.returnStates = returnStates;
	return this;
}

ArrayPredictionContext.prototype = Object.create(PredictionContext.prototype);
ArrayPredictionContext.prototype.constructor = ArrayPredictionContext;

ArrayPredictionContext.prototype.isEmpty = function() {
	// since EMPTY_RETURN_STATE can only appear in the last position, we
	// don't need to verify that size==1
	return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
};

Object.defineProperty(ArrayPredictionContext.prototype, "length", {
	get : function() {
		return this.returnStates.length;
	}
});

ArrayPredictionContext.prototype.getParent = function(index) {
	return this.parents[index];
};

ArrayPredictionContext.prototype.getReturnState = function(index) {
	return this.returnStates[index];
};

ArrayPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof ArrayPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		return this.returnStates === other.returnStates &&
				this.parents === other.parents;
	}
};

ArrayPredictionContext.prototype.toString = function() {
	if (this.isEmpty()) {
		return "[]";
	} else {
		var s = "[";
		for (var i = 0; i < this.returnStates.length; i++) {
			if (i > 0) {
				s = s + ", ";
			}
			if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
				s = s + "$";
				continue;
			}
			s = s + this.returnStates[i];
			if (this.parents[i] !== null) {
				s = s + " " + this.parents[i];
			} else {
				s = s + "null";
			}
		}
		return s + "]";
	}
};

// Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
// Return {@link //EMPTY} if {@code outerContext} is empty or null.
// /
function predictionContextFromRuleContext(atn, outerContext) {
	if (outerContext === undefined || outerContext === null) {
		outerContext = RuleContext.EMPTY;
	}
	// if we are in RuleContext of start rule, s, then PredictionContext
	// is EMPTY. Nobody called us. (if we are empty, return empty)
	if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	// If we have a parent, convert it to a PredictionContext graph
	var parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
	var state = atn.states[outerContext.invokingState];
	var transition = state.transitions[0];
	return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
/*
function calculateListsHashString(parents, returnStates) {
	var s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}
*/
function merge(a, b, rootIsWildcard, mergeCache) {
	// share same graph if both same
	if (a === b) {
		return a;
	}
	if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
		return mergeSingletons(a, b, rootIsWildcard, mergeCache);
	}
	// At least one of a or b is array
	// If one is $ and rootIsWildcard, return $ as// wildcard
	if (rootIsWildcard) {
		if (a instanceof EmptyPredictionContext) {
			return a;
		}
		if (b instanceof EmptyPredictionContext) {
			return b;
		}
	}
	// convert singleton so both are arrays to normalize
	if (a instanceof SingletonPredictionContext) {
		a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
	}
	if (b instanceof SingletonPredictionContext) {
		b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
	}
	return mergeArrays(a, b, rootIsWildcard, mergeCache);
}

//
// Merge two {@link SingletonPredictionContext} instances.
//
// <p>Stack tops equal, parents merge is same; return left graph.<br>
// <embed src="images/SingletonMerge_SameRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Same stack top, parents differ; merge parents giving array node, then
// remainders of those graphs. A new root node is created to point to the
// merged parents.<br>
// <embed src="images/SingletonMerge_SameRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to same parent. Make array node for the
// root where both element in the root point to the same (original)
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to different parents. Make array node for
// the root where each element points to the corresponding original
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// @param mergeCache
// /
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}

	var rootMerge = mergeRoot(a, b, rootIsWildcard);
	if (rootMerge !== null) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, rootMerge);
		}
		return rootMerge;
	}
	if (a.returnState === b.returnState) {
		var parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
		// if parent is same as existing a or b parent or reduced to a parent,
		// return it
		if (parent === a.parentCtx) {
			return a; // ax + bx = ax, if a=b
		}
		if (parent === b.parentCtx) {
			return b; // ax + bx = bx, if a=b
		}
		// else: ax + ay = a'[x,y]
		// merge parents x and y, giving array node with x,y then remainders
		// of those graphs. dup a, a' points at merged array
		// new joined parent so create new singleton pointing to it, a'
		var spc = SingletonPredictionContext.create(parent, a.returnState);
		if (mergeCache !== null) {
			mergeCache.set(a, b, spc);
		}
		return spc;
	} else { // a != b payloads differ
		// see if we can collapse parents due to $+x parents if local ctx
		var singleParent = null;
		if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
																				// bx =
																				// [a,b]x
			singleParent = a.parentCtx;
		}
		if (singleParent !== null) { // parents are same
			// sort payloads and use same parent
			var payloads = [ a.returnState, b.returnState ];
			if (a.returnState > b.returnState) {
				payloads[0] = b.returnState;
				payloads[1] = a.returnState;
			}
			var parents = [ singleParent, singleParent ];
			var apc = new ArrayPredictionContext(parents, payloads);
			if (mergeCache !== null) {
				mergeCache.set(a, b, apc);
			}
			return apc;
		}
		// parents differ and can't merge them. Just pack together
		// into array; can't merge.
		// ax + by = [ax,by]
		var payloads = [ a.returnState, b.returnState ];
		var parents = [ a.parentCtx, b.parentCtx ];
		if (a.returnState > b.returnState) { // sort by payload
			payloads[0] = b.returnState;
			payloads[1] = a.returnState;
			parents = [ b.parentCtx, a.parentCtx ];
		}
		var a_ = new ArrayPredictionContext(parents, payloads);
		if (mergeCache !== null) {
			mergeCache.set(a, b, a_);
		}
		return a_;
	}
}

//
// Handle case where at least one of {@code a} or {@code b} is
// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
// to represent {@link //EMPTY}.
//
// <h2>Local-Context Merges</h2>
//
// <p>These local-context merge operations are used when {@code rootIsWildcard}
// is true.</p>
//
// <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
// <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
// {@code //EMPTY}; return left graph.<br>
// <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
//
// <p>Special case of last merge if local context.<br>
// <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
//
// <h2>Full-Context Merges</h2>
//
// <p>These full-context merge operations are used when {@code rootIsWildcard}
// is false.</p>
//
// <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
//
// <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
// null parent).<br>
// <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// /
function mergeRoot(a, b, rootIsWildcard) {
	if (rootIsWildcard) {
		if (a === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // // + b =//
		}
		if (b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // a +// =//
		}
	} else {
		if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // $ + $ = $
		} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]
			var payloads = [ b.returnState,
					PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ b.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)
			var payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ a.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		}
	}
	return null;
}

//
// Merge two {@link ArrayPredictionContext} instances.
//
// <p>Different tops, different parents.<br>
// <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, same parents.<br>
// <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, different parents.<br>
// <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, all shared parents.<br>
// <embed src="images/ArrayMerge_ShareTopSharePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Equal tops, merge parents and reduce top to
// {@link SingletonPredictionContext}.<br>
// <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
// /
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}
	// merge sorted payloads a + b => M
	var i = 0; // walks a
	var j = 0; // walks b
	var k = 0; // walks target M array

	var mergedReturnStates = [];
	var mergedParents = [];
	// walk and merge to yield mergedParents, mergedReturnStates
	while (i < a.returnStates.length && j < b.returnStates.length) {
		var a_parent = a.parents[i];
		var b_parent = b.parents[j];
		if (a.returnStates[i] === b.returnStates[j]) {
			// same payload (stack tops are equal), must yield merged singleton
			var payload = a.returnStates[i];
			// $+$ = $
			var bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&
					a_parent === null && b_parent === null;
			var ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
																							// ->
																							// ax
			if (bothDollars || ax_ax) {
				mergedParents[k] = a_parent; // choose left
				mergedReturnStates[k] = payload;
			} else { // ax+ay -> a'[x,y]
				var mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
				mergedParents[k] = mergedParent;
				mergedReturnStates[k] = payload;
			}
			i += 1; // hop over left one as usual
			j += 1; // but also skip one in right side since we merge
		} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
			mergedParents[k] = a_parent;
			mergedReturnStates[k] = a.returnStates[i];
			i += 1;
		} else { // b > a, copy b[j] to M
			mergedParents[k] = b_parent;
			mergedReturnStates[k] = b.returnStates[j];
			j += 1;
		}
		k += 1;
	}
	// copy over any payloads remaining in either array
	if (i < a.returnStates.length) {
		for (var p = i; p < a.returnStates.length; p++) {
			mergedParents[k] = a.parents[p];
			mergedReturnStates[k] = a.returnStates[p];
			k += 1;
		}
	} else {
		for (var p = j; p < b.returnStates.length; p++) {
			mergedParents[k] = b.parents[p];
			mergedReturnStates[k] = b.returnStates[p];
			k += 1;
		}
	}
	// trim merged if we combined a few that had same stack tops
	if (k < mergedParents.length) { // write index < last position; trim
		if (k === 1) { // for just one merged element, return singleton top
			var a_ = SingletonPredictionContext.create(mergedParents[0],
					mergedReturnStates[0]);
			if (mergeCache !== null) {
				mergeCache.set(a, b, a_);
			}
			return a_;
		}
		mergedParents = mergedParents.slice(0, k);
		mergedReturnStates = mergedReturnStates.slice(0, k);
	}

	var M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

	// if we created same array as a or b, return that instead
	// TODO: track whether this is possible above during merge sort for speed
	if (M === a) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, a);
		}
		return a;
	}
	if (M === b) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, b);
		}
		return b;
	}
	combineCommonParents(mergedParents);

	if (mergeCache !== null) {
		mergeCache.set(a, b, M);
	}
	return M;
}

//
// Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
// ones.
// /
function combineCommonParents(parents) {
	var uniqueParents = {};

	for (var p = 0; p < parents.length; p++) {
		var parent = parents[p];
		if (!(parent in uniqueParents)) {
			uniqueParents[parent] = parent;
		}
	}
	for (var q = 0; q < parents.length; q++) {
		parents[q] = uniqueParents[parents[q]];
	}
}

function getCachedPredictionContext(context, contextCache, visited) {
	if (context.isEmpty()) {
		return context;
	}
	var existing = visited[context] || null;
	if (existing !== null) {
		return existing;
	}
	existing = contextCache.get(context);
	if (existing !== null) {
		visited[context] = existing;
		return existing;
	}
	var changed = false;
	var parents = [];
	for (var i = 0; i < parents.length; i++) {
		var parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
		if (changed || parent !== context.getParent(i)) {
			if (!changed) {
				parents = [];
				for (var j = 0; j < context.length; j++) {
					parents[j] = context.getParent(j);
				}
				changed = true;
			}
			parents[i] = parent;
		}
	}
	if (!changed) {
		contextCache.add(context);
		visited[context] = context;
		return context;
	}
	var updated = null;
	if (parents.length === 0) {
		updated = PredictionContext.EMPTY;
	} else if (parents.length === 1) {
		updated = SingletonPredictionContext.create(parents[0], context
				.getReturnState(0));
	} else {
		updated = new ArrayPredictionContext(parents, context.returnStates);
	}
	contextCache.add(updated);
	visited[updated] = updated;
	visited[context] = updated;

	return updated;
}

// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
	if (nodes === null) {
		nodes = [];
		return getAllContextNodes(context, nodes, visited);
	} else if (visited === null) {
		visited = {};
		return getAllContextNodes(context, nodes, visited);
	} else {
		if (context === null || visited[context] !== null) {
			return nodes;
		}
		visited[context] = context;
		nodes.push(context);
		for (var i = 0; i < context.length; i++) {
			getAllContextNodes(context.getParent(i), nodes, visited);
		}
		return nodes;
	}
}

exports.merge = merge;
exports.PredictionContext = PredictionContext;
exports.PredictionContextCache = PredictionContextCache;
exports.SingletonPredictionContext = SingletonPredictionContext;
exports.predictionContextFromRuleContext = predictionContextFromRuleContext;
exports.getCachedPredictionContext = getCachedPredictionContext;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var LL1Analyzer = __webpack_require__(111).LL1Analyzer;
var IntervalSet = __webpack_require__(2).IntervalSet;

function ATN(grammarType , maxTokenType) {

    // Used for runtime deserialization of ATNs from strings///
    // The type of the ATN.
    this.grammarType = grammarType;
    // The maximum value for any symbol recognized by a transition in the ATN.
    this.maxTokenType = maxTokenType;
    this.states = [];
    // Each subrule/rule is a decision point and we must track them so we
    //  can go back later and build DFA predictors for them.  This includes
    //  all the rules, subrules, optional blocks, ()+, ()* etc...
    this.decisionToState = [];
    // Maps from rule index to starting state number.
    this.ruleToStartState = [];
    // Maps from rule index to stop state number.
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    // For lexer ATNs, this maps the rule index to the resulting token type.
    // For parser ATNs, this maps the rule index to the generated bypass token
    // type if the
    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
    // deserialization option was specified; otherwise, this is {@code null}.
    this.ruleToTokenType = null;
    // For lexer ATNs, this is an array of {@link LexerAction} objects which may
    // be referenced by action transitions in the ATN.
    this.lexerActions = null;
    this.modeToStartState = [];

    return this;
}

// Compute the set of valid tokens that can occur starting in state {@code s}.
//  If {@code ctx} is null, the set of tokens will not include what can follow
//  the rule surrounding {@code s}. In other words, the set will be
//  restricted to tokens reachable staying within {@code s}'s rule.
ATN.prototype.nextTokensInContext = function(s, ctx) {
    var anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
};

// Compute the set of valid tokens that can occur starting in {@code s} and
// staying in same rule. {@link Token//EPSILON} is in set if we reach end of
// rule.
ATN.prototype.nextTokensNoContext = function(s) {
    if (s.nextTokenWithinRule !== null ) {
        return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
};

ATN.prototype.nextTokens = function(s, ctx) {
    if ( ctx===undefined ) {
        return this.nextTokensNoContext(s);
    } else {
        return this.nextTokensInContext(s, ctx);
    }
};

ATN.prototype.addState = function( state) {
    if ( state !== null ) {
        state.atn = this;
        state.stateNumber = this.states.length;
    }
    this.states.push(state);
};

ATN.prototype.removeState = function( state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
};

ATN.prototype.defineDecisionState = function( s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length-1;
    return s.decision;
};

ATN.prototype.getDecisionState = function( decision) {
    if (this.decisionToState.length===0) {
        return null;
    } else {
        return this.decisionToState[decision];
    }
};

// Computes the set of input symbols which could follow ATN state number
// {@code stateNumber} in the specified full {@code context}. This method
// considers the complete parser context, but does not evaluate semantic
// predicates (i.e. all predicates encountered during the calculation are
// assumed true). If a path in the ATN exists from the starting state to the
// {@link RuleStopState} of the outermost context without matching any
// symbols, {@link Token//EOF} is added to the returned set.
//
// <p>If {@code context} is {@code null}, it is treated as
// {@link ParserRuleContext//EMPTY}.</p>
//
// @param stateNumber the ATN state number
// @param context the full parse context
// @return The set of potentially valid input symbols which could follow the
// specified state in the specified context.
// @throws IllegalArgumentException if the ATN does not contain a state with
// number {@code stateNumber}
var Token = __webpack_require__(1).Token;

ATN.prototype.getExpectedTokens = function( stateNumber, ctx ) {
    if ( stateNumber < 0 || stateNumber >= this.states.length ) {
        throw("Invalid state number.");
    }
    var s = this.states[stateNumber];
    var following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
        return following;
    }
    var expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        var invokingState = this.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
        expected.addOne(Token.EOF);
    }
    return expected;
};

ATN.INVALID_ALT_NUMBER = 0;

exports.ATN = ATN;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//  An ATN transition between any two ATN states.  Subclasses define
//  atom, set, epsilon, action, predicate, rule transitions.
//
//  <p>This is a one way link.  It emanates from a state (usually via a list of
//  transitions) and has a target state.</p>
//
//  <p>Since we never have to change the ATN transitions once we construct it,
//  we can fix these transitions as specific classes. The DFA transitions
//  on the other hand need to update the labels as it adds transitions to
//  the states. We'll use the term Edge for the DFA to distinguish them from
//  ATN transitions.</p>

var Token = __webpack_require__(1).Token;
var Interval = __webpack_require__(2).Interval;
var IntervalSet = __webpack_require__(2).IntervalSet;
var Predicate = __webpack_require__(16).Predicate;
var PrecedencePredicate = __webpack_require__(16).PrecedencePredicate;

function Transition (target) {
    // The target of this transition.
    if (target===undefined || target===null) {
        throw "target cannot be null.";
    }
    this.target = target;
    // Are we epsilon, action, sempred?
    this.isEpsilon = false;
    this.label = null;
    return this;
}
    // constants for serialization
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4; // e.g., {isType(input.LT(1))}?
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7; // ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;

Transition.serializationNames = [
            "INVALID",
            "EPSILON",
            "RANGE",
            "RULE",
            "PREDICATE",
            "ATOM",
            "ACTION",
            "SET",
            "NOT_SET",
            "WILDCARD",
            "PRECEDENCE"
        ];

Transition.serializationTypes = {
        EpsilonTransition: Transition.EPSILON,
        RangeTransition: Transition.RANGE,
        RuleTransition: Transition.RULE,
        PredicateTransition: Transition.PREDICATE,
        AtomTransition: Transition.ATOM,
        ActionTransition: Transition.ACTION,
        SetTransition: Transition.SET,
        NotSetTransition: Transition.NOT_SET,
        WildcardTransition: Transition.WILDCARD,
        PrecedencePredicateTransition: Transition.PRECEDENCE
    };


// TODO: make all transitions sets? no, should remove set edges
function AtomTransition(target, label) {
	Transition.call(this, target);
	this.label_ = label; // The token type or character value; or, signifies special label.
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
    return this;
}

AtomTransition.prototype = Object.create(Transition.prototype);
AtomTransition.prototype.constructor = AtomTransition;

AtomTransition.prototype.makeLabel = function() {
	var s = new IntervalSet();
    s.addOne(this.label_);
    return s;
};

AtomTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
    return this.label_ === symbol;
};

AtomTransition.prototype.toString = function() {
	return this.label_;
};

function RuleTransition(ruleStart, ruleIndex, precedence, followState) {
	Transition.call(this, ruleStart);
    this.ruleIndex = ruleIndex; // ptr to the rule definition object for this rule ref
    this.precedence = precedence;
    this.followState = followState; // what node to begin computations following ref to rule
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
    return this;
}

RuleTransition.prototype = Object.create(Transition.prototype);
RuleTransition.prototype.constructor = RuleTransition;

RuleTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};


function EpsilonTransition(target, outermostPrecedenceReturn) {
	Transition.call(this, target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    return this;
}

EpsilonTransition.prototype = Object.create(Transition.prototype);
EpsilonTransition.prototype.constructor = EpsilonTransition;

EpsilonTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

EpsilonTransition.prototype.toString = function() {
	return "epsilon";
};

function RangeTransition(target, start, stop) {
	Transition.call(this, target);
	this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
    return this;
}

RangeTransition.prototype = Object.create(Transition.prototype);
RangeTransition.prototype.constructor = RangeTransition;

RangeTransition.prototype.makeLabel = function() {
    var s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
};

RangeTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= this.start && symbol <= this.stop;
};

RangeTransition.prototype.toString = function() {
	return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
};

function AbstractPredicateTransition(target) {
	Transition.call(this, target);
	return this;
}

AbstractPredicateTransition.prototype = Object.create(Transition.prototype);
AbstractPredicateTransition.prototype.constructor = AbstractPredicateTransition;

function PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

PredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PredicateTransition.prototype.constructor = PredicateTransition;

PredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PredicateTransition.prototype.getPredicate = function() {
	return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

PredicateTransition.prototype.toString = function() {
	return "pred_" + this.ruleIndex + ":" + this.predIndex;
};

function ActionTransition(target, ruleIndex, actionIndex, isCtxDependent) {
	Transition.call(this, target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex===undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

ActionTransition.prototype = Object.create(Transition.prototype);
ActionTransition.prototype.constructor = ActionTransition;


ActionTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

ActionTransition.prototype.toString = function() {
	return "action_" + this.ruleIndex + ":" + this.actionIndex;
};


// A transition containing a set of values.
function SetTransition(target, set) {
	Transition.call(this, target);
	this.serializationType = Transition.SET;
    if (set !==undefined && set !==null) {
        this.label = set;
    } else {
        this.label = new IntervalSet();
        this.label.addOne(Token.INVALID_TYPE);
    }
    return this;
}

SetTransition.prototype = Object.create(Transition.prototype);
SetTransition.prototype.constructor = SetTransition;

SetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return this.label.contains(symbol);
};


SetTransition.prototype.toString = function() {
	return this.label.toString();
};

function NotSetTransition(target, set) {
	SetTransition.call(this, target, set);
	this.serializationType = Transition.NOT_SET;
	return this;
}

NotSetTransition.prototype = Object.create(SetTransition.prototype);
NotSetTransition.prototype.constructor = NotSetTransition;

NotSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
			!SetTransition.prototype.matches.call(this, symbol, minVocabSymbol, maxVocabSymbol);
};

NotSetTransition.prototype.toString = function() {
	return '~' + SetTransition.prototype.toString.call(this);
};

function WildcardTransition(target) {
	Transition.call(this, target);
	this.serializationType = Transition.WILDCARD;
	return this;
}

WildcardTransition.prototype = Object.create(Transition.prototype);
WildcardTransition.prototype.constructor = WildcardTransition;


WildcardTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
};

WildcardTransition.prototype.toString = function() {
	return ".";
};

function PrecedencePredicateTransition(target, precedence) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
    return this;
}

PrecedencePredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PrecedencePredicateTransition.prototype.constructor = PrecedencePredicateTransition;

PrecedencePredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PrecedencePredicateTransition.prototype.getPredicate = function() {
	return new PrecedencePredicate(this.precedence);
};

PrecedencePredicateTransition.prototype.toString = function() {
	return this.precedence + " >= _p";
};

exports.Transition = Transition;
exports.AtomTransition = AtomTransition;
exports.SetTransition = SetTransition;
exports.NotSetTransition = NotSetTransition;
exports.RuleTransition = RuleTransition;
exports.ActionTransition = ActionTransition;
exports.EpsilonTransition = EpsilonTransition;
exports.RangeTransition = RangeTransition;
exports.WildcardTransition = WildcardTransition;
exports.PredicateTransition = PredicateTransition;
exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
exports.AbstractPredicateTransition = AbstractPredicateTransition;

/***/ }),
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//
// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
// info about the set, with support for combining similar configurations using a
// graph-structured stack.
///

var ATN = __webpack_require__(10).ATN;
var Utils = __webpack_require__(0);
var Hash = Utils.Hash;
var Set = Utils.Set;
var SemanticContext = __webpack_require__(16).SemanticContext;
var merge = __webpack_require__(9).merge;

function hashATNConfig(c) {
	return c.hashCodeForConfigSet();
}

function equalATNConfigs(a, b) {
	if ( a===b ) {
		return true;
	} else if ( a===null || b===null ) {
		return false;
	} else
       return a.equalsForConfigSet(b);
 }


function ATNConfigSet(fullCtx) {
	//
	// The reason that we need this is because we don't want the hash map to use
	// the standard hash code and equals. We need all configurations with the
	// same
	// {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
	// doubles
	// the number of objects associated with ATNConfigs. The other solution is
	// to
	// use a hash table that lets us specify the equals/hashcode operation.
	// All configs but hashed by (s, i, _, pi) not including context. Wiped out
	// when we go readonly as this set becomes a DFA state.
	this.configLookup = new Set(hashATNConfig, equalATNConfigs);
	// Indicates that this configuration set is part of a full context
	// LL prediction. It will be used to determine how to merge $. With SLL
	// it's a wildcard whereas it is not for LL context merge.
	this.fullCtx = fullCtx === undefined ? true : fullCtx;
	// Indicates that the set of configurations is read-only. Do not
	// allow any code to manipulate the set; DFA states will point at
	// the sets and they must not change. This does not protect the other
	// fields; in particular, conflictingAlts is set after
	// we've made this readonly.
	this.readOnly = false;
	// Track the elements as they are added to the set; supports get(i)///
	this.configs = [];

	// TODO: these fields make me pretty uncomfortable but nice to pack up info
	// together, saves recomputation
	// TODO: can we track conflicts as they are added to save scanning configs
	// later?
	this.uniqueAlt = 0;
	this.conflictingAlts = null;

	// Used in parser and lexer. In lexer, it indicates we hit a pred
	// while computing a closure operation. Don't make a DFA state from this.
	this.hasSemanticContext = false;
	this.dipsIntoOuterContext = false;

	this.cachedHashCode = -1;

	return this;
}

// Adding a new config means merging contexts with existing configs for
// {@code (s, i, pi, _)}, where {@code s} is the
// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
// {@code pi} is the {@link ATNConfig//semanticContext}. We use
// {@code (s,i,pi)} as key.
//
// <p>This method updates {@link //dipsIntoOuterContext} and
// {@link //hasSemanticContext} when necessary.</p>
// /
ATNConfigSet.prototype.add = function(config, mergeCache) {
	if (mergeCache === undefined) {
		mergeCache = null;
	}
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (config.semanticContext !== SemanticContext.NONE) {
		this.hasSemanticContext = true;
	}
	if (config.reachesIntoOuterContext > 0) {
		this.dipsIntoOuterContext = true;
	}
	var existing = this.configLookup.add(config);
	if (existing === config) {
		this.cachedHashCode = -1;
		this.configs.push(config); // track order here
		return true;
	}
	// a previous (s,i,pi,_), merge with it and save result
	var rootIsWildcard = !this.fullCtx;
	var merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
	// no need to check for existing.context, config.context in cache
	// since only way to create new graphs is "call rule" and here. We
	// cache at both places.
	existing.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
	// make sure to preserve the precedence filter suppression during the merge
	if (config.precedenceFilterSuppressed) {
		existing.precedenceFilterSuppressed = true;
	}
	existing.context = merged; // replace context; no need to alt mapping
	return true;
};

ATNConfigSet.prototype.getStates = function() {
	var states = new Set();
	for (var i = 0; i < this.configs.length; i++) {
		states.add(this.configs[i].state);
	}
	return states;
};

ATNConfigSet.prototype.getPredicates = function() {
	var preds = [];
	for (var i = 0; i < this.configs.length; i++) {
		var c = this.configs[i].semanticContext;
		if (c !== SemanticContext.NONE) {
			preds.push(c.semanticContext);
		}
	}
	return preds;
};

Object.defineProperty(ATNConfigSet.prototype, "items", {
	get : function() {
		return this.configs;
	}
});

ATNConfigSet.prototype.optimizeConfigs = function(interpreter) {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (this.configLookup.length === 0) {
		return;
	}
	for (var i = 0; i < this.configs.length; i++) {
		var config = this.configs[i];
		config.context = interpreter.getCachedContext(config.context);
	}
};

ATNConfigSet.prototype.addAll = function(coll) {
	for (var i = 0; i < coll.length; i++) {
		this.add(coll[i]);
	}
	return false;
};

ATNConfigSet.prototype.equals = function(other) {
	return this === other ||
		(other instanceof ATNConfigSet &&
		Utils.equalArrays(this.configs, other.configs) &&
		this.fullCtx === other.fullCtx &&
		this.uniqueAlt === other.uniqueAlt &&
		this.conflictingAlts === other.conflictingAlts &&
		this.hasSemanticContext === other.hasSemanticContext &&
		this.dipsIntoOuterContext === other.dipsIntoOuterContext);
};

ATNConfigSet.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};


ATNConfigSet.prototype.updateHashCode = function(hash) {
	if (this.readOnly) {
		if (this.cachedHashCode === -1) {
            var hash = new Hash();
            hash.update(this.configs);
			this.cachedHashCode = hash.finish();
		}
        hash.update(this.cachedHashCode);
	} else {
        hash.update(this.configs);
	}
};


Object.defineProperty(ATNConfigSet.prototype, "length", {
	get : function() {
		return this.configs.length;
	}
});

ATNConfigSet.prototype.isEmpty = function() {
	return this.configs.length === 0;
};

ATNConfigSet.prototype.contains = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.contains(item);
};

ATNConfigSet.prototype.containsFast = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.containsFast(item);
};

ATNConfigSet.prototype.clear = function() {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	this.configs = [];
	this.cachedHashCode = -1;
	this.configLookup = new Set();
};

ATNConfigSet.prototype.setReadonly = function(readOnly) {
	this.readOnly = readOnly;
	if (readOnly) {
		this.configLookup = null; // can't mod, no need for lookup cache
	}
};

ATNConfigSet.prototype.toString = function() {
	return Utils.arrayToString(this.configs) +
		(this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
		(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
		(this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
		(this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
};

function OrderedATNConfigSet() {
	ATNConfigSet.call(this);
	this.configLookup = new Set();
	return this;
}

OrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);
OrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;

exports.ATNConfigSet = ATNConfigSet;
exports.OrderedATNConfigSet = OrderedATNConfigSet;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A tree structure used to record the semantic context in which
//  an ATN configuration is valid.  It's either a single predicate,
//  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
//
//  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
//  {@link SemanticContext} within the scope of this outer class.</p>
//

var Set = __webpack_require__(0).Set;
var Hash = __webpack_require__(0).Hash;

function SemanticContext() {
	return this;
}

SemanticContext.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};

// For context independent predicates, we evaluate them without a local
// context (i.e., null context). That way, we can evaluate them without
// having to create proper rule-specific context during prediction (as
// opposed to the parser, which creates them naturally). In a practical
// sense, this avoids a cast exception from RuleContext to myruleContext.
//
// <p>For context dependent predicates, we must pass in a local context so that
// references such as $arg evaluate properly as _localctx.arg. We only
// capture context dependent predicates in the context in which we begin
// prediction, so we passed in the outer context here in case of context
// dependent predicate evaluation.</p>
//
SemanticContext.prototype.evaluate = function(parser, outerContext) {
};

//
// Evaluate the precedence predicates for the context and reduce the result.
//
// @param parser The parser instance.
// @param outerContext The current parser context object.
// @return The simplified semantic context after precedence predicates are
// evaluated, which will be one of the following values.
// <ul>
// <li>{@link //NONE}: if the predicate simplifies to {@code true} after
// precedence predicates are evaluated.</li>
// <li>{@code null}: if the predicate simplifies to {@code false} after
// precedence predicates are evaluated.</li>
// <li>{@code this}: if the semantic context is not changed as a result of
// precedence predicate evaluation.</li>
// <li>A non-{@code null} {@link SemanticContext}: the new simplified
// semantic context after precedence predicates are evaluated.</li>
// </ul>
//
SemanticContext.prototype.evalPrecedence = function(parser, outerContext) {
	return this;
};

SemanticContext.andContext = function(a, b) {
	if (a === null || a === SemanticContext.NONE) {
		return b;
	}
	if (b === null || b === SemanticContext.NONE) {
		return a;
	}
	var result = new AND(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

SemanticContext.orContext = function(a, b) {
	if (a === null) {
		return b;
	}
	if (b === null) {
		return a;
	}
	if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
		return SemanticContext.NONE;
	}
	var result = new OR(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

function Predicate(ruleIndex, predIndex, isCtxDependent) {
	SemanticContext.call(this);
	this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
	this.predIndex = predIndex === undefined ? -1 : predIndex;
	this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
	return this;
}

Predicate.prototype = Object.create(SemanticContext.prototype);
Predicate.prototype.constructor = Predicate;

//The default {@link SemanticContext}, which is semantically equivalent to
//a predicate of the form {@code {true}?}.
//
SemanticContext.NONE = new Predicate();


Predicate.prototype.evaluate = function(parser, outerContext) {
	var localctx = this.isCtxDependent ? outerContext : null;
	return parser.sempred(localctx, this.ruleIndex, this.predIndex);
};

Predicate.prototype.updateHashCode = function(hash) {
	hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

Predicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof Predicate)) {
		return false;
	} else {
		return this.ruleIndex === other.ruleIndex &&
				this.predIndex === other.predIndex &&
				this.isCtxDependent === other.isCtxDependent;
	}
};

Predicate.prototype.toString = function() {
	return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
};

function PrecedencePredicate(precedence) {
	SemanticContext.call(this);
	this.precedence = precedence === undefined ? 0 : precedence;
}

PrecedencePredicate.prototype = Object.create(SemanticContext.prototype);
PrecedencePredicate.prototype.constructor = PrecedencePredicate;

PrecedencePredicate.prototype.evaluate = function(parser, outerContext) {
	return parser.precpred(outerContext, this.precedence);
};

PrecedencePredicate.prototype.evalPrecedence = function(parser, outerContext) {
	if (parser.precpred(outerContext, this.precedence)) {
		return SemanticContext.NONE;
	} else {
		return null;
	}
};

PrecedencePredicate.prototype.compareTo = function(other) {
	return this.precedence - other.precedence;
};

PrecedencePredicate.prototype.updateHashCode = function(hash) {
    hash.update(31);
};

PrecedencePredicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof PrecedencePredicate)) {
		return false;
	} else {
		return this.precedence === other.precedence;
	}
};

PrecedencePredicate.prototype.toString = function() {
	return "{"+this.precedence+">=prec}?";
};



PrecedencePredicate.filterPrecedencePredicates = function(set) {
	var result = [];
	set.values().map( function(context) {
		if (context instanceof PrecedencePredicate) {
			result.push(context);
		}
	});
	return result;
};


// A semantic context which is true whenever none of the contained contexts
// is false.
//
function AND(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof AND) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof AND) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}
	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the lowest precedence
		var reduced = null;
		precedencePredicates.map( function(p) {
			if(reduced===null || p.precedence<reduced.precedence) {
				reduced = p;
			}
		});
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

AND.prototype = Object.create(SemanticContext.prototype);
AND.prototype.constructor = AND;

AND.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof AND)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

AND.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "AND");
};
//
// {@inheritDoc}
//
// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
AND.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (!this.opnds[i].evaluate(parser, outerContext)) {
			return false;
		}
	}
	return true;
};

AND.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === null) {
			// The AND context is false if any element is false
			return null;
		} else if (evaluated !== SemanticContext.NONE) {
			// Reduce the result by skipping true elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were true, so the AND context is true
		return SemanticContext.NONE;
	}
	var result = null;
	operands.map(function(o) {
		result = result === null ? o : SemanticContext.andContext(result, o);
	});
	return result;
};

AND.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "&& " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

//
// A semantic context which is true whenever at least one of the contained
// contexts is true.
//
function OR(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof OR) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof OR) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}

	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the highest precedence
		var s = precedencePredicates.sort(function(a, b) {
			return a.compareTo(b);
		});
		var reduced = s[s.length-1];
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

OR.prototype = Object.create(SemanticContext.prototype);
OR.prototype.constructor = OR;

OR.prototype.constructor = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof OR)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

OR.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "OR");
};

// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
OR.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (this.opnds[i].evaluate(parser, outerContext)) {
			return true;
		}
	}
	return false;
};

OR.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === SemanticContext.NONE) {
			// The OR context is true if any element is true
			return SemanticContext.NONE;
		} else if (evaluated !== null) {
			// Reduce the result by skipping false elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were false, so the OR context is false
		return null;
	}
	var result = null;
	operands.map(function(o) {
		return result === null ? o : SemanticContext.orContext(result, o);
	});
	return result;
};

OR.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "|| " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

exports.SemanticContext = SemanticContext;
exports.PrecedencePredicate = PrecedencePredicate;
exports.Predicate = Predicate;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var Utils = __webpack_require__(0);
var Hash = Utils.Hash;
var Set = Utils.Set;

// Map a predicate to a predicted alternative.///

function PredPrediction(pred, alt) {
	this.alt = alt;
	this.pred = pred;
	return this;
}

PredPrediction.prototype.toString = function() {
	return "(" + this.pred + ", " + this.alt + ")";
};

// A DFA state represents a set of possible ATN configurations.
// As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
// to keep track of all possible states the ATN can be in after
// reading each input symbol. That is to say, after reading
// input a1a2..an, the DFA is in a state that represents the
// subset T of the states of the ATN that are reachable from the
// ATN's start state along some path labeled a1a2..an."
// In conventional NFA&rarr;DFA conversion, therefore, the subset T
// would be a bitset representing the set of states the
// ATN could be in. We need to track the alt predicted by each
// state as well, however. More importantly, we need to maintain
// a stack of states, tracking the closure operations as they
// jump from rule to rule, emulating rule invocations (method calls).
// I have to add a stack to simulate the proper lookahead sequences for
// the underlying LL grammar from which the ATN was derived.
//
// <p>I use a set of ATNConfig objects not simple states. An ATNConfig
// is both a state (ala normal conversion) and a RuleContext describing
// the chain of rules (if any) followed to arrive at that state.</p>
//
// <p>A DFA state may have multiple references to a particular state,
// but with different ATN contexts (with same or different alts)
// meaning that state was reached via a different set of rule invocations.</p>
// /

function DFAState(stateNumber, configs) {
	if (stateNumber === null) {
		stateNumber = -1;
	}
	if (configs === null) {
		configs = new ATNConfigSet();
	}
	this.stateNumber = stateNumber;
	this.configs = configs;
	// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
	// {@link Token//EOF} maps to {@code edges[0]}.
	this.edges = null;
	this.isAcceptState = false;
	// if accept state, what ttype do we match or alt do we predict?
	// This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link
	// //predicates}{@code !=null} or
	// {@link //requiresFullContext}.
	this.prediction = 0;
	this.lexerActionExecutor = null;
	// Indicates that this state was created during SLL prediction that
	// discovered a conflict between the configurations in the state. Future
	// {@link ParserATNSimulator//execATN} invocations immediately jumped doing
	// full context prediction if this field is true.
	this.requiresFullContext = false;
	// During SLL parsing, this is a list of predicates associated with the
	// ATN configurations of the DFA state. When we have predicates,
	// {@link //requiresFullContext} is {@code false} since full context
	// prediction evaluates predicates
	// on-the-fly. If this is not null, then {@link //prediction} is
	// {@link ATN//INVALID_ALT_NUMBER}.
	//
	// <p>We only use these for non-{@link //requiresFullContext} but
	// conflicting states. That
	// means we know from the context (it's $ or we don't dip into outer
	// context) that it's an ambiguity not a conflict.</p>
	//
	// <p>This list is computed by {@link
	// ParserATNSimulator//predicateDFAState}.</p>
	this.predicates = null;
	return this;
}

// Get the set of all alts mentioned by all ATN configurations in this
// DFA state.
DFAState.prototype.getAltSet = function() {
	var alts = new Set();
	if (this.configs !== null) {
		for (var i = 0; i < this.configs.length; i++) {
			var c = this.configs[i];
			alts.add(c.alt);
		}
	}
	if (alts.length === 0) {
		return null;
	} else {
		return alts;
	}
};

// Two {@link DFAState} instances are equal if their ATN configuration sets
// are the same. This method is used to see if a state already exists.
//
// <p>Because the number of alternatives and number of ATN configurations are
// finite, there is a finite number of DFA states that can be processed.
// This is necessary to show that the algorithm terminates.</p>
//
// <p>Cannot test the DFA state numbers here because in
// {@link ParserATNSimulator//addDFAState} we need to know if any other state
// exists that has this exact set of ATN configurations. The
// {@link //stateNumber} is irrelevant.</p>
DFAState.prototype.equals = function(other) {
	// compare set of ATN configurations in this set with other
	return this === other ||
			(other instanceof DFAState &&
				this.configs.equals(other.configs));
};

DFAState.prototype.toString = function() {
	var s = "" + this.stateNumber + ":" + this.configs;
	if(this.isAcceptState) {
        s = s + "=>";
        if (this.predicates !== null)
            s = s + this.predicates;
        else
            s = s + this.prediction;
    }
	return s;
};

DFAState.prototype.hashCode = function() {
	var hash = new Hash();
	hash.update(this.configs);
	if(this.isAcceptState) {
        if (this.predicates !== null)
            hash.update(this.predicates);
        else
            hash.update(this.prediction);
    }
    return hash.finish();
};

exports.DFAState = DFAState;
exports.PredPrediction = PredPrediction;


/***/ }),
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.atn = __webpack_require__(110);
exports.codepointat = __webpack_require__(66);
exports.dfa = __webpack_require__(117);
exports.fromcodepoint = __webpack_require__(67);
exports.tree = __webpack_require__(119);
exports.error = __webpack_require__(120);
exports.Token = __webpack_require__(1).Token;
exports.CharStreams = __webpack_require__(122).CharStreams;
exports.CommonToken = __webpack_require__(1).CommonToken;
exports.InputStream = __webpack_require__(35).InputStream;
exports.FileStream = __webpack_require__(123).FileStream;
exports.CommonTokenStream = __webpack_require__(124).CommonTokenStream;
exports.Lexer = __webpack_require__(27).Lexer;
exports.Parser = __webpack_require__(126).Parser;
var pc = __webpack_require__(9);
exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = __webpack_require__(34).ParserRuleContext;
exports.Interval = __webpack_require__(2).Interval;
exports.Utils = __webpack_require__(0);


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A tuple: (ATN state, predicted alt, syntactic, semantic context).
//  The syntactic context is a graph-structured stack node whose
//  path(s) to the root is the rule invocation(s)
//  chain used to arrive at the state.  The semantic context is
//  the tree of semantic predicates encountered before reaching
//  an ATN state.
///

var DecisionState = __webpack_require__(7).DecisionState;
var SemanticContext = __webpack_require__(16).SemanticContext;
var Hash = __webpack_require__(0).Hash;


function checkParams(params, isCfg) {
	if(params===null) {
		var result = { state:null, alt:null, context:null, semanticContext:null };
		if(isCfg) {
			result.reachesIntoOuterContext = 0;
		}
		return result;
	} else {
		var props = {};
		props.state = params.state || null;
		props.alt = (params.alt === undefined) ? null : params.alt;
		props.context = params.context || null;
		props.semanticContext = params.semanticContext || null;
		if(isCfg) {
			props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
			props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
		}
		return props;
	}
}

function ATNConfig(params, config) {
	this.checkContext(params, config);
	params = checkParams(params);
	config = checkParams(config, true);
    // The ATN state associated with this configuration///
    this.state = params.state!==null ? params.state : config.state;
    // What alt (or lexer rule) is predicted by this configuration///
    this.alt = params.alt!==null ? params.alt : config.alt;
    // The stack of invoking states leading to the rule/states associated
    //  with this config.  We track only those contexts pushed during
    //  execution of the ATN simulator.
    this.context = params.context!==null ? params.context : config.context;
    this.semanticContext = params.semanticContext!==null ? params.semanticContext :
        (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);
    // We cannot execute predicates dependent upon local context unless
    // we know for sure we are in the correct context. Because there is
    // no way to do this efficiently, we simply cannot evaluate
    // dependent predicates unless we are in the rule that initially
    // invokes the ATN simulator.
    //
    // closure() tracks the depth of how far we dip into the
    // outer context: depth &gt; 0.  Note that it may not be totally
    // accurate depth since I don't ever decrement. TODO: make it a boolean then
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    return this;
}

ATNConfig.prototype.checkContext = function(params, config) {
	if((params.context===null || params.context===undefined) &&
			(config===null || config.context===null || config.context===undefined)) {
		this.context = null;
	}
};


ATNConfig.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};


ATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
};

// An ATN configuration is equal to another if both have
//  the same state, they predict the same alternative, and
//  syntactic/semantic contexts are the same.

ATNConfig.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            (this.context===null ? other.context===null : this.context.equals(other.context)) &&
            this.semanticContext.equals(other.semanticContext) &&
            this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;
    }
};


ATNConfig.prototype.hashCodeForConfigSet = function() {
    var hash = new Hash();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
};


ATNConfig.prototype.equalsForConfigSet = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            this.semanticContext.equals(other.semanticContext);
    }
};


ATNConfig.prototype.toString = function() {
    return "(" + this.state + "," + this.alt +
        (this.context!==null ? ",[" + this.context.toString() + "]" : "") +
        (this.semanticContext !== SemanticContext.NONE ?
                ("," + this.semanticContext.toString())
                : "") +
        (this.reachesIntoOuterContext>0 ?
                (",up=" + this.reachesIntoOuterContext)
                : "") + ")";
};


function LexerATNConfig(params, config) {
	ATNConfig.call(this, params, config);

    // This is the backing field for {@link //getLexerActionExecutor}.
	var lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;
    return this;
}

LexerATNConfig.prototype = Object.create(ATNConfig.prototype);
LexerATNConfig.prototype.constructor = LexerATNConfig;

LexerATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
};

LexerATNConfig.prototype.equals = function(other) {
    return this === other ||
            (other instanceof LexerATNConfig &&
            this.passedThroughNonGreedyDecision == other.passedThroughNonGreedyDecision &&
            (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&
            ATNConfig.prototype.equals.call(this, other));
};

LexerATNConfig.prototype.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;

LexerATNConfig.prototype.equalsForConfigSet = LexerATNConfig.prototype.equals;


LexerATNConfig.prototype.checkNonGreedyDecision = function(source, target) {
    return source.passedThroughNonGreedyDecision ||
        (target instanceof DecisionState) && target.nonGreedy;
};

exports.ATNConfig = ATNConfig;
exports.LexerATNConfig = LexerATNConfig;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//  A rule context is a record of a single rule invocation. It knows
//  which context invoked it, if any. If there is no parent context, then
//  naturally the invoking state is not valid.  The parent link
//  provides a chain upwards from the current rule invocation to the root
//  of the invocation tree, forming a stack. We actually carry no
//  information about the rule associated with this context (except
//  when parsing). We keep only the state number of the invoking state from
//  the ATN submachine that invoked this. Contrast this with the s
//  pointer inside ParserRuleContext that tracks the current state
//  being "executed" for the current rule.
//
//  The parent contexts are useful for computing lookahead sets and
//  getting error information.
//
//  These objects are used during parsing and prediction.
//  For the special case of parsers, we use the subclass
//  ParserRuleContext.
//
//  @see ParserRuleContext
///

var RuleNode = __webpack_require__(5).RuleNode;
var INVALID_INTERVAL = __webpack_require__(5).INVALID_INTERVAL;
var INVALID_ALT_NUMBER = __webpack_require__(10).INVALID_ALT_NUMBER;

function RuleContext(parent, invokingState) {
	RuleNode.call(this);
	// What context invoked this rule?
	this.parentCtx = parent || null;
	// What state invoked the rule associated with this context?
	// The "return address" is the followState of invokingState
	// If parent is null, this should be -1.
	this.invokingState = invokingState || -1;
	return this;
}

RuleContext.prototype = Object.create(RuleNode.prototype);
RuleContext.prototype.constructor = RuleContext;

RuleContext.prototype.depth = function() {
	var n = 0;
	var p = this;
	while (p !== null) {
		p = p.parentCtx;
		n += 1;
	}
	return n;
};

// A context is empty if there is no invoking state; meaning nobody call
// current context.
RuleContext.prototype.isEmpty = function() {
	return this.invokingState === -1;
};

// satisfy the ParseTree / SyntaxTree interface

RuleContext.prototype.getSourceInterval = function() {
	return INVALID_INTERVAL;
};

RuleContext.prototype.getRuleContext = function() {
	return this;
};

RuleContext.prototype.getPayload = function() {
	return this;
};

// Return the combined text of all child nodes. This method only considers
// tokens which have been added to the parse tree.
// <p>
// Since tokens on hidden channels (e.g. whitespace or comments) are not
// added to the parse trees, they will not appear in the output of this
// method.
// /
RuleContext.prototype.getText = function() {
	if (this.getChildCount() === 0) {
		return "";
	} else {
		return this.children.map(function(child) {
			return child.getText();
		}).join("");
	}
};

// For rule associated with this parse tree internal node, return
// the outer alternative number used to match the input. Default
// implementation does not compute nor store this alt num. Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
// to set it.
RuleContext.prototype.getAltNumber = function() { return INVALID_ALT_NUMBER; }

// Set the outer alternative number for this context node. Default
// implementation does nothing to avoid backing field overhead for
// trees that don't need it.  Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
RuleContext.prototype.setAltNumber = function(altNumber) { }

RuleContext.prototype.getChild = function(i) {
	return null;
};

RuleContext.prototype.getChildCount = function() {
	return 0;
};

RuleContext.prototype.accept = function(visitor) {
	return visitor.visitChildren(this);
};

//need to manage circular dependencies, so export now
exports.RuleContext = RuleContext;
var Trees = __webpack_require__(59).Trees;


// Print out a whole tree, not just a node, in LISP format
// (root child1 .. childN). Print just a node if this is a leaf.
//

RuleContext.prototype.toStringTree = function(ruleNames, recog) {
	return Trees.toStringTree(this, ruleNames, recog);
};

RuleContext.prototype.toString = function(ruleNames, stop) {
	ruleNames = ruleNames || null;
	stop = stop || null;
	var p = this;
	var s = "[";
	while (p !== null && p !== stop) {
		if (ruleNames === null) {
			if (!p.isEmpty()) {
				s += p.invokingState;
			}
		} else {
			var ri = p.ruleIndex;
			var ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
					: "" + ri;
			s += ruleName;
		}
		if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
			s += " ";
		}
		p = p.parentCtx;
	}
	s += "]";
	return s;
};



/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A lexer is recognizer that draws input symbols from a character stream.
//  lexer grammars result in a subclass of this object. A Lexer object
//  uses simplified match() and error recovery mechanisms in the interest of speed.

var Token = __webpack_require__(1).Token;
var Recognizer = __webpack_require__(63).Recognizer;
var CommonTokenFactory = __webpack_require__(114).CommonTokenFactory;
var RecognitionException  = __webpack_require__(8).RecognitionException;
var LexerNoViableAltException = __webpack_require__(8).LexerNoViableAltException;

function TokenSource() {
	return this;
}

function Lexer(input) {
	Recognizer.call(this);
	this._input = input;
	this._factory = CommonTokenFactory.DEFAULT;
	this._tokenFactorySourcePair = [ this, input ];

	this._interp = null; // child classes must populate this

	// The goal of all lexer rules/methods is to create a token object.
	// this is an instance variable as multiple rules may collaborate to
	// create a single token. nextToken will return this object after
	// matching lexer rule(s). If you subclass to allow multiple token
	// emissions, then set this to the last token to be matched or
	// something nonnull so that the auto token emit mechanism will not
	// emit another token.
	this._token = null;

	// What character index in the stream did the current token start at?
	// Needed, for example, to get the text for current token. Set at
	// the start of nextToken.
	this._tokenStartCharIndex = -1;

	// The line on which the first character of the token resides///
	this._tokenStartLine = -1;

	// The character position of first character within the line///
	this._tokenStartColumn = -1;

	// Once we see EOF on char stream, next token will be EOF.
	// If you have DONE : EOF ; then you see DONE EOF.
	this._hitEOF = false;

	// The channel number for the current token///
	this._channel = Token.DEFAULT_CHANNEL;

	// The token type for the current token///
	this._type = Token.INVALID_TYPE;

	this._modeStack = [];
	this._mode = Lexer.DEFAULT_MODE;

	// You can set the text for the current token to override what is in
	// the input char buffer. Use setText() or can set this instance var.
	// /
	this._text = null;

	return this;
}

Lexer.prototype = Object.create(Recognizer.prototype);
Lexer.prototype.constructor = Lexer;

Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;

Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;

Lexer.prototype.reset = function() {
	// wack Lexer state variables
	if (this._input !== null) {
		this._input.seek(0); // rewind the input
	}
	this._token = null;
	this._type = Token.INVALID_TYPE;
	this._channel = Token.DEFAULT_CHANNEL;
	this._tokenStartCharIndex = -1;
	this._tokenStartColumn = -1;
	this._tokenStartLine = -1;
	this._text = null;

	this._hitEOF = false;
	this._mode = Lexer.DEFAULT_MODE;
	this._modeStack = [];

	this._interp.reset();
};

// Return a token from this source; i.e., match a token on the char stream.
Lexer.prototype.nextToken = function() {
	if (this._input === null) {
		throw "nextToken requires a non-null input stream.";
	}

	// Mark start location in char stream so unbuffered streams are
	// guaranteed at least have text of current token
	var tokenStartMarker = this._input.mark();
	try {
		while (true) {
			if (this._hitEOF) {
				this.emitEOF();
				return this._token;
			}
			this._token = null;
			this._channel = Token.DEFAULT_CHANNEL;
			this._tokenStartCharIndex = this._input.index;
			this._tokenStartColumn = this._interp.column;
			this._tokenStartLine = this._interp.line;
			this._text = null;
			var continueOuter = false;
			while (true) {
				this._type = Token.INVALID_TYPE;
				var ttype = Lexer.SKIP;
				try {
					ttype = this._interp.match(this._input, this._mode);
				} catch (e) {
				    if(e instanceof RecognitionException) {
                        this.notifyListeners(e); // report error
                        this.recover(e);
                    } else {
                        console.log(e.stack);
                        throw e;
                    }
				}
				if (this._input.LA(1) === Token.EOF) {
					this._hitEOF = true;
				}
				if (this._type === Token.INVALID_TYPE) {
					this._type = ttype;
				}
				if (this._type === Lexer.SKIP) {
					continueOuter = true;
					break;
				}
				if (this._type !== Lexer.MORE) {
					break;
				}
			}
			if (continueOuter) {
				continue;
			}
			if (this._token === null) {
				this.emit();
			}
			return this._token;
		}
	} finally {
		// make sure we release marker after match or
		// unbuffered char stream will keep buffering
		this._input.release(tokenStartMarker);
	}
};

// Instruct the lexer to skip creating a token for current lexer rule
// and look for another token. nextToken() knows to keep looking when
// a lexer rule finishes with token set to SKIP_TOKEN. Recall that
// if token==null at end of any token rule, it creates one for you
// and emits it.
// /
Lexer.prototype.skip = function() {
	this._type = Lexer.SKIP;
};

Lexer.prototype.more = function() {
	this._type = Lexer.MORE;
};

Lexer.prototype.mode = function(m) {
	this._mode = m;
};

Lexer.prototype.pushMode = function(m) {
	if (this._interp.debug) {
		console.log("pushMode " + m);
	}
	this._modeStack.push(this._mode);
	this.mode(m);
};

Lexer.prototype.popMode = function() {
	if (this._modeStack.length === 0) {
		throw "Empty Stack";
	}
	if (this._interp.debug) {
		console.log("popMode back to " + this._modeStack.slice(0, -1));
	}
	this.mode(this._modeStack.pop());
	return this._mode;
};

// Set the char stream and reset the lexer
Object.defineProperty(Lexer.prototype, "inputStream", {
	get : function() {
		return this._input;
	},
	set : function(input) {
		this._input = null;
		this._tokenFactorySourcePair = [ this, this._input ];
		this.reset();
		this._input = input;
		this._tokenFactorySourcePair = [ this, this._input ];
	}
});

Object.defineProperty(Lexer.prototype, "sourceName", {
	get : function sourceName() {
		return this._input.sourceName;
	}
});

// By default does not support multiple emits per nextToken invocation
// for efficiency reasons. Subclass and override this method, nextToken,
// and getToken (to push tokens into a list and pull from that list
// rather than a single variable as this implementation does).
// /
Lexer.prototype.emitToken = function(token) {
	this._token = token;
};

// The standard method called to automatically emit a token at the
// outermost lexical rule. The token object should point into the
// char buffer start..stop. If there is a text override in 'text',
// use that to set the token's text. Override this method to emit
// custom Token objects or provide a new factory.
// /
Lexer.prototype.emit = function() {
	var t = this._factory.create(this._tokenFactorySourcePair, this._type,
			this._text, this._channel, this._tokenStartCharIndex, this
					.getCharIndex() - 1, this._tokenStartLine,
			this._tokenStartColumn);
	this.emitToken(t);
	return t;
};

Lexer.prototype.emitEOF = function() {
	var cpos = this.column;
	var lpos = this.line;
	var eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,
			null, Token.DEFAULT_CHANNEL, this._input.index,
			this._input.index - 1, lpos, cpos);
	this.emitToken(eof);
	return eof;
};

Object.defineProperty(Lexer.prototype, "type", {
	get : function() {
		return this.type;
	},
	set : function(type) {
		this._type = type;
	}
});

Object.defineProperty(Lexer.prototype, "line", {
	get : function() {
		return this._interp.line;
	},
	set : function(line) {
		this._interp.line = line;
	}
});

Object.defineProperty(Lexer.prototype, "column", {
	get : function() {
		return this._interp.column;
	},
	set : function(column) {
		this._interp.column = column;
	}
});


// What is the index of the current character of lookahead?///
Lexer.prototype.getCharIndex = function() {
	return this._input.index;
};

// Return the text matched so far for the current token or any text override.
//Set the complete text of this token; it wipes any previous changes to the text.
Object.defineProperty(Lexer.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		} else {
			return this._interp.getText(this._input);
		}
	},
	set : function(text) {
		this._text = text;
	}
});
// Return a list of all Token objects in input char stream.
// Forces load of all tokens. Does not include EOF token.
// /
Lexer.prototype.getAllTokens = function() {
	var tokens = [];
	var t = this.nextToken();
	while (t.type !== Token.EOF) {
		tokens.push(t);
		t = this.nextToken();
	}
	return tokens;
};

Lexer.prototype.notifyListeners = function(e) {
	var start = this._tokenStartCharIndex;
	var stop = this._input.index;
	var text = this._input.getText(start, stop);
	var msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, null, this._tokenStartLine,
			this._tokenStartColumn, msg, e);
};

Lexer.prototype.getErrorDisplay = function(s) {
	var d = [];
	for (var i = 0; i < s.length; i++) {
		d.push(s[i]);
	}
	return d.join('');
};

Lexer.prototype.getErrorDisplayForChar = function(c) {
	if (c.charCodeAt(0) === Token.EOF) {
		return "<EOF>";
	} else if (c === '\n') {
		return "\\n";
	} else if (c === '\t') {
		return "\\t";
	} else if (c === '\r') {
		return "\\r";
	} else {
		return c;
	}
};

Lexer.prototype.getCharErrorDisplay = function(c) {
	return "'" + this.getErrorDisplayForChar(c) + "'";
};

// Lexers can normally match any char in it's vocabulary after matching
// a token, so do the easy thing and just kill a character and hope
// it all works out. You can instead use the rule invocation stack
// to do sophisticated error recovery if you are in a fragment rule.
// /
Lexer.prototype.recover = function(re) {
	if (this._input.LA(1) !== Token.EOF) {
		if (re instanceof LexerNoViableAltException) {
			// skip a char and try again
			this._interp.consume(this._input);
		} else {
			// TODO: Do we lose character or line position information?
			this._input.consume();
		}
	}
};

exports.Lexer = Lexer;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// Provides an empty default implementation of {@link ANTLRErrorListener}. The
// default implementation of each method does nothing, but can be overridden as
// necessary.

function ErrorListener() {
	return this;
}

ErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
};

ErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
};

ErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
};

ErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
};

function ConsoleErrorListener() {
	ErrorListener.call(this);
	return this;
}

ConsoleErrorListener.prototype = Object.create(ErrorListener.prototype);
ConsoleErrorListener.prototype.constructor = ConsoleErrorListener;

//
// Provides a default instance of {@link ConsoleErrorListener}.
//
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

//
// {@inheritDoc}
//
// <p>
// This implementation prints messages to {@link System//err} containing the
// values of {@code line}, {@code charPositionInLine}, and {@code msg} using
// the following format.</p>
//
// <pre>
// line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
// </pre>
//
ConsoleErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
};

function ProxyErrorListener(delegates) {
	ErrorListener.call(this);
    if (delegates===null) {
        throw "delegates";
    }
    this.delegates = delegates;
	return this;
}

ProxyErrorListener.prototype = Object.create(ErrorListener.prototype);
ProxyErrorListener.prototype.constructor = ProxyErrorListener;

ProxyErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(function(d) { d.syntaxError(recognizer, offendingSymbol, line, column, msg, e); });
};

ProxyErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(function(d) { d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs); });
};

ProxyErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	this.delegates.map(function(d) { d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs); });
};

ProxyErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	this.delegates.map(function(d) { d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs); });
};

exports.ErrorListener = ErrorListener;
exports.ConsoleErrorListener = ConsoleErrorListener;
exports.ProxyErrorListener = ProxyErrorListener;



/***/ }),
/* 29 */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// A DFA walker that knows how to dump them to serialized strings.#/


function DFASerializer(dfa, literalNames, symbolicNames) {
	this.dfa = dfa;
	this.literalNames = literalNames || [];
	this.symbolicNames = symbolicNames || [];
	return this;
}

DFASerializer.prototype.toString = function() {
   if(this.dfa.s0 === null) {
       return null;
   }
   var buf = "";
   var states = this.dfa.sortedStates();
   for(var i=0;i<states.length;i++) {
       var s = states[i];
       if(s.edges!==null) {
            var n = s.edges.length;
            for(var j=0;j<n;j++) {
                var t = s.edges[j] || null;
                if(t!==null && t.stateNumber !== 0x7FFFFFFF) {
                    buf = buf.concat(this.getStateString(s));
                    buf = buf.concat("-");
                    buf = buf.concat(this.getEdgeLabel(j));
                    buf = buf.concat("->");
                    buf = buf.concat(this.getStateString(t));
                    buf = buf.concat('\n');
                }
            }
       }
   }
   return buf.length===0 ? null : buf;
};

DFASerializer.prototype.getEdgeLabel = function(i) {
    if (i===0) {
        return "EOF";
    } else if(this.literalNames !==null || this.symbolicNames!==null) {
        return this.literalNames[i-1] || this.symbolicNames[i-1];
    } else {
        return String.fromCharCode(i-1);
    }
};

DFASerializer.prototype.getStateString = function(s) {
    var baseStateStr = ( s.isAcceptState ? ":" : "") + "s" + s.stateNumber + ( s.requiresFullContext ? "^" : "");
    if(s.isAcceptState) {
        if (s.predicates !== null) {
            return baseStateStr + "=>" + s.predicates.toString();
        } else {
            return baseStateStr + "=>" + s.prediction.toString();
        }
    } else {
        return baseStateStr;
    }
};

function LexerDFASerializer(dfa) {
	DFASerializer.call(this, dfa, null);
	return this;
}

LexerDFASerializer.prototype = Object.create(DFASerializer.prototype);
LexerDFASerializer.prototype.constructor = LexerDFASerializer;

LexerDFASerializer.prototype.getEdgeLabel = function(i) {
	return "'" + String.fromCharCode(i) + "'";
};

exports.DFASerializer = DFASerializer;
exports.LexerDFASerializer = LexerDFASerializer;



/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//* A rule invocation record for parsing.
//
//  Contains all of the information about the current rule not stored in the
//  RuleContext. It handles parse tree children list, Any ATN state
//  tracing, and the default values available for rule indications:
//  start, stop, rule index, current alt number, current
//  ATN state.
//
//  Subclasses made for each rule and grammar track the parameters,
//  return values, locals, and labels specific to that rule. These
//  are the objects that are returned from rules.
//
//  Note text is not an actual field of a rule return value; it is computed
//  from start and stop using the input stream's toString() method.  I
//  could add a ctor to this so that we can pass in and store the input
//  stream, but I'm not sure we want to do that.  It would seem to be undefined
//  to get the .text property anyway if the rule matches tokens from multiple
//  input streams.
//
//  I do not use getters for fields of objects that are used simply to
//  group values such as this aggregate.  The getters/setters are there to
//  satisfy the superclass interface.

var RuleContext = __webpack_require__(26).RuleContext;
var Tree = __webpack_require__(5);
var INVALID_INTERVAL = Tree.INVALID_INTERVAL;
var TerminalNode = Tree.TerminalNode;
var TerminalNodeImpl = Tree.TerminalNodeImpl;
var ErrorNodeImpl = Tree.ErrorNodeImpl;
var Interval = __webpack_require__(2).Interval;

function ParserRuleContext(parent, invokingStateNumber) {
	parent = parent || null;
	invokingStateNumber = invokingStateNumber || null;
	RuleContext.call(this, parent, invokingStateNumber);
	this.ruleIndex = -1;
    // * If we are debugging or building a parse tree for a visitor,
    // we need to track all of the tokens and rule invocations associated
    // with this rule's context. This is empty for parsing w/o tree constr.
    // operation because we don't the need to track the details about
    // how we parse this rule.
    // /
    this.children = null;
    this.start = null;
    this.stop = null;
    // The exception that forced this rule to return. If the rule successfully
    // completed, this is {@code null}.
    this.exception = null;
}

ParserRuleContext.prototype = Object.create(RuleContext.prototype);
ParserRuleContext.prototype.constructor = ParserRuleContext;

// * COPY a ctx (I'm deliberately not using copy constructor)///
ParserRuleContext.prototype.copyFrom = function(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    // copy any error nodes to alt label node
    if(ctx.children) {
        this.children = [];
        // reset parent pointer for any error nodes
    	ctx.children.map(function(child) {
    		if (child instanceof ErrorNodeImpl) {
                this.children.push(child);
                child.parentCtx = this;
            }
		}, this);
	}
};

// Double dispatch methods for listeners
ParserRuleContext.prototype.enterRule = function(listener) {
};

ParserRuleContext.prototype.exitRule = function(listener) {
};

// * Does not set parent link; other add methods do that///
ParserRuleContext.prototype.addChild = function(child) {
    if (this.children === null) {
        this.children = [];
    }
    this.children.push(child);
    return child;
};

// * Used by enterOuterAlt to toss out a RuleContext previously added as
// we entered a rule. If we have // label, we will need to remove
// generic ruleContext object.
// /
ParserRuleContext.prototype.removeLastChild = function() {
    if (this.children !== null) {
        this.children.pop();
    }
};

ParserRuleContext.prototype.addTokenNode = function(token) {
    var node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.addErrorNode = function(badToken) {
    var node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.getChild = function(i, type) {
	type = type || null;
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	if (type === null) {
		return this.children[i];
	} else {
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if(child instanceof type) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
		}
		return null;
    }
};


ParserRuleContext.prototype.getToken = function(ttype, i) {
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	for(var j=0; j<this.children.length; j++) {
		var child = this.children[j];
		if (child instanceof TerminalNode) {
			if (child.symbol.type === ttype) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
        }
	}
    return null;
};

ParserRuleContext.prototype.getTokens = function(ttype ) {
    if (this.children=== null) {
        return [];
    } else {
		var tokens = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof TerminalNode) {
				if (child.symbol.type === ttype) {
					tokens.push(child);
				}
			}
		}
		return tokens;
    }
};

ParserRuleContext.prototype.getTypedRuleContext = function(ctxType, i) {
    return this.getChild(i, ctxType);
};

ParserRuleContext.prototype.getTypedRuleContexts = function(ctxType) {
    if (this.children=== null) {
        return [];
    } else {
		var contexts = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof ctxType) {
				contexts.push(child);
			}
		}
		return contexts;
	}
};

ParserRuleContext.prototype.getChildCount = function() {
	if (this.children=== null) {
		return 0;
	} else {
		return this.children.length;
	}
};

ParserRuleContext.prototype.getSourceInterval = function() {
    if( this.start === null || this.stop === null) {
        return INVALID_INTERVAL;
    } else {
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
};

RuleContext.EMPTY = new ParserRuleContext();

function InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
	ParserRuleContext.call(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
    return this;
}

InterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);
InterpreterRuleContext.prototype.constructor = InterpreterRuleContext;

exports.ParserRuleContext = ParserRuleContext;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(1).Token;
__webpack_require__(66);
__webpack_require__(67);

// Vacuum all input from a string and then treat it like a buffer.

function _loadString(stream, decodeToUnicodeCodePoints) {
	stream._index = 0;
	stream.data = [];
	if (stream.decodeToUnicodeCodePoints) {
		for (var i = 0; i < stream.strdata.length; ) {
			var codePoint = stream.strdata.codePointAt(i);
			stream.data.push(codePoint);
			i += codePoint <= 0xFFFF ? 1 : 2;
		}
	} else {
		for (var i = 0; i < stream.strdata.length; i++) {
			var codeUnit = stream.strdata.charCodeAt(i);
			stream.data.push(codeUnit);
		}
	}
	stream._size = stream.data.length;
}

// If decodeToUnicodeCodePoints is true, the input is treated
// as a series of Unicode code points.
//
// Otherwise, the input is treated as a series of 16-bit UTF-16 code
// units.
function InputStream(data, decodeToUnicodeCodePoints) {
	this.name = "<empty>";
	this.strdata = data;
	this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
	_loadString(this);
	return this;
}

Object.defineProperty(InputStream.prototype, "index", {
	get : function() {
		return this._index;
	}
});

Object.defineProperty(InputStream.prototype, "size", {
	get : function() {
		return this._size;
	}
});

// Reset the stream so that it's in the same state it was
// when the object was created *except* the data array is not
// touched.
//
InputStream.prototype.reset = function() {
	this._index = 0;
};

InputStream.prototype.consume = function() {
	if (this._index >= this._size) {
		// assert this.LA(1) == Token.EOF
		throw ("cannot consume EOF");
	}
	this._index += 1;
};

InputStream.prototype.LA = function(offset) {
	if (offset === 0) {
		return 0; // undefined
	}
	if (offset < 0) {
		offset += 1; // e.g., translate LA(-1) to use offset=0
	}
	var pos = this._index + offset - 1;
	if (pos < 0 || pos >= this._size) { // invalid
		return Token.EOF;
	}
	return this.data[pos];
};

InputStream.prototype.LT = function(offset) {
	return this.LA(offset);
};

// mark/release do nothing; we have entire buffer
InputStream.prototype.mark = function() {
	return -1;
};

InputStream.prototype.release = function(marker) {
};

// consume() ahead until p==_index; can't just set p=_index as we must
// update line and column. If we seek backwards, just set p
//
InputStream.prototype.seek = function(_index) {
	if (_index <= this._index) {
		this._index = _index; // just jump; don't update stream state (line,
								// ...)
		return;
	}
	// seek forward
	this._index = Math.min(_index, this._size);
};

InputStream.prototype.getText = function(start, stop) {
	if (stop >= this._size) {
		stop = this._size - 1;
	}
	if (start >= this._size) {
		return "";
	} else {
		if (this.decodeToUnicodeCodePoints) {
			var result = "";
			for (var i = start; i <= stop; i++) {
				result += String.fromCodePoint(this.data[i]);
			}
			return result;
		} else {
			return this.strdata.slice(start, stop + 1);
		}
	}
};

InputStream.prototype.toString = function() {
	return this.strdata;
};

exports.InputStream = InputStream;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Utils = __webpack_require__(0);
var Token = __webpack_require__(1).Token;
var RuleNode = __webpack_require__(5).RuleNode;
var ErrorNode = __webpack_require__(5).ErrorNode;
var TerminalNode = __webpack_require__(5).TerminalNode;
var ParserRuleContext = __webpack_require__(34).ParserRuleContext;
var RuleContext = __webpack_require__(26).RuleContext;
var INVALID_ALT_NUMBER = __webpack_require__(10).INVALID_ALT_NUMBER;


/** A set of utility routines useful for all kinds of ANTLR trees. */
function Trees() {
}

// Print out a whole tree in LISP form. {@link //getNodeText} is used on the
//  node payloads to get the text for the nodes.  Detect
//  parse trees and extract data appropriately.
Trees.toStringTree = function(tree, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
       ruleNames = recog.ruleNames;
    }
    var s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    var c = tree.getChildCount();
    if(c===0) {
        return s;
    }
    var res = "(" + s + ' ';
    if(c>0) {
        s = Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
    }
    for(var i=1;i<c;i++) {
        s = Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(' ' + s);
    }
    res = res.concat(")");
    return res;
};

Trees.getNodeText = function(t, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
        ruleNames = recog.ruleNames;
    }
    if(ruleNames!==null) {
       if (t instanceof RuleContext) {
           var altNumber = t.getAltNumber();
           if ( altNumber!=INVALID_ALT_NUMBER ) {
               return ruleNames[t.ruleIndex]+":"+altNumber;
           }
           return ruleNames[t.ruleIndex];
       } else if ( t instanceof ErrorNode) {
           return t.toString();
       } else if(t instanceof TerminalNode) {
           if(t.symbol!==null) {
               return t.symbol.text;
           }
       }
    }
    // no recog for rule names
    var payload = t.getPayload();
    if (payload instanceof Token ) {
       return payload.text;
    }
    return t.getPayload().toString();
};


// Return ordered list of all children of this node
Trees.getChildren = function(t) {
	var list = [];
	for(var i=0;i<t.getChildCount();i++) {
		list.push(t.getChild(i));
	}
	return list;
};

// Return a list of all ancestors of this node.  The first node of
//  list is the root and the last is the parent of this node.
//
Trees.getAncestors = function(t) {
    var ancestors = [];
    t = t.getParent();
    while(t!==null) {
        ancestors = [t].concat(ancestors);
        t = t.getParent();
    }
    return ancestors;
};

Trees.findAllTokenNodes = function(t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
};

Trees.findAllRuleNodes = function(t, ruleIndex) {
	return Trees.findAllNodes(t, ruleIndex, false);
};

Trees.findAllNodes = function(t, index, findTokens) {
	var nodes = [];
	Trees._findAllNodes(t, index, findTokens, nodes);
	return nodes;
};

Trees._findAllNodes = function(t, index, findTokens, nodes) {
	// check this node (the root) first
	if(findTokens && (t instanceof TerminalNode)) {
		if(t.symbol.type===index) {
			nodes.push(t);
		}
	} else if(!findTokens && (t instanceof ParserRuleContext)) {
		if(t.ruleIndex===index) {
			nodes.push(t);
		}
	}
	// check children
	for(var i=0;i<t.getChildCount();i++) {
		Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
	}
};

Trees.descendants = function(t) {
	var nodes = [t];
    for(var i=0;i<t.getChildCount();i++) {
        nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
};


exports.Trees = Trees;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = __webpack_require__(1).Token;
var ATN = __webpack_require__(10).ATN;
var ATNType = __webpack_require__(112).ATNType;
var ATNStates = __webpack_require__(7);
var ATNState = ATNStates.ATNState;
var BasicState = ATNStates.BasicState;
var DecisionState = ATNStates.DecisionState;
var BlockStartState = ATNStates.BlockStartState;
var BlockEndState = ATNStates.BlockEndState;
var LoopEndState = ATNStates.LoopEndState;
var RuleStartState = ATNStates.RuleStartState;
var RuleStopState = ATNStates.RuleStopState;
var TokensStartState = ATNStates.TokensStartState;
var PlusLoopbackState = ATNStates.PlusLoopbackState;
var StarLoopbackState = ATNStates.StarLoopbackState;
var StarLoopEntryState = ATNStates.StarLoopEntryState;
var PlusBlockStartState = ATNStates.PlusBlockStartState;
var StarBlockStartState = ATNStates.StarBlockStartState;
var BasicBlockStartState = ATNStates.BasicBlockStartState;
var Transitions = __webpack_require__(11);
var Transition = Transitions.Transition;
var AtomTransition = Transitions.AtomTransition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var RangeTransition = Transitions.RangeTransition;
var ActionTransition = Transitions.ActionTransition;
var EpsilonTransition = Transitions.EpsilonTransition;
var WildcardTransition = Transitions.WildcardTransition;
var PredicateTransition = Transitions.PredicateTransition;
var PrecedencePredicateTransition = Transitions.PrecedencePredicateTransition;
var IntervalSet = __webpack_require__(2).IntervalSet;
var Interval = __webpack_require__(2).Interval;
var ATNDeserializationOptions = __webpack_require__(61).ATNDeserializationOptions;
var LexerActions = __webpack_require__(62);
var LexerActionType = LexerActions.LexerActionType;
var LexerSkipAction = LexerActions.LexerSkipAction;
var LexerChannelAction = LexerActions.LexerChannelAction;
var LexerCustomAction = LexerActions.LexerCustomAction;
var LexerMoreAction = LexerActions.LexerMoreAction;
var LexerTypeAction = LexerActions.LexerTypeAction;
var LexerPushModeAction = LexerActions.LexerPushModeAction;
var LexerPopModeAction = LexerActions.LexerPopModeAction;
var LexerModeAction = LexerActions.LexerModeAction;
// This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance
var BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";

//
// This UUID indicates the serialized ATN contains two sets of
// IntervalSets, where the second set's values are encoded as
// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
//
var ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089";

// This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.
var SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];

var SERIALIZED_VERSION = 3;

// This is the current serialized UUID.
var SERIALIZED_UUID = ADDED_UNICODE_SMP;

function initArray( length, value) {
	var tmp = [];
	tmp[length-1] = value;
	return tmp.map(function(i) {return value;});
}

function ATNDeserializer (options) {

    if ( options=== undefined || options === null ) {
        options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;

    return this;
}

// Determines if a particular serialized representation of an ATN supports
// a particular feature, identified by the {@link UUID} used for serializing
// the ATN at the time the feature was first introduced.
//
// @param feature The {@link UUID} marking the first time the feature was
// supported in the serialized ATN.
// @param actualUuid The {@link UUID} of the actual serialized ATN which is
// currently being deserialized.
// @return {@code true} if the {@code actualUuid} value represents a
// serialized ATN at or after the feature identified by {@code feature} was
// introduced; otherwise, {@code false}.

ATNDeserializer.prototype.isFeatureSupported = function(feature, actualUuid) {
    var idx1 = SUPPORTED_UUIDS.indexOf(feature);
    if (idx1<0) {
        return false;
    }
    var idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
    return idx2 >= idx1;
};

ATNDeserializer.prototype.deserialize = function(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    var atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    var sets = [];
    // First, deserialize sets with 16-bit arguments <= U+FFFF.
    this.readSets(atn, sets, this.readInt.bind(this));
    // Next, if the ATN was serialized with the Unicode SMP feature,
    // deserialize sets with 32-bit arguments <= U+10FFFF.
    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
        this.readSets(atn, sets, this.readInt32.bind(this));
    }
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {
        this.generateRuleBypassTransitions(atn);
        // re-verify after modification
        this.verifyATN(atn);
    }
    return atn;
};

ATNDeserializer.prototype.reset = function(data) {
	var adjust = function(c) {
        var v = c.charCodeAt(0);
        return v>1  ? v-2 : v + 65533;
	};
    var temp = data.split("").map(adjust);
    // don't adjust the first value since that's the version number
    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
};

ATNDeserializer.prototype.checkVersion = function() {
    var version = this.readInt();
    if ( version !== SERIALIZED_VERSION ) {
        throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
    }
};

ATNDeserializer.prototype.checkUUID = function() {
    var uuid = this.readUUID();
    if (SUPPORTED_UUIDS.indexOf(uuid)<0) {
        throw ("Could not deserialize ATN with UUID: " + uuid +
                        " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID);
    }
    this.uuid = uuid;
};

ATNDeserializer.prototype.readATN = function() {
    var grammarType = this.readInt();
    var maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
};

ATNDeserializer.prototype.readStates = function(atn) {
	var j, pair, stateNumber;
    var loopBackStateNumbers = [];
    var endStateNumbers = [];
    var nstates = this.readInt();
    for(var i=0; i<nstates; i++) {
        var stype = this.readInt();
        // ignore bad type of states
        if (stype===ATNState.INVALID_TYPE) {
            atn.addState(null);
            continue;
        }
        var ruleIndex = this.readInt();
        if (ruleIndex === 0xFFFF) {
            ruleIndex = -1;
        }
        var s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNState.LOOP_END) { // special case
            var loopBackStateNumber = this.readInt();
            loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if(s instanceof BlockStartState) {
            var endStateNumber = this.readInt();
            endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
    }
    // delay the assignment of loop back and end states until we know all the
	// state instances have been initialized
    for (j=0; j<loopBackStateNumbers.length; j++) {
        pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]];
    }

    for (j=0; j<endStateNumbers.length; j++) {
        pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
    }

    var numNonGreedyStates = this.readInt();
    for (j=0; j<numNonGreedyStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].nonGreedy = true;
    }

    var numPrecedenceStates = this.readInt();
    for (j=0; j<numPrecedenceStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].isPrecedenceRule = true;
    }
};

ATNDeserializer.prototype.readRules = function(atn) {
    var i;
    var nrules = this.readInt();
    if (atn.grammarType === ATNType.LEXER ) {
        atn.ruleToTokenType = initArray(nrules, 0);
    }
    atn.ruleToStartState = initArray(nrules, 0);
    for (i=0; i<nrules; i++) {
        var s = this.readInt();
        var startState = atn.states[s];
        atn.ruleToStartState[i] = startState;
        if ( atn.grammarType === ATNType.LEXER ) {
            var tokenType = this.readInt();
            if (tokenType === 0xFFFF) {
                tokenType = Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
        }
    }
    atn.ruleToStopState = initArray(nrules, 0);
    for (i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
            continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
};

ATNDeserializer.prototype.readModes = function(atn) {
    var nmodes = this.readInt();
    for (var i=0; i<nmodes; i++) {
        var s = this.readInt();
        atn.modeToStartState.push(atn.states[s]);
    }
};

ATNDeserializer.prototype.readSets = function(atn, sets, readUnicode) {
    var m = this.readInt();
    for (var i=0; i<m; i++) {
        var iset = new IntervalSet();
        sets.push(iset);
        var n = this.readInt();
        var containsEof = this.readInt();
        if (containsEof!==0) {
            iset.addOne(-1);
        }
        for (var j=0; j<n; j++) {
            var i1 = readUnicode();
            var i2 = readUnicode();
            iset.addRange(i1, i2);
        }
    }
};

ATNDeserializer.prototype.readEdges = function(atn, sets) {
	var i, j, state, trans, target;
    var nedges = this.readInt();
    for (i=0; i<nedges; i++) {
        var src = this.readInt();
        var trg = this.readInt();
        var ttype = this.readInt();
        var arg1 = this.readInt();
        var arg2 = this.readInt();
        var arg3 = this.readInt();
        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        var srcState = atn.states[src];
        srcState.addTransition(trans);
    }
    // edges for rule stop states can be derived, so they aren't serialized
    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for (j=0; j<state.transitions.length; j++) {
            var t = state.transitions[j];
            if (!(t instanceof RuleTransition)) {
                continue;
            }
			var outermostPrecedenceReturn = -1;
			if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
				if (t.precedence === 0) {
					outermostPrecedenceReturn = t.target.ruleIndex;
				}
			}

			trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
    }

    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
            // we need to know the end state to set its start state
            if (state.endState === null) {
                throw ("IllegalState");
            }
            // block end states can only be associated to a single block start
			// state
            if ( state.endState.startState !== null) {
                throw ("IllegalState");
            }
            state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof PlusBlockStartState) {
                    target.loopBackState = state;
                }
            }
        } else if (state instanceof StarLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof StarLoopEntryState) {
                    target.loopBackState = state;
                }
            }
        }
    }
};

ATNDeserializer.prototype.readDecisions = function(atn) {
    var ndecisions = this.readInt();
    for (var i=0; i<ndecisions; i++) {
        var s = this.readInt();
        var decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
    }
};

ATNDeserializer.prototype.readLexerActions = function(atn) {
    if (atn.grammarType === ATNType.LEXER) {
        var count = this.readInt();
        atn.lexerActions = initArray(count, null);
        for (var i=0; i<count; i++) {
            var actionType = this.readInt();
            var data1 = this.readInt();
            if (data1 === 0xFFFF) {
                data1 = -1;
            }
            var data2 = this.readInt();
            if (data2 === 0xFFFF) {
                data2 = -1;
            }
            var lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[i] = lexerAction;
        }
    }
};

ATNDeserializer.prototype.generateRuleBypassTransitions = function(atn) {
	var i;
    var count = atn.ruleToStartState.length;
    for(i=0; i<count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for(i=0; i<count; i++) {
        this.generateRuleBypassTransition(atn, i);
    }
};

ATNDeserializer.prototype.generateRuleBypassTransition = function(atn, idx) {
	var i, state;
    var bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);

    var bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);

    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);

    bypassStop.startState = bypassStart;

    var excludeTransition = null;
    var endState = null;

    if (atn.ruleToStartState[idx].isPrecedenceRule) {
        // wrap from the beginning of the rule to the StarLoopEntryState
        endState = null;
        for(i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            if (this.stateIsEndStateFor(state, idx)) {
                endState = state;
                excludeTransition = state.loopBackState.transitions[0];
                break;
            }
        }
        if (excludeTransition === null) {
            throw ("Couldn't identify final state of the precedence rule prefix section.");
        }
    } else {
        endState = atn.ruleToStopState[idx];
    }

    // all non-excluded transitions that currently target end state need to
	// target blockEnd instead
    for(i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for(var j=0; j<state.transitions.length; j++) {
            var transition = state.transitions[j];
            if (transition === excludeTransition) {
                continue;
            }
            if (transition.target === endState) {
                transition.target = bypassStop;
            }
        }
    }

    // all transitions leaving the rule start state need to leave blockStart
	// instead
    var ruleToStartState = atn.ruleToStartState[idx];
    var count = ruleToStartState.transitions.length;
    while ( count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count-1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    // link the new states
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));

    var matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
};

ATNDeserializer.prototype.stateIsEndStateFor = function(state, idx) {
    if ( state.ruleIndex !== idx) {
        return null;
    }
    if (!( state instanceof StarLoopEntryState)) {
        return null;
    }
    var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!( maybeLoopEndState instanceof LoopEndState)) {
        return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions &&
        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
        return state;
    } else {
        return null;
    }
};

//
// Analyze the {@link StarLoopEntryState} states in the specified ATN to set
// the {@link StarLoopEntryState//isPrecedenceDecision} field to the
// correct value.
//
// @param atn The ATN.
//
ATNDeserializer.prototype.markPrecedenceDecisions = function(atn) {
	for(var i=0; i<atn.states.length; i++) {
		var state = atn.states[i];
		if (!( state instanceof StarLoopEntryState)) {
            continue;
        }
        // We analyze the ATN to determine if this ATN decision state is the
        // decision for the closure block that determines whether a
        // precedence rule should continue or complete.
        //
        if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
            if (maybeLoopEndState instanceof LoopEndState) {
                if ( maybeLoopEndState.epsilonOnlyTransitions &&
                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
                    state.isPrecedenceDecision = true;
                }
            }
        }
	}
};

ATNDeserializer.prototype.verifyATN = function(atn) {
    if (!this.deserializationOptions.verifyATN) {
        return;
    }
    // verify assumptions
	for(var i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (state === null) {
            continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== null);
        } else  if (state instanceof StarLoopEntryState) {
            this.checkCondition(state.loopBackState !== null);
            this.checkCondition(state.transitions.length === 2);
            if (state.transitions[0].target instanceof StarBlockStartState) {
                this.checkCondition(state.transitions[1].target instanceof LoopEndState);
                this.checkCondition(!state.nonGreedy);
            } else if (state.transitions[0].target instanceof LoopEndState) {
                this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
                this.checkCondition(state.nonGreedy);
            } else {
                throw("IllegalState");
            }
        } else if (state instanceof StarLoopbackState) {
            this.checkCondition(state.transitions.length === 1);
            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
            this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
            this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
            this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
            this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
            this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));
        }
	}
};

ATNDeserializer.prototype.checkCondition = function(condition, message) {
    if (!condition) {
        if (message === undefined || message===null) {
            message = "IllegalState";
        }
        throw (message);
    }
};

ATNDeserializer.prototype.readInt = function() {
    return this.data[this.pos++];
};

ATNDeserializer.prototype.readInt32 = function() {
    var low = this.readInt();
    var high = this.readInt();
    return low | (high << 16);
};

ATNDeserializer.prototype.readLong = function() {
    var low = this.readInt32();
    var high = this.readInt32();
    return (low & 0x00000000FFFFFFFF) | (high << 32);
};

function createByteToHex() {
	var bth = [];
	for (var i = 0; i < 256; i++) {
		bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
	}
	return bth;
}

var byteToHex = createByteToHex();

ATNDeserializer.prototype.readUUID = function() {
	var bb = [];
	for(var i=7;i>=0;i--) {
		var int = this.readInt();
		/* jshint bitwise: false */
		bb[(2*i)+1] = int & 0xFF;
		bb[2*i] = (int >> 8) & 0xFF;
	}
    return byteToHex[bb[0]] + byteToHex[bb[1]] +
    byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +
    byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +
    byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +
    byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +
    byteToHex[bb[10]] + byteToHex[bb[11]] +
    byteToHex[bb[12]] + byteToHex[bb[13]] +
    byteToHex[bb[14]] + byteToHex[bb[15]];
};

ATNDeserializer.prototype.edgeFactory = function(atn, type, src, trg, arg1, arg2, arg3, sets) {
    var target = atn.states[trg];
    switch(type) {
    case Transition.EPSILON:
        return new EpsilonTransition(target);
    case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
    case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
    case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
    case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
    case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.SET:
        return new SetTransition(target, sets[arg1]);
    case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
    case Transition.WILDCARD:
        return new WildcardTransition(target);
    default:
        throw "The specified transition type: " + type + " is not valid.";
    }
};

ATNDeserializer.prototype.stateFactory = function(type, ruleIndex) {
    if (this.stateFactories === null) {
        var sf = [];
        sf[ATNState.INVALID_TYPE] = null;
        sf[ATNState.BASIC] = function() { return new BasicState(); };
        sf[ATNState.RULE_START] = function() { return new RuleStartState(); };
        sf[ATNState.BLOCK_START] = function() { return new BasicBlockStartState(); };
        sf[ATNState.PLUS_BLOCK_START] = function() { return new PlusBlockStartState(); };
        sf[ATNState.STAR_BLOCK_START] = function() { return new StarBlockStartState(); };
        sf[ATNState.TOKEN_START] = function() { return new TokensStartState(); };
        sf[ATNState.RULE_STOP] = function() { return new RuleStopState(); };
        sf[ATNState.BLOCK_END] = function() { return new BlockEndState(); };
        sf[ATNState.STAR_LOOP_BACK] = function() { return new StarLoopbackState(); };
        sf[ATNState.STAR_LOOP_ENTRY] = function() { return new StarLoopEntryState(); };
        sf[ATNState.PLUS_LOOP_BACK] = function() { return new PlusLoopbackState(); };
        sf[ATNState.LOOP_END] = function() { return new LoopEndState(); };
        this.stateFactories = sf;
    }
    if (type>this.stateFactories.length || this.stateFactories[type] === null) {
        throw("The specified state type " + type + " is not valid.");
    } else {
        var s = this.stateFactories[type]();
        if (s!==null) {
            s.ruleIndex = ruleIndex;
            return s;
        }
    }
};

ATNDeserializer.prototype.lexerActionFactory = function(type, data1, data2) {
    if (this.actionFactories === null) {
        var af = [];
        af[LexerActionType.CHANNEL] = function(data1, data2) { return new LexerChannelAction(data1); };
        af[LexerActionType.CUSTOM] = function(data1, data2) { return new LexerCustomAction(data1, data2); };
        af[LexerActionType.MODE] = function(data1, data2) { return new LexerModeAction(data1); };
        af[LexerActionType.MORE] = function(data1, data2) { return LexerMoreAction.INSTANCE; };
        af[LexerActionType.POP_MODE] = function(data1, data2) { return LexerPopModeAction.INSTANCE; };
        af[LexerActionType.PUSH_MODE] = function(data1, data2) { return new LexerPushModeAction(data1); };
        af[LexerActionType.SKIP] = function(data1, data2) { return LexerSkipAction.INSTANCE; };
        af[LexerActionType.TYPE] = function(data1, data2) { return new LexerTypeAction(data1); };
        this.actionFactories = af;
    }
    if (type>this.actionFactories.length || this.actionFactories[type] === null) {
        throw("The specified lexer action type " + type + " is not valid.");
    } else {
        return this.actionFactories[type](data1, data2);
    }
};


exports.ATNDeserializer = ATNDeserializer;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function ATNDeserializationOptions(copyFrom) {
	if(copyFrom===undefined) {
		copyFrom = null;
	}
	this.readOnly = false;
    this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;

    return this;
}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

//    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

exports.ATNDeserializationOptions = ATNDeserializationOptions;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
 //

function LexerActionType() {
}

LexerActionType.CHANNEL = 0;     //The type of a {@link LexerChannelAction} action.
LexerActionType.CUSTOM = 1;      //The type of a {@link LexerCustomAction} action.
LexerActionType.MODE = 2;        //The type of a {@link LexerModeAction} action.
LexerActionType.MORE = 3;        //The type of a {@link LexerMoreAction} action.
LexerActionType.POP_MODE = 4;    //The type of a {@link LexerPopModeAction} action.
LexerActionType.PUSH_MODE = 5;   //The type of a {@link LexerPushModeAction} action.
LexerActionType.SKIP = 6;        //The type of a {@link LexerSkipAction} action.
LexerActionType.TYPE = 7;        //The type of a {@link LexerTypeAction} action.

function LexerAction(action) {
    this.actionType = action;
    this.isPositionDependent = false;
    return this;
}

LexerAction.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish()
};

LexerAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType);
};

LexerAction.prototype.equals = function(other) {
    return this === other;
};



//
// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
//
// <p>The {@code skip} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerSkipAction() {
	LexerAction.call(this, LexerActionType.SKIP);
	return this;
}

LexerSkipAction.prototype = Object.create(LexerAction.prototype);
LexerSkipAction.prototype.constructor = LexerSkipAction;

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

LexerSkipAction.prototype.execute = function(lexer) {
    lexer.skip();
};

LexerSkipAction.prototype.toString = function() {
	return "skip";
};

//  Implements the {@code type} lexer action by calling {@link Lexer//setType}
// with the assigned type.
function LexerTypeAction(type) {
	LexerAction.call(this, LexerActionType.TYPE);
	this.type = type;
	return this;
}

LexerTypeAction.prototype = Object.create(LexerAction.prototype);
LexerTypeAction.prototype.constructor = LexerTypeAction;

LexerTypeAction.prototype.execute = function(lexer) {
    lexer.type = this.type;
};

LexerTypeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.type);
};


LexerTypeAction.prototype.equals = function(other) {
    if(this === other) {
        return true;
    } else if (! (other instanceof LexerTypeAction)) {
        return false;
    } else {
        return this.type === other.type;
    }
};

LexerTypeAction.prototype.toString = function() {
    return "type(" + this.type + ")";
};

// Implements the {@code pushMode} lexer action by calling
// {@link Lexer//pushMode} with the assigned mode.
function LexerPushModeAction(mode) {
	LexerAction.call(this, LexerActionType.PUSH_MODE);
    this.mode = mode;
    return this;
}

LexerPushModeAction.prototype = Object.create(LexerAction.prototype);
LexerPushModeAction.prototype.constructor = LexerPushModeAction;

// <p>This action is implemented by calling {@link Lexer//pushMode} with the
// value provided by {@link //getMode}.</p>
LexerPushModeAction.prototype.execute = function(lexer) {
    lexer.pushMode(this.mode);
};

LexerPushModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerPushModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerPushModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerPushModeAction.prototype.toString = function() {
	return "pushMode(" + this.mode + ")";
};


// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
//
// <p>The {@code popMode} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerPopModeAction() {
	LexerAction.call(this,LexerActionType.POP_MODE);
	return this;
}

LexerPopModeAction.prototype = Object.create(LexerAction.prototype);
LexerPopModeAction.prototype.constructor = LexerPopModeAction;

LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerPopModeAction.prototype.execute = function(lexer) {
    lexer.popMode();
};

LexerPopModeAction.prototype.toString = function() {
	return "popMode";
};

// Implements the {@code more} lexer action by calling {@link Lexer//more}.
//
// <p>The {@code more} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerMoreAction() {
	LexerAction.call(this, LexerActionType.MORE);
	return this;
}

LexerMoreAction.prototype = Object.create(LexerAction.prototype);
LexerMoreAction.prototype.constructor = LexerMoreAction;

LexerMoreAction.INSTANCE = new LexerMoreAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerMoreAction.prototype.execute = function(lexer) {
    lexer.more();
};

LexerMoreAction.prototype.toString = function() {
    return "more";
};


// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
// the assigned mode.
function LexerModeAction(mode) {
	LexerAction.call(this, LexerActionType.MODE);
    this.mode = mode;
    return this;
}

LexerModeAction.prototype = Object.create(LexerAction.prototype);
LexerModeAction.prototype.constructor = LexerModeAction;

// <p>This action is implemented by calling {@link Lexer//mode} with the
// value provided by {@link //getMode}.</p>
LexerModeAction.prototype.execute = function(lexer) {
    lexer.mode(this.mode);
};

LexerModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerModeAction.prototype.toString = function() {
    return "mode(" + this.mode + ")";
};

// Executes a custom lexer action by calling {@link Recognizer//action} with the
// rule and action indexes assigned to the custom action. The implementation of
// a custom action is added to the generated code for the lexer in an override
// of {@link Recognizer//action} when the grammar is compiled.
//
// <p>This class may represent embedded actions created with the <code>{...}</code>
// syntax in ANTLR 4, as well as actions created for lexer commands where the
// command argument could not be evaluated when the grammar was compiled.</p>


    // Constructs a custom lexer action with the specified rule and action
    // indexes.
    //
    // @param ruleIndex The rule index to use for calls to
    // {@link Recognizer//action}.
    // @param actionIndex The action index to use for calls to
    // {@link Recognizer//action}.

function LexerCustomAction(ruleIndex, actionIndex) {
	LexerAction.call(this, LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
    return this;
}

LexerCustomAction.prototype = Object.create(LexerAction.prototype);
LexerCustomAction.prototype.constructor = LexerCustomAction;

// <p>Custom actions are implemented by calling {@link Lexer//action} with the
// appropriate rule and action indexes.</p>
LexerCustomAction.prototype.execute = function(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerCustomAction)) {
        return false;
    } else {
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
};

// Implements the {@code channel} lexer action by calling
// {@link Lexer//setChannel} with the assigned channel.
// Constructs a new {@code channel} action with the specified channel value.
// @param channel The channel value to pass to {@link Lexer//setChannel}.
function LexerChannelAction(channel) {
	LexerAction.call(this, LexerActionType.CHANNEL);
    this.channel = channel;
    return this;
}

LexerChannelAction.prototype = Object.create(LexerAction.prototype);
LexerChannelAction.prototype.constructor = LexerChannelAction;

// <p>This action is implemented by calling {@link Lexer//setChannel} with the
// value provided by {@link //getChannel}.</p>
LexerChannelAction.prototype.execute = function(lexer) {
    lexer._channel = this.channel;
};

LexerChannelAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.channel);
};

LexerChannelAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerChannelAction)) {
        return false;
    } else {
        return this.channel === other.channel;
    }
};

LexerChannelAction.prototype.toString = function() {
    return "channel(" + this.channel + ")";
};

// This implementation of {@link LexerAction} is used for tracking input offsets
// for position-dependent actions within a {@link LexerActionExecutor}.
//
// <p>This action is not serialized as part of the ATN, and is only required for
// position-dependent lexer actions which appear at a location other than the
// end of a rule. For more information about DFA optimizations employed for
// lexer actions, see {@link LexerActionExecutor//append} and
// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>

// Constructs a new indexed custom action by associating a character offset
// with a {@link LexerAction}.
//
// <p>Note: This class is only required for lexer actions for which
// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
//
// @param offset The offset into the input {@link CharStream}, relative to
// the token start index, at which the specified lexer action should be
// executed.
// @param action The lexer action to execute at a particular offset in the
// input {@link CharStream}.
function LexerIndexedCustomAction(offset, action) {
	LexerAction.call(this, action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
    return this;
}

LexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);
LexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction;

// <p>This method calls {@link //execute} on the result of {@link //getAction}
// using the provided {@code lexer}.</p>
LexerIndexedCustomAction.prototype.execute = function(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
};

LexerIndexedCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.offset, this.action);
};

LexerIndexedCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerIndexedCustomAction)) {
        return false;
    } else {
        return this.offset === other.offset && this.action === other.action;
    }
};


exports.LexerActionType = LexerActionType;
exports.LexerSkipAction = LexerSkipAction;
exports.LexerChannelAction = LexerChannelAction;
exports.LexerCustomAction = LexerCustomAction;
exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
exports.LexerMoreAction = LexerMoreAction;
exports.LexerTypeAction = LexerTypeAction;
exports.LexerPushModeAction = LexerPushModeAction;
exports.LexerPopModeAction = LexerPopModeAction;
exports.LexerModeAction = LexerModeAction;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(1).Token;
var ConsoleErrorListener = __webpack_require__(28).ConsoleErrorListener;
var ProxyErrorListener = __webpack_require__(28).ProxyErrorListener;

function Recognizer() {
    this._listeners = [ ConsoleErrorListener.INSTANCE ];
    this._interp = null;
    this._stateNumber = -1;
    return this;
}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};


Recognizer.prototype.checkVersion = function(toolVersion) {
    var runtimeVersion = "4.7.1";
    if (runtimeVersion!==toolVersion) {
        console.log("ANTLR runtime and generated code versions disagree: "+runtimeVersion+"!="+toolVersion);
    }
};

Recognizer.prototype.addErrorListener = function(listener) {
    this._listeners.push(listener);
};

Recognizer.prototype.removeErrorListeners = function() {
    this._listeners = [];
};

Recognizer.prototype.getTokenTypeMap = function() {
    var tokenNames = this.getTokenNames();
    if (tokenNames===null) {
        throw("The current recognizer does not provide a list of token names.");
    }
    var result = this.tokenTypeMapCache[tokenNames];
    if(result===undefined) {
        result = tokenNames.reduce(function(o, k, i) { o[k] = i; });
        result.EOF = Token.EOF;
        this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
};

// Get a map from rule names to rule indexes.
//
// <p>Used for XPath and tree pattern compilation.</p>
//
Recognizer.prototype.getRuleIndexMap = function() {
    var ruleNames = this.ruleNames;
    if (ruleNames===null) {
        throw("The current recognizer does not provide a list of rule names.");
    }
    var result = this.ruleIndexMapCache[ruleNames];
    if(result===undefined) {
        result = ruleNames.reduce(function(o, k, i) { o[k] = i; });
        this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
};

Recognizer.prototype.getTokenType = function(tokenName) {
    var ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !==undefined) {
        return ttype;
    } else {
        return Token.INVALID_TYPE;
    }
};


// What is the error header, normally line/character position information?//
Recognizer.prototype.getErrorHeader = function(e) {
    var line = e.getOffendingToken().line;
    var column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
};


// How should a token be displayed in an error message? The default
//  is to display just the text, but during development you might
//  want to have a lot of information spit out.  Override in that case
//  to use t.toString() (which, for CommonToken, dumps everything about
//  the token). This is better than forcing you to override a method in
//  your token objects because you don't have to go modify your lexer
//  so that it creates a new Java type.
//
// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
// implementations of {@link ANTLRErrorStrategy} may provide a similar
// feature when necessary. For example, see
// {@link DefaultErrorStrategy//getTokenErrorDisplay}.
//
Recognizer.prototype.getTokenErrorDisplay = function(t) {
    if (t===null) {
        return "<no token>";
    }
    var s = t.text;
    if (s===null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    s = s.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t");
    return "'" + s + "'";
};

Recognizer.prototype.getErrorListenerDispatch = function() {
    return new ProxyErrorListener(this._listeners);
};

// subclass needs to override these if there are sempreds or actions
// that the ATN interp needs to execute
Recognizer.prototype.sempred = function(localctx, ruleIndex, actionIndex) {
    return true;
};

Recognizer.prototype.precpred = function(localctx , precedence) {
    return true;
};

//Indicate that the recognizer has changed internal state that is
//consistent with the ATN state passed in.  This way we always know
//where we are in the ATN as the parser goes along. The rule
//context objects form a stack that lets us see the stack of
//invoking rules. Combine this and we have complete ATN
//configuration information.

Object.defineProperty(Recognizer.prototype, "state", {
	get : function() {
		return this._stateNumber;
	},
	set : function(state) {
		this._stateNumber = state;
	}
});


exports.Recognizer = Recognizer;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var DFAState = __webpack_require__(17).DFAState;
var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var getCachedPredictionContext = __webpack_require__(9).getCachedPredictionContext;

function ATNSimulator(atn, sharedContextCache) {

    // The context cache maps all PredictionContext objects that are ==
    //  to a single cached copy. This cache is shared across all contexts
    //  in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
    //  to use only cached nodes/graphs in addDFAState(). We don't want to
    //  fill this during closure() since there are lots of contexts that
    //  pop up but are not used ever again. It also greatly slows down closure().
    //
    //  <p>This cache makes a huge difference in memory and a little bit in speed.
    //  For the Java grammar on java.*, it dropped the memory requirements
    //  at the end from 25M to 16M. We don't store any of the full context
    //  graphs in the DFA because they are limited to local context only,
    //  but apparently there's a lot of repetition there as well. We optimize
    //  the config contexts before storing the config set in the DFA states
    //  by literally rebuilding them with cached subgraphs only.</p>
    //
    //  <p>I tried a cache for use during closure operations, that was
    //  whacked after each adaptivePredict(). It cost a little bit
    //  more time I think and doesn't save on the overall footprint
    //  so it's not worth the complexity.</p>
    ///
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());


ATNSimulator.prototype.getCachedContext = function(context) {
    if (this.sharedContextCache ===null) {
        return context;
    }
    var visited = {};
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
};

exports.ATNSimulator = ATNSimulator;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//
//
// This enumeration defines the prediction modes available in ANTLR 4 along with
// utility methods for analyzing configuration sets for conflicts and/or
// ambiguities.

var Set = __webpack_require__(0).Set;
var Map = __webpack_require__(0).Map;
var BitSet = __webpack_require__(0).BitSet;
var AltDict = __webpack_require__(0).AltDict;
var ATN = __webpack_require__(10).ATN;
var RuleStopState = __webpack_require__(7).RuleStopState;
var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var ATNConfig = __webpack_require__(25).ATNConfig;
var SemanticContext = __webpack_require__(16).SemanticContext;
var Hash = __webpack_require__(0).Hash;
var hashStuff = __webpack_require__(0).hashStuff;
var equalArrays = __webpack_require__(0).equalArrays;

function PredictionMode() {
	return this;
}

//
// The SLL(*) prediction mode. This prediction mode ignores the current
// parser context when making predictions. This is the fastest prediction
// mode, and provides correct results for many grammars. This prediction
// mode is more powerful than the prediction mode provided by ANTLR 3, but
// may result in syntax errors for grammar and input combinations which are
// not SLL.
//
// <p>
// When using this prediction mode, the parser will either return a correct
// parse tree (i.e. the same parse tree that would be returned with the
// {@link //LL} prediction mode), or it will report a syntax error. If a
// syntax error is encountered when using the {@link //SLL} prediction mode,
// it may be due to either an actual syntax error in the input or indicate
// that the particular combination of grammar and input requires the more
// powerful {@link //LL} prediction abilities to complete successfully.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.SLL = 0;
//
// The LL(*) prediction mode. This prediction mode allows the current parser
// context to be used for resolving SLL conflicts that occur during
// prediction. This is the fastest prediction mode that guarantees correct
// parse results for all combinations of grammars with syntactically correct
// inputs.
//
// <p>
// When using this prediction mode, the parser will make correct decisions
// for all syntactically-correct grammar and input combinations. However, in
// cases where the grammar is truly ambiguous this prediction mode might not
// report a precise answer for <em>exactly which</em> alternatives are
// ambiguous.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL = 1;
//
// The LL(*) prediction mode with exact ambiguity detection. In addition to
// the correctness guarantees provided by the {@link //LL} prediction mode,
// this prediction mode instructs the prediction algorithm to determine the
// complete and exact set of ambiguous alternatives for every ambiguous
// decision encountered while parsing.
//
// <p>
// This prediction mode may be used for diagnosing ambiguities during
// grammar development. Due to the performance overhead of calculating sets
// of ambiguous alternatives, this prediction mode should be avoided when
// the exact results are not necessary.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL_EXACT_AMBIG_DETECTION = 2;


//
// Computes the SLL prediction termination condition.
//
// <p>
// This method computes the SLL prediction termination condition for both of
// the following cases.</p>
//
// <ul>
// <li>The usual SLL+LL fallback upon SLL conflict</li>
// <li>Pure SLL without LL fallback</li>
// </ul>
//
// <p><strong>COMBINED SLL+LL PARSING</strong></p>
//
// <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
// ensured regardless of how the termination condition is computed by this
// method. Due to the substantially higher cost of LL prediction, the
// prediction should only fall back to LL when the additional lookahead
// cannot lead to a unique SLL prediction.</p>
//
// <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
// conflicting subsets should fall back to full LL, even if the
// configuration sets don't resolve to the same alternative (e.g.
// {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
// configuration, SLL could continue with the hopes that more lookahead will
// resolve via one of those non-conflicting configurations.</p>
//
// <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
// stops when it sees only conflicting configuration subsets. In contrast,
// full LL keeps going when there is uncertainty.</p>
//
// <p><strong>HEURISTIC</strong></p>
//
// <p>As a heuristic, we stop prediction when we see any conflicting subset
// unless we see a state that only has one alternative associated with it.
// The single-alt-state thing lets prediction continue upon rules like
// (otherwise, it would admit defeat too soon):</p>
//
// <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
//
// <p>When the ATN simulation reaches the state before {@code ';'}, it has a
// DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
// {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
// processing this node because alternative to has another way to continue,
// via {@code [6|2|[]]}.</p>
//
// <p>It also let's us continue for this rule:</p>
//
// <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
//
// <p>After matching input A, we reach the stop state for rule A, state 1.
// State 8 is the state right before B. Clearly alternatives 1 and 2
// conflict and no amount of further lookahead will separate the two.
// However, alternative 3 will be able to continue and so we do not stop
// working on this state. In the previous example, we're concerned with
// states associated with the conflicting alternatives. Here alt 3 is not
// associated with the conflicting configs, but since we can continue
// looking for input reasonably, don't declare the state done.</p>
//
// <p><strong>PURE SLL PARSING</strong></p>
//
// <p>To handle pure SLL parsing, all we have to do is make sure that we
// combine stack contexts for configurations that differ only by semantic
// predicate. From there, we can do the usual SLL termination heuristic.</p>
//
// <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
//
// <p>SLL decisions don't evaluate predicates until after they reach DFA stop
// states because they need to create the DFA cache that works in all
// semantic situations. In contrast, full LL evaluates predicates collected
// during start state computation so it can ignore predicates thereafter.
// This means that SLL termination detection can totally ignore semantic
// predicates.</p>
//
// <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
// semantic predicate contexts so we might see two configurations like the
// following.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
//
// <p>Before testing these configurations against others, we have to merge
// {@code x} and {@code x'} (without modifying the existing configurations).
// For example, we test {@code (x+x')==x''} when looking for conflicts in
// the following configurations.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
//
// <p>If the configuration set has predicates (as indicated by
// {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
// the configurations to strip out all of the predicates so that a standard
// {@link ATNConfigSet} will merge everything ignoring predicates.</p>
//
PredictionMode.hasSLLConflictTerminatingPrediction = function( mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
    }
    // pure SLL mode parsing
    if (mode === PredictionMode.SLL) {
        // Don't bother with combining configs from different semantic
        // contexts if we can fail over to full LL; costs more time
        // since we'll often fail over anyway.
        if (configs.hasSemanticContext) {
            // dup configs, tossing out semantic predicates
            var dup = new ATNConfigSet();
            for(var i=0;i<configs.items.length;i++) {
            	var c = configs.items[i];
                c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);
                dup.add(c);
            }
            configs = dup;
        }
        // now we have combined contexts for configs with dissimilar preds
    }
    // pure SLL or combined SLL+LL mode parsing
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
};

// Checks if any configuration in {@code configs} is in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if any configuration in {@code configs} is in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.hasConfigInRuleStopState = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (c.state instanceof RuleStopState) {
            return true;
        }
	}
    return false;
};

// Checks if all configurations in {@code configs} are in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if all configurations in {@code configs} are in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.allConfigsInRuleStopStates = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (!(c.state instanceof RuleStopState)) {
            return false;
        }
	}
    return true;
};

//
// Full LL prediction termination.
//
// <p>Can we stop looking ahead during ATN simulation or is there some
// uncertainty as to which alternative we will ultimately pick, after
// consuming more input? Even if there are partial conflicts, we might know
// that everything is going to resolve to the same minimum alternative. That
// means we can stop since no more lookahead will change that fact. On the
// other hand, there might be multiple conflicts that resolve to different
// minimums. That means we need more look ahead to decide which of those
// alternatives we should predict.</p>
//
// <p>The basic idea is to split the set of configurations {@code C}, into
// conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
// non-conflicting configurations. Two configurations conflict if they have
// identical {@link ATNConfig//state} and {@link ATNConfig//context} values
// but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
// and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
//
// <p>Reduce these configuration subsets to the set of possible alternatives.
// You can compute the alternative subsets in one pass as follows:</p>
//
// <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
// {@code C} holding {@code s} and {@code ctx} fixed.</p>
//
// <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>
//
// <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
//
// <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
// {@code s} and {@code ctx}.</p>
//
// <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
// the union of these alternative subsets is a singleton, then no amount of
// more lookahead will help us. We will always pick that alternative. If,
// however, there is more than one alternative, then we are uncertain which
// alternative to predict and must continue looking for resolution. We may
// or may not discover an ambiguity in the future, even if there are no
// conflicting subsets this round.</p>
//
// <p>The biggest sin is to terminate early because it means we've made a
// decision but were uncertain as to the eventual outcome. We haven't used
// enough lookahead. On the other hand, announcing a conflict too late is no
// big deal; you will still have the conflict. It's just inefficient. It
// might even look until the end of file.</p>
//
// <p>No special consideration for semantic predicates is required because
// predicates are evaluated on-the-fly for full LL prediction, ensuring that
// no configuration contains a semantic context during the termination
// check.</p>
//
// <p><strong>CONFLICTING CONFIGS</strong></p>
//
// <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
// when {@code i!=j} but {@code x=x'}. Because we merge all
// {@code (s, i, _)} configurations together, that means that there are at
// most {@code n} configurations associated with state {@code s} for
// {@code n} possible alternatives in the decision. The merged stacks
// complicate the comparison of configuration contexts {@code x} and
// {@code x'}. Sam checks to see if one is a subset of the other by calling
// merge and checking to see if the merged result is either {@code x} or
// {@code x'}. If the {@code x} associated with lowest alternative {@code i}
// is the superset, then {@code i} is the only possible prediction since the
// others resolve to {@code min(i)} as well. However, if {@code x} is
// associated with {@code j>i} then at least one stack configuration for
// {@code j} is not in conflict with alternative {@code i}. The algorithm
// should keep going, looking for more lookahead due to the uncertainty.</p>
//
// <p>For simplicity, I'm doing a equality check between {@code x} and
// {@code x'} that lets the algorithm continue to consume lookahead longer
// than necessary. The reason I like the equality is of course the
// simplicity but also because that is the test you need to detect the
// alternatives that are actually in conflict.</p>
//
// <p><strong>CONTINUE/STOP RULE</strong></p>
//
// <p>Continue if union of resolved alternative sets from non-conflicting and
// conflicting alternative subsets has more than one alternative. We are
// uncertain about which alternative to predict.</p>
//
// <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
// alternatives are still in the running for the amount of input we've
// consumed at this point. The conflicting sets let us to strip away
// configurations that won't lead to more states because we resolve
// conflicts to the configuration with a minimum alternate for the
// conflicting set.</p>
//
// <p><strong>CASES</strong></p>
//
// <ul>
//
// <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
//
// <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
// {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
// {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1,3}} =&gt; continue
// </li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
// {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1}} =&gt; stop and predict 1</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
// ambiguity {@code {1,2}}</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
// {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {2}} = {@code {1,2}} =&gt; continue</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
// {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {3}} = {@code {1,3}} =&gt; continue</li>
//
// </ul>
//
// <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
//
// <p>If all states report the same conflicting set of alternatives, then we
// know we have the exact ambiguity set.</p>
//
// <p><code>|A_<em>i</em>|&gt;1</code> and
// <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
//
// <p>In other words, we continue examining lookahead until all {@code A_i}
// have more than one alternative and all {@code A_i} are the same. If
// {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
// because the resolved set is {@code {1}}. To determine what the real
// ambiguity is, we have to know whether the ambiguity is between one and
// two or one and three so we keep going. We can only stop prediction when
// we need exact ambiguity detection when the sets look like
// {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
//
PredictionMode.resolvesToJustOneViableAlt = function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
};

//
// Determines if every alternative subset in {@code altsets} contains more
// than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every {@link BitSet} in {@code altsets} has
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.allSubsetsConflict = function(altsets) {
    return ! PredictionMode.hasNonConflictingAltSet(altsets);
};
//
// Determines if any single alternative subset in {@code altsets} contains
// exactly one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
//
PredictionMode.hasNonConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length===1) {
            return true;
        }
	}
    return false;
};

//
// Determines if any single alternative subset in {@code altsets} contains
// more than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.hasConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length>1) {
            return true;
        }
	}
    return false;
};

//
// Determines if every alternative subset in {@code altsets} is equivalent.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every member of {@code altsets} is equal to the
// others, otherwise {@code false}
//
PredictionMode.allSubsetsEqual = function(altsets) {
    var first = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (first === null) {
            first = alts;
        } else if (alts!==first) {
            return false;
        }
	}
    return true;
};

//
// Returns the unique alternative predicted by all alternative subsets in
// {@code altsets}. If no such alternative exists, this method returns
// {@link ATN//INVALID_ALT_NUMBER}.
//
// @param altsets a collection of alternative subsets
//
PredictionMode.getUniqueAlt = function(altsets) {
    var all = PredictionMode.getAlts(altsets);
    if (all.length===1) {
        return all.minValue();
    } else {
        return ATN.INVALID_ALT_NUMBER;
    }
};

// Gets the complete set of represented alternatives for a collection of
// alternative subsets. This method returns the union of each {@link BitSet}
// in {@code altsets}.
//
// @param altsets a collection of alternative subsets
// @return the set of represented alternatives in {@code altsets}
//
PredictionMode.getAlts = function(altsets) {
    var all = new BitSet();
    altsets.map( function(alts) { all.or(alts); });
    return all;
};

//
// This function gets the conflicting alt subsets from a configuration set.
// For each configuration {@code c} in {@code configs}:
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>

PredictionMode.getConflictingAltSubsets = function(configs) {
    var configToAlts = new Map();
    configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };
    configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber==c2.state.stateNumber && c1.context.equals(c2.context);}
    configs.items.map(function(cfg) {
        var alts = configToAlts.get(cfg);
        if (alts === null) {
            alts = new BitSet();
            configToAlts.put(cfg, alts);
        }
        alts.add(cfg.alt);
	});
    return configToAlts.getValues();
};

//
// Get a map from state to alt subset from a configuration set. For each
// configuration {@code c} in {@code configs}:
//
// <pre>
// map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
// </pre>
//
PredictionMode.getStateToAltMap = function(configs) {
    var m = new AltDict();
    configs.items.map(function(c) {
        var alts = m.get(c.state);
        if (alts === null) {
            alts = new BitSet();
            m.put(c.state, alts);
        }
        alts.add(c.alt);
    });
    return m;
};

PredictionMode.hasStateAssociatedWithOneAlt = function(configs) {
    var values = PredictionMode.getStateToAltMap(configs).values();
    for(var i=0;i<values.length;i++) {
        if (values[i].length===1) {
            return true;
        }
    }
    return false;
};

PredictionMode.getSingleViableAlt = function(altsets) {
    var result = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        var minAlt = alts.minValue();
        if(result===null) {
            result = minAlt;
        } else if(result!==minAlt) { // more than 1 viable alt
            return ATN.INVALID_ALT_NUMBER;
        }
	}
    return result;
};

exports.PredictionMode = PredictionMode;


/***/ }),
/* 66 */
/***/ (function(module, exports) {

/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var codePointAt = function(position) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			var size = string.length;
			// `ToInteger`
			var index = position ? Number(position) : 0;
			if (index != index) { // better `isNaN`
				index = 0;
			}
			// Account for out-of-bounds indices:
			if (index < 0 || index >= size) {
				return undefined;
			}
			// Get the first code unit
			var first = string.charCodeAt(index);
			var second;
			if ( // check if it’s the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				size > index + 1 // there is a next code unit
			) {
				second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				}
			}
			return first;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'codePointAt', {
				'value': codePointAt,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.codePointAt = codePointAt;
		}
	}());
}


/***/ }),
/* 67 */
/***/ (function(module, exports) {

/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
	(function() {
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var stringFromCharCode = String.fromCharCode;
		var floor = Math.floor;
		var fromCodePoint = function(_) {
			var MAX_SIZE = 0x4000;
			var codeUnits = [];
			var highSurrogate;
			var lowSurrogate;
			var index = -1;
			var length = arguments.length;
			if (!length) {
				return '';
			}
			var result = '';
			while (++index < length) {
				var codePoint = Number(arguments[index]);
				if (
					!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
					codePoint < 0 || // not a valid Unicode code point
					codePoint > 0x10FFFF || // not a valid Unicode code point
					floor(codePoint) != codePoint // not an integer
				) {
					throw RangeError('Invalid code point: ' + codePoint);
				}
				if (codePoint <= 0xFFFF) { // BMP code point
					codeUnits.push(codePoint);
				} else { // Astral code point; split in surrogate halves
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					codePoint -= 0x10000;
					highSurrogate = (codePoint >> 10) + 0xD800;
					lowSurrogate = (codePoint % 0x400) + 0xDC00;
					codeUnits.push(highSurrogate, lowSurrogate);
				}
				if (index + 1 == length || codeUnits.length > MAX_SIZE) {
					result += stringFromCharCode.apply(null, codeUnits);
					codeUnits.length = 0;
				}
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String, 'fromCodePoint', {
				'value': fromCodePoint,
				'configurable': true,
				'writable': true
			});
		} else {
			String.fromCodePoint = fromCodePoint;
		}
	}());
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(1).Token;
var Errors = __webpack_require__(8);
var NoViableAltException = Errors.NoViableAltException;
var InputMismatchException = Errors.InputMismatchException;
var FailedPredicateException = Errors.FailedPredicateException;
var ParseCancellationException = Errors.ParseCancellationException;
var ATNState = __webpack_require__(7).ATNState;
var Interval = __webpack_require__(2).Interval;
var IntervalSet = __webpack_require__(2).IntervalSet;

function ErrorStrategy() {

}

ErrorStrategy.prototype.reset = function(recognizer){
};

ErrorStrategy.prototype.recoverInline = function(recognizer){
};

ErrorStrategy.prototype.recover = function(recognizer, e){
};

ErrorStrategy.prototype.sync = function(recognizer){
};

ErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer){
};

ErrorStrategy.prototype.reportError = function(recognizer){
};



// This is the default implementation of {@link ANTLRErrorStrategy} used for
// error reporting and recovery in ANTLR parsers.
//
function DefaultErrorStrategy() {
	ErrorStrategy.call(this);
    // Indicates whether the error strategy is currently "recovering from an
    // error". This is used to suppress reporting multiple error messages while
    // attempting to recover from a detected syntax error.
    //
    // @see //inErrorRecoveryMode
    //
    this.errorRecoveryMode = false;

    // The index into the input stream where the last error occurred.
    // This is used to prevent infinite loops where an error is found
    // but no token is consumed during recovery...another error is found,
    // ad nauseum. This is a failsafe mechanism to guarantee that at least
    // one token/tree node is consumed for two errors.
    //
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    return this;
}

DefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);
DefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy;

// <p>The default implementation simply calls {@link //endErrorCondition} to
// ensure that the handler is not in error recovery mode.</p>
DefaultErrorStrategy.prototype.reset = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// This method is called to enter error recovery mode when a recognition
// exception is reported.
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.beginErrorCondition = function(recognizer) {
    this.errorRecoveryMode = true;
};

DefaultErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer) {
    return this.errorRecoveryMode;
};

//
// This method is called to leave error recovery mode after recovering from
// a recognition exception.
//
// @param recognizer
//
DefaultErrorStrategy.prototype.endErrorCondition = function(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
};

//
// {@inheritDoc}
//
// <p>The default implementation simply calls {@link //endErrorCondition}.</p>
//
DefaultErrorStrategy.prototype.reportMatch = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// {@inheritDoc}
//
// <p>The default implementation returns immediately if the handler is already
// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
// and dispatches the reporting task based on the runtime type of {@code e}
// according to the following table.</p>
//
// <ul>
// <li>{@link NoViableAltException}: Dispatches the call to
// {@link //reportNoViableAlternative}</li>
// <li>{@link InputMismatchException}: Dispatches the call to
// {@link //reportInputMismatch}</li>
// <li>{@link FailedPredicateException}: Dispatches the call to
// {@link //reportFailedPredicate}</li>
// <li>All other types: calls {@link Parser//notifyErrorListeners} to report
// the exception</li>
// </ul>
//
DefaultErrorStrategy.prototype.reportError = function(recognizer, e) {
   // if we've already reported an error and have not matched a token
   // yet successfully, don't report any errors.
    if(this.inErrorRecoveryMode(recognizer)) {
        return; // don't report spurious errors
    }
    this.beginErrorCondition(recognizer);
    if ( e instanceof NoViableAltException ) {
        this.reportNoViableAlternative(recognizer, e);
    } else if ( e instanceof InputMismatchException ) {
        this.reportInputMismatch(recognizer, e);
    } else if ( e instanceof FailedPredicateException ) {
        this.reportFailedPredicate(recognizer, e);
    } else {
        console.log("unknown recognition error type: " + e.constructor.name);
        console.log(e.stack);
        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
};
//
// {@inheritDoc}
//
// <p>The default implementation resynchronizes the parser by consuming tokens
// until we find one in the resynchronization set--loosely the set of tokens
// that can follow the current rule.</p>
//
DefaultErrorStrategy.prototype.recover = function(recognizer, e) {
    if (this.lastErrorIndex===recognizer.getInputStream().index &&
        this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {
		// uh oh, another error at same token index and previously-visited
		// state in ATN; must be a case where LT(1) is in the recovery
		// token set so nothing got consumed. Consume a single token
		// at least to prevent an infinite loop; this is a failsafe.
		recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
        this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    var followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
};

// The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
// that the current lookahead symbol is consistent with what were expecting
// at this point in the ATN. You can call this anytime but ANTLR only
// generates code to check before subrules/loops and each iteration.
//
// <p>Implements Jim Idle's magic sync mechanism in closures and optional
// subrules. E.g.,</p>
//
// <pre>
// a : sync ( stuff sync )* ;
// sync : {consume to what can follow sync} ;
// </pre>
//
// At the start of a sub rule upon error, {@link //sync} performs single
// token deletion, if possible. If it can't do that, it bails on the current
// rule and uses the default error recovery, which consumes until the
// resynchronization set of the current rule.
//
// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
// with an empty alternative), then the expected set includes what follows
// the subrule.</p>
//
// <p>During loop iteration, it consumes until it sees a token that can start a
// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
// stay in the loop as long as possible.</p>
//
// <p><strong>ORIGINS</strong></p>
//
// <p>Previous versions of ANTLR did a poor job of their recovery within loops.
// A single mismatch token or missing token would force the parser to bail
// out of the entire rules surrounding the loop. So, for rule</p>
//
// <pre>
// classDef : 'class' ID '{' member* '}'
// </pre>
//
// input with an extra token between members would force the parser to
// consume until it found the next class definition rather than the next
// member definition of the current class.
//
// <p>This functionality cost a little bit of effort because the parser has to
// compare token set at the start of the loop and at each iteration. If for
// some reason speed is suffering for you, you can turn off this
// functionality by simply overriding this method as a blank { }.</p>
//
DefaultErrorStrategy.prototype.sync = function(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    var s = recognizer._interp.atn.states[recognizer.state];
    var la = recognizer.getTokenStream().LA(1);
    // try cheaper subset first; might get lucky. seems to shave a wee bit off
    var nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(Token.EPSILON) || nextTokens.contains(la)) {
        return;
    }
    switch (s.stateType) {
    case ATNState.BLOCK_START:
    case ATNState.STAR_BLOCK_START:
    case ATNState.PLUS_BLOCK_START:
    case ATNState.STAR_LOOP_ENTRY:
       // report error and recover if possible
        if( this.singleTokenDeletion(recognizer) !== null) {
            return;
        } else {
            throw new InputMismatchException(recognizer);
        }
        break;
    case ATNState.PLUS_LOOP_BACK:
    case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        var expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
    default:
        // do nothing if we can't identify the exact kind of ATN state
    }
};

// This is called by {@link //reportError} when the exception is a
// {@link NoViableAltException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportNoViableAlternative = function(recognizer, e) {
    var tokens = recognizer.getTokenStream();
    var input;
    if(tokens !== null) {
        if (e.startToken.type===Token.EOF) {
            input = "<EOF>";
        } else {
            input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
        }
    } else {
        input = "<unknown input>";
    }
    var msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is an
// {@link InputMismatchException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportInputMismatch = function(recognizer, e) {
    var msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
          " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is a
// {@link FailedPredicateException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportFailedPredicate = function(recognizer, e) {
    var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    var msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

// This method is called to report a syntax error which requires the removal
// of a token from the input stream. At the time this method is called, the
// erroneous symbol is current {@code LT(1)} symbol and has not yet been
// removed from the input stream. When this method returns,
// {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenDeletion} identifies
// single-token deletion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportUnwantedToken = function(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var tokenName = this.getTokenErrorDisplay(t);
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "extraneous input " + tokenName + " expecting " +
        expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
};
// This method is called to report a syntax error which requires the
// insertion of a missing token into the input stream. At the time this
// method is called, the missing token has not yet been inserted. When this
// method returns, {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenInsertion} identifies
// single-token insertion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportMissingToken = function(recognizer) {
    if ( this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
          " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
};

// <p>The default implementation attempts to recover from the mismatched input
// by using single token insertion and deletion as described below. If the
// recovery attempt fails, this method throws an
// {@link InputMismatchException}.</p>
//
// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
//
// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
// right token, however, then assume {@code LA(1)} is some extra spurious
// token and delete it. Then consume and return the next token (which was
// the {@code LA(2)} token) as the successful result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenDeletion}.</p>
//
// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
//
// <p>If current token (at {@code LA(1)}) is consistent with what could come
// after the expected {@code LA(1)} token, then assume the token is missing
// and use the parser's {@link TokenFactory} to create it on the fly. The
// "insertion" is performed by returning the created token as the successful
// result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenInsertion}.</p>
//
// <p><strong>EXAMPLE</strong></p>
//
// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
// the parser returns from the nested call to {@code expr}, it will have
// call chain:</p>
//
// <pre>
// stat &rarr; expr &rarr; atom
// </pre>
//
// and it will be trying to match the {@code ')'} at this point in the
// derivation:
//
// <pre>
// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
// ^
// </pre>
//
// The attempt to match {@code ')'} will fail when it sees {@code ';'} and
// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
// is in the set of tokens that can follow the {@code ')'} token reference
// in rule {@code atom}. It can assume that you forgot the {@code ')'}.
//
DefaultErrorStrategy.prototype.recoverInline = function(recognizer) {
    // SINGLE TOKEN DELETION
    var matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
        // we have deleted the extra token.
        // now, move past ttype token as if all were ok
        recognizer.consume();
        return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
};

//
// This method implements the single-token insertion inline error recovery
// strategy. It is called by {@link //recoverInline} if the single-token
// deletion strategy fails to recover from the mismatched input. If this
// method returns {@code true}, {@code recognizer} will be in error recovery
// mode.
//
// <p>This method determines whether or not single-token insertion is viable by
// checking if the {@code LA(1)} input symbol could be successfully matched
// if it were instead the {@code LA(2)} symbol. If this method returns
// {@code true}, the caller is responsible for creating and inserting a
// token with the correct type to produce this behavior.</p>
//
// @param recognizer the parser instance
// @return {@code true} if single-token insertion is a viable recovery
// strategy for the current mismatched input, otherwise {@code false}
//
DefaultErrorStrategy.prototype.singleTokenInsertion = function(recognizer) {
    var currentSymbolType = recognizer.getTokenStream().LA(1);
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    var atn = recognizer._interp.atn;
    var currentState = atn.states[recognizer.state];
    var next = currentState.transitions[0].target;
    var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType) ){
        this.reportMissingToken(recognizer);
        return true;
    } else {
        return false;
    }
};

// This method implements the single-token deletion inline error recovery
// strategy. It is called by {@link //recoverInline} to attempt to recover
// from mismatched input. If this method returns null, the parser and error
// handler state will not have changed. If this method returns non-null,
// {@code recognizer} will <em>not</em> be in error recovery mode since the
// returned token was a successful match.
//
// <p>If the single-token deletion is successful, this method calls
// {@link //reportUnwantedToken} to report the error, followed by
// {@link Parser//consume} to actually "delete" the extraneous token. Then,
// before returning {@link //reportMatch} is called to signal a successful
// match.</p>
//
// @param recognizer the parser instance
// @return the successfully matched {@link Token} instance if single-token
// deletion successfully recovers from the mismatched input, otherwise
// {@code null}
//
DefaultErrorStrategy.prototype.singleTokenDeletion = function(recognizer) {
    var nextTokenType = recognizer.getTokenStream().LA(2);
    var expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        // print("recoverFromMismatchedToken deleting " \
        // + str(recognizer.getTokenStream().LT(1)) \
        // + " since " + str(recognizer.getTokenStream().LT(2)) \
        // + " is what we want", file=sys.stderr)
        recognizer.consume(); // simply delete extra token
        // we want to return the token we're actually matching
        var matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer); // we know current token is correct
        return matchedSymbol;
    } else {
        return null;
    }
};

// Conjure up a missing token during error recovery.
//
// The recognizer attempts to recover from single missing
// symbols. But, actions might refer to that missing symbol.
// For example, x=ID {f($x);}. The action clearly assumes
// that there has been an identifier matched previously and that
// $x points at that token. If that token is missing, but
// the next token in the stream is what we want we assume that
// this token is missing and we keep going. Because we
// have to return some token to replace the missing token,
// we have to conjure one up. This method gives the user control
// over the tokens returned for missing tokens. Mostly,
// you will want to create something special for identifier
// tokens. For literals such as '{' and ',', the default
// action in the parser or tree parser works. It simply creates
// a CommonToken of the appropriate type. The text will be the token.
// If you change what tokens must be created by the lexer,
// override this method to create the appropriate tokens.
//
DefaultErrorStrategy.prototype.getMissingSymbol = function(recognizer) {
    var currentSymbol = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var expectedTokenType = expecting.first(); // get any element
    var tokenText;
    if (expectedTokenType===Token.EOF) {
        tokenText = "<missing EOF>";
    } else {
        tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    var current = currentSymbol;
    var lookback = recognizer.getTokenStream().LT(-1);
    if (current.type===Token.EOF && lookback !== null) {
        current = lookback;
    }
    return recognizer.getTokenFactory().create(current.source,
        expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,
        -1, -1, current.line, current.column);
};

DefaultErrorStrategy.prototype.getExpectedTokens = function(recognizer) {
    return recognizer.getExpectedTokens();
};

// How should a token be displayed in an error message? The default
// is to display just the text, but during development you might
// want to have a lot of information spit out. Override in that case
// to use t.toString() (which, for CommonToken, dumps everything about
// the token). This is better than forcing you to override a method in
// your token objects because you don't have to go modify your lexer
// so that it creates a new Java type.
//
DefaultErrorStrategy.prototype.getTokenErrorDisplay = function(t) {
    if (t === null) {
        return "<no token>";
    }
    var s = t.text;
    if (s === null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    return this.escapeWSAndQuote(s);
};

DefaultErrorStrategy.prototype.escapeWSAndQuote = function(s) {
    s = s.replace(/\n/g,"\\n");
    s = s.replace(/\r/g,"\\r");
    s = s.replace(/\t/g,"\\t");
    return "'" + s + "'";
};

// Compute the error recovery set for the current rule. During
// rule invocation, the parser pushes the set of tokens that can
// follow that rule reference on the stack; this amounts to
// computing FIRST of what follows the rule reference in the
// enclosing rule. See LinearApproximator.FIRST().
// This local follow set only includes tokens
// from within the rule; i.e., the FIRST computation done by
// ANTLR stops at the end of a rule.
//
// EXAMPLE
//
// When you find a "no viable alt exception", the input is not
// consistent with any of the alternatives for rule r. The best
// thing to do is to consume tokens until you see something that
// can legally follow a call to r//or* any rule that called r.
// You don't want the exact set of viable next tokens because the
// input might just be missing a token--you might consume the
// rest of the input looking for one of the missing tokens.
//
// Consider grammar:
//
// a : '[' b ']'
// | '(' b ')'
// ;
// b : c '^' INT ;
// c : ID
// | INT
// ;
//
// At each rule invocation, the set of tokens that could follow
// that rule is pushed on a stack. Here are the various
// context-sensitive follow sets:
//
// FOLLOW(b1_in_a) = FIRST(']') = ']'
// FOLLOW(b2_in_a) = FIRST(')') = ')'
// FOLLOW(c_in_b) = FIRST('^') = '^'
//
// Upon erroneous input "[]", the call chain is
//
// a -> b -> c
//
// and, hence, the follow context stack is:
//
// depth follow set start of rule execution
// 0 <EOF> a (from main())
// 1 ']' b
// 2 '^' c
//
// Notice that ')' is not included, because b would have to have
// been called from a different context in rule a for ')' to be
// included.
//
// For error recovery, we cannot consider FOLLOW(c)
// (context-sensitive or otherwise). We need the combined set of
// all context-sensitive FOLLOW sets--the set of all tokens that
// could follow any reference in the call chain. We need to
// resync to one of those tokens. Note that FOLLOW(c)='^' and if
// we resync'd to that token, we'd consume until EOF. We need to
// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
// In this case, for input "[]", LA(1) is ']' and in the set, so we would
// not consume anything. After printing an error, rule c would
// return normally. Rule b would not find the required '^' though.
// At this point, it gets a mismatched token error and throws an
// exception (since LA(1) is not in the viable following token
// set). The rule exception handler tries to recover, but finds
// the same recovery set and doesn't consume anything. Rule b
// exits normally returning to rule a. Now it finds the ']' (and
// with the successful match exits errorRecovery mode).
//
// So, you can see that the parser walks up the call chain looking
// for the token that was a member of the recovery set.
//
// Errors are not generated in errorRecovery mode.
//
// ANTLR's error recovery mechanism is based upon original ideas:
//
// "Algorithms + Data Structures = Programs" by Niklaus Wirth
//
// and
//
// "A note on error recovery in recursive descent parsers":
// http://portal.acm.org/citation.cfm?id=947902.947905
//
// Later, Josef Grosch had some good ideas:
//
// "Efficient and Comfortable Error Recovery in Recursive Descent
// Parsers":
// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
//
// Like Grosch I implement context-sensitive FOLLOW sets that are combined
// at run-time upon error to avoid overhead during parsing.
//
DefaultErrorStrategy.prototype.getErrorRecoverySet = function(recognizer) {
    var atn = recognizer._interp.atn;
    var ctx = recognizer._ctx;
    var recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState>=0) {
        // compute what follows who invoked us
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        var follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
};

// Consume tokens until one matches the given token set.//
DefaultErrorStrategy.prototype.consumeUntil = function(recognizer, set) {
    var ttype = recognizer.getTokenStream().LA(1);
    while( ttype !== Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.getTokenStream().LA(1);
    }
};

//
// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
// by immediately canceling the parse operation with a
// {@link ParseCancellationException}. The implementation ensures that the
// {@link ParserRuleContext//exception} field is set for all parse tree nodes
// that were not completed prior to encountering the error.
//
// <p>
// This error strategy is useful in the following scenarios.</p>
//
// <ul>
// <li><strong>Two-stage parsing:</strong> This error strategy allows the first
// stage of two-stage parsing to immediately terminate if an error is
// encountered, and immediately fall back to the second stage. In addition to
// avoiding wasted work by attempting to recover from errors here, the empty
// implementation of {@link BailErrorStrategy//sync} improves the performance of
// the first stage.</li>
// <li><strong>Silent validation:</strong> When syntax errors are not being
// reported or logged, and the parse result is simply ignored if errors occur,
// the {@link BailErrorStrategy} avoids wasting work on recovering from errors
// when the result will be ignored either way.</li>
// </ul>
//
// <p>
// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
//
// @see Parser//setErrorHandler(ANTLRErrorStrategy)
//
function BailErrorStrategy() {
	DefaultErrorStrategy.call(this);
	return this;
}

BailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);
BailErrorStrategy.prototype.constructor = BailErrorStrategy;

// Instead of recovering from exception {@code e}, re-throw it wrapped
// in a {@link ParseCancellationException} so it is not caught by the
// rule function catches. Use {@link Exception//getCause()} to get the
// original {@link RecognitionException}.
//
BailErrorStrategy.prototype.recover = function(recognizer, e) {
    var context = recognizer._ctx;
    while (context !== null) {
        context.exception = e;
        context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
};

// Make sure we don't attempt to recover inline; if the parser
// successfully recovers, it won't throw an exception.
//
BailErrorStrategy.prototype.recoverInline = function(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
};

// Make sure we don't attempt to recover from problems in subrules.//
BailErrorStrategy.prototype.sync = function(recognizer) {
    // pass
};

exports.BailErrorStrategy = BailErrorStrategy;
exports.DefaultErrorStrategy = DefaultErrorStrategy;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// Generated from C.g4 by ANTLR 4.7.1
// jshint ignore: start
var antlr4 = __webpack_require__(24);

// This class defines a complete generic visitor for a parse tree produced by CParser.

function CVisitor() {
  antlr4.tree.ParseTreeVisitor.call(this);
  return this;
}

CVisitor.prototype = Object.create(antlr4.tree.ParseTreeVisitor.prototype);
CVisitor.prototype.constructor = CVisitor;

// Visit a parse tree produced by CParser#primaryExpression.
CVisitor.prototype.visitPrimaryExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#genericSelection.
CVisitor.prototype.visitGenericSelection = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#genericAssocList.
CVisitor.prototype.visitGenericAssocList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#genericAssociation.
CVisitor.prototype.visitGenericAssociation = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#postfixExpression.
CVisitor.prototype.visitPostfixExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#argumentExpressionList.
CVisitor.prototype.visitArgumentExpressionList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#unaryExpression.
CVisitor.prototype.visitUnaryExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#unaryOperator.
CVisitor.prototype.visitUnaryOperator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#castExpression.
CVisitor.prototype.visitCastExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#multiplicativeExpression.
CVisitor.prototype.visitMultiplicativeExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#additiveExpression.
CVisitor.prototype.visitAdditiveExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#shiftExpression.
CVisitor.prototype.visitShiftExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#relationalExpression.
CVisitor.prototype.visitRelationalExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#equalityExpression.
CVisitor.prototype.visitEqualityExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#andExpression.
CVisitor.prototype.visitAndExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#exclusiveOrExpression.
CVisitor.prototype.visitExclusiveOrExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#inclusiveOrExpression.
CVisitor.prototype.visitInclusiveOrExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#logicalAndExpression.
CVisitor.prototype.visitLogicalAndExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#logicalOrExpression.
CVisitor.prototype.visitLogicalOrExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#conditionalExpression.
CVisitor.prototype.visitConditionalExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#assignmentExpression.
CVisitor.prototype.visitAssignmentExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#assignmentOperator.
CVisitor.prototype.visitAssignmentOperator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#expression.
CVisitor.prototype.visitExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#constantExpression.
CVisitor.prototype.visitConstantExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declaration.
CVisitor.prototype.visitDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declarationSpecifiers.
CVisitor.prototype.visitDeclarationSpecifiers = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declarationSpecifiers2.
CVisitor.prototype.visitDeclarationSpecifiers2 = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declarationSpecifier.
CVisitor.prototype.visitDeclarationSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#initDeclaratorList.
CVisitor.prototype.visitInitDeclaratorList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#initDeclarator.
CVisitor.prototype.visitInitDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#storageClassSpecifier.
CVisitor.prototype.visitStorageClassSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#typeSpecifier.
CVisitor.prototype.visitTypeSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structOrUnionSpecifier.
CVisitor.prototype.visitStructOrUnionSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structOrUnion.
CVisitor.prototype.visitStructOrUnion = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structDeclarationList.
CVisitor.prototype.visitStructDeclarationList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structDeclaration.
CVisitor.prototype.visitStructDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#specifierQualifierList.
CVisitor.prototype.visitSpecifierQualifierList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structDeclaratorList.
CVisitor.prototype.visitStructDeclaratorList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#structDeclarator.
CVisitor.prototype.visitStructDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#enumSpecifier.
CVisitor.prototype.visitEnumSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#enumeratorList.
CVisitor.prototype.visitEnumeratorList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#enumerator.
CVisitor.prototype.visitEnumerator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#enumerationConstant.
CVisitor.prototype.visitEnumerationConstant = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#atomicTypeSpecifier.
CVisitor.prototype.visitAtomicTypeSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#typeQualifier.
CVisitor.prototype.visitTypeQualifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#functionSpecifier.
CVisitor.prototype.visitFunctionSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#alignmentSpecifier.
CVisitor.prototype.visitAlignmentSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declarator.
CVisitor.prototype.visitDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#directDeclarator.
CVisitor.prototype.visitDirectDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#gccDeclaratorExtension.
CVisitor.prototype.visitGccDeclaratorExtension = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#gccAttributeSpecifier.
CVisitor.prototype.visitGccAttributeSpecifier = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#gccAttributeList.
CVisitor.prototype.visitGccAttributeList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#gccAttribute.
CVisitor.prototype.visitGccAttribute = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#nestedParenthesesBlock.
CVisitor.prototype.visitNestedParenthesesBlock = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#pointer.
CVisitor.prototype.visitPointer = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#typeQualifierList.
CVisitor.prototype.visitTypeQualifierList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#parameterTypeList.
CVisitor.prototype.visitParameterTypeList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#parameterList.
CVisitor.prototype.visitParameterList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#parameterDeclaration.
CVisitor.prototype.visitParameterDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#identifierList.
CVisitor.prototype.visitIdentifierList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#typeName.
CVisitor.prototype.visitTypeName = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#abstractDeclarator.
CVisitor.prototype.visitAbstractDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#directAbstractDeclarator.
CVisitor.prototype.visitDirectAbstractDeclarator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#typedefName.
CVisitor.prototype.visitTypedefName = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#initializer.
CVisitor.prototype.visitInitializer = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#initializerList.
CVisitor.prototype.visitInitializerList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#designation.
CVisitor.prototype.visitDesignation = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#designatorList.
CVisitor.prototype.visitDesignatorList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#designator.
CVisitor.prototype.visitDesignator = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#staticAssertDeclaration.
CVisitor.prototype.visitStaticAssertDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#statement.
CVisitor.prototype.visitStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#labeledStatement.
CVisitor.prototype.visitLabeledStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#compoundStatement.
CVisitor.prototype.visitCompoundStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#blockItemList.
CVisitor.prototype.visitBlockItemList = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#blockItem.
CVisitor.prototype.visitBlockItem = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#expressionStatement.
CVisitor.prototype.visitExpressionStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#selectionStatement.
CVisitor.prototype.visitSelectionStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#iterationStatement.
CVisitor.prototype.visitIterationStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#forCondition.
CVisitor.prototype.visitForCondition = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#forDeclaration.
CVisitor.prototype.visitForDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#forExpression.
CVisitor.prototype.visitForExpression = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#jumpStatement.
CVisitor.prototype.visitJumpStatement = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#compilationUnit.
CVisitor.prototype.visitCompilationUnit = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#translationUnit.
CVisitor.prototype.visitTranslationUnit = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#externalDeclaration.
CVisitor.prototype.visitExternalDeclaration = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#functionDefinition.
CVisitor.prototype.visitFunctionDefinition = function (ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by CParser#declarationList.
CVisitor.prototype.visitDeclarationList = function (ctx) {
  return this.visitChildren(ctx);
};



exports.CVisitor = CVisitor;

/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

const antlr4 = __webpack_require__(24);
const CLexer = __webpack_require__(127);
const CParser = __webpack_require__(128);
const CVisitor = __webpack_require__(69);
const antlr4tree = __webpack_require__(5);

class CMapper extends CVisitor.CVisitor {

  constructor(isDebugMode) {
    super();
    this._isDebugMode = isDebugMode;
  }

  parse(code) {
    const chars = new antlr4.InputStream(code);
    const [tree, parser] = this.parseCore(chars);
    return this.visit(tree);
  }

  getRawTree(code) {
    const chars = new antlr4.InputStream(code);
    return this.parseCore(chars);
  }

  parseCore(chars) {
    const lexer = new CLexer.CLexer(chars);
    const tokens = new antlr4.CommonTokenStream(lexer);
    this.parser = new CParser.CParser(tokens);
    this.parser.buildParseTrees = true;
    const tree = this.parser.compilationUnit();
    return [tree, this.parser];
  }
  visit(tree) {
    if (this._isDebugMode) {
      if (Array.isArray(tree)) {
        return tree.map(function (element) {
          return this.visit(element);
        },              this);
      }
      if (!(tree instanceof antlr4tree.TerminalNode)) {
        const ruleName = this.parser.ruleNames[tree.ruleIndex];
        console.log('*** visit Rule : ' + ruleName + ' ***');
      }
      const ret = super.visit(tree);
      console.log('returned: ' + ret);
      return ret;
    } else {
      return super.visit(tree);
    }
  }

  visitChildren(node) {
    return this.visit(node.children);
  }

  visitTerminal(node) {
    const text = node.getText();
    if (this._isDebugMode) {
      const _plus = 'visit TERMINAL : ' + text;
      console.log(_plus);
    }
    return text;
  }

  // visitTranslationUnit(node) {
  //   const program = new UniProgram();
  //   return program;
  // }
  visitDeclarator(node) {
    return super.visitDeclaration(node);
  }
}
exports.CMapper = CMapper;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.ATN = __webpack_require__(10).ATN;
exports.ATNDeserializer = __webpack_require__(60).ATNDeserializer;
exports.LexerATNSimulator = __webpack_require__(113).LexerATNSimulator;
exports.ParserATNSimulator = __webpack_require__(116).ParserATNSimulator;
exports.PredictionMode = __webpack_require__(65).PredictionMode;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var Set = __webpack_require__(0).Set;
var BitSet = __webpack_require__(0).BitSet;
var Token = __webpack_require__(1).Token;
var ATNConfig = __webpack_require__(25).ATNConfig;
var Interval = __webpack_require__(2).Interval;
var IntervalSet = __webpack_require__(2).IntervalSet;
var RuleStopState = __webpack_require__(7).RuleStopState;
var RuleTransition = __webpack_require__(11).RuleTransition;
var NotSetTransition = __webpack_require__(11).NotSetTransition;
var WildcardTransition = __webpack_require__(11).WildcardTransition;
var AbstractPredicateTransition = __webpack_require__(11).AbstractPredicateTransition;

var pc = __webpack_require__(9);
var predictionContextFromRuleContext = pc.predictionContextFromRuleContext;
var PredictionContext = pc.PredictionContext;
var SingletonPredictionContext = pc.SingletonPredictionContext;

function LL1Analyzer (atn) {
    this.atn = atn;
}

//* Special value added to the lookahead sets to indicate that we hit
//  a predicate during analysis if {@code seeThruPreds==false}.
///
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;


//*
// Calculates the SLL(1) expected lookahead set for each outgoing transition
// of an {@link ATNState}. The returned array has one element for each
// outgoing transition in {@code s}. If the closure from transition
// <em>i</em> leads to a semantic predicate before matching a symbol, the
// element at index <em>i</em> of the result will be {@code null}.
//
// @param s the ATN state
// @return the expected symbols for each outgoing transition of {@code s}.
///
LL1Analyzer.prototype.getDecisionLookahead = function(s) {
    if (s === null) {
        return null;
    }
    var count = s.transitions.length;
    var look = [];
    for(var alt=0; alt< count; alt++) {
        look[alt] = new IntervalSet();
        var lookBusy = new Set();
        var seeThruPreds = false; // fail to get lookahead upon pred
        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
              look[alt], lookBusy, new BitSet(), seeThruPreds, false);
        // Wipe out lookahead for this alternative if we found nothing
        // or we had a predicate when we !seeThruPreds
        if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
            look[alt] = null;
        }
    }
    return look;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and the end of the rule containing
// {@code s} is reached, {@link Token//EPSILON} is added to the result set.
// If {@code ctx} is not {@code null} and the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx the complete parser context, or {@code null} if the context
// should be ignored
//
// @return The set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
///
LL1Analyzer.prototype.LOOK = function(s, stopState, ctx) {
    var r = new IntervalSet();
    var seeThruPreds = true; // ignore preds; get all lookahead
	ctx = ctx || null;
    var lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);
    return r;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
// rule containing {@code s} is reached, {@link Token//EPSILON} is added to
// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
// {@code true} and {@code stopState} or the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state.
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx The outer context, or {@code null} if the outer context should
// not be used.
// @param look The result lookahead set.
// @param lookBusy A set used for preventing epsilon closures in the ATN
// from causing a stack overflow. Outside code should pass
// {@code new Set<ATNConfig>} for this argument.
// @param calledRuleStack A set used for preventing left recursion in the
// ATN from causing a stack overflow. Outside code should pass
// {@code new BitSet()} for this argument.
// @param seeThruPreds {@code true} to true semantic predicates as
// implicitly {@code true} and "see through them", otherwise {@code false}
// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
// result if one is encountered.
// @param addEOF Add {@link Token//EOF} to the result if the end of the
// outermost context is reached. This parameter has no effect if {@code ctx}
// is {@code null}.
///
LL1Analyzer.prototype._LOOK = function(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    var c = new ATNConfig({state:s, alt:0, context: ctx}, null);
    if (lookBusy.contains(c)) {
        return;
    }
    lookBusy.add(c);
    if (s === stopState) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
    }
    if (s instanceof RuleStopState ) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
        if (ctx !== PredictionContext.EMPTY) {
            // run thru all possible stack tops in ctx
            for(var i=0; i<ctx.length; i++) {
                var returnState = this.atn.states[ctx.getReturnState(i)];
                var removed = calledRuleStack.contains(returnState.ruleIndex);
                try {
                    calledRuleStack.remove(returnState.ruleIndex);
                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } finally {
                    if (removed) {
                        calledRuleStack.add(returnState.ruleIndex);
                    }
                }
            }
            return;
        }
    }
    for(var j=0; j<s.transitions.length; j++) {
        var t = s.transitions[j];
        if (t.constructor === RuleTransition) {
            if (calledRuleStack.contains(t.target.ruleIndex)) {
                continue;
            }
            var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
            try {
                calledRuleStack.add(t.target.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
                calledRuleStack.remove(t.target.ruleIndex);
            }
        } else if (t instanceof AbstractPredicateTransition ) {
            if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
                look.addOne(LL1Analyzer.HIT_PRED);
            }
        } else if( t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t.constructor === WildcardTransition) {
            look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );
        } else {
            var set = t.label;
            if (set !== null) {
                if (t instanceof NotSetTransition) {
                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                }
                look.addSet(set);
            }
        }
    }
};

exports.LL1Analyzer = LL1Analyzer;



/***/ }),
/* 112 */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents the type of recognizer an ATN applies to.

function ATNType() {

}

ATNType.LEXER = 0;
ATNType.PARSER = 1;

exports.ATNType = ATNType;



/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// When we hit an accept state in either the DFA or the ATN, we
//  have to notify the character stream to start buffering characters
//  via {@link IntStream//mark} and record the current state. The current sim state
//  includes the current index into the input, the current line,
//  and current character position in that line. Note that the Lexer is
//  tracking the starting line and characterization of the token. These
//  variables track the "state" of the simulator when it hits an accept state.
//
//  <p>We track these variables separately for the DFA and ATN simulation
//  because the DFA simulation often has to fail over to the ATN
//  simulation. If the ATN simulation fails, we need the DFA to fall
//  back to its previously accepted state, if any. If the ATN succeeds,
//  then the ATN does the accept and the DFA simulator that invoked it
//  can simply return the predicted token type.</p>
///

var Token = __webpack_require__(1).Token;
var Lexer = __webpack_require__(27).Lexer;
var ATN = __webpack_require__(10).ATN;
var ATNSimulator = __webpack_require__(64).ATNSimulator;
var DFAState = __webpack_require__(17).DFAState;
var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var OrderedATNConfigSet = __webpack_require__(15).OrderedATNConfigSet;
var PredictionContext = __webpack_require__(9).PredictionContext;
var SingletonPredictionContext = __webpack_require__(9).SingletonPredictionContext;
var RuleStopState = __webpack_require__(7).RuleStopState;
var LexerATNConfig = __webpack_require__(25).LexerATNConfig;
var Transition = __webpack_require__(11).Transition;
var LexerActionExecutor = __webpack_require__(115).LexerActionExecutor;
var LexerNoViableAltException = __webpack_require__(8).LexerNoViableAltException;

function resetSimState(sim) {
	sim.index = -1;
	sim.line = 0;
	sim.column = -1;
	sim.dfaState = null;
}

function SimState() {
	resetSimState(this);
	return this;
}

SimState.prototype.reset = function() {
	resetSimState(this);
};

function LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
	this.decisionToDFA = decisionToDFA;
	this.recog = recog;
	// The current token's starting index into the character stream.
	// Shared across DFA to ATN simulation in case the ATN fails and the
	// DFA did not have a previous accept state. In this case, we use the
	// ATN-generated exception object.
	this.startIndex = -1;
	// line number 1..n within the input///
	this.line = 1;
	// The index of the character relative to the beginning of the line
	// 0..n-1///
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
	// Used during DFA/ATN exec to record the most recent accept configuration
	// info
	this.prevAccept = new SimState();
	// done
	return this;
}

LexerATNSimulator.prototype = Object.create(ATNSimulator.prototype);
LexerATNSimulator.prototype.constructor = LexerATNSimulator;

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;

LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;

LexerATNSimulator.prototype.copyState = function(simulator) {
	this.column = simulator.column;
	this.line = simulator.line;
	this.mode = simulator.mode;
	this.startIndex = simulator.startIndex;
};

LexerATNSimulator.prototype.match = function(input, mode) {
	this.match_calls += 1;
	this.mode = mode;
	var mark = input.mark();
	try {
		this.startIndex = input.index;
		this.prevAccept.reset();
		var dfa = this.decisionToDFA[mode];
		if (dfa.s0 === null) {
			return this.matchATN(input);
		} else {
			return this.execATN(input, dfa.s0);
		}
	} finally {
		input.release(mark);
	}
};

LexerATNSimulator.prototype.reset = function() {
	this.prevAccept.reset();
	this.startIndex = -1;
	this.line = 1;
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
};

LexerATNSimulator.prototype.matchATN = function(input) {
	var startState = this.atn.modeToStartState[this.mode];

	if (LexerATNSimulator.debug) {
		console.log("matchATN mode " + this.mode + " start: " + startState);
	}
	var old_mode = this.mode;
	var s0_closure = this.computeStartState(input, startState);
	var suppressEdge = s0_closure.hasSemanticContext;
	s0_closure.hasSemanticContext = false;

	var next = this.addDFAState(s0_closure);
	if (!suppressEdge) {
		this.decisionToDFA[this.mode].s0 = next;
	}

	var predict = this.execATN(input, next);

	if (LexerATNSimulator.debug) {
		console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
	}
	return predict;
};

LexerATNSimulator.prototype.execATN = function(input, ds0) {
	if (LexerATNSimulator.debug) {
		console.log("start state closure=" + ds0.configs);
	}
	if (ds0.isAcceptState) {
		// allow zero-length tokens
		this.captureSimState(this.prevAccept, input, ds0);
	}
	var t = input.LA(1);
	var s = ds0; // s is current/from DFA state

	while (true) { // while more work
		if (LexerATNSimulator.debug) {
			console.log("execATN loop starting closure: " + s.configs);
		}

		// As we move src->trg, src->trg, we keep track of the previous trg to
		// avoid looking up the DFA state again, which is expensive.
		// If the previous target was already part of the DFA, we might
		// be able to avoid doing a reach operation upon t. If s!=null,
		// it means that semantic predicates didn't prevent us from
		// creating a DFA state. Once we know s!=null, we check to see if
		// the DFA state has an edge already for t. If so, we can just reuse
		// it's configuration set; there's no point in re-computing it.
		// This is kind of like doing DFA simulation within the ATN
		// simulation because DFA simulation is really just a way to avoid
		// computing reach/closure sets. Technically, once we know that
		// we have a previously added DFA state, we could jump over to
		// the DFA simulator. But, that would mean popping back and forth
		// a lot and making things more complicated algorithmically.
		// This optimization makes a lot of sense for loops within DFA.
		// A character will take us back to an existing DFA state
		// that already has lots of edges out of it. e.g., .* in comments.
		// print("Target for:" + str(s) + " and:" + str(t))
		var target = this.getExistingTargetState(s, t);
		// print("Existing:" + str(target))
		if (target === null) {
			target = this.computeTargetState(input, s, t);
			// print("Computed:" + str(target))
		}
		if (target === ATNSimulator.ERROR) {
			break;
		}
		// If this is a consumable input element, make sure to consume before
		// capturing the accept state so the input index, line, and char
		// position accurately reflect the state of the interpreter at the
		// end of the token.
		if (t !== Token.EOF) {
			this.consume(input);
		}
		if (target.isAcceptState) {
			this.captureSimState(this.prevAccept, input, target);
			if (t === Token.EOF) {
				break;
			}
		}
		t = input.LA(1);
		s = target; // flip; current DFA target becomes new src/from state
	}
	return this.failOrAccept(this.prevAccept, input, s.configs, t);
};

// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param s The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
LexerATNSimulator.prototype.getExistingTargetState = function(s, t) {
	if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
		return null;
	}

	var target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
	if(target===undefined) {
		target = null;
	}
	if (LexerATNSimulator.debug && target !== null) {
		console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
	}
	return target;
};

// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param input The input stream
// @param s The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
LexerATNSimulator.prototype.computeTargetState = function(input, s, t) {
	var reach = new OrderedATNConfigSet();
	// if we don't find an existing DFA state
	// Fill reach starting from closure, following t transitions
	this.getReachableConfigSet(input, s.configs, reach, t);

	if (reach.items.length === 0) { // we got nowhere on t from s
		if (!reach.hasSemanticContext) {
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			this.addDFAEdge(s, t, ATNSimulator.ERROR);
		}
		// stop when we can't match any more char
		return ATNSimulator.ERROR;
	}
	// Add an edge from s to target DFA found/created for reach
	return this.addDFAEdge(s, t, null, reach);
};

LexerATNSimulator.prototype.failOrAccept = function(prevAccept, input, reach, t) {
	if (this.prevAccept.dfaState !== null) {
		var lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
		this.accept(input, lexerActionExecutor, this.startIndex,
				prevAccept.index, prevAccept.line, prevAccept.column);
		return prevAccept.dfaState.prediction;
	} else {
		// if no accept and EOF is first char, return EOF
		if (t === Token.EOF && input.index === this.startIndex) {
			return Token.EOF;
		}
		throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
	}
};

// Given a starting configuration set, figure out all ATN configurations
// we can reach upon input {@code t}. Parameter {@code reach} is a return
// parameter.
LexerATNSimulator.prototype.getReachableConfigSet = function(input, closure,
		reach, t) {
	// this is used to skip processing for configs which have a lower priority
	// than a config that already reached an accept state for the same rule
	var skipAlt = ATN.INVALID_ALT_NUMBER;
	for (var i = 0; i < closure.items.length; i++) {
		var cfg = closure.items[i];
		var currentAltReachedAcceptState = (cfg.alt === skipAlt);
		if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
			continue;
		}
		if (LexerATNSimulator.debug) {
			console.log("testing %s at %s\n", this.getTokenName(t), cfg
					.toString(this.recog, true));
		}
		for (var j = 0; j < cfg.state.transitions.length; j++) {
			var trans = cfg.state.transitions[j]; // for each transition
			var target = this.getReachableTarget(trans, t);
			if (target !== null) {
				var lexerActionExecutor = cfg.lexerActionExecutor;
				if (lexerActionExecutor !== null) {
					lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
				}
				var treatEofAsEpsilon = (t === Token.EOF);
				var config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);
				if (this.closure(input, config, reach,
						currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
					// any remaining configs for this alt have a lower priority
					// than the one that just reached an accept state.
					skipAlt = cfg.alt;
				}
			}
		}
	}
};

LexerATNSimulator.prototype.accept = function(input, lexerActionExecutor,
		startIndex, index, line, charPos) {
	if (LexerATNSimulator.debug) {
		console.log("ACTION %s\n", lexerActionExecutor);
	}
	// seek to after last char in token
	input.seek(index);
	this.line = line;
	this.column = charPos;
	if (lexerActionExecutor !== null && this.recog !== null) {
		lexerActionExecutor.execute(this.recog, input, startIndex);
	}
};

LexerATNSimulator.prototype.getReachableTarget = function(trans, t) {
	if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
		return trans.target;
	} else {
		return null;
	}
};

LexerATNSimulator.prototype.computeStartState = function(input, p) {
	var initialContext = PredictionContext.EMPTY;
	var configs = new OrderedATNConfigSet();
	for (var i = 0; i < p.transitions.length; i++) {
		var target = p.transitions[i].target;
        var cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);
		this.closure(input, cfg, configs, false, false, false);
	}
	return configs;
};

// Since the alternatives within any lexer decision are ordered by
// preference, this method stops pursuing the closure as soon as an accept
// state is reached. After the first accept state is reached by depth-first
// search from {@code config}, all other (potentially reachable) states for
// this rule would have a lower priority.
//
// @return {@code true} if an accept state is reached, otherwise
// {@code false}.
LexerATNSimulator.prototype.closure = function(input, config, configs,
		currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (LexerATNSimulator.debug) {
		console.log("closure(" + config.toString(this.recog, true) + ")");
	}
	if (config.state instanceof RuleStopState) {
		if (LexerATNSimulator.debug) {
			if (this.recog !== null) {
				console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
			} else {
				console.log("closure at rule stop %s\n", config);
			}
		}
		if (config.context === null || config.context.hasEmptyPath()) {
			if (config.context === null || config.context.isEmpty()) {
				configs.add(config);
				return true;
			} else {
				configs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));
				currentAltReachedAcceptState = true;
			}
		}
		if (config.context !== null && !config.context.isEmpty()) {
			for (var i = 0; i < config.context.length; i++) {
				if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
					var newContext = config.context.getParent(i); // "pop" return state
					var returnState = this.atn.states[config.context.getReturnState(i)];
					cfg = new LexerATNConfig({ state:returnState, context:newContext }, config);
					currentAltReachedAcceptState = this.closure(input, cfg,
							configs, currentAltReachedAcceptState, speculative,
							treatEofAsEpsilon);
				}
			}
		}
		return currentAltReachedAcceptState;
	}
	// optimization
	if (!config.state.epsilonOnlyTransitions) {
		if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
			configs.add(config);
		}
	}
	for (var j = 0; j < config.state.transitions.length; j++) {
		var trans = config.state.transitions[j];
		cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
		if (cfg !== null) {
			currentAltReachedAcceptState = this.closure(input, cfg, configs,
					currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
		}
	}
	return currentAltReachedAcceptState;
};

// side-effect: can alter configs.hasSemanticContext
LexerATNSimulator.prototype.getEpsilonTarget = function(input, config, trans,
		configs, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (trans.serializationType === Transition.RULE) {
		var newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
		cfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);
	} else if (trans.serializationType === Transition.PRECEDENCE) {
		throw "Precedence predicates are not supported in lexers.";
	} else if (trans.serializationType === Transition.PREDICATE) {
		// Track traversing semantic predicates. If we traverse,
		// we cannot add a DFA state for this "reach" computation
		// because the DFA would not test the predicate again in the
		// future. Rather than creating collections of semantic predicates
		// like v3 and testing them on prediction, v4 will test them on the
		// fly all the time using the ATN not the DFA. This is slower but
		// semantically it's not used that often. One of the key elements to
		// this predicate mechanism is not adding DFA states that see
		// predicates immediately afterwards in the ATN. For example,

		// a : ID {p1}? | ID {p2}? ;

		// should create the start state for rule 'a' (to save start state
		// competition), but should not create target of ID state. The
		// collection of ATN states the following ID references includes
		// states reached by traversing predicates. Since this is when we
		// test them, we cannot cash the DFA state target of ID.

		if (LexerATNSimulator.debug) {
			console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
		}
		configs.hasSemanticContext = true;
		if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
			cfg = new LexerATNConfig({ state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.ACTION) {
		if (config.context === null || config.context.hasEmptyPath()) {
			// execute actions anywhere in the start rule for a token.
			//
			// TODO: if the entry rule is invoked recursively, some
			// actions may be executed during the recursive call. The
			// problem can appear when hasEmptyPath() is true but
			// isEmpty() is false. In this case, the config needs to be
			// split into two contexts - one with just the empty path
			// and another with everything but the empty path.
			// Unfortunately, the current algorithm does not allow
			// getEpsilonTarget to return two configurations, so
			// additional modifications are needed before we can support
			// the split operation.
			var lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,
					this.atn.lexerActions[trans.actionIndex]);
			cfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);
		} else {
			// ignore actions in referenced rules
			cfg = new LexerATNConfig( { state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.EPSILON) {
		cfg = new LexerATNConfig({ state:trans.target}, config);
	} else if (trans.serializationType === Transition.ATOM ||
				trans.serializationType === Transition.RANGE ||
				trans.serializationType === Transition.SET) {
		if (treatEofAsEpsilon) {
			if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
				cfg = new LexerATNConfig( { state:trans.target }, config);
			}
		}
	}
	return cfg;
};

// Evaluate a predicate specified in the lexer.
//
// <p>If {@code speculative} is {@code true}, this method was called before
// {@link //consume} for the matched character. This method should call
// {@link //consume} before evaluating the predicate to ensure position
// sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
// and {@link Lexer//getcolumn}, properly reflect the current
// lexer state. This method should restore {@code input} and the simulator
// to the original state before returning (i.e. undo the actions made by the
// call to {@link //consume}.</p>
//
// @param input The input stream.
// @param ruleIndex The rule containing the predicate.
// @param predIndex The index of the predicate within the rule.
// @param speculative {@code true} if the current index in {@code input} is
// one character before the predicate's location.
//
// @return {@code true} if the specified predicate evaluates to
// {@code true}.
// /
LexerATNSimulator.prototype.evaluatePredicate = function(input, ruleIndex,
		predIndex, speculative) {
	// assume true if no recognizer was provided
	if (this.recog === null) {
		return true;
	}
	if (!speculative) {
		return this.recog.sempred(null, ruleIndex, predIndex);
	}
	var savedcolumn = this.column;
	var savedLine = this.line;
	var index = input.index;
	var marker = input.mark();
	try {
		this.consume(input);
		return this.recog.sempred(null, ruleIndex, predIndex);
	} finally {
		this.column = savedcolumn;
		this.line = savedLine;
		input.seek(index);
		input.release(marker);
	}
};

LexerATNSimulator.prototype.captureSimState = function(settings, input, dfaState) {
	settings.index = input.index;
	settings.line = this.line;
	settings.column = this.column;
	settings.dfaState = dfaState;
};

LexerATNSimulator.prototype.addDFAEdge = function(from_, tk, to, cfgs) {
	if (to === undefined) {
		to = null;
	}
	if (cfgs === undefined) {
		cfgs = null;
	}
	if (to === null && cfgs !== null) {
		// leading to this call, ATNConfigSet.hasSemanticContext is used as a
		// marker indicating dynamic predicate evaluation makes this edge
		// dependent on the specific input sequence, so the static edge in the
		// DFA should be omitted. The target DFAState is still created since
		// execATN has the ability to resynchronize with the DFA state cache
		// following the predicate evaluation step.
		//
		// TJP notes: next time through the DFA, we see a pred again and eval.
		// If that gets us to a previously created (but dangling) DFA
		// state, we can continue in pure DFA mode from there.
		// /
		var suppressEdge = cfgs.hasSemanticContext;
		cfgs.hasSemanticContext = false;

		to = this.addDFAState(cfgs);

		if (suppressEdge) {
			return to;
		}
	}
	// add the edge
	if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
		// Only track edges within the DFA bounds
		return to;
	}
	if (LexerATNSimulator.debug) {
		console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
	}
	if (from_.edges === null) {
		// make room for tokens 1..n and -1 masquerading as index 0
		from_.edges = [];
	}
	from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

	return to;
};

// Add a new DFA state if there isn't one with this set of
// configurations already. This method also detects the first
// configuration containing an ATN rule stop state. Later, when
// traversing the DFA, we will know which rule to accept.
LexerATNSimulator.prototype.addDFAState = function(configs) {
	var proposed = new DFAState(null, configs);
	var firstConfigWithRuleStopState = null;
	for (var i = 0; i < configs.items.length; i++) {
		var cfg = configs.items[i];
		if (cfg.state instanceof RuleStopState) {
			firstConfigWithRuleStopState = cfg;
			break;
		}
	}
	if (firstConfigWithRuleStopState !== null) {
		proposed.isAcceptState = true;
		proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
		proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
	}
	var dfa = this.decisionToDFA[this.mode];
	var existing = dfa.states.get(proposed);
	if (existing!==null) {
		return existing;
	}
	var newState = proposed;
	newState.stateNumber = dfa.states.length;
	configs.setReadonly(true);
	newState.configs = configs;
	dfa.states.add(newState);
	return newState;
};

LexerATNSimulator.prototype.getDFA = function(mode) {
	return this.decisionToDFA[mode];
};

// Get the text matched so far for the current token.
LexerATNSimulator.prototype.getText = function(input) {
	// index is first lookahead char, don't include.
	return input.getText(this.startIndex, input.index - 1);
};

LexerATNSimulator.prototype.consume = function(input) {
	var curChar = input.LA(1);
	if (curChar === "\n".charCodeAt(0)) {
		this.line += 1;
		this.column = 0;
	} else {
		this.column += 1;
	}
	input.consume();
};

LexerATNSimulator.prototype.getTokenName = function(tt) {
	if (tt === -1) {
		return "EOF";
	} else {
		return "'" + String.fromCharCode(tt) + "'";
	}
};

exports.LexerATNSimulator = LexerATNSimulator;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This default implementation of {@link TokenFactory} creates
// {@link CommonToken} objects.
//

var CommonToken = __webpack_require__(1).CommonToken;

function TokenFactory() {
	return this;
}

function CommonTokenFactory(copyText) {
	TokenFactory.call(this);
    // Indicates whether {@link CommonToken//setText} should be called after
    // constructing tokens to explicitly set the text. This is useful for cases
    // where the input stream might not be able to provide arbitrary substrings
    // of text from the input after the lexer creates a token (e.g. the
    // implementation of {@link CharStream//getText} in
    // {@link UnbufferedCharStream} throws an
    // {@link UnsupportedOperationException}). Explicitly setting the token text
    // allows {@link Token//getText} to be called at any time regardless of the
    // input stream implementation.
    //
    // <p>
    // The default value is {@code false} to avoid the performance and memory
    // overhead of copying text for every token unless explicitly requested.</p>
    //
    this.copyText = copyText===undefined ? false : copyText;
	return this;
}

CommonTokenFactory.prototype = Object.create(TokenFactory.prototype);
CommonTokenFactory.prototype.constructor = CommonTokenFactory;

//
// The default {@link CommonTokenFactory} instance.
//
// <p>
// This token factory does not explicitly copy token text when constructing
// tokens.</p>
//
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

CommonTokenFactory.prototype.create = function(source, type, text, channel, start, stop, line, column) {
    var t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !==null) {
        t.text = text;
    } else if (this.copyText && source[1] !==null) {
        t.text = source[1].getText(start,stop);
    }
    return t;
};

CommonTokenFactory.prototype.createThin = function(type, text) {
    var t = new CommonToken(null, type);
    t.text = text;
    return t;
};

exports.CommonTokenFactory = CommonTokenFactory;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents an executor for a sequence of lexer actions which traversed during
// the matching operation of a lexer rule (token).
//
// <p>The executor tracks position information for position-dependent lexer actions
// efficiently, ensuring that actions appearing only at the end of the rule do
// not cause bloating of the {@link DFA} created for the lexer.</p>

var hashStuff = __webpack_require__(0).hashStuff;
var LexerIndexedCustomAction = __webpack_require__(62).LexerIndexedCustomAction;

function LexerActionExecutor(lexerActions) {
	this.lexerActions = lexerActions === null ? [] : lexerActions;
	// Caches the result of {@link //hashCode} since the hash code is an element
	// of the performance-critical {@link LexerATNConfig//hashCode} operation.
	this.cachedHashCode = hashStuff(lexerActions); // "".join([str(la) for la in
	// lexerActions]))
	return this;
}

// Creates a {@link LexerActionExecutor} which executes the actions for
// the input {@code lexerActionExecutor} followed by a specified
// {@code lexerAction}.
//
// @param lexerActionExecutor The executor for actions already traversed by
// the lexer while matching a token within a particular
// {@link LexerATNConfig}. If this is {@code null}, the method behaves as
// though it were an empty executor.
// @param lexerAction The lexer action to execute after the actions
// specified in {@code lexerActionExecutor}.
//
// @return A {@link LexerActionExecutor} for executing the combine actions
// of {@code lexerActionExecutor} and {@code lexerAction}.
LexerActionExecutor.append = function(lexerActionExecutor, lexerAction) {
	if (lexerActionExecutor === null) {
		return new LexerActionExecutor([ lexerAction ]);
	}
	var lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);
	return new LexerActionExecutor(lexerActions);
};

// Creates a {@link LexerActionExecutor} which encodes the current offset
// for position-dependent lexer actions.
//
// <p>Normally, when the executor encounters lexer actions where
// {@link LexerAction//isPositionDependent} returns {@code true}, it calls
// {@link IntStream//seek} on the input {@link CharStream} to set the input
// position to the <em>end</em> of the current token. This behavior provides
// for efficient DFA representation of lexer actions which appear at the end
// of a lexer rule, even when the lexer rule matches a variable number of
// characters.</p>
//
// <p>Prior to traversing a match transition in the ATN, the current offset
// from the token start index is assigned to all position-dependent lexer
// actions which have not already been assigned a fixed offset. By storing
// the offsets relative to the token start index, the DFA representation of
// lexer actions which appear in the middle of tokens remains efficient due
// to sharing among tokens of the same length, regardless of their absolute
// position in the input stream.</p>
//
// <p>If the current executor already has offsets assigned to all
// position-dependent lexer actions, the method returns {@code this}.</p>
//
// @param offset The current offset to assign to all position-dependent
// lexer actions which do not already have offsets assigned.
//
// @return A {@link LexerActionExecutor} which stores input stream offsets
// for all position-dependent lexer actions.
// /
LexerActionExecutor.prototype.fixOffsetBeforeMatch = function(offset) {
	var updatedLexerActions = null;
	for (var i = 0; i < this.lexerActions.length; i++) {
		if (this.lexerActions[i].isPositionDependent &&
				!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
			if (updatedLexerActions === null) {
				updatedLexerActions = this.lexerActions.concat([]);
			}
			updatedLexerActions[i] = new LexerIndexedCustomAction(offset,
					this.lexerActions[i]);
		}
	}
	if (updatedLexerActions === null) {
		return this;
	} else {
		return new LexerActionExecutor(updatedLexerActions);
	}
};

// Execute the actions encapsulated by this executor within the context of a
// particular {@link Lexer}.
//
// <p>This method calls {@link IntStream//seek} to set the position of the
// {@code input} {@link CharStream} prior to calling
// {@link LexerAction//execute} on a position-dependent action. Before the
// method returns, the input position will be restored to the same position
// it was in when the method was invoked.</p>
//
// @param lexer The lexer instance.
// @param input The input stream which is the source for the current token.
// When this method is called, the current {@link IntStream//index} for
// {@code input} should be the start of the following token, i.e. 1
// character past the end of the current token.
// @param startIndex The token start index. This value may be passed to
// {@link IntStream//seek} to set the {@code input} position to the beginning
// of the token.
// /
LexerActionExecutor.prototype.execute = function(lexer, input, startIndex) {
	var requiresSeek = false;
	var stopIndex = input.index;
	try {
		for (var i = 0; i < this.lexerActions.length; i++) {
			var lexerAction = this.lexerActions[i];
			if (lexerAction instanceof LexerIndexedCustomAction) {
				var offset = lexerAction.offset;
				input.seek(startIndex + offset);
				lexerAction = lexerAction.action;
				requiresSeek = (startIndex + offset) !== stopIndex;
			} else if (lexerAction.isPositionDependent) {
				input.seek(stopIndex);
				requiresSeek = false;
			}
			lexerAction.execute(lexer);
		}
	} finally {
		if (requiresSeek) {
			input.seek(stopIndex);
		}
	}
};

LexerActionExecutor.prototype.hashCode = function() {
	return this.cachedHashCode;
};

LexerActionExecutor.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};


LexerActionExecutor.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof LexerActionExecutor)) {
		return false;
	} else if (this.cachedHashCode != other.cachedHashCode) {
		return false;
	} else if (this.lexerActions.length != other.lexerActions.length) {
		return false;
	} else {
		var numActions = this.lexerActions.length
		for (var idx = 0; idx < numActions; ++idx) {
			if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
				return false;
			}
		}
		return true;
	}
};

exports.LexerActionExecutor = LexerActionExecutor;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
//
// <p>
// The basic complexity of the adaptive strategy makes it harder to understand.
// We begin with ATN simulation to build paths in a DFA. Subsequent prediction
// requests go through the DFA first. If they reach a state without an edge for
// the current symbol, the algorithm fails over to the ATN simulation to
// complete the DFA path for the current input (until it finds a conflict state
// or uniquely predicting state).</p>
//
// <p>
// All of that is done without using the outer context because we want to create
// a DFA that is not dependent upon the rule invocation stack when we do a
// prediction. One DFA works in all contexts. We avoid using context not
// necessarily because it's slower, although it can be, but because of the DFA
// caching problem. The closure routine only considers the rule invocation stack
// created during prediction beginning in the decision rule. For example, if
// prediction occurs without invoking another rule's ATN, there are no context
// stacks in the configurations. When lack of context leads to a conflict, we
// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
// strategy (versus full LL(*)).</p>
//
// <p>
// When SLL yields a configuration set with conflict, we rewind the input and
// retry the ATN simulation, this time using full outer context without adding
// to the DFA. Configuration context stacks will be the full invocation stacks
// from the start rule. If we get a conflict using full context, then we can
// definitively say we have a true ambiguity for that input sequence. If we
// don't get a conflict, it implies that the decision is sensitive to the outer
// context. (It is not context-sensitive in the sense of context-sensitive
// grammars.)</p>
//
// <p>
// The next time we reach this DFA state with an SLL conflict, through DFA
// simulation, we will again retry the ATN simulation using full context mode.
// This is slow because we can't save the results and have to "interpret" the
// ATN each time we get that input.</p>
//
// <p>
// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
//
// <p>
// We could cache results from full context to predicted alternative easily and
// that saves a lot of time but doesn't work in presence of predicates. The set
// of visible predicates from the ATN start state changes depending on the
// context, because closure can fall off the end of a rule. I tried to cache
// tuples (stack context, semantic context, predicted alt) but it was slower
// than interpreting and much more complicated. Also required a huge amount of
// memory. The goal is not to create the world's fastest parser anyway. I'd like
// to keep this algorithm simple. By launching multiple threads, we can improve
// the speed of parsing across a large number of files.</p>
//
// <p>
// There is no strict ordering between the amount of input used by SLL vs LL,
// which makes it really hard to build a cache for full context. Let's say that
// we have input A B C that leads to an SLL conflict with full context X. That
// implies that using X we might only use A B but we could also use A B C D to
// resolve conflict. Input A B C D could predict alternative 1 in one position
// in the input and A B C E could predict alternative 2 in another position in
// input. The conflicting SLL configurations could still be non-unique in the
// full context prediction, which would lead us to requiring more input than the
// original A B C.	To make a	prediction cache work, we have to track	the exact
// input	used during the previous prediction. That amounts to a cache that maps
// X to a specific DFA for that context.</p>
//
// <p>
// Something should be done for left-recursive expression predictions. They are
// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
// with full LL thing Sam does.</p>
//
// <p>
// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
//
// <p>
// We avoid doing full context retry when the outer context is empty, we did not
// dip into the outer context by falling off the end of the decision state rule,
// or when we force SLL mode.</p>
//
// <p>
// As an example of the not dip into outer context case, consider as super
// constructor calls versus function calls. One grammar might look like
// this:</p>
//
// <pre>
// ctorBody
//   : '{' superCall? stat* '}'
//   ;
// </pre>
//
// <p>
// Or, you might see something like</p>
//
// <pre>
// stat
//   : superCall ';'
//   | expression ';'
//   | ...
//   ;
// </pre>
//
// <p>
// In both cases I believe that no closure operations will dip into the outer
// context. In the first case ctorBody in the worst case will stop at the '}'.
// In the 2nd case it should stop at the ';'. Both cases should stay within the
// entry rule and not dip into the outer context.</p>
//
// <p>
// <strong>PREDICATES</strong></p>
//
// <p>
// Predicates are always evaluated if present in either SLL or LL both. SLL and
// LL simulation deals with predicates differently. SLL collects predicates as
// it performs closure operations like ANTLR v3 did. It delays predicate
// evaluation until it reaches and accept state. This allows us to cache the SLL
// ATN simulation whereas, if we had evaluated predicates on-the-fly during
// closure, the DFA state configuration sets would be different and we couldn't
// build up a suitable DFA.</p>
//
// <p>
// When building a DFA accept state during ATN simulation, we evaluate any
// predicates and return the sole semantically valid alternative. If there is
// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
// we throw an exception. Alternatives without predicates act like they have
// true predicates. The simple way to think about it is to strip away all
// alternatives with false predicates and choose the minimum alternative that
// remains.</p>
//
// <p>
// When we start in the DFA and reach an accept state that's predicated, we test
// those and return the minimum semantically viable alternative. If no
// alternatives are viable, we throw an exception.</p>
//
// <p>
// During full LL ATN simulation, closure always evaluates predicates and
// on-the-fly. This is crucial to reducing the configuration set size during
// closure. It hits a landmine when parsing with the Java grammar, for example,
// without this on-the-fly evaluation.</p>
//
// <p>
// <strong>SHARING DFA</strong></p>
//
// <p>
// All instances of the same parser share the same decision DFAs through a
// static field. Each instance gets its own ATN simulator but they share the
// same {@link //decisionToDFA} field. They also share a
// {@link PredictionContextCache} object that makes sure that all
// {@link PredictionContext} objects are shared among the DFA states. This makes
// a big size difference.</p>
//
// <p>
// <strong>THREAD SAFETY</strong></p>
//
// <p>
// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
// it adds a new DFA object to that array. {@link //addDFAEdge}
// locks on the DFA for the current decision when setting the
// {@link DFAState//edges} field. {@link //addDFAState} locks on
// the DFA for the current decision when looking up a DFA state to see if it
// already exists. We must make sure that all requests to add DFA states that
// are equivalent result in the same shared DFA object. This is because lots of
// threads will be trying to update the DFA at once. The
// {@link //addDFAState} method also locks inside the DFA lock
// but this time on the shared context cache when it rebuilds the
// configurations' {@link PredictionContext} objects using cached
// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
// safe as long as we can guarantee that all threads referencing
// {@code s.edge[t]} get the same physical target {@link DFAState}, or
// {@code null}. Once into the DFA, the DFA simulation does not reference the
// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
// targets. The DFA simulator will either find {@link DFAState//edges} to be
// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
// {@code dfa.edges[t]} to be non-null. The
// {@link //addDFAEdge} method could be racing to set the field
// but in either case the DFA simulator works; if {@code null}, and requests ATN
// simulation. It could also race trying to get {@code dfa.edges[t]}, but either
// way it will work because it's not doing a test and set operation.</p>
//
// <p>
// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
// Parsing)</strong></p>
//
// <p>
// Sam pointed out that if SLL does not give a syntax error, then there is no
// point in doing full LL, which is slower. We only have to try LL if we get a
// syntax error. For maximum speed, Sam starts the parser set to pure SLL
// mode with the {@link BailErrorStrategy}:</p>
//
// <pre>
// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
// </pre>
//
// <p>
// If it does not get a syntax error, then we're done. If it does get a syntax
// error, we need to retry with the combined SLL/LL strategy.</p>
//
// <p>
// The reason this works is as follows. If there are no SLL conflicts, then the
// grammar is SLL (at least for that input set). If there is an SLL conflict,
// the full LL analysis must yield a set of viable alternatives which is a
// subset of the alternatives reported by SLL. If the LL set is a singleton,
// then the grammar is LL but not SLL. If the LL set is the same size as the SLL
// set, the decision is SLL. If the LL set has size &gt; 1, then that decision
// is truly ambiguous on the current input. If the LL set is smaller, then the
// SLL conflict resolution might choose an alternative that the full LL would
// rule out as a possibility based upon better context information. If that's
// the case, then the SLL parse will definitely get an error because the full LL
// analysis says it's not viable. If SLL conflict resolution chooses an
// alternative within the LL set, them both SLL and LL would choose the same
// alternative because they both choose the minimum of multiple conflicting
// alternatives.</p>
//
// <p>
// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
// parsing will get an error because SLL will pursue alternative 1. If
// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
// choose the same alternative because alternative one is the minimum of either
// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
//
// <p>
// Of course, if the input is invalid, then we will get an error for sure in
// both SLL and LL parsing. Erroneous input will therefore require 2 passes over
// the input.</p>
//

var Utils = __webpack_require__(0);
var Set = Utils.Set;
var BitSet = Utils.BitSet;
var DoubleDict = Utils.DoubleDict;
var ATN = __webpack_require__(10).ATN;
var ATNState = __webpack_require__(7).ATNState;
var ATNConfig = __webpack_require__(25).ATNConfig;
var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var Token = __webpack_require__(1).Token;
var DFAState = __webpack_require__(17).DFAState;
var PredPrediction = __webpack_require__(17).PredPrediction;
var ATNSimulator = __webpack_require__(64).ATNSimulator;
var PredictionMode = __webpack_require__(65).PredictionMode;
var RuleContext = __webpack_require__(26).RuleContext;
var ParserRuleContext = __webpack_require__(34).ParserRuleContext;
var SemanticContext = __webpack_require__(16).SemanticContext;
var StarLoopEntryState = __webpack_require__(7).StarLoopEntryState;
var RuleStopState = __webpack_require__(7).RuleStopState;
var PredictionContext = __webpack_require__(9).PredictionContext;
var Interval = __webpack_require__(2).Interval;
var Transitions = __webpack_require__(11);
var Transition = Transitions.Transition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var ActionTransition = Transitions.ActionTransition;
var NoViableAltException = __webpack_require__(8).NoViableAltException;

var SingletonPredictionContext = __webpack_require__(9).SingletonPredictionContext;
var predictionContextFromRuleContext = __webpack_require__(9).predictionContextFromRuleContext;

function ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    // SLL, LL, or LL + exact ambig detection?//
    this.predictionMode = PredictionMode.LL;
    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    // Each prediction operation uses a cache for merge of prediction contexts.
    //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
    //  isn't synchronized but we're ok since two threads shouldn't reuse same
    //  parser/atnsim object because it can only handle one input at a time.
    //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
    //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
    //  also be examined during cache lookup.
    //
    this.mergeCache = null;
    return this;
}

ParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);
ParserATNSimulator.prototype.constructor = ParserATNSimulator;

ParserATNSimulator.prototype.debug = false;
ParserATNSimulator.prototype.debug_closure = false;
ParserATNSimulator.prototype.debug_add = false;
ParserATNSimulator.prototype.debug_list_atn_decisions = false;
ParserATNSimulator.prototype.dfa_debug = false;
ParserATNSimulator.prototype.retry_debug = false;


ParserATNSimulator.prototype.reset = function() {
};

ParserATNSimulator.prototype.adaptivePredict = function(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("adaptivePredict decision " + decision +
                               " exec LA(1)==" + this.getLookaheadName(input) +
                               " line " + input.LT(1).line + ":" +
                               input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;

    var dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    var m = input.mark();
    var index = input.index;

    // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?
    try {
        var s0;
        if (dfa.precedenceDfa) {
            // the start state for a precedence DFA depends on the current
            // parser precedence, and is provided by a DFA method.
            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
            // the start state for a "regular" DFA is just s0
            s0 = dfa.s0;
        }
        if (s0===null) {
            if (outerContext===null) {
                outerContext = RuleContext.EMPTY;
            }
            if (this.debug || this.debug_list_atn_decisions) {
                console.log("predictATN decision " + dfa.decision +
                                   " exec LA(1)==" + this.getLookaheadName(input) +
                                   ", outerContext=" + outerContext.toString(this.parser.ruleNames));
            }

            var fullCtx = false;
            var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

            if( dfa.precedenceDfa) {
                // If this is a precedence DFA, we use applyPrecedenceFilter
                // to convert the computed start state to a precedence start
                // state. We then use DFA.setPrecedenceStartState to set the
                // appropriate start state for the precedence level rather
                // than simply setting DFA.s0.
                //
                dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
                s0_closure = this.applyPrecedenceFilter(s0_closure);
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
            } else {
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.s0 = s0;
            }
        }
        var alt = this.execATN(dfa, s0, input, index, outerContext);
        if (this.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames));
        }
        return alt;
    } finally {
        this._dfa = null;
        this.mergeCache = null; // wack cache after each prediction
        input.seek(index);
        input.release(m);
    }
};
// Performs ATN simulation to compute a predicted alternative based
//  upon the remaining input, but also updates the DFA cache to avoid
//  having to traverse the ATN again for the same input sequence.

// There are some key conditions we're looking for after computing a new
// set of ATN configs (proposed DFA state):
      // if the set is empty, there is no viable alternative for current symbol
      // does the state uniquely predict an alternative?
      // does the state have a conflict that would prevent us from
      //   putting it on the work list?

// We also have some key operations to do:
      // add an edge from previous DFA state to potentially new DFA state, D,
      //   upon current symbol but only if adding to work list, which means in all
      //   cases except no viable alternative (and possibly non-greedy decisions?)
      // collecting predicates and adding semantic context to DFA accept states
      // adding rule context to context-sensitive DFA accept states
      // consuming an input symbol
      // reporting a conflict
      // reporting an ambiguity
      // reporting a context sensitivity
      // reporting insufficient predicates

// cover these cases:
//    dead end
//    single alt
//    single alt + preds
//    conflict
//    conflict + preds
//
ParserATNSimulator.prototype.execATN = function(dfa, s0, input, startIndex, outerContext ) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATN decision " + dfa.decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    var alt;
    var previousD = s0;

    if (this.debug) {
        console.log("s0 = " + s0);
    }
    var t = input.LA(1);
    while(true) { // while more work
        var D = this.getExistingTargetState(previousD, t);
        if(D===null) {
            D = this.computeTargetState(dfa, previousD, t);
        }
        if(D===ATNSimulator.ERROR) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for SLL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
            input.seek(startIndex);
            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
            // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
            var conflictingAlts = null;
            if (D.predicates!==null) {
                if (this.debug) {
                    console.log("DFA state has preds in DFA sim LL failover");
                }
                var conflictIndex = input.index;
                if(conflictIndex !== startIndex) {
                    input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (conflictingAlts.length===1) {
                    if(this.debug) {
                        console.log("Full LL avoided");
                    }
                    return conflictingAlts.minValue();
                }
                if (conflictIndex !== startIndex) {
                    // restore the index so reporting the fallback to full
                    // context occurs with the index at the correct spot
                    input.seek(conflictIndex);
                }
            }
            if (this.dfa_debug) {
                console.log("ctx sensitive state " + outerContext +" in " + D);
            }
            var fullCtx = true;
            var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
            this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
            alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
            return alt;
        }
        if (D.isAcceptState) {
            if (D.predicates===null) {
                return D.prediction;
            }
            var stopIndex = input.index;
            input.seek(startIndex);
            var alts = this.evalSemanticContext(D.predicates, outerContext, true);
            if (alts.length===0) {
                throw this.noViableAlt(input, outerContext, D.configs, startIndex);
            } else if (alts.length===1) {
                return alts.minValue();
            } else {
                // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                return alts.minValue();
            }
        }
        previousD = D;

        if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
};
//
// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param previousD The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
//
ParserATNSimulator.prototype.getExistingTargetState = function(previousD, t) {
    var edges = previousD.edges;
    if (edges===null) {
        return null;
    } else {
        return edges[t + 1] || null;
    }
};
//
// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param dfa The DFA
// @param previousD The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
//
ParserATNSimulator.prototype.computeTargetState = function(dfa, previousD, t) {
   var reach = this.computeReachSet(previousD.configs, t, false);
    if(reach===null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
    }
    // create new target state; we'll add to DFA after it's complete
    var D = new DFAState(null, reach);

    var predictedAlt = this.getUniqueAlt(reach);

    if (this.debug) {
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) +
                    ", previous=" + previousD.configs +
                    ", configs=" + reach +
                    ", predict=" + predictedAlt +
                    ", allSubsetsConflict=" +
                    PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                    this.getConflictingAlts(reach));
    }
    if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {
        // NO CONFLICT, UNIQUELY PREDICTED ALT
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        // MORE THAN ONE VIABLE ALTERNATIVE
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        // in SLL-only mode, we will stop at this state and return the minimum alt
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if( D.predicates!==null) {
            D.prediction = ATN.INVALID_ALT_NUMBER;
        }
    }
    // all adds to dfa are done after we've created full D state
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
};

ParserATNSimulator.prototype.predicateDFAState = function(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    var nalts = decisionState.transitions.length;
    // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts
    var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred!==null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
        // There are preds in configs but they might go away
        // when OR'd together like {p}? || NONE == NONE. If neither
        // alt has preds, resolve to min alt
        dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
};

// comes back with reach.uniqueAlt set to a valid alt
ParserATNSimulator.prototype.execATNWithFullContext = function(dfa, D, // how far we got before failing over
                                     s0,
                                     input,
                                     startIndex,
                                     outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATNWithFullContext "+s0);
    }
    var fullCtx = true;
    var foundExactAmbig = false;
    var reach = null;
    var previous = s0;
    input.seek(startIndex);
    var t = input.LA(1);
    var predictedAlt = -1;
    while (true) { // while more work
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach===null) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for LL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previous, startIndex);
            input.seek(startIndex);
            var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if(this.debug) {
            console.log("LL altSubSets=" + altSubSets + ", predict=" +
                  PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                  PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = this.getUniqueAlt(reach);
        // unique prediction?
        if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {
            predictedAlt = reach.uniqueAlt;
            break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
            if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {
                break;
            }
        } else {
            // In exact ambiguity mode, we never try to terminate early.
            // Just keeps scarfing until we know what the conflict is
            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
                foundExactAmbig = true;
                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
                break;
            }
            // else there are multiple non-conflicting subsets or
            // we're not sure what the ambiguity is yet.
            // So, keep going.
        }
        previous = reach;
        if( t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
    // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
    }
    // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.

    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:

    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.

    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);

    return predictedAlt;
};

ParserATNSimulator.prototype.computeReachSet = function(closure, t, fullCtx) {
    if (this.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
    }
    if( this.mergeCache===null) {
        this.mergeCache = new DoubleDict();
    }
    var intermediate = new ATNConfigSet(fullCtx);

    // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.

    var skippedStopStates = null;

    // First figure out where we can reach on input t
    for (var i=0; i<closure.items.length;i++) {
        var c = closure.items[i];
        if(this.debug_add) {
            console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
            if (fullCtx || t === Token.EOF) {
                if (skippedStopStates===null) {
                    skippedStopStates = [];
                }
                skippedStopStates.push(c);
                if(this.debug_add) {
                    console.log("added " + c + " to skippedStopStates");
                }
            }
            continue;
        }
        for(var j=0;j<c.state.transitions.length;j++) {
            var trans = c.state.transitions[j];
            var target = this.getReachableTarget(trans, t);
            if (target!==null) {
                var cfg = new ATNConfig({state:target}, c);
                intermediate.add(cfg, this.mergeCache);
                if(this.debug_add) {
                    console.log("added " + cfg + " to intermediate");
                }
            }
        }
    }
    // Now figure out where the reach operation can take us...
    var reach = null;

    // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //
    if (skippedStopStates===null && t!==Token.EOF) {
        if (intermediate.items.length===1) {
            // Don't pursue the closure if there is just one state.
            // It can only have one alternative; just add to result
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        }
    }
    // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //
    if (reach===null) {
        reach = new ATNConfigSet(fullCtx);
        var closureBusy = new Set();
        var treatEofAsEpsilon = t === Token.EOF;
        for (var k=0; k<intermediate.items.length;k++) {
            this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
    }
    if (t === Token.EOF) {
        // After consuming EOF no additional input is possible, so we are
        // only interested in configurations which reached the end of the
        // decision rule (local context) or end of the start rule (full
        // context). Update reach to contain only these configurations. This
        // handles both explicit EOF transitions in the grammar and implicit
        // EOF transitions following the end of the decision or start rule.
        //
        // When reach==intermediate, no closure operation was performed. In
        // this case, removeAllConfigsNotInRuleStopState needs to check for
        // reachable rule stop states as well as configurations already in
        // a rule stop state.
        //
        // This is handled before the configurations in skippedStopStates,
        // because any configurations potentially added from that list are
        // already guaranteed to meet this condition whether or not it's
        // required.
        //
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //
    if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {
        for (var l=0; l<skippedStopStates.length;l++) {
            reach.add(skippedStopStates[l], this.mergeCache);
        }
    }
    if (reach.items.length===0) {
        return null;
    } else {
        return reach;
    }
};
//
// Return a configuration set containing only the configurations from
// {@code configs} which are in a {@link RuleStopState}. If all
// configurations in {@code configs} are already in a rule stop state, this
// method simply returns {@code configs}.
//
// <p>When {@code lookToEndOfRule} is true, this method uses
// {@link ATN//nextTokens} for each configuration in {@code configs} which is
// not already in a rule stop state to see if a rule stop state is reachable
// from the configuration via epsilon-only transitions.</p>
//
// @param configs the configuration set to update
// @param lookToEndOfRule when true, this method checks for rule stop states
// reachable by epsilon-only transitions from each configuration in
// {@code configs}.
//
// @return {@code configs} if all configurations in {@code configs} are in a
// rule stop state, otherwise return a new configuration set containing only
// the configurations from {@code configs} which are in a rule stop state
//
ParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
    }
    var result = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length;i++) {
        var config = configs.items[i];
        if (config.state instanceof RuleStopState) {
            result.add(config, this.mergeCache);
            continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
            var nextTokens = this.atn.nextTokens(config.state);
            if (nextTokens.contains(Token.EPSILON)) {
                var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);
            }
        }
    }
    return result;
};

ParserATNSimulator.prototype.computeStartState = function(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    var initialContext = predictionContextFromRuleContext(this.atn, ctx);
    var configs = new ATNConfigSet(fullCtx);
    for(var i=0;i<p.transitions.length;i++) {
        var target = p.transitions[i].target;
        var c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);
        var closureBusy = new Set();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
};

//
// This method transforms the start state computed by
// {@link //computeStartState} to the special start state used by a
// precedence DFA for a particular precedence value. The transformation
// process applies the following changes to the start state's configuration
// set.
//
// <ol>
// <li>Evaluate the precedence predicates for each configuration using
// {@link SemanticContext//evalPrecedence}.</li>
// <li>Remove all configurations which predict an alternative greater than
// 1, for which another configuration that predicts alternative 1 is in the
// same ATN state with the same prediction context. This transformation is
// valid for the following reasons:
// <ul>
// <li>The closure block cannot contain any epsilon transitions which bypass
// the body of the closure, so all states reachable via alternative 1 are
// part of the precedence alternatives of the transformed left-recursive
// rule.</li>
// <li>The "primary" portion of a left recursive rule cannot contain an
// epsilon transition, so the only way an alternative other than 1 can exist
// in a state that is also reachable via alternative 1 is by nesting calls
// to the left-recursive rule, with the outer calls not being at the
// preferred precedence level.</li>
// </ul>
// </li>
// </ol>
//
// <p>
// The prediction context must be considered by this filter to address
// situations like the following.
// </p>
// <code>
// <pre>
// grammar TA;
// prog: statement* EOF;
// statement: letterA | statement letterA 'b' ;
// letterA: 'a';
// </pre>
// </code>
// <p>
// If the above grammar, the ATN state immediately before the token
// reference {@code 'a'} in {@code letterA} is reachable from the left edge
// of both the primary and closure blocks of the left-recursive rule
// {@code statement}. The prediction context associated with each of these
// configurations distinguishes between them, and prevents the alternative
// which stepped out to {@code prog} (and then back in to {@code statement}
// from being eliminated by the filter.
// </p>
//
// @param configs The configuration set computed by
// {@link //computeStartState} as the start state for the DFA.
// @return The transformed configuration set representing the start state
// for a precedence DFA at a particular precedence level (determined by
// calling {@link Parser//getPrecedence}).
//
ParserATNSimulator.prototype.applyPrecedenceFilter = function(configs) {
	var config;
	var statesFromAlt1 = [];
    var configSet = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        // handle alt 1 first
        if (config.alt !== 1) {
            continue;
        }
        var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
        if (updatedContext===null) {
            // the configuration was eliminated
            continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
            configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);
        } else {
            configSet.add(config, this.mergeCache);
        }
    }
    for(i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt === 1) {
            // already handled
            continue;
        }
        // In the future, this elimination step could be updated to also
        // filter the prediction context for alternatives predicting alt>1
        // (basically a graph subtraction algorithm).
		if (!config.precedenceFilterSuppressed) {
            var context = statesFromAlt1[config.state.stateNumber] || null;
            if (context!==null && context.equals(config.context)) {
                // eliminated
                continue;
            }
		}
        configSet.add(config, this.mergeCache);
    }
    return configSet;
};

ParserATNSimulator.prototype.getReachableTarget = function(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
    } else {
        return null;
    }
};

ParserATNSimulator.prototype.getPredsForAmbigAlts = function(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    var altToPred = [];
    for(var i=0;i<configs.items.length;i++) {
        var c = configs.items[i];
        if(ambigAlts.contains( c.alt )) {
            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
        }
    }
    var nPredAlts = 0;
    for (i =1;i< nalts+1;i++) {
        var pred = altToPred[i] || null;
        if (pred===null) {
            altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
            nPredAlts += 1;
        }
    }
    // nonambig alts are null in altToPred
    if (nPredAlts===0) {
        altToPred = null;
    }
    if (this.debug) {
        console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }
    return altToPred;
};

ParserATNSimulator.prototype.getPredicatePredictions = function(ambigAlts, altToPred) {
    var pairs = [];
    var containsPredicate = false;
    for (var i=1; i<altToPred.length;i++) {
        var pred = altToPred[i];
        // unpredicated is indicated by SemanticContext.NONE
        if( ambigAlts!==null && ambigAlts.contains( i )) {
            pairs.push(new PredPrediction(pred, i));
        }
        if (pred !== SemanticContext.NONE) {
            containsPredicate = true;
        }
    }
    if (! containsPredicate) {
        return null;
    }
    return pairs;
};

//
// This method is used to improve the localization of error messages by
// choosing an alternative rather than throwing a
// {@link NoViableAltException} in particular prediction scenarios where the
// {@link //ERROR} state was reached during ATN simulation.
//
// <p>
// The default implementation of this method uses the following
// algorithm to identify an ATN configuration which successfully parsed the
// decision entry rule. Choosing such an alternative ensures that the
// {@link ParserRuleContext} returned by the calling rule will be complete
// and valid, and the syntax error will be reported later at a more
// localized location.</p>
//
// <ul>
// <li>If a syntactically valid path or paths reach the end of the decision rule and
// they are semantically valid if predicated, return the min associated alt.</li>
// <li>Else, if a semantically invalid but syntactically valid path exist
// or paths exist, return the minimum associated alt.
// </li>
// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
// </ul>
//
// <p>
// In some scenarios, the algorithm described above could predict an
// alternative which will result in a {@link FailedPredicateException} in
// the parser. Specifically, this could occur if the <em>only</em> configuration
// capable of successfully parsing to the end of the decision rule is
// blocked by a semantic predicate. By choosing this alternative within
// {@link //adaptivePredict} instead of throwing a
// {@link NoViableAltException}, the resulting
// {@link FailedPredicateException} in the parser will identify the specific
// predicate which is preventing the parser from successfully parsing the
// decision rule, which helps developers identify and correct logic errors
// in semantic predicates.
// </p>
//
// @param configs The ATN configurations which were valid immediately before
// the {@link //ERROR} state was reached
// @param outerContext The is the \gamma_0 initial parser context from the paper
// or the parser stack at the instant before prediction commences.
//
// @return The value to return from {@link //adaptivePredict}, or
// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
// identified and {@link //adaptivePredict} should report an error instead.
//
ParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function(configs, outerContext) {
    var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    var semValidConfigs = cfgs[0];
    var semInvalidConfigs = cfgs[1];
    var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
        return alt;
    }
    // Is there a syntactically valid path with a failed pred?
    if (semInvalidConfigs.items.length>0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists
            return alt;
        }
    }
    return ATN.INVALID_ALT_NUMBER;
};

ParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function(configs) {
    var alts = [];
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {
            if(alts.indexOf(c.alt)<0) {
                alts.push(c.alt);
            }
        }
    }
    if (alts.length===0) {
        return ATN.INVALID_ALT_NUMBER;
    } else {
        return Math.min.apply(null, alts);
    }
};
// Walk the list of configurations and split them according to
//  those that have preds evaluating to true/false.  If no pred, assume
//  true pred and include in succeeded set.  Returns Pair of sets.
//
//  Create a new set so as not to alter the incoming parameter.
//
//  Assumption: the input stream has been restored to the starting point
//  prediction, which is where predicates need to evaluate.
//
ParserATNSimulator.prototype.splitAccordingToSemanticValidity = function( configs, outerContext) {
    var succeeded = new ATNConfigSet(configs.fullCtx);
    var failed = new ATNConfigSet(configs.fullCtx);
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.semanticContext !== SemanticContext.NONE) {
            var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
            if (predicateEvaluationResult) {
                succeeded.add(c);
            } else {
                failed.add(c);
            }
        } else {
            succeeded.add(c);
        }
    }
    return [succeeded, failed];
};

// Look through a list of predicate/alt pairs, returning alts for the
//  pairs that win. A {@code NONE} predicate indicates an alt containing an
//  unpredicated config which behaves as "always true." If !complete
//  then we stop at the first predicate that evaluates to true. This
//  includes pairs with null predicates.
//
ParserATNSimulator.prototype.evalSemanticContext = function(predPredictions, outerContext, complete) {
    var predictions = new BitSet();
    for(var i=0;i<predPredictions.length;i++) {
    	var pair = predPredictions[i];
        if (pair.pred === SemanticContext.NONE) {
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
            continue;
        }
        var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (this.debug || this.dfa_debug) {
            console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
            if (this.debug || this.dfa_debug) {
                console.log("PREDICT " + pair.alt);
            }
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
        }
    }
    return predictions;
};

// TODO: If we are doing predicates, there is no point in pursuing
//     closure operations if we reach a DFA state that uniquely predicts
//     alternative. We will not be caching that DFA state and it is a
//     waste to pursue the closure. Might have to advance when we do
//     ambig detection thought :(
//

ParserATNSimulator.prototype.closure = function(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    var initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,
                             fullCtx, initialDepth, treatEofAsEpsilon);
};


ParserATNSimulator.prototype.closureCheckingStopState = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
        console.log("closure(" + config.toString(this.parser,true) + ")");
        // console.log("configs(" + configs.toString() + ")");
        if(config.reachesIntoOuterContext>50) {
            throw "problem";
        }
    }
    if (config.state instanceof RuleStopState) {
        // We hit rule end. If we have context info, use it
        // run thru all possible stack tops in ctx
        if (! config.context.isEmpty()) {
            for ( var i =0; i<config.context.length; i++) {
                if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                    if (fullCtx) {
                        configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);
                        continue;
                    } else {
                        // we have no context info, just chase follow links (if greedy)
                        if (this.debug) {
                            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                        }
                        this.closure_(config, configs, closureBusy, collectPredicates,
                                 fullCtx, depth, treatEofAsEpsilon);
                    }
                    continue;
                }
                var returnState = this.atn.states[config.context.getReturnState(i)];
                var newContext = config.context.getParent(i); // "pop" return state
                var parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};
                var c = new ATNConfig(parms, null);
                // While we have context to pop back from, we may have
                // gotten that context AFTER having falling off a rule.
                // Make sure we track that we are now out of context.
                c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
            }
            return;
        } else if( fullCtx) {
            // reached end of start rule
            configs.add(config, this.mergeCache);
            return;
        } else {
            // else if we have no context info, just chase follow links (if greedy)
            if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
        }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
};


// Do the actual work of walking epsilon edges//
ParserATNSimulator.prototype.closure_ = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    var p = config.state;
    // optimization
    if (! p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
        // make sure to not return here, because EOF transitions can act as
        // both epsilon transitions and non-epsilon transitions.
    }
    for(var i = 0;i<p.transitions.length; i++) {
        if(i==0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
            continue;

        var t = p.transitions[i];
        var continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c!==null) {
			if (!t.isEpsilon && closureBusy.add(c)!==c){
				// avoid infinite recursion for EOF* and EOF+
				continue;
			}
            var newDepth = depth;
            if ( config.state instanceof RuleStopState) {
                // target fell off end of rule; mark resulting c as having dipped into outer context
                // We can't get here if incoming config was rule stop and we had context
                // track how far we dip into outer context.  Might
                // come in handy and we avoid evaluating context dependent
                // preds if this is > 0.

                if (closureBusy.add(c)!==c) {
                    // avoid infinite recursion for right-recursive rules
                    continue;
                }

				if (this._dfa !== null && this._dfa.precedenceDfa) {
					if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
						c.precedenceFilterSuppressed = true;
					}
				}

                c.reachesIntoOuterContext += 1;
                configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                newDepth -= 1;
                if (this.debug) {
                    console.log("dips into outer ctx: " + c);
                }
            } else if (t instanceof RuleTransition) {
                // latch when newDepth goes negative - once we step out of the entry context we can't return
                if (newDepth >= 0) {
                    newDepth += 1;
                }
            }
            this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
        }
    }
};


ParserATNSimulator.prototype.canDropLoopEntryEdgeInLeftRecursiveRule = function(config) {
    // return False
    var p = config.state;
    // First check to see if we are in StarLoopEntryState generated during
    // left-recursion elimination. For efficiency, also check if
    // the context has an empty stack case. If so, it would mean
    // global FOLLOW so we can't perform optimization
    // Are we the special loop entry/exit state? or SLL wildcard
    if(p.stateType != ATNState.STAR_LOOP_ENTRY)
        return false;
    if(p.stateType != ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||
           config.context.isEmpty() || config.context.hasEmptyPath())
        return false;

    // Require all return states to return back to the same rule that p is in.
    var numCtxs = config.context.length;
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnState = this.atn.states[config.context.getReturnState(i)];
        if (returnState.ruleIndex != p.ruleIndex)
            return false;
    }

    var decisionStartState = p.transitions[0].target;
    var blockEndStateNum = decisionStartState.endState.stateNumber;
    var blockEndState = this.atn.states[blockEndStateNum];

    // Verify that the top of each stack context leads to loop entry/exit
    // state through epsilon edges and w/o leaving rule.
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnStateNumber = config.context.getReturnState(i);
        var returnState = this.atn.states[returnStateNumber];
        // all states must have single outgoing epsilon edge
        if (returnState.transitions.length != 1 || !returnState.transitions[0].isEpsilon)
            return false;

        // Look for prefix op case like 'not expr', (' type ')' expr
        var returnStateTarget = returnState.transitions[0].target;
        if ( returnState.stateType == ATNState.BLOCK_END && returnStateTarget == p )
            continue;

        // Look for 'expr op expr' or case where expr's return state is block end
        // of (...)* internal block; the block end points to loop back
        // which points to p but we don't need to check that
        if ( returnState == blockEndState )
            continue;

        // Look for ternary expr ? expr : expr. The return state points at block end,
        // which points at loop entry state
        if ( returnStateTarget == blockEndState )
            continue;

        // Look for complex prefix 'between expr and expr' case where 2nd expr's
        // return state points at block end state of (...)* internal block
        if (returnStateTarget.stateType == ATNState.BLOCK_END && returnStateTarget.transitions.length == 1
                && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target == p)
            continue;

        // anything else ain't conforming
        return false;
    }
    return true;
};


ParserATNSimulator.prototype.getRuleName = function( index) {
    if (this.parser!==null && index>=0) {
        return this.parser.ruleNames[index];
    } else {
        return "<rule " + index + ">";
    }
};

ParserATNSimulator.prototype.getEpsilonTarget = function(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch(t.serializationType) {
    case Transition.RULE:
        return this.ruleTransition(config, t);
    case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.ACTION:
        return this.actionTransition(config, t);
    case Transition.EPSILON:
        return new ATNConfig({state:t.target}, config);
    case Transition.ATOM:
    case Transition.RANGE:
    case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
            if (t.matches(Token.EOF, 0, 1)) {
                return new ATNConfig({state: t.target}, config);
            }
        }
        return null;
    default:
    	return null;
    }
};

ParserATNSimulator.prototype.actionTransition = function(config, t) {
    if (this.debug) {
        var index = t.actionIndex==-1 ? 65535 : t.actionIndex;
        console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }
    return new ATNConfig({state:t.target}, config);
};

ParserATNSimulator.prototype.precedenceTransition = function(config, pt,  collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser!==null) {
        	console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && inContext) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.predTransition = function(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser!==null) {
            console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.ruleTransition = function(config, t) {
    if (this.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    var returnState = t.followState;
    var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({state:t.target, context:newContext}, config );
};

ParserATNSimulator.prototype.getConflictingAlts = function(configs) {
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
};

 // Sam pointed out a problem with the previous definition, v3, of
 // ambiguous states. If we have another state associated with conflicting
 // alternatives, we should keep going. For example, the following grammar
 //
 // s : (ID | ID ID?) ';' ;
 //
 // When the ATN simulation reaches the state before ';', it has a DFA
 // state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
 // 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
 // because alternative to has another way to continue, via [6|2|[]].
 // The key is that we have a single state that has config's only associated
 // with a single alternative, 2, and crucially the state transitions
 // among the configurations are all non-epsilon transitions. That means
 // we don't consider any conflicts that include alternative 2. So, we
 // ignore the conflict between alts 1 and 2. We ignore a set of
 // conflicting alts when there is an intersection with an alternative
 // associated with a single alt state in the state&rarr;config-list map.
 //
 // It's also the case that we might have two conflicting configurations but
 // also a 3rd nonconflicting configuration for a different alternative:
 // [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
 //
 // a : A | A | A B ;
 //
 // After matching input A, we reach the stop state for rule A, state 1.
 // State 8 is the state right before B. Clearly alternatives 1 and 2
 // conflict and no amount of further lookahead will separate the two.
 // However, alternative 3 will be able to continue and so we do not
 // stop working on this state. In the previous example, we're concerned
 // with states associated with the conflicting alternatives. Here alt
 // 3 is not associated with the conflicting configs, but since we can continue
 // looking for input reasonably, I don't declare the state done. We
 // ignore a set of conflicting alts when we have an alternative
 // that we still need to pursue.
//

ParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function(configs) {
    var conflictingAlts = null;
    if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.add(configs.uniqueAlt);
    } else {
        conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
};

ParserATNSimulator.prototype.getTokenName = function( t) {
    if (t===Token.EOF) {
        return "EOF";
    }
    if( this.parser!==null && this.parser.literalNames!==null) {
        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
            console.log("" + t + " ttype out of range: " + this.parser.literalNames);
            console.log("" + this.parser.getInputStream().getTokens());
        } else {
            var name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
            return name + "<" + t + ">";
        }
    }
    return "" + t;
};

ParserATNSimulator.prototype.getLookaheadName = function(input) {
    return this.getTokenName(input.LA(1));
};

// Used for debugging in adaptivePredict around execATN but I cut
//  it out for clarity now that alg. works well. We can leave this
//  "dead" code for a bit.
//
ParserATNSimulator.prototype.dumpDeadEndConfigs = function(nvae) {
    console.log("dead end configs: ");
    var decs = nvae.getDeadEndConfigs();
    for(var i=0; i<decs.length; i++) {
    	var c = decs[i];
        var trans = "no edges";
        if (c.state.transitions.length>0) {
            var t = c.state.transitions[0];
            if (t instanceof AtomTransition) {
                trans = "Atom "+ this.getTokenName(t.label);
            } else if (t instanceof SetTransition) {
                var neg = (t instanceof NotSetTransition);
                trans = (neg ? "~" : "") + "Set " + t.set;
            }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
    }
};

ParserATNSimulator.prototype.noViableAlt = function(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
};

ParserATNSimulator.prototype.getUniqueAlt = function(configs) {
    var alt = ATN.INVALID_ALT_NUMBER;
    for(var i=0;i<configs.items.length;i++) {
    	var c = configs.items[i];
        if (alt === ATN.INVALID_ALT_NUMBER) {
            alt = c.alt // found first alt
        } else if( c.alt!==alt) {
            return ATN.INVALID_ALT_NUMBER;
        }
    }
    return alt;
};

//
// Add an edge to the DFA, if possible. This method calls
// {@link //addDFAState} to ensure the {@code to} state is present in the
// DFA. If {@code from} is {@code null}, or if {@code t} is outside the
// range of edges that can be represented in the DFA tables, this method
// returns without adding the edge to the DFA.
//
// <p>If {@code to} is {@code null}, this method returns {@code null}.
// Otherwise, this method returns the {@link DFAState} returned by calling
// {@link //addDFAState} for the {@code to} state.</p>
//
// @param dfa The DFA
// @param from The source state for the edge
// @param t The input symbol
// @param to The target state for the edge
//
// @return If {@code to} is {@code null}, this method returns {@code null};
// otherwise this method returns the result of calling {@link //addDFAState}
// on {@code to}
//
ParserATNSimulator.prototype.addDFAEdge = function(dfa, from_, t, to) {
    if( this.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to===null) {
        return null;
    }
    to = this.addDFAState(dfa, to); // used existing if possible not incoming
    if (from_===null || t < -1 || t > this.atn.maxTokenType) {
        return to;
    }
    if (from_.edges===null) {
        from_.edges = [];
    }
    from_.edges[t+1] = to; // connect

    if (this.debug) {
        var literalNames = this.parser===null ? null : this.parser.literalNames;
        var symbolicNames = this.parser===null ? null : this.parser.symbolicNames;
        console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
};
//
// Add state {@code D} to the DFA if it is not already present, and return
// the actual instance stored in the DFA. If a state equivalent to {@code D}
// is already in the DFA, the existing state is returned. Otherwise this
// method returns {@code D} after adding it to the DFA.
//
// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
// does not change the DFA.</p>
//
// @param dfa The dfa
// @param D The DFA state to add
// @return The state stored in the DFA. This will be either the existing
// state if {@code D} is already in the DFA, or {@code D} itself if the
// state was not already present.
//
ParserATNSimulator.prototype.addDFAState = function(dfa, D) {
    if (D == ATNSimulator.ERROR) {
        return D;
    }
    var existing = dfa.states.get(D);
    if(existing!==null) {
        return existing;
    }
    D.stateNumber = dfa.states.length;
    if (! D.configs.readOnly) {
        D.configs.optimizeConfigs(this);
        D.configs.setReadonly(true);
    }
    dfa.states.add(D);
    if (this.debug) {
        console.log("adding new DFA state: " + D);
    }
    return D;
};

ParserATNSimulator.prototype.reportAttemptingFullContext = function(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
};

ParserATNSimulator.prototype.reportContextSensitivity = function(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
};

// If context sensitive parsing, we know it's ambiguity not conflict//
ParserATNSimulator.prototype.reportAmbiguity = function(dfa, D, startIndex, stopIndex,
                               exact, ambigAlts, configs ) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
};

exports.ParserATNSimulator = ParserATNSimulator;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.DFA = __webpack_require__(118).DFA;
exports.DFASerializer = __webpack_require__(29).DFASerializer;
exports.LexerDFASerializer = __webpack_require__(29).LexerDFASerializer;
exports.PredPrediction = __webpack_require__(17).PredPrediction;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Set = __webpack_require__(0).Set;
var DFAState = __webpack_require__(17).DFAState;
var StarLoopEntryState = __webpack_require__(7).StarLoopEntryState;
var ATNConfigSet = __webpack_require__(15).ATNConfigSet;
var DFASerializer = __webpack_require__(29).DFASerializer;
var LexerDFASerializer = __webpack_require__(29).LexerDFASerializer;



function DFA(atnStartState, decision) {
	if (decision === undefined) {
		decision = 0;
	}
	// From which ATN state did we create this DFA?
	this.atnStartState = atnStartState;
	this.decision = decision;
	// A set of all DFA states. Use {@link Map} so we can get old state back
	// ({@link Set} only allows you to see if it's there).
	this._states = new Set();
	this.s0 = null;
	// {@code true} if this DFA is for a precedence decision; otherwise,
	// {@code false}. This is the backing field for {@link //isPrecedenceDfa},
	// {@link //setPrecedenceDfa}.
	this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState)
    {
        if (atnStartState.isPrecedenceDecision) {
            this.precedenceDfa = true;
            var precedenceState = new DFAState(null, new ATNConfigSet());
            precedenceState.edges = [];
            precedenceState.isAcceptState = false;
            precedenceState.requiresFullContext = false;
            this.s0 = precedenceState;
        }
    }
	return this;
}

// Get the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @return The start state corresponding to the specified precedence, or
// {@code null} if no start state exists for the specified precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()

DFA.prototype.getPrecedenceStartState = function(precedence) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	// s0.edges is never null for a precedence DFA
	if (precedence < 0 || precedence >= this.s0.edges.length) {
		return null;
	}
	return this.s0.edges[precedence] || null;
};

// Set the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @param startState The start state corresponding to the specified
// precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()
//
DFA.prototype.setPrecedenceStartState = function(precedence, startState) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	if (precedence < 0) {
		return;
	}

	// synchronization on s0 here is ok. when the DFA is turned into a
	// precedence DFA, s0 will be initialized once and not updated again
	// s0.edges is never null for a precedence DFA
	this.s0.edges[precedence] = startState;
};

//
// Sets whether this is a precedence DFA. If the specified value differs
// from the current DFA configuration, the following actions are taken;
// otherwise no changes are made to the current DFA.
//
// <ul>
// <li>The {@link //states} map is cleared</li>
// <li>If {@code precedenceDfa} is {@code false}, the initial state
// {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
// {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
// store the start states for individual precedence values.</li>
// <li>The {@link //precedenceDfa} field is updated</li>
// </ul>
//
// @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
// {@code false}

DFA.prototype.setPrecedenceDfa = function(precedenceDfa) {
	if (this.precedenceDfa!==precedenceDfa) {
		this._states = new DFAStatesSet();
		if (precedenceDfa) {
			var precedenceState = new DFAState(null, new ATNConfigSet());
			precedenceState.edges = [];
			precedenceState.isAcceptState = false;
			precedenceState.requiresFullContext = false;
			this.s0 = precedenceState;
		} else {
			this.s0 = null;
		}
		this.precedenceDfa = precedenceDfa;
	}
};

Object.defineProperty(DFA.prototype, "states", {
	get : function() {
		return this._states;
	}
});

// Return a list of all states in this DFA, ordered by state number.
DFA.prototype.sortedStates = function() {
	var list = this._states.values();
	return list.sort(function(a, b) {
		return a.stateNumber - b.stateNumber;
	});
};

DFA.prototype.toString = function(literalNames, symbolicNames) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	if (this.s0 === null) {
		return "";
	}
	var serializer = new DFASerializer(this, literalNames, symbolicNames);
	return serializer.toString();
};

DFA.prototype.toLexerString = function() {
	if (this.s0 === null) {
		return "";
	}
	var serializer = new LexerDFASerializer(this);
	return serializer.toString();
};

exports.DFA = DFA;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Tree = __webpack_require__(5);
exports.Trees = __webpack_require__(59).Trees;
exports.RuleNode = Tree.RuleNode;
exports.ParseTreeListener = Tree.ParseTreeListener;
exports.ParseTreeVisitor = Tree.ParseTreeVisitor;
exports.ParseTreeWalker = Tree.ParseTreeWalker;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.RecognitionException = __webpack_require__(8).RecognitionException;
exports.NoViableAltException = __webpack_require__(8).NoViableAltException;
exports.LexerNoViableAltException = __webpack_require__(8).LexerNoViableAltException;
exports.InputMismatchException = __webpack_require__(8).InputMismatchException;
exports.FailedPredicateException = __webpack_require__(8).FailedPredicateException;
exports.DiagnosticErrorListener = __webpack_require__(121).DiagnosticErrorListener;
exports.BailErrorStrategy = __webpack_require__(68).BailErrorStrategy;
exports.ErrorListener = __webpack_require__(28).ErrorListener;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This implementation of {@link ANTLRErrorListener} can be used to identify
// certain potential correctness and performance problems in grammars. "Reports"
// are made by calling {@link Parser//notifyErrorListeners} with the appropriate
// message.
//
// <ul>
// <li><b>Ambiguities</b>: These are cases where more than one path through the
// grammar can match the input.</li>
// <li><b>Weak context sensitivity</b>: These are cases where full-context
// prediction resolved an SLL conflict to a unique alternative which equaled the
// minimum alternative of the SLL conflict.</li>
// <li><b>Strong (forced) context sensitivity</b>: These are cases where the
// full-context prediction resolved an SLL conflict to a unique alternative,
// <em>and</em> the minimum alternative of the SLL conflict was found to not be
// a truly viable alternative. Two-stage parsing cannot be used for inputs where
// this situation occurs.</li>
// </ul>

var BitSet = __webpack_require__(0).BitSet;
var ErrorListener = __webpack_require__(28).ErrorListener;
var Interval = __webpack_require__(2).Interval;

function DiagnosticErrorListener(exactOnly) {
	ErrorListener.call(this);
	exactOnly = exactOnly || true;
	// whether all ambiguities or only exact ambiguities are reported.
	this.exactOnly = exactOnly;
	return this;
}

DiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);
DiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;

DiagnosticErrorListener.prototype.reportAmbiguity = function(recognizer, dfa,
		startIndex, stopIndex, exact, ambigAlts, configs) {
	if (this.exactOnly && !exact) {
		return;
	}
	var msg = "reportAmbiguity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			": ambigAlts=" +
			this.getConflictingAlts(ambigAlts, configs) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportAttemptingFullContext = function(
		recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	var msg = "reportAttemptingFullContext d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportContextSensitivity = function(
		recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	var msg = "reportContextSensitivity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.getDecisionDescription = function(recognizer, dfa) {
	var decision = dfa.decision;
	var ruleIndex = dfa.atnStartState.ruleIndex;

	var ruleNames = recognizer.ruleNames;
	if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
		return "" + decision;
	}
	var ruleName = ruleNames[ruleIndex] || null;
	if (ruleName === null || ruleName.length === 0) {
		return "" + decision;
	}
	return "" + decision + " (" + ruleName + ")";
};

//
// Computes the set of conflicting or ambiguous alternatives from a
// configuration set, if that information was not already provided by the
// parser.
//
// @param reportedAlts The set of conflicting or ambiguous alternatives, as
// reported by the parser.
// @param configs The conflicting or ambiguous configuration set.
// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
// returns the set of alternatives represented in {@code configs}.
//
DiagnosticErrorListener.prototype.getConflictingAlts = function(reportedAlts, configs) {
	if (reportedAlts !== null) {
		return reportedAlts;
	}
	var result = new BitSet();
	for (var i = 0; i < configs.items.length; i++) {
		result.add(configs.items[i].alt);
	}
	return "{" + result.values().join(", ") + "}";
};

exports.DiagnosticErrorListener = DiagnosticErrorListener;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var InputStream = __webpack_require__(35).InputStream;

var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? __webpack_require__(36) : null;

// Utility functions to create InputStreams from various sources.
//
// All returned InputStreams support the full range of Unicode
// up to U+10FFFF (the default behavior of InputStream only supports
// code points up to U+FFFF).
var CharStreams = {
  // Creates an InputStream from a string.
  fromString: function(str) {
    return new InputStream(str, true);
  },

  // Asynchronously creates an InputStream from a blob given the
  // encoding of the bytes in that blob (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes onLoad(result) on success, onError(error) on
  // failure.
  fromBlob: function(blob, encoding, onLoad, onError) {
    var reader = FileReader();
    reader.onload = function(e) {
      var is = new InputStream(e.target.result, true);
      onLoad(is);
    };
    reader.onerror = onError;
    reader.readAsText(blob, encoding);
  },

  // Creates an InputStream from a Buffer given the
  // encoding of the bytes in that buffer (defaults to 'utf8' if
  // encoding is null).
  fromBuffer: function(buffer, encoding) {
    return new InputStream(buffer.toString(encoding), true);
  },

  // Asynchronously creates an InputStream from a file on disk given
  // the encoding of the bytes in that file (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes callback(error, result) on completion.
  fromPath: function(path, encoding, callback) {
    fs.readFile(path, encoding, function(err, data) {
      var is = null;
      if (data !== null) {
        is = new InputStream(data, true);
      }
      callback(err, is);
    });
  },

  // Synchronously creates an InputStream given a path to a file
  // on disk and the encoding of the bytes in that file (defaults to
  // 'utf8' if encoding is null).
  fromPathSync: function(path, encoding) {
    var data = fs.readFileSync(path, encoding);
    return new InputStream(data, true);
  }
};

exports.CharStreams = CharStreams;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
//  This is an InputStream that is loaded from a file all at once
//  when you construct the object.
//
var InputStream = __webpack_require__(35).InputStream;
var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? __webpack_require__(36) : null;

function FileStream(fileName, decodeToUnicodeCodePoints) {
	var data = fs.readFileSync(fileName, "utf8");
	InputStream.call(this, data, decodeToUnicodeCodePoints);
	this.fileName = fileName;
	return this;
}

FileStream.prototype = Object.create(InputStream.prototype);
FileStream.prototype.constructor = FileStream;

exports.FileStream = FileStream;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//
// This class extends {@link BufferedTokenStream} with functionality to filter
// token streams to tokens on a particular channel (tokens where
// {@link Token//getChannel} returns a particular value).
//
// <p>
// This token stream provides access to all tokens by index or when calling
// methods like {@link //getText}. The channel filtering is only used for code
// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
// {@link //LB}.</p>
//
// <p>
// By default, tokens are placed on the default channel
// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
// call {@link Lexer//setChannel}.
// </p>
//
// <p>
// Note: lexer rules which use the {@code ->skip} lexer command or call
// {@link Lexer//skip} do not produce tokens at all, so input text matched by
// such a rule will not be available as part of the token stream, regardless of
// channel.</p>
///

var Token = __webpack_require__(1).Token;
var BufferedTokenStream = __webpack_require__(125).BufferedTokenStream;

function CommonTokenStream(lexer, channel) {
	BufferedTokenStream.call(this, lexer);
    this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;
    return this;
}

CommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);
CommonTokenStream.prototype.constructor = CommonTokenStream;

CommonTokenStream.prototype.adjustSeekIndex = function(i) {
    return this.nextTokenOnChannel(i, this.channel);
};

CommonTokenStream.prototype.LB = function(k) {
    if (k===0 || this.index-k<0) {
        return null;
    }
    var i = this.index;
    var n = 1;
    // find k good tokens looking backwards
    while (n <= k) {
        // skip off-channel tokens
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n += 1;
    }
    if (i < 0) {
        return null;
    }
    return this.tokens[i];
};

CommonTokenStream.prototype.LT = function(k) {
    this.lazyInit();
    if (k === 0) {
        return null;
    }
    if (k < 0) {
        return this.LB(-k);
    }
    var i = this.index;
    var n = 1; // we know tokens[pos] is a good one
    // find k good tokens
    while (n < k) {
        // skip off-channel tokens, but make sure to not look past EOF
        if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n += 1;
    }
    return this.tokens[i];
};

// Count EOF just once.///
CommonTokenStream.prototype.getNumberOfOnChannelTokens = function() {
    var n = 0;
    this.fill();
    for (var i =0; i< this.tokens.length;i++) {
        var t = this.tokens[i];
        if( t.channel===this.channel) {
            n += 1;
        }
        if( t.type===Token.EOF) {
            break;
        }
    }
    return n;
};

exports.CommonTokenStream = CommonTokenStream;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// This implementation of {@link TokenStream} loads tokens from a
// {@link TokenSource} on-demand, and places the tokens in a buffer to provide
// access to any previous token by index.
//
// <p>
// This token stream ignores the value of {@link Token//getChannel}. If your
// parser requires the token stream filter tokens to only those on a particular
// channel, such as {@link Token//DEFAULT_CHANNEL} or
// {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
// {@link CommonTokenStream}.</p>

var Token = __webpack_require__(1).Token;
var Lexer = __webpack_require__(27).Lexer;
var Interval = __webpack_require__(2).Interval;

// this is just to keep meaningful parameter types to Parser
function TokenStream() {
	return this;
}

function BufferedTokenStream(tokenSource) {

	TokenStream.call(this);
	// The {@link TokenSource} from which tokens for this stream are fetched.
	this.tokenSource = tokenSource;

	// A collection of all tokens fetched from the token source. The list is
	// considered a complete view of the input once {@link //fetchedEOF} is set
	// to {@code true}.
	this.tokens = [];

	// The index into {@link //tokens} of the current token (next token to
	// {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
	// be
	// {@link //LT LT(1)}.
	//
	// <p>This field is set to -1 when the stream is first constructed or when
	// {@link //setTokenSource} is called, indicating that the first token has
	// not yet been fetched from the token source. For additional information,
	// see the documentation of {@link IntStream} for a description of
	// Initializing Methods.</p>
	this.index = -1;

	// Indicates whether the {@link Token//EOF} token has been fetched from
	// {@link //tokenSource} and added to {@link //tokens}. This field improves
	// performance for the following cases:
	//
	// <ul>
	// <li>{@link //consume}: The lookahead check in {@link //consume} to
	// prevent
	// consuming the EOF symbol is optimized by checking the values of
	// {@link //fetchedEOF} and {@link //p} instead of calling {@link
	// //LA}.</li>
	// <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
	// into
	// {@link //tokens} is trivial with this field.</li>
	// <ul>
	this.fetchedEOF = false;
	return this;
}

BufferedTokenStream.prototype = Object.create(TokenStream.prototype);
BufferedTokenStream.prototype.constructor = BufferedTokenStream;

BufferedTokenStream.prototype.mark = function() {
	return 0;
};

BufferedTokenStream.prototype.release = function(marker) {
	// no resources to release
};

BufferedTokenStream.prototype.reset = function() {
	this.seek(0);
};

BufferedTokenStream.prototype.seek = function(index) {
	this.lazyInit();
	this.index = this.adjustSeekIndex(index);
};

BufferedTokenStream.prototype.get = function(index) {
	this.lazyInit();
	return this.tokens[index];
};

BufferedTokenStream.prototype.consume = function() {
	var skipEofCheck = false;
	if (this.index >= 0) {
		if (this.fetchedEOF) {
			// the last token in tokens is EOF. skip check if p indexes any
			// fetched token except the last.
			skipEofCheck = this.index < this.tokens.length - 1;
		} else {
			// no EOF token in tokens. skip check if p indexes a fetched token.
			skipEofCheck = this.index < this.tokens.length;
		}
	} else {
		// not yet initialized
		skipEofCheck = false;
	}
	if (!skipEofCheck && this.LA(1) === Token.EOF) {
		throw "cannot consume EOF";
	}
	if (this.sync(this.index + 1)) {
		this.index = this.adjustSeekIndex(this.index + 1);
	}
};

// Make sure index {@code i} in tokens has a token.
//
// @return {@code true} if a token is located at index {@code i}, otherwise
// {@code false}.
// @see //get(int i)
// /
BufferedTokenStream.prototype.sync = function(i) {
	var n = i - this.tokens.length + 1; // how many more elements we need?
	if (n > 0) {
		var fetched = this.fetch(n);
		return fetched >= n;
	}
	return true;
};

// Add {@code n} elements to buffer.
//
// @return The actual number of elements added to the buffer.
// /
BufferedTokenStream.prototype.fetch = function(n) {
	if (this.fetchedEOF) {
		return 0;
	}
	for (var i = 0; i < n; i++) {
		var t = this.tokenSource.nextToken();
		t.tokenIndex = this.tokens.length;
		this.tokens.push(t);
		if (t.type === Token.EOF) {
			this.fetchedEOF = true;
			return i + 1;
		}
	}
	return n;
};

// Get all tokens from start..stop inclusively///
BufferedTokenStream.prototype.getTokens = function(start, stop, types) {
	if (types === undefined) {
		types = null;
	}
	if (start < 0 || stop < 0) {
		return null;
	}
	this.lazyInit();
	var subset = [];
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	for (var i = start; i < stop; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		if (types === null || types.contains(t.type)) {
			subset.push(t);
		}
	}
	return subset;
};

BufferedTokenStream.prototype.LA = function(i) {
	return this.LT(i).type;
};

BufferedTokenStream.prototype.LB = function(k) {
	if (this.index - k < 0) {
		return null;
	}
	return this.tokens[this.index - k];
};

BufferedTokenStream.prototype.LT = function(k) {
	this.lazyInit();
	if (k === 0) {
		return null;
	}
	if (k < 0) {
		return this.LB(-k);
	}
	var i = this.index + k - 1;
	this.sync(i);
	if (i >= this.tokens.length) { // return EOF token
		// EOF must be last token
		return this.tokens[this.tokens.length - 1];
	}
	return this.tokens[i];
};

// Allowed derived classes to modify the behavior of operations which change
// the current stream position by adjusting the target token index of a seek
// operation. The default implementation simply returns {@code i}. If an
// exception is thrown in this method, the current stream index should not be
// changed.
//
// <p>For example, {@link CommonTokenStream} overrides this method to ensure
// that
// the seek target is always an on-channel token.</p>
//
// @param i The target token index.
// @return The adjusted target token index.

BufferedTokenStream.prototype.adjustSeekIndex = function(i) {
	return i;
};

BufferedTokenStream.prototype.lazyInit = function() {
	if (this.index === -1) {
		this.setup();
	}
};

BufferedTokenStream.prototype.setup = function() {
	this.sync(0);
	this.index = this.adjustSeekIndex(0);
};

// Reset this token stream by setting its token source.///
BufferedTokenStream.prototype.setTokenSource = function(tokenSource) {
	this.tokenSource = tokenSource;
	this.tokens = [];
	this.index = -1;
	this.fetchedEOF = false;
};


// Given a starting index, return the index of the next token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and EOF.
// /
BufferedTokenStream.prototype.nextTokenOnChannel = function(i, channel) {
	this.sync(i);
	if (i >= this.tokens.length) {
		return -1;
	}
	var token = this.tokens[i];
	while (token.channel !== this.channel) {
		if (token.type === Token.EOF) {
			return -1;
		}
		i += 1;
		this.sync(i);
		token = this.tokens[i];
	}
	return i;
};

// Given a starting index, return the index of the previous token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and 0.
BufferedTokenStream.prototype.previousTokenOnChannel = function(i, channel) {
	while (i >= 0 && this.tokens[i].channel !== channel) {
		i -= 1;
	}
	return i;
};

// Collect all tokens on specified channel to the right of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
// EOF. If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToRight = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	var from_ = tokenIndex + 1;
	// if none onchannel to right, nextOnChannel=-1 so set to = last token
	var to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
	return this.filterForChannel(from_, to, channel);
};

// Collect all tokens on specified channel to the left of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
// If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToLeft = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	if (prevOnChannel === tokenIndex - 1) {
		return null;
	}
	// if none on channel to left, prevOnChannel=-1 then from=0
	var from_ = prevOnChannel + 1;
	var to = tokenIndex - 1;
	return this.filterForChannel(from_, to, channel);
};

BufferedTokenStream.prototype.filterForChannel = function(left, right, channel) {
	var hidden = [];
	for (var i = left; i < right + 1; i++) {
		var t = this.tokens[i];
		if (channel === -1) {
			if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
				hidden.push(t);
			}
		} else if (t.channel === channel) {
			hidden.push(t);
		}
	}
	if (hidden.length === 0) {
		return null;
	}
	return hidden;
};

BufferedTokenStream.prototype.getSourceName = function() {
	return this.tokenSource.getSourceName();
};

// Get the text of all tokens in this buffer.///
BufferedTokenStream.prototype.getText = function(interval) {
	this.lazyInit();
	this.fill();
	if (interval === undefined || interval === null) {
		interval = new Interval(0, this.tokens.length - 1);
	}
	var start = interval.start;
	if (start instanceof Token) {
		start = start.tokenIndex;
	}
	var stop = interval.stop;
	if (stop instanceof Token) {
		stop = stop.tokenIndex;
	}
	if (start === null || stop === null || start < 0 || stop < 0) {
		return "";
	}
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	var s = "";
	for (var i = start; i < stop + 1; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		s = s + t.text;
	}
	return s;
};

// Get all tokens from lexer until EOF///
BufferedTokenStream.prototype.fill = function() {
	this.lazyInit();
	while (this.fetch(1000) === 1000) {
		continue;
	}
};

exports.BufferedTokenStream = BufferedTokenStream;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = __webpack_require__(1).Token;
var ParseTreeListener = __webpack_require__(5).ParseTreeListener;
var Recognizer = __webpack_require__(63).Recognizer;
var DefaultErrorStrategy = __webpack_require__(68).DefaultErrorStrategy;
var ATNDeserializer = __webpack_require__(60).ATNDeserializer;
var ATNDeserializationOptions = __webpack_require__(61).ATNDeserializationOptions;
var TerminalNode = __webpack_require__(5).TerminalNode;
var ErrorNode = __webpack_require__(5).ErrorNode;

function TraceListener(parser) {
	ParseTreeListener.call(this);
    this.parser = parser;
	return this;
}

TraceListener.prototype = Object.create(ParseTreeListener.prototype);
TraceListener.prototype.constructor = TraceListener;

TraceListener.prototype.enterEveryRule = function(ctx) {
	console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

TraceListener.prototype.visitTerminal = function( node) {
	console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
};

TraceListener.prototype.exitEveryRule = function(ctx) {
	console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

// this is all the parsing support code essentially; most of it is error
// recovery stuff.//
function Parser(input) {
	Recognizer.call(this);
	// The input stream.
	this._input = null;
	// The error handling strategy for the parser. The default value is a new
	// instance of {@link DefaultErrorStrategy}.
	this._errHandler = new DefaultErrorStrategy();
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	// The {@link ParserRuleContext} object for the currently executing rule.
	// this is always non-null during the parsing process.
	this._ctx = null;
	// Specifies whether or not the parser should construct a parse tree during
	// the parsing process. The default value is {@code true}.
	this.buildParseTrees = true;
	// When {@link //setTrace}{@code (true)} is called, a reference to the
	// {@link TraceListener} is stored here so it can be easily removed in a
	// later call to {@link //setTrace}{@code (false)}. The listener itself is
	// implemented as a parser listener so this field is not directly used by
	// other parser methods.
	this._tracer = null;
	// The list of {@link ParseTreeListener} listeners registered to receive
	// events during the parse.
	this._parseListeners = null;
	// The number of syntax errors reported during parsing. this value is
	// incremented each time {@link //notifyErrorListeners} is called.
	this._syntaxErrors = 0;
	this.setInputStream(input);
	return this;
}

Parser.prototype = Object.create(Recognizer.prototype);
Parser.prototype.contructor = Parser;

// this field maps from the serialized ATN string to the deserialized {@link
// ATN} with
// bypass alternatives.
//
// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
//
Parser.bypassAltsAtnCache = {};

// reset the parser's state//
Parser.prototype.reset = function() {
	if (this._input !== null) {
		this._input.seek(0);
	}
	this._errHandler.reset(this);
	this._ctx = null;
	this._syntaxErrors = 0;
	this.setTrace(false);
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	if (this._interp !== null) {
		this._interp.reset();
	}
};

// Match current input symbol against {@code ttype}. If the symbol type
// matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
// called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @param ttype the token type to match
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// {@code ttype} and the error strategy could not recover from the
// mismatched symbol

Parser.prototype.match = function(ttype) {
	var t = this.getCurrentToken();
	if (t.type === ttype) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this.buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};
// Match current input symbol as a wildcard. If the symbol type matches
// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
// and {@link //consume} are called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// a wildcard and the error strategy could not recover from the mismatched
// symbol

Parser.prototype.matchWildcard = function() {
	var t = this.getCurrentToken();
	if (t.type > 0) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this._buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};

Parser.prototype.getParseListeners = function() {
	return this._parseListeners || [];
};

// Registers {@code listener} to receive events during the parsing process.
//
// <p>To support output-preserving grammar transformations (including but not
// limited to left-recursion removal, automated left-factoring, and
// optimized code generation), calls to listener methods during the parse
// may differ substantially from calls made by
// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
// particular, rule entry and exit events may occur in a different order
// during the parse than after the parser. In addition, calls to certain
// rule entry methods may be omitted.</p>
//
// <p>With the following specific exceptions, calls to listener events are
// <em>deterministic</em>, i.e. for identical input the calls to listener
// methods will be the same.</p>
//
// <ul>
// <li>Alterations to the grammar used to generate code may change the
// behavior of the listener calls.</li>
// <li>Alterations to the command line options passed to ANTLR 4 when
// generating the parser may change the behavior of the listener calls.</li>
// <li>Changing the version of the ANTLR Tool used to generate the parser
// may change the behavior of the listener calls.</li>
// </ul>
//
// @param listener the listener to add
//
// @throws NullPointerException if {@code} listener is {@code null}
//
Parser.prototype.addParseListener = function(listener) {
	if (listener === null) {
		throw "listener";
	}
	if (this._parseListeners === null) {
		this._parseListeners = [];
	}
	this._parseListeners.push(listener);
};

//
// Remove {@code listener} from the list of parse listeners.
//
// <p>If {@code listener} is {@code null} or has not been added as a parse
// listener, this method does nothing.</p>
// @param listener the listener to remove
//
Parser.prototype.removeParseListener = function(listener) {
	if (this._parseListeners !== null) {
		var idx = this._parseListeners.indexOf(listener);
		if (idx >= 0) {
			this._parseListeners.splice(idx, 1);
		}
		if (this._parseListeners.length === 0) {
			this._parseListeners = null;
		}
	}
};

// Remove all parse listeners.
Parser.prototype.removeParseListeners = function() {
	this._parseListeners = null;
};

// Notify any parse listeners of an enter rule event.
Parser.prototype.triggerEnterRuleEvent = function() {
	if (this._parseListeners !== null) {
        var ctx = this._ctx;
		this._parseListeners.map(function(listener) {
			listener.enterEveryRule(ctx);
			ctx.enterRule(listener);
		});
	}
};

//
// Notify any parse listeners of an exit rule event.
//
// @see //addParseListener
//
Parser.prototype.triggerExitRuleEvent = function() {
	if (this._parseListeners !== null) {
		// reverse order walk of listeners
        var ctx = this._ctx;
		this._parseListeners.slice(0).reverse().map(function(listener) {
			ctx.exitRule(listener);
			listener.exitEveryRule(ctx);
		});
	}
};

Parser.prototype.getTokenFactory = function() {
	return this._input.tokenSource._factory;
};

// Tell our token source and error strategy about a new way to create tokens.//
Parser.prototype.setTokenFactory = function(factory) {
	this._input.tokenSource._factory = factory;
};

// The ATN with bypass alternatives is expensive to create so we create it
// lazily.
//
// @throws UnsupportedOperationException if the current parser does not
// implement the {@link //getSerializedATN()} method.
//
Parser.prototype.getATNWithBypassAlts = function() {
	var serializedAtn = this.getSerializedATN();
	if (serializedAtn === null) {
		throw "The current parser does not support an ATN with bypass alternatives.";
	}
	var result = this.bypassAltsAtnCache[serializedAtn];
	if (result === null) {
		var deserializationOptions = new ATNDeserializationOptions();
		deserializationOptions.generateRuleBypassTransitions = true;
		result = new ATNDeserializer(deserializationOptions)
				.deserialize(serializedAtn);
		this.bypassAltsAtnCache[serializedAtn] = result;
	}
	return result;
};

// The preferred method of getting a tree pattern. For example, here's a
// sample use:
//
// <pre>
// ParseTree t = parser.expr();
// ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
// MyParser.RULE_expr);
// ParseTreeMatch m = p.match(t);
// String id = m.get("ID");
// </pre>

var Lexer = __webpack_require__(27).Lexer;

Parser.prototype.compileParseTreePattern = function(pattern, patternRuleIndex, lexer) {
	lexer = lexer || null;
	if (lexer === null) {
		if (this.getTokenStream() !== null) {
			var tokenSource = this.getTokenStream().tokenSource;
			if (tokenSource instanceof Lexer) {
				lexer = tokenSource;
			}
		}
	}
	if (lexer === null) {
		throw "Parser can't discover a lexer to use";
	}
	var m = new ParseTreePatternMatcher(lexer, this);
	return m.compile(pattern, patternRuleIndex);
};

Parser.prototype.getInputStream = function() {
	return this.getTokenStream();
};

Parser.prototype.setInputStream = function(input) {
	this.setTokenStream(input);
};

Parser.prototype.getTokenStream = function() {
	return this._input;
};

// Set the token stream and reset the parser.//
Parser.prototype.setTokenStream = function(input) {
	this._input = null;
	this.reset();
	this._input = input;
};

// Match needs to return the current input symbol, which gets put
// into the label for the associated token ref; e.g., x=ID.
//
Parser.prototype.getCurrentToken = function() {
	return this._input.LT(1);
};

Parser.prototype.notifyErrorListeners = function(msg, offendingToken, err) {
	offendingToken = offendingToken || null;
	err = err || null;
	if (offendingToken === null) {
		offendingToken = this.getCurrentToken();
	}
	this._syntaxErrors += 1;
	var line = offendingToken.line;
	var column = offendingToken.column;
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, offendingToken, line, column, msg, err);
};

//
// Consume and return the {@linkplain //getCurrentToken current symbol}.
//
// <p>E.g., given the following input with {@code A} being the current
// lookahead symbol, this function moves the cursor to {@code B} and returns
// {@code A}.</p>
//
// <pre>
// A B
// ^
// </pre>
//
// If the parser is not in error recovery mode, the consumed symbol is added
// to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
// {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
// If the parser <em>is</em> in error recovery mode, the consumed symbol is
// added to the parse tree using
// {@link ParserRuleContext//addErrorNode(Token)}, and
// {@link ParseTreeListener//visitErrorNode} is called on any parse
// listeners.
//
Parser.prototype.consume = function() {
	var o = this.getCurrentToken();
	if (o.type !== Token.EOF) {
		this.getInputStream().consume();
	}
	var hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
	if (this.buildParseTrees || hasListener) {
		var node;
		if (this._errHandler.inErrorRecoveryMode(this)) {
			node = this._ctx.addErrorNode(o);
		} else {
			node = this._ctx.addTokenNode(o);
		}
        node.invokingState = this.state;
		if (hasListener) {
			this._parseListeners.map(function(listener) {
				if (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {
					listener.visitErrorNode(node);
				} else if (node instanceof TerminalNode) {
					listener.visitTerminal(node);
				}
			});
		}
	}
	return o;
};

Parser.prototype.addContextToParseTree = function() {
	// add current context to parent if we have a parent
	if (this._ctx.parentCtx !== null) {
		this._ctx.parentCtx.addChild(this._ctx);
	}
};

// Always called by generated parsers upon entry to a rule. Access field
// {@link //_ctx} get the current context.

Parser.prototype.enterRule = function(localctx, state, ruleIndex) {
	this.state = state;
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this.buildParseTrees) {
		this.addContextToParseTree();
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent();
	}
};

Parser.prototype.exitRule = function() {
	this._ctx.stop = this._input.LT(-1);
	// trigger event on _ctx, before it reverts to parent
	if (this._parseListeners !== null) {
		this.triggerExitRuleEvent();
	}
	this.state = this._ctx.invokingState;
	this._ctx = this._ctx.parentCtx;
};

Parser.prototype.enterOuterAlt = function(localctx, altNum) {
   	localctx.setAltNumber(altNum);
	// if we have new localctx, make sure we replace existing ctx
	// that is previous child of parse tree
	if (this.buildParseTrees && this._ctx !== localctx) {
		if (this._ctx.parentCtx !== null) {
			this._ctx.parentCtx.removeLastChild();
			this._ctx.parentCtx.addChild(localctx);
		}
	}
	this._ctx = localctx;
};

// Get the precedence level for the top-most precedence rule.
//
// @return The precedence level for the top-most precedence rule, or -1 if
// the parser context is not nested within a precedence rule.

Parser.prototype.getPrecedence = function() {
	if (this._precedenceStack.length === 0) {
		return -1;
	} else {
		return this._precedenceStack[this._precedenceStack.length-1];
	}
};

Parser.prototype.enterRecursionRule = function(localctx, state, ruleIndex,
		precedence) {
	this.state = state;
	this._precedenceStack.push(precedence);
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

//
// Like {@link //enterRule} but for recursive rules.

Parser.prototype.pushNewRecursionContext = function(localctx, state, ruleIndex) {
	var previous = this._ctx;
	previous.parentCtx = localctx;
	previous.invokingState = state;
	previous.stop = this._input.LT(-1);

	this._ctx = localctx;
	this._ctx.start = previous.start;
	if (this.buildParseTrees) {
		this._ctx.addChild(previous);
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

Parser.prototype.unrollRecursionContexts = function(parentCtx) {
	this._precedenceStack.pop();
	this._ctx.stop = this._input.LT(-1);
	var retCtx = this._ctx; // save current ctx (return value)
	// unroll so _ctx is as it was before call to recursive method
	if (this._parseListeners !== null) {
		while (this._ctx !== parentCtx) {
			this.triggerExitRuleEvent();
			this._ctx = this._ctx.parentCtx;
		}
	} else {
		this._ctx = parentCtx;
	}
	// hook into tree
	retCtx.parentCtx = parentCtx;
	if (this.buildParseTrees && parentCtx !== null) {
		// add return ctx into invoking rule's tree
		parentCtx.addChild(retCtx);
	}
};

Parser.prototype.getInvokingContext = function(ruleIndex) {
	var ctx = this._ctx;
	while (ctx !== null) {
		if (ctx.ruleIndex === ruleIndex) {
			return ctx;
		}
		ctx = ctx.parentCtx;
	}
	return null;
};

Parser.prototype.precpred = function(localctx, precedence) {
	return precedence >= this._precedenceStack[this._precedenceStack.length-1];
};

Parser.prototype.inContext = function(context) {
	// TODO: useful in parser?
	return false;
};

//
// Checks whether or not {@code symbol} can follow the current state in the
// ATN. The behavior of this method is equivalent to the following, but is
// implemented such that the complete context-sensitive follow set does not
// need to be explicitly constructed.
//
// <pre>
// return getExpectedTokens().contains(symbol);
// </pre>
//
// @param symbol the symbol type to check
// @return {@code true} if {@code symbol} can follow the current state in
// the ATN, otherwise {@code false}.

Parser.prototype.isExpectedToken = function(symbol) {
	var atn = this._interp.atn;
	var ctx = this._ctx;
	var s = atn.states[this.state];
	var following = atn.nextTokens(s);
	if (following.contains(symbol)) {
		return true;
	}
	if (!following.contains(Token.EPSILON)) {
		return false;
	}
	while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
		var invokingState = atn.states[ctx.invokingState];
		var rt = invokingState.transitions[0];
		following = atn.nextTokens(rt.followState);
		if (following.contains(symbol)) {
			return true;
		}
		ctx = ctx.parentCtx;
	}
	if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
		return true;
	} else {
		return false;
	}
};

// Computes the set of input symbols which could follow the current parser
// state and context, as given by {@link //getState} and {@link //getContext},
// respectively.
//
// @see ATN//getExpectedTokens(int, RuleContext)
//
Parser.prototype.getExpectedTokens = function() {
	return this._interp.atn.getExpectedTokens(this.state, this._ctx);
};

Parser.prototype.getExpectedTokensWithinCurrentRule = function() {
	var atn = this._interp.atn;
	var s = atn.states[this.state];
	return atn.nextTokens(s);
};

// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.//
Parser.prototype.getRuleIndex = function(ruleName) {
	var ruleIndex = this.getRuleIndexMap()[ruleName];
	if (ruleIndex !== null) {
		return ruleIndex;
	} else {
		return -1;
	}
};

// Return List&lt;String&gt; of the rule names in your parser instance
// leading up to a call to the current rule. You could override if
// you want more details such as the file/line info of where
// in the ATN a rule is invoked.
//
// this is very useful for error messages.
//
Parser.prototype.getRuleInvocationStack = function(p) {
	p = p || null;
	if (p === null) {
		p = this._ctx;
	}
	var stack = [];
	while (p !== null) {
		// compute what follows who invoked us
		var ruleIndex = p.ruleIndex;
		if (ruleIndex < 0) {
			stack.push("n/a");
		} else {
			stack.push(this.ruleNames[ruleIndex]);
		}
		p = p.parentCtx;
	}
	return stack;
};

// For debugging and other purposes.//
Parser.prototype.getDFAStrings = function() {
	return this._interp.decisionToDFA.toString();
};
// For debugging and other purposes.//
Parser.prototype.dumpDFA = function() {
	var seenOne = false;
	for (var i = 0; i < this._interp.decisionToDFA.length; i++) {
		var dfa = this._interp.decisionToDFA[i];
		if (dfa.states.length > 0) {
			if (seenOne) {
				console.log();
			}
			this.printer.println("Decision " + dfa.decision + ":");
			this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
			seenOne = true;
		}
	}
};

/*
"			printer = function() {\r\n" +
"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
"			};\r\n" +
*/

Parser.prototype.getSourceName = function() {
	return this._input.sourceName;
};

// During a parse is sometimes useful to listen in on the rule entry and exit
// events as well as token matches. this is for quick and dirty debugging.
//
Parser.prototype.setTrace = function(trace) {
	if (!trace) {
		this.removeParseListener(this._tracer);
		this._tracer = null;
	} else {
		if (this._tracer !== null) {
			this.removeParseListener(this._tracer);
		}
		this._tracer = new TraceListener(this);
		this.addParseListener(this._tracer);
	}
};

exports.Parser = Parser;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// Generated from C.g4 by ANTLR 4.7.1
// jshint ignore: start
var antlr4 = __webpack_require__(24);


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0002w\u0538\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004",
    "\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t",
    "\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004",
    "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010",
    "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013",
    "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017",
    "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a",
    "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e",
    "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#",
    "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004",
    "*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u0004",
    "1\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u0004",
    "8\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004",
    "?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004",
    "F\tF\u0004G\tG\u0004H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004",
    "M\tM\u0004N\tN\u0004O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004",
    "T\tT\u0004U\tU\u0004V\tV\u0004W\tW\u0004X\tX\u0004Y\tY\u0004Z\tZ\u0004",
    "[\t[\u0004\\\t\\\u0004]\t]\u0004^\t^\u0004_\t_\u0004`\t`\u0004a\ta\u0004",
    "b\tb\u0004c\tc\u0004d\td\u0004e\te\u0004f\tf\u0004g\tg\u0004h\th\u0004",
    "i\ti\u0004j\tj\u0004k\tk\u0004l\tl\u0004m\tm\u0004n\tn\u0004o\to\u0004",
    "p\tp\u0004q\tq\u0004r\tr\u0004s\ts\u0004t\tt\u0004u\tu\u0004v\tv\u0004",
    "w\tw\u0004x\tx\u0004y\ty\u0004z\tz\u0004{\t{\u0004|\t|\u0004}\t}\u0004",
    "~\t~\u0004\u007f\t\u007f\u0004\u0080\t\u0080\u0004\u0081\t\u0081\u0004",
    "\u0082\t\u0082\u0004\u0083\t\u0083\u0004\u0084\t\u0084\u0004\u0085\t",
    "\u0085\u0004\u0086\t\u0086\u0004\u0087\t\u0087\u0004\u0088\t\u0088\u0004",
    "\u0089\t\u0089\u0004\u008a\t\u008a\u0004\u008b\t\u008b\u0004\u008c\t",
    "\u008c\u0004\u008d\t\u008d\u0004\u008e\t\u008e\u0004\u008f\t\u008f\u0004",
    "\u0090\t\u0090\u0004\u0091\t\u0091\u0004\u0092\t\u0092\u0004\u0093\t",
    "\u0093\u0004\u0094\t\u0094\u0004\u0095\t\u0095\u0004\u0096\t\u0096\u0004",
    "\u0097\t\u0097\u0004\u0098\t\u0098\u0004\u0099\t\u0099\u0004\u009a\t",
    "\u009a\u0004\u009b\t\u009b\u0004\u009c\t\u009c\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0004",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004",
    "\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005",
    "\u0003\u0005\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0007\u0003\u0007\u0003\u0007",
    "\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\b",
    "\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003",
    "\b\u0003\b\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003",
    "\t\u0003\t\u0003\t\u0003\t\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\u000b\u0003\u000b\u0003\u000b",
    "\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b",
    "\u0003\u000b\u0003\u000b\u0003\f\u0003\f\u0003\f\u0003\f\u0003\f\u0003",
    "\f\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\u000e\u0003\u000e\u0003",
    "\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003",
    "\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003",
    "\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003",
    "\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003",
    "\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003",
    "\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003",
    "\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015\u0003",
    "\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003",
    "\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003",
    "\u0018\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003",
    "\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b\u0003",
    "\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003",
    "\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001e\u0003\u001e\u0003",
    "\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003",
    " \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003!\u0003!\u0003!\u0003",
    "!\u0003\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003#\u0003#\u0003#\u0003",
    "#\u0003#\u0003#\u0003#\u0003#\u0003#\u0003$\u0003$\u0003$\u0003$\u0003",
    "$\u0003$\u0003$\u0003$\u0003$\u0003%\u0003%\u0003%\u0003%\u0003%\u0003",
    "%\u0003%\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003\'\u0003\'\u0003",
    "\'\u0003\'\u0003\'\u0003\'\u0003\'\u0003(\u0003(\u0003(\u0003(\u0003",
    "(\u0003(\u0003(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003",
    "*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003+\u0003+\u0003+\u0003",
    "+\u0003+\u0003+\u0003+\u0003,\u0003,\u0003,\u0003,\u0003,\u0003,\u0003",
    ",\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003.\u0003.\u0003",
    ".\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003/\u0003/\u0003/\u0003",
    "/\u0003/\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00031\u00031\u00031\u00031\u00031\u00031\u00032\u00032\u00032\u0003",
    "2\u00032\u00032\u00032\u00032\u00032\u00033\u00033\u00033\u00033\u0003",
    "3\u00033\u00033\u00033\u00033\u00034\u00034\u00034\u00034\u00034\u0003",
    "4\u00034\u00034\u00035\u00035\u00035\u00035\u00035\u00035\u00036\u0003",
    "6\u00036\u00036\u00036\u00036\u00036\u00036\u00036\u00037\u00037\u0003",
    "7\u00037\u00037\u00037\u00037\u00037\u00037\u00038\u00038\u00038\u0003",
    "8\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00039\u00039\u0003",
    "9\u00039\u00039\u00039\u00039\u00039\u00039\u00039\u0003:\u0003:\u0003",
    ":\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003",
    ":\u0003:\u0003:\u0003;\u0003;\u0003;\u0003;\u0003;\u0003;\u0003;\u0003",
    ";\u0003;\u0003;\u0003;\u0003;\u0003;\u0003;\u0003<\u0003<\u0003=\u0003",
    "=\u0003>\u0003>\u0003?\u0003?\u0003@\u0003@\u0003A\u0003A\u0003B\u0003",
    "B\u0003C\u0003C\u0003C\u0003D\u0003D\u0003E\u0003E\u0003E\u0003F\u0003",
    "F\u0003F\u0003G\u0003G\u0003G\u0003H\u0003H\u0003I\u0003I\u0003I\u0003",
    "J\u0003J\u0003K\u0003K\u0003K\u0003L\u0003L\u0003M\u0003M\u0003N\u0003",
    "N\u0003O\u0003O\u0003P\u0003P\u0003Q\u0003Q\u0003Q\u0003R\u0003R\u0003",
    "R\u0003S\u0003S\u0003T\u0003T\u0003U\u0003U\u0003V\u0003V\u0003W\u0003",
    "W\u0003X\u0003X\u0003Y\u0003Y\u0003Z\u0003Z\u0003[\u0003[\u0003[\u0003",
    "\\\u0003\\\u0003\\\u0003]\u0003]\u0003]\u0003^\u0003^\u0003^\u0003_",
    "\u0003_\u0003_\u0003`\u0003`\u0003`\u0003`\u0003a\u0003a\u0003a\u0003",
    "a\u0003b\u0003b\u0003b\u0003c\u0003c\u0003c\u0003d\u0003d\u0003d\u0003",
    "e\u0003e\u0003e\u0003f\u0003f\u0003f\u0003g\u0003g\u0003g\u0003h\u0003",
    "h\u0003i\u0003i\u0003i\u0003i\u0003j\u0003j\u0003j\u0007j\u0389\nj\f",
    "j\u000ej\u038c\u000bj\u0003k\u0003k\u0005k\u0390\nk\u0003l\u0003l\u0003",
    "m\u0003m\u0003n\u0003n\u0003n\u0003n\u0003n\u0003n\u0003n\u0003n\u0003",
    "n\u0003n\u0005n\u03a0\nn\u0003o\u0003o\u0003o\u0003o\u0003o\u0003p\u0003",
    "p\u0003p\u0005p\u03aa\np\u0003q\u0003q\u0005q\u03ae\nq\u0003q\u0003",
    "q\u0005q\u03b2\nq\u0003q\u0003q\u0005q\u03b6\nq\u0003q\u0005q\u03b9",
    "\nq\u0003r\u0003r\u0003r\u0006r\u03be\nr\rr\u000er\u03bf\u0003s\u0003",
    "s\u0007s\u03c4\ns\fs\u000es\u03c7\u000bs\u0003t\u0003t\u0007t\u03cb",
    "\nt\ft\u000et\u03ce\u000bt\u0003u\u0003u\u0006u\u03d2\nu\ru\u000eu\u03d3",
    "\u0003v\u0003v\u0003v\u0003w\u0003w\u0003x\u0003x\u0003y\u0003y\u0003",
    "z\u0003z\u0005z\u03e1\nz\u0003z\u0003z\u0003z\u0003z\u0003z\u0005z\u03e8",
    "\nz\u0003z\u0003z\u0005z\u03ec\nz\u0005z\u03ee\nz\u0003{\u0003{\u0003",
    "|\u0003|\u0003}\u0003}\u0003}\u0003}\u0005}\u03f8\n}\u0003~\u0003~\u0005",
    "~\u03fc\n~\u0003\u007f\u0003\u007f\u0005\u007f\u0400\n\u007f\u0003\u007f",
    "\u0005\u007f\u0403\n\u007f\u0003\u007f\u0003\u007f\u0003\u007f\u0005",
    "\u007f\u0408\n\u007f\u0005\u007f\u040a\n\u007f\u0003\u0080\u0003\u0080",
    "\u0003\u0080\u0003\u0080\u0005\u0080\u0410\n\u0080\u0003\u0080\u0003",
    "\u0080\u0003\u0080\u0003\u0080\u0005\u0080\u0416\n\u0080\u0005\u0080",
    "\u0418\n\u0080\u0003\u0081\u0005\u0081\u041b\n\u0081\u0003\u0081\u0003",
    "\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0005\u0081\u0422\n\u0081",
    "\u0003\u0082\u0003\u0082\u0005\u0082\u0426\n\u0082\u0003\u0082\u0003",
    "\u0082\u0003\u0082\u0005\u0082\u042b\n\u0082\u0003\u0082\u0005\u0082",
    "\u042e\n\u0082\u0003\u0083\u0003\u0083\u0003\u0084\u0006\u0084\u0433",
    "\n\u0084\r\u0084\u000e\u0084\u0434\u0003\u0085\u0005\u0085\u0438\n\u0085",
    "\u0003\u0085\u0003\u0085\u0003\u0085\u0003\u0085\u0003\u0085\u0005\u0085",
    "\u043f\n\u0085\u0003\u0086\u0003\u0086\u0005\u0086\u0443\n\u0086\u0003",
    "\u0086\u0003\u0086\u0003\u0086\u0005\u0086\u0448\n\u0086\u0003\u0086",
    "\u0005\u0086\u044b\n\u0086\u0003\u0087\u0006\u0087\u044e\n\u0087\r\u0087",
    "\u000e\u0087\u044f\u0003\u0088\u0003\u0088\u0003\u0089\u0003\u0089\u0003",
    "\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003",
    "\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003",
    "\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003",
    "\u0089\u0003\u0089\u0005\u0089\u046a\n\u0089\u0003\u008a\u0006\u008a",
    "\u046d\n\u008a\r\u008a\u000e\u008a\u046e\u0003\u008b\u0003\u008b\u0005",
    "\u008b\u0473\n\u008b\u0003\u008c\u0003\u008c\u0003\u008c\u0003\u008c",
    "\u0005\u008c\u0479\n\u008c\u0003\u008d\u0003\u008d\u0003\u008d\u0003",
    "\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003",
    "\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0005\u008e\u0489",
    "\n\u008e\u0003\u008f\u0003\u008f\u0003\u008f\u0003\u008f\u0006\u008f",
    "\u048f\n\u008f\r\u008f\u000e\u008f\u0490\u0003\u0090\u0005\u0090\u0494",
    "\n\u0090\u0003\u0090\u0003\u0090\u0005\u0090\u0498\n\u0090\u0003\u0090",
    "\u0003\u0090\u0003\u0091\u0003\u0091\u0003\u0091\u0005\u0091\u049f\n",
    "\u0091\u0003\u0092\u0006\u0092\u04a2\n\u0092\r\u0092\u000e\u0092\u04a3",
    "\u0003\u0093\u0003\u0093\u0003\u0093\u0003\u0093\u0003\u0093\u0003\u0093",
    "\u0003\u0093\u0005\u0093\u04ad\n\u0093\u0003\u0094\u0003\u0094\u0005",
    "\u0094\u04b1\n\u0094\u0003\u0094\u0003\u0094\u0003\u0094\u0003\u0094",
    "\u0003\u0094\u0003\u0094\u0003\u0094\u0003\u0094\u0007\u0094\u04bb\n",
    "\u0094\f\u0094\u000e\u0094\u04be\u000b\u0094\u0003\u0094\u0003\u0094",
    "\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0095\u0007\u0095",
    "\u04c7\n\u0095\f\u0095\u000e\u0095\u04ca\u000b\u0095\u0003\u0095\u0003",
    "\u0095\u0007\u0095\u04ce\n\u0095\f\u0095\u000e\u0095\u04d1\u000b\u0095",
    "\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0096\u0003\u0096",
    "\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0007\u0096",
    "\u04de\n\u0096\f\u0096\u000e\u0096\u04e1\u000b\u0096\u0003\u0096\u0007",
    "\u0096\u04e4\n\u0096\f\u0096\u000e\u0096\u04e7\u000b\u0096\u0003\u0096",
    "\u0003\u0096\u0003\u0097\u0003\u0097\u0005\u0097\u04ed\n\u0097\u0003",
    "\u0097\u0003\u0097\u0005\u0097\u04f1\n\u0097\u0003\u0097\u0003\u0097",
    "\u0007\u0097\u04f5\n\u0097\f\u0097\u000e\u0097\u04f8\u000b\u0097\u0003",
    "\u0097\u0003\u0097\u0003\u0098\u0003\u0098\u0005\u0098\u04fe\n\u0098",
    "\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098",
    "\u0003\u0098\u0003\u0098\u0003\u0098\u0007\u0098\u0509\n\u0098\f\u0098",
    "\u000e\u0098\u050c\u000b\u0098\u0003\u0098\u0003\u0098\u0003\u0099\u0006",
    "\u0099\u0511\n\u0099\r\u0099\u000e\u0099\u0512\u0003\u0099\u0003\u0099",
    "\u0003\u009a\u0003\u009a\u0005\u009a\u0519\n\u009a\u0003\u009a\u0005",
    "\u009a\u051c\n\u009a\u0003\u009a\u0003\u009a\u0003\u009b\u0003\u009b",
    "\u0003\u009b\u0003\u009b\u0007\u009b\u0524\n\u009b\f\u009b\u000e\u009b",
    "\u0527\u000b\u009b\u0003\u009b\u0003\u009b\u0003\u009b\u0003\u009b\u0003",
    "\u009b\u0003\u009c\u0003\u009c\u0003\u009c\u0003\u009c\u0007\u009c\u0532",
    "\n\u009c\f\u009c\u000e\u009c\u0535\u000b\u009c\u0003\u009c\u0003\u009c",
    "\u0003\u0525\u0002\u009d\u0003\u0003\u0005\u0004\u0007\u0005\t\u0006",
    "\u000b\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015\f\u0017\r\u0019\u000e",
    "\u001b\u000f\u001d\u0010\u001f\u0011!\u0012#\u0013%\u0014\'\u0015)\u0016",
    "+\u0017-\u0018/\u00191\u001a3\u001b5\u001c7\u001d9\u001e;\u001f= ?!",
    "A\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y>{?}@\u007f",
    "A\u0081B\u0083C\u0085D\u0087E\u0089F\u008bG\u008dH\u008fI\u0091J\u0093",
    "K\u0095L\u0097M\u0099N\u009bO\u009dP\u009fQ\u00a1R\u00a3S\u00a5T\u00a7",
    "U\u00a9V\u00abW\u00adX\u00afY\u00b1Z\u00b3[\u00b5\\\u00b7]\u00b9^\u00bb",
    "_\u00bd`\u00bfa\u00c1b\u00c3c\u00c5d\u00c7e\u00c9f\u00cbg\u00cdh\u00cf",
    "i\u00d1j\u00d3k\u00d5\u0002\u00d7\u0002\u00d9\u0002\u00db\u0002\u00dd",
    "\u0002\u00dfl\u00e1\u0002\u00e3\u0002\u00e5\u0002\u00e7\u0002\u00e9",
    "\u0002\u00eb\u0002\u00ed\u0002\u00ef\u0002\u00f1\u0002\u00f3\u0002\u00f5",
    "\u0002\u00f7\u0002\u00f9\u0002\u00fb\u0002\u00fd\u0002\u00ff\u0002\u0101",
    "\u0002\u0103\u0002\u0105\u0002\u0107m\u0109\u0002\u010b\u0002\u010d",
    "\u0002\u010f\u0002\u0111\u0002\u0113\u0002\u0115\u0002\u0117\u0002\u0119",
    "\u0002\u011b\u0002\u011d\u0002\u011fn\u0121\u0002\u0123\u0002\u0125",
    "\u0002\u0127o\u0129p\u012bq\u012dr\u012fs\u0131t\u0133u\u0135v\u0137",
    "w\u0003\u0002\u0017\u0005\u0002C\\aac|\u0003\u00022;\u0004\u0002DDd",
    "d\u0003\u000223\u0004\u0002ZZzz\u0003\u00023;\u0003\u000229\u0005\u0002",
    "2;CHch\u0004\u0002WWww\u0004\u0002NNnn\u0004\u0002--//\u0006\u0002H",
    "HNNhhnn\u0006\u0002\f\f\u000f\u000f))^^\f\u0002$$))AA^^cdhhppttvvxx",
    "\u0005\u0002NNWWww\u0006\u0002\f\f\u000f\u000f$$^^\u0003\u0002%%\u0003",
    "\u0002}}\u0003\u0002\u007f\u007f\u0004\u0002\f\f\u000f\u000f\u0004\u0002",
    "\u000b\u000b\"\"\u0002\u055e\u0002\u0003\u0003\u0002\u0002\u0002\u0002",
    "\u0005\u0003\u0002\u0002\u0002\u0002\u0007\u0003\u0002\u0002\u0002\u0002",
    "\t\u0003\u0002\u0002\u0002\u0002\u000b\u0003\u0002\u0002\u0002\u0002",
    "\r\u0003\u0002\u0002\u0002\u0002\u000f\u0003\u0002\u0002\u0002\u0002",
    "\u0011\u0003\u0002\u0002\u0002\u0002\u0013\u0003\u0002\u0002\u0002\u0002",
    "\u0015\u0003\u0002\u0002\u0002\u0002\u0017\u0003\u0002\u0002\u0002\u0002",
    "\u0019\u0003\u0002\u0002\u0002\u0002\u001b\u0003\u0002\u0002\u0002\u0002",
    "\u001d\u0003\u0002\u0002\u0002\u0002\u001f\u0003\u0002\u0002\u0002\u0002",
    "!\u0003\u0002\u0002\u0002\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003",
    "\u0002\u0002\u0002\u0002\'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002",
    "\u0002\u0002\u0002+\u0003\u0002\u0002\u0002\u0002-\u0003\u0002\u0002",
    "\u0002\u0002/\u0003\u0002\u0002\u0002\u00021\u0003\u0002\u0002\u0002",
    "\u00023\u0003\u0002\u0002\u0002\u00025\u0003\u0002\u0002\u0002\u0002",
    "7\u0003\u0002\u0002\u0002\u00029\u0003\u0002\u0002\u0002\u0002;\u0003",
    "\u0002\u0002\u0002\u0002=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002",
    "\u0002\u0002\u0002A\u0003\u0002\u0002\u0002\u0002C\u0003\u0002\u0002",
    "\u0002\u0002E\u0003\u0002\u0002\u0002\u0002G\u0003\u0002\u0002\u0002",
    "\u0002I\u0003\u0002\u0002\u0002\u0002K\u0003\u0002\u0002\u0002\u0002",
    "M\u0003\u0002\u0002\u0002\u0002O\u0003\u0002\u0002\u0002\u0002Q\u0003",
    "\u0002\u0002\u0002\u0002S\u0003\u0002\u0002\u0002\u0002U\u0003\u0002",
    "\u0002\u0002\u0002W\u0003\u0002\u0002\u0002\u0002Y\u0003\u0002\u0002",
    "\u0002\u0002[\u0003\u0002\u0002\u0002\u0002]\u0003\u0002\u0002\u0002",
    "\u0002_\u0003\u0002\u0002\u0002\u0002a\u0003\u0002\u0002\u0002\u0002",
    "c\u0003\u0002\u0002\u0002\u0002e\u0003\u0002\u0002\u0002\u0002g\u0003",
    "\u0002\u0002\u0002\u0002i\u0003\u0002\u0002\u0002\u0002k\u0003\u0002",
    "\u0002\u0002\u0002m\u0003\u0002\u0002\u0002\u0002o\u0003\u0002\u0002",
    "\u0002\u0002q\u0003\u0002\u0002\u0002\u0002s\u0003\u0002\u0002\u0002",
    "\u0002u\u0003\u0002\u0002\u0002\u0002w\u0003\u0002\u0002\u0002\u0002",
    "y\u0003\u0002\u0002\u0002\u0002{\u0003\u0002\u0002\u0002\u0002}\u0003",
    "\u0002\u0002\u0002\u0002\u007f\u0003\u0002\u0002\u0002\u0002\u0081\u0003",
    "\u0002\u0002\u0002\u0002\u0083\u0003\u0002\u0002\u0002\u0002\u0085\u0003",
    "\u0002\u0002\u0002\u0002\u0087\u0003\u0002\u0002\u0002\u0002\u0089\u0003",
    "\u0002\u0002\u0002\u0002\u008b\u0003\u0002\u0002\u0002\u0002\u008d\u0003",
    "\u0002\u0002\u0002\u0002\u008f\u0003\u0002\u0002\u0002\u0002\u0091\u0003",
    "\u0002\u0002\u0002\u0002\u0093\u0003\u0002\u0002\u0002\u0002\u0095\u0003",
    "\u0002\u0002\u0002\u0002\u0097\u0003\u0002\u0002\u0002\u0002\u0099\u0003",
    "\u0002\u0002\u0002\u0002\u009b\u0003\u0002\u0002\u0002\u0002\u009d\u0003",
    "\u0002\u0002\u0002\u0002\u009f\u0003\u0002\u0002\u0002\u0002\u00a1\u0003",
    "\u0002\u0002\u0002\u0002\u00a3\u0003\u0002\u0002\u0002\u0002\u00a5\u0003",
    "\u0002\u0002\u0002\u0002\u00a7\u0003\u0002\u0002\u0002\u0002\u00a9\u0003",
    "\u0002\u0002\u0002\u0002\u00ab\u0003\u0002\u0002\u0002\u0002\u00ad\u0003",
    "\u0002\u0002\u0002\u0002\u00af\u0003\u0002\u0002\u0002\u0002\u00b1\u0003",
    "\u0002\u0002\u0002\u0002\u00b3\u0003\u0002\u0002\u0002\u0002\u00b5\u0003",
    "\u0002\u0002\u0002\u0002\u00b7\u0003\u0002\u0002\u0002\u0002\u00b9\u0003",
    "\u0002\u0002\u0002\u0002\u00bb\u0003\u0002\u0002\u0002\u0002\u00bd\u0003",
    "\u0002\u0002\u0002\u0002\u00bf\u0003\u0002\u0002\u0002\u0002\u00c1\u0003",
    "\u0002\u0002\u0002\u0002\u00c3\u0003\u0002\u0002\u0002\u0002\u00c5\u0003",
    "\u0002\u0002\u0002\u0002\u00c7\u0003\u0002\u0002\u0002\u0002\u00c9\u0003",
    "\u0002\u0002\u0002\u0002\u00cb\u0003\u0002\u0002\u0002\u0002\u00cd\u0003",
    "\u0002\u0002\u0002\u0002\u00cf\u0003\u0002\u0002\u0002\u0002\u00d1\u0003",
    "\u0002\u0002\u0002\u0002\u00d3\u0003\u0002\u0002\u0002\u0002\u00df\u0003",
    "\u0002\u0002\u0002\u0002\u0107\u0003\u0002\u0002\u0002\u0002\u011f\u0003",
    "\u0002\u0002\u0002\u0002\u0127\u0003\u0002\u0002\u0002\u0002\u0129\u0003",
    "\u0002\u0002\u0002\u0002\u012b\u0003\u0002\u0002\u0002\u0002\u012d\u0003",
    "\u0002\u0002\u0002\u0002\u012f\u0003\u0002\u0002\u0002\u0002\u0131\u0003",
    "\u0002\u0002\u0002\u0002\u0133\u0003\u0002\u0002\u0002\u0002\u0135\u0003",
    "\u0002\u0002\u0002\u0002\u0137\u0003\u0002\u0002\u0002\u0003\u0139\u0003",
    "\u0002\u0002\u0002\u0005\u0147\u0003\u0002\u0002\u0002\u0007\u0158\u0003",
    "\u0002\u0002\u0002\t\u016b\u0003\u0002\u0002\u0002\u000b\u0172\u0003",
    "\u0002\u0002\u0002\r\u017a\u0003\u0002\u0002\u0002\u000f\u0182\u0003",
    "\u0002\u0002\u0002\u0011\u018d\u0003\u0002\u0002\u0002\u0013\u0198\u0003",
    "\u0002\u0002\u0002\u0015\u01a2\u0003\u0002\u0002\u0002\u0017\u01ad\u0003",
    "\u0002\u0002\u0002\u0019\u01b3\u0003\u0002\u0002\u0002\u001b\u01c1\u0003",
    "\u0002\u0002\u0002\u001d\u01c9\u0003\u0002\u0002\u0002\u001f\u01d6\u0003",
    "\u0002\u0002\u0002!\u01db\u0003\u0002\u0002\u0002#\u01e1\u0003\u0002",
    "\u0002\u0002%\u01e6\u0003\u0002\u0002\u0002\'\u01eb\u0003\u0002\u0002",
    "\u0002)\u01f1\u0003\u0002\u0002\u0002+\u01fa\u0003\u0002\u0002\u0002",
    "-\u0202\u0003\u0002\u0002\u0002/\u0205\u0003\u0002\u0002\u00021\u020c",
    "\u0003\u0002\u0002\u00023\u0211\u0003\u0002\u0002\u00025\u0216\u0003",
    "\u0002\u0002\u00027\u021d\u0003\u0002\u0002\u00029\u0223\u0003\u0002",
    "\u0002\u0002;\u0227\u0003\u0002\u0002\u0002=\u022c\u0003\u0002\u0002",
    "\u0002?\u022f\u0003\u0002\u0002\u0002A\u0236\u0003\u0002\u0002\u0002",
    "C\u023a\u0003\u0002\u0002\u0002E\u023f\u0003\u0002\u0002\u0002G\u0248",
    "\u0003\u0002\u0002\u0002I\u0251\u0003\u0002\u0002\u0002K\u0258\u0003",
    "\u0002\u0002\u0002M\u025e\u0003\u0002\u0002\u0002O\u0265\u0003\u0002",
    "\u0002\u0002Q\u026c\u0003\u0002\u0002\u0002S\u0273\u0003\u0002\u0002",
    "\u0002U\u027a\u0003\u0002\u0002\u0002W\u0281\u0003\u0002\u0002\u0002",
    "Y\u0289\u0003\u0002\u0002\u0002[\u028f\u0003\u0002\u0002\u0002]\u0298",
    "\u0003\u0002\u0002\u0002_\u029d\u0003\u0002\u0002\u0002a\u02a6\u0003",
    "\u0002\u0002\u0002c\u02ac\u0003\u0002\u0002\u0002e\u02b5\u0003\u0002",
    "\u0002\u0002g\u02be\u0003\u0002\u0002\u0002i\u02c6\u0003\u0002\u0002",
    "\u0002k\u02cc\u0003\u0002\u0002\u0002m\u02d5\u0003\u0002\u0002\u0002",
    "o\u02de\u0003\u0002\u0002\u0002q\u02e9\u0003\u0002\u0002\u0002s\u02f3",
    "\u0003\u0002\u0002\u0002u\u0302\u0003\u0002\u0002\u0002w\u0310\u0003",
    "\u0002\u0002\u0002y\u0312\u0003\u0002\u0002\u0002{\u0314\u0003\u0002",
    "\u0002\u0002}\u0316\u0003\u0002\u0002\u0002\u007f\u0318\u0003\u0002",
    "\u0002\u0002\u0081\u031a\u0003\u0002\u0002\u0002\u0083\u031c\u0003\u0002",
    "\u0002\u0002\u0085\u031e\u0003\u0002\u0002\u0002\u0087\u0321\u0003\u0002",
    "\u0002\u0002\u0089\u0323\u0003\u0002\u0002\u0002\u008b\u0326\u0003\u0002",
    "\u0002\u0002\u008d\u0329\u0003\u0002\u0002\u0002\u008f\u032c\u0003\u0002",
    "\u0002\u0002\u0091\u032e\u0003\u0002\u0002\u0002\u0093\u0331\u0003\u0002",
    "\u0002\u0002\u0095\u0333\u0003\u0002\u0002\u0002\u0097\u0336\u0003\u0002",
    "\u0002\u0002\u0099\u0338\u0003\u0002\u0002\u0002\u009b\u033a\u0003\u0002",
    "\u0002\u0002\u009d\u033c\u0003\u0002\u0002\u0002\u009f\u033e\u0003\u0002",
    "\u0002\u0002\u00a1\u0340\u0003\u0002\u0002\u0002\u00a3\u0343\u0003\u0002",
    "\u0002\u0002\u00a5\u0346\u0003\u0002\u0002\u0002\u00a7\u0348\u0003\u0002",
    "\u0002\u0002\u00a9\u034a\u0003\u0002\u0002\u0002\u00ab\u034c\u0003\u0002",
    "\u0002\u0002\u00ad\u034e\u0003\u0002\u0002\u0002\u00af\u0350\u0003\u0002",
    "\u0002\u0002\u00b1\u0352\u0003\u0002\u0002\u0002\u00b3\u0354\u0003\u0002",
    "\u0002\u0002\u00b5\u0356\u0003\u0002\u0002\u0002\u00b7\u0359\u0003\u0002",
    "\u0002\u0002\u00b9\u035c\u0003\u0002\u0002\u0002\u00bb\u035f\u0003\u0002",
    "\u0002\u0002\u00bd\u0362\u0003\u0002\u0002\u0002\u00bf\u0365\u0003\u0002",
    "\u0002\u0002\u00c1\u0369\u0003\u0002\u0002\u0002\u00c3\u036d\u0003\u0002",
    "\u0002\u0002\u00c5\u0370\u0003\u0002\u0002\u0002\u00c7\u0373\u0003\u0002",
    "\u0002\u0002\u00c9\u0376\u0003\u0002\u0002\u0002\u00cb\u0379\u0003\u0002",
    "\u0002\u0002\u00cd\u037c\u0003\u0002\u0002\u0002\u00cf\u037f\u0003\u0002",
    "\u0002\u0002\u00d1\u0381\u0003\u0002\u0002\u0002\u00d3\u0385\u0003\u0002",
    "\u0002\u0002\u00d5\u038f\u0003\u0002\u0002\u0002\u00d7\u0391\u0003\u0002",
    "\u0002\u0002\u00d9\u0393\u0003\u0002\u0002\u0002\u00db\u039f\u0003\u0002",
    "\u0002\u0002\u00dd\u03a1\u0003\u0002\u0002\u0002\u00df\u03a9\u0003\u0002",
    "\u0002\u0002\u00e1\u03b8\u0003\u0002\u0002\u0002\u00e3\u03ba\u0003\u0002",
    "\u0002\u0002\u00e5\u03c1\u0003\u0002\u0002\u0002\u00e7\u03c8\u0003\u0002",
    "\u0002\u0002\u00e9\u03cf\u0003\u0002\u0002\u0002\u00eb\u03d5\u0003\u0002",
    "\u0002\u0002\u00ed\u03d8\u0003\u0002\u0002\u0002\u00ef\u03da\u0003\u0002",
    "\u0002\u0002\u00f1\u03dc\u0003\u0002\u0002\u0002\u00f3\u03ed\u0003\u0002",
    "\u0002\u0002\u00f5\u03ef\u0003\u0002\u0002\u0002\u00f7\u03f1\u0003\u0002",
    "\u0002\u0002\u00f9\u03f7\u0003\u0002\u0002\u0002\u00fb\u03fb\u0003\u0002",
    "\u0002\u0002\u00fd\u0409\u0003\u0002\u0002\u0002\u00ff\u0417\u0003\u0002",
    "\u0002\u0002\u0101\u0421\u0003\u0002\u0002\u0002\u0103\u042d\u0003\u0002",
    "\u0002\u0002\u0105\u042f\u0003\u0002\u0002\u0002\u0107\u0432\u0003\u0002",
    "\u0002\u0002\u0109\u043e\u0003\u0002\u0002\u0002\u010b\u044a\u0003\u0002",
    "\u0002\u0002\u010d\u044d\u0003\u0002\u0002\u0002\u010f\u0451\u0003\u0002",
    "\u0002\u0002\u0111\u0469\u0003\u0002\u0002\u0002\u0113\u046c\u0003\u0002",
    "\u0002\u0002\u0115\u0472\u0003\u0002\u0002\u0002\u0117\u0478\u0003\u0002",
    "\u0002\u0002\u0119\u047a\u0003\u0002\u0002\u0002\u011b\u0488\u0003\u0002",
    "\u0002\u0002\u011d\u048a\u0003\u0002\u0002\u0002\u011f\u0493\u0003\u0002",
    "\u0002\u0002\u0121\u049e\u0003\u0002\u0002\u0002\u0123\u04a1\u0003\u0002",
    "\u0002\u0002\u0125\u04ac\u0003\u0002\u0002\u0002\u0127\u04ae\u0003\u0002",
    "\u0002\u0002\u0129\u04c1\u0003\u0002\u0002\u0002\u012b\u04d6\u0003\u0002",
    "\u0002\u0002\u012d\u04ea\u0003\u0002\u0002\u0002\u012f\u04fb\u0003\u0002",
    "\u0002\u0002\u0131\u0510\u0003\u0002\u0002\u0002\u0133\u051b\u0003\u0002",
    "\u0002\u0002\u0135\u051f\u0003\u0002\u0002\u0002\u0137\u052d\u0003\u0002",
    "\u0002\u0002\u0139\u013a\u0007a\u0002\u0002\u013a\u013b\u0007a\u0002",
    "\u0002\u013b\u013c\u0007g\u0002\u0002\u013c\u013d\u0007z\u0002\u0002",
    "\u013d\u013e\u0007v\u0002\u0002\u013e\u013f\u0007g\u0002\u0002\u013f",
    "\u0140\u0007p\u0002\u0002\u0140\u0141\u0007u\u0002\u0002\u0141\u0142",
    "\u0007k\u0002\u0002\u0142\u0143\u0007q\u0002\u0002\u0143\u0144\u0007",
    "p\u0002\u0002\u0144\u0145\u0007a\u0002\u0002\u0145\u0146\u0007a\u0002",
    "\u0002\u0146\u0004\u0003\u0002\u0002\u0002\u0147\u0148\u0007a\u0002",
    "\u0002\u0148\u0149\u0007a\u0002\u0002\u0149\u014a\u0007d\u0002\u0002",
    "\u014a\u014b\u0007w\u0002\u0002\u014b\u014c\u0007k\u0002\u0002\u014c",
    "\u014d\u0007n\u0002\u0002\u014d\u014e\u0007v\u0002\u0002\u014e\u014f",
    "\u0007k\u0002\u0002\u014f\u0150\u0007p\u0002\u0002\u0150\u0151\u0007",
    "a\u0002\u0002\u0151\u0152\u0007x\u0002\u0002\u0152\u0153\u0007c\u0002",
    "\u0002\u0153\u0154\u0007a\u0002\u0002\u0154\u0155\u0007c\u0002\u0002",
    "\u0155\u0156\u0007t\u0002\u0002\u0156\u0157\u0007i\u0002\u0002\u0157",
    "\u0006\u0003\u0002\u0002\u0002\u0158\u0159\u0007a\u0002\u0002\u0159",
    "\u015a\u0007a\u0002\u0002\u015a\u015b\u0007d\u0002\u0002\u015b\u015c",
    "\u0007w\u0002\u0002\u015c\u015d\u0007k\u0002\u0002\u015d\u015e\u0007",
    "n\u0002\u0002\u015e\u015f\u0007v\u0002\u0002\u015f\u0160\u0007k\u0002",
    "\u0002\u0160\u0161\u0007p\u0002\u0002\u0161\u0162\u0007a\u0002\u0002",
    "\u0162\u0163\u0007q\u0002\u0002\u0163\u0164\u0007h\u0002\u0002\u0164",
    "\u0165\u0007h\u0002\u0002\u0165\u0166\u0007u\u0002\u0002\u0166\u0167",
    "\u0007g\u0002\u0002\u0167\u0168\u0007v\u0002\u0002\u0168\u0169\u0007",
    "q\u0002\u0002\u0169\u016a\u0007h\u0002\u0002\u016a\b\u0003\u0002\u0002",
    "\u0002\u016b\u016c\u0007a\u0002\u0002\u016c\u016d\u0007a\u0002\u0002",
    "\u016d\u016e\u0007o\u0002\u0002\u016e\u016f\u00073\u0002\u0002\u016f",
    "\u0170\u00074\u0002\u0002\u0170\u0171\u0007:\u0002\u0002\u0171\n\u0003",
    "\u0002\u0002\u0002\u0172\u0173\u0007a\u0002\u0002\u0173\u0174\u0007",
    "a\u0002\u0002\u0174\u0175\u0007o\u0002\u0002\u0175\u0176\u00073\u0002",
    "\u0002\u0176\u0177\u00074\u0002\u0002\u0177\u0178\u0007:\u0002\u0002",
    "\u0178\u0179\u0007f\u0002\u0002\u0179\f\u0003\u0002\u0002\u0002\u017a",
    "\u017b\u0007a\u0002\u0002\u017b\u017c\u0007a\u0002\u0002\u017c\u017d",
    "\u0007o\u0002\u0002\u017d\u017e\u00073\u0002\u0002\u017e\u017f\u0007",
    "4\u0002\u0002\u017f\u0180\u0007:\u0002\u0002\u0180\u0181\u0007k\u0002",
    "\u0002\u0181\u000e\u0003\u0002\u0002\u0002\u0182\u0183\u0007a\u0002",
    "\u0002\u0183\u0184\u0007a\u0002\u0002\u0184\u0185\u0007v\u0002\u0002",
    "\u0185\u0186\u0007{\u0002\u0002\u0186\u0187\u0007r\u0002\u0002\u0187",
    "\u0188\u0007g\u0002\u0002\u0188\u0189\u0007q\u0002\u0002\u0189\u018a",
    "\u0007h\u0002\u0002\u018a\u018b\u0007a\u0002\u0002\u018b\u018c\u0007",
    "a\u0002\u0002\u018c\u0010\u0003\u0002\u0002\u0002\u018d\u018e\u0007",
    "a\u0002\u0002\u018e\u018f\u0007a\u0002\u0002\u018f\u0190\u0007k\u0002",
    "\u0002\u0190\u0191\u0007p\u0002\u0002\u0191\u0192\u0007n\u0002\u0002",
    "\u0192\u0193\u0007k\u0002\u0002\u0193\u0194\u0007p\u0002\u0002\u0194",
    "\u0195\u0007g\u0002\u0002\u0195\u0196\u0007a\u0002\u0002\u0196\u0197",
    "\u0007a\u0002\u0002\u0197\u0012\u0003\u0002\u0002\u0002\u0198\u0199",
    "\u0007a\u0002\u0002\u0199\u019a\u0007a\u0002\u0002\u019a\u019b\u0007",
    "u\u0002\u0002\u019b\u019c\u0007v\u0002\u0002\u019c\u019d\u0007f\u0002",
    "\u0002\u019d\u019e\u0007e\u0002\u0002\u019e\u019f\u0007c\u0002\u0002",
    "\u019f\u01a0\u0007n\u0002\u0002\u01a0\u01a1\u0007n\u0002\u0002\u01a1",
    "\u0014\u0003\u0002\u0002\u0002\u01a2\u01a3\u0007a\u0002\u0002\u01a3",
    "\u01a4\u0007a\u0002\u0002\u01a4\u01a5\u0007f\u0002\u0002\u01a5\u01a6",
    "\u0007g\u0002\u0002\u01a6\u01a7\u0007e\u0002\u0002\u01a7\u01a8\u0007",
    "n\u0002\u0002\u01a8\u01a9\u0007u\u0002\u0002\u01a9\u01aa\u0007r\u0002",
    "\u0002\u01aa\u01ab\u0007g\u0002\u0002\u01ab\u01ac\u0007e\u0002\u0002",
    "\u01ac\u0016\u0003\u0002\u0002\u0002\u01ad\u01ae\u0007a\u0002\u0002",
    "\u01ae\u01af\u0007a\u0002\u0002\u01af\u01b0\u0007c\u0002\u0002\u01b0",
    "\u01b1\u0007u\u0002\u0002\u01b1\u01b2\u0007o\u0002\u0002\u01b2\u0018",
    "\u0003\u0002\u0002\u0002\u01b3\u01b4\u0007a\u0002\u0002\u01b4\u01b5",
    "\u0007a\u0002\u0002\u01b5\u01b6\u0007c\u0002\u0002\u01b6\u01b7\u0007",
    "v\u0002\u0002\u01b7\u01b8\u0007v\u0002\u0002\u01b8\u01b9\u0007t\u0002",
    "\u0002\u01b9\u01ba\u0007k\u0002\u0002\u01ba\u01bb\u0007d\u0002\u0002",
    "\u01bb\u01bc\u0007w\u0002\u0002\u01bc\u01bd\u0007v\u0002\u0002\u01bd",
    "\u01be\u0007g\u0002\u0002\u01be\u01bf\u0007a\u0002\u0002\u01bf\u01c0",
    "\u0007a\u0002\u0002\u01c0\u001a\u0003\u0002\u0002\u0002\u01c1\u01c2",
    "\u0007a\u0002\u0002\u01c2\u01c3\u0007a\u0002\u0002\u01c3\u01c4\u0007",
    "c\u0002\u0002\u01c4\u01c5\u0007u\u0002\u0002\u01c5\u01c6\u0007o\u0002",
    "\u0002\u01c6\u01c7\u0007a\u0002\u0002\u01c7\u01c8\u0007a\u0002\u0002",
    "\u01c8\u001c\u0003\u0002\u0002\u0002\u01c9\u01ca\u0007a\u0002\u0002",
    "\u01ca\u01cb\u0007a\u0002\u0002\u01cb\u01cc\u0007x\u0002\u0002\u01cc",
    "\u01cd\u0007q\u0002\u0002\u01cd\u01ce\u0007n\u0002\u0002\u01ce\u01cf",
    "\u0007c\u0002\u0002\u01cf\u01d0\u0007v\u0002\u0002\u01d0\u01d1\u0007",
    "k\u0002\u0002\u01d1\u01d2\u0007n\u0002\u0002\u01d2\u01d3\u0007g\u0002",
    "\u0002\u01d3\u01d4\u0007a\u0002\u0002\u01d4\u01d5\u0007a\u0002\u0002",
    "\u01d5\u001e\u0003\u0002\u0002\u0002\u01d6\u01d7\u0007c\u0002\u0002",
    "\u01d7\u01d8\u0007w\u0002\u0002\u01d8\u01d9\u0007v\u0002\u0002\u01d9",
    "\u01da\u0007q\u0002\u0002\u01da \u0003\u0002\u0002\u0002\u01db\u01dc",
    "\u0007d\u0002\u0002\u01dc\u01dd\u0007t\u0002\u0002\u01dd\u01de\u0007",
    "g\u0002\u0002\u01de\u01df\u0007c\u0002\u0002\u01df\u01e0\u0007m\u0002",
    "\u0002\u01e0\"\u0003\u0002\u0002\u0002\u01e1\u01e2\u0007e\u0002\u0002",
    "\u01e2\u01e3\u0007c\u0002\u0002\u01e3\u01e4\u0007u\u0002\u0002\u01e4",
    "\u01e5\u0007g\u0002\u0002\u01e5$\u0003\u0002\u0002\u0002\u01e6\u01e7",
    "\u0007e\u0002\u0002\u01e7\u01e8\u0007j\u0002\u0002\u01e8\u01e9\u0007",
    "c\u0002\u0002\u01e9\u01ea\u0007t\u0002\u0002\u01ea&\u0003\u0002\u0002",
    "\u0002\u01eb\u01ec\u0007e\u0002\u0002\u01ec\u01ed\u0007q\u0002\u0002",
    "\u01ed\u01ee\u0007p\u0002\u0002\u01ee\u01ef\u0007u\u0002\u0002\u01ef",
    "\u01f0\u0007v\u0002\u0002\u01f0(\u0003\u0002\u0002\u0002\u01f1\u01f2",
    "\u0007e\u0002\u0002\u01f2\u01f3\u0007q\u0002\u0002\u01f3\u01f4\u0007",
    "p\u0002\u0002\u01f4\u01f5\u0007v\u0002\u0002\u01f5\u01f6\u0007k\u0002",
    "\u0002\u01f6\u01f7\u0007p\u0002\u0002\u01f7\u01f8\u0007w\u0002\u0002",
    "\u01f8\u01f9\u0007g\u0002\u0002\u01f9*\u0003\u0002\u0002\u0002\u01fa",
    "\u01fb\u0007f\u0002\u0002\u01fb\u01fc\u0007g\u0002\u0002\u01fc\u01fd",
    "\u0007h\u0002\u0002\u01fd\u01fe\u0007c\u0002\u0002\u01fe\u01ff\u0007",
    "w\u0002\u0002\u01ff\u0200\u0007n\u0002\u0002\u0200\u0201\u0007v\u0002",
    "\u0002\u0201,\u0003\u0002\u0002\u0002\u0202\u0203\u0007f\u0002\u0002",
    "\u0203\u0204\u0007q\u0002\u0002\u0204.\u0003\u0002\u0002\u0002\u0205",
    "\u0206\u0007f\u0002\u0002\u0206\u0207\u0007q\u0002\u0002\u0207\u0208",
    "\u0007w\u0002\u0002\u0208\u0209\u0007d\u0002\u0002\u0209\u020a\u0007",
    "n\u0002\u0002\u020a\u020b\u0007g\u0002\u0002\u020b0\u0003\u0002\u0002",
    "\u0002\u020c\u020d\u0007g\u0002\u0002\u020d\u020e\u0007n\u0002\u0002",
    "\u020e\u020f\u0007u\u0002\u0002\u020f\u0210\u0007g\u0002\u0002\u0210",
    "2\u0003\u0002\u0002\u0002\u0211\u0212\u0007g\u0002\u0002\u0212\u0213",
    "\u0007p\u0002\u0002\u0213\u0214\u0007w\u0002\u0002\u0214\u0215\u0007",
    "o\u0002\u0002\u02154\u0003\u0002\u0002\u0002\u0216\u0217\u0007g\u0002",
    "\u0002\u0217\u0218\u0007z\u0002\u0002\u0218\u0219\u0007v\u0002\u0002",
    "\u0219\u021a\u0007g\u0002\u0002\u021a\u021b\u0007t\u0002\u0002\u021b",
    "\u021c\u0007p\u0002\u0002\u021c6\u0003\u0002\u0002\u0002\u021d\u021e",
    "\u0007h\u0002\u0002\u021e\u021f\u0007n\u0002\u0002\u021f\u0220\u0007",
    "q\u0002\u0002\u0220\u0221\u0007c\u0002\u0002\u0221\u0222\u0007v\u0002",
    "\u0002\u02228\u0003\u0002\u0002\u0002\u0223\u0224\u0007h\u0002\u0002",
    "\u0224\u0225\u0007q\u0002\u0002\u0225\u0226\u0007t\u0002\u0002\u0226",
    ":\u0003\u0002\u0002\u0002\u0227\u0228\u0007i\u0002\u0002\u0228\u0229",
    "\u0007q\u0002\u0002\u0229\u022a\u0007v\u0002\u0002\u022a\u022b\u0007",
    "q\u0002\u0002\u022b<\u0003\u0002\u0002\u0002\u022c\u022d\u0007k\u0002",
    "\u0002\u022d\u022e\u0007h\u0002\u0002\u022e>\u0003\u0002\u0002\u0002",
    "\u022f\u0230\u0007k\u0002\u0002\u0230\u0231\u0007p\u0002\u0002\u0231",
    "\u0232\u0007n\u0002\u0002\u0232\u0233\u0007k\u0002\u0002\u0233\u0234",
    "\u0007p\u0002\u0002\u0234\u0235\u0007g\u0002\u0002\u0235@\u0003\u0002",
    "\u0002\u0002\u0236\u0237\u0007k\u0002\u0002\u0237\u0238\u0007p\u0002",
    "\u0002\u0238\u0239\u0007v\u0002\u0002\u0239B\u0003\u0002\u0002\u0002",
    "\u023a\u023b\u0007n\u0002\u0002\u023b\u023c\u0007q\u0002\u0002\u023c",
    "\u023d\u0007p\u0002\u0002\u023d\u023e\u0007i\u0002\u0002\u023eD\u0003",
    "\u0002\u0002\u0002\u023f\u0240\u0007t\u0002\u0002\u0240\u0241\u0007",
    "g\u0002\u0002\u0241\u0242\u0007i\u0002\u0002\u0242\u0243\u0007k\u0002",
    "\u0002\u0243\u0244\u0007u\u0002\u0002\u0244\u0245\u0007v\u0002\u0002",
    "\u0245\u0246\u0007g\u0002\u0002\u0246\u0247\u0007t\u0002\u0002\u0247",
    "F\u0003\u0002\u0002\u0002\u0248\u0249\u0007t\u0002\u0002\u0249\u024a",
    "\u0007g\u0002\u0002\u024a\u024b\u0007u\u0002\u0002\u024b\u024c\u0007",
    "v\u0002\u0002\u024c\u024d\u0007t\u0002\u0002\u024d\u024e\u0007k\u0002",
    "\u0002\u024e\u024f\u0007e\u0002\u0002\u024f\u0250\u0007v\u0002\u0002",
    "\u0250H\u0003\u0002\u0002\u0002\u0251\u0252\u0007t\u0002\u0002\u0252",
    "\u0253\u0007g\u0002\u0002\u0253\u0254\u0007v\u0002\u0002\u0254\u0255",
    "\u0007w\u0002\u0002\u0255\u0256\u0007t\u0002\u0002\u0256\u0257\u0007",
    "p\u0002\u0002\u0257J\u0003\u0002\u0002\u0002\u0258\u0259\u0007u\u0002",
    "\u0002\u0259\u025a\u0007j\u0002\u0002\u025a\u025b\u0007q\u0002\u0002",
    "\u025b\u025c\u0007t\u0002\u0002\u025c\u025d\u0007v\u0002\u0002\u025d",
    "L\u0003\u0002\u0002\u0002\u025e\u025f\u0007u\u0002\u0002\u025f\u0260",
    "\u0007k\u0002\u0002\u0260\u0261\u0007i\u0002\u0002\u0261\u0262\u0007",
    "p\u0002\u0002\u0262\u0263\u0007g\u0002\u0002\u0263\u0264\u0007f\u0002",
    "\u0002\u0264N\u0003\u0002\u0002\u0002\u0265\u0266\u0007u\u0002\u0002",
    "\u0266\u0267\u0007k\u0002\u0002\u0267\u0268\u0007|\u0002\u0002\u0268",
    "\u0269\u0007g\u0002\u0002\u0269\u026a\u0007q\u0002\u0002\u026a\u026b",
    "\u0007h\u0002\u0002\u026bP\u0003\u0002\u0002\u0002\u026c\u026d\u0007",
    "u\u0002\u0002\u026d\u026e\u0007v\u0002\u0002\u026e\u026f\u0007c\u0002",
    "\u0002\u026f\u0270\u0007v\u0002\u0002\u0270\u0271\u0007k\u0002\u0002",
    "\u0271\u0272\u0007e\u0002\u0002\u0272R\u0003\u0002\u0002\u0002\u0273",
    "\u0274\u0007u\u0002\u0002\u0274\u0275\u0007v\u0002\u0002\u0275\u0276",
    "\u0007t\u0002\u0002\u0276\u0277\u0007w\u0002\u0002\u0277\u0278\u0007",
    "e\u0002\u0002\u0278\u0279\u0007v\u0002\u0002\u0279T\u0003\u0002\u0002",
    "\u0002\u027a\u027b\u0007u\u0002\u0002\u027b\u027c\u0007y\u0002\u0002",
    "\u027c\u027d\u0007k\u0002\u0002\u027d\u027e\u0007v\u0002\u0002\u027e",
    "\u027f\u0007e\u0002\u0002\u027f\u0280\u0007j\u0002\u0002\u0280V\u0003",
    "\u0002\u0002\u0002\u0281\u0282\u0007v\u0002\u0002\u0282\u0283\u0007",
    "{\u0002\u0002\u0283\u0284\u0007r\u0002\u0002\u0284\u0285\u0007g\u0002",
    "\u0002\u0285\u0286\u0007f\u0002\u0002\u0286\u0287\u0007g\u0002\u0002",
    "\u0287\u0288\u0007h\u0002\u0002\u0288X\u0003\u0002\u0002\u0002\u0289",
    "\u028a\u0007w\u0002\u0002\u028a\u028b\u0007p\u0002\u0002\u028b\u028c",
    "\u0007k\u0002\u0002\u028c\u028d\u0007q\u0002\u0002\u028d\u028e\u0007",
    "p\u0002\u0002\u028eZ\u0003\u0002\u0002\u0002\u028f\u0290\u0007w\u0002",
    "\u0002\u0290\u0291\u0007p\u0002\u0002\u0291\u0292\u0007u\u0002\u0002",
    "\u0292\u0293\u0007k\u0002\u0002\u0293\u0294\u0007i\u0002\u0002\u0294",
    "\u0295\u0007p\u0002\u0002\u0295\u0296\u0007g\u0002\u0002\u0296\u0297",
    "\u0007f\u0002\u0002\u0297\\\u0003\u0002\u0002\u0002\u0298\u0299\u0007",
    "x\u0002\u0002\u0299\u029a\u0007q\u0002\u0002\u029a\u029b\u0007k\u0002",
    "\u0002\u029b\u029c\u0007f\u0002\u0002\u029c^\u0003\u0002\u0002\u0002",
    "\u029d\u029e\u0007x\u0002\u0002\u029e\u029f\u0007q\u0002\u0002\u029f",
    "\u02a0\u0007n\u0002\u0002\u02a0\u02a1\u0007c\u0002\u0002\u02a1\u02a2",
    "\u0007v\u0002\u0002\u02a2\u02a3\u0007k\u0002\u0002\u02a3\u02a4\u0007",
    "n\u0002\u0002\u02a4\u02a5\u0007g\u0002\u0002\u02a5`\u0003\u0002\u0002",
    "\u0002\u02a6\u02a7\u0007y\u0002\u0002\u02a7\u02a8\u0007j\u0002\u0002",
    "\u02a8\u02a9\u0007k\u0002\u0002\u02a9\u02aa\u0007n\u0002\u0002\u02aa",
    "\u02ab\u0007g\u0002\u0002\u02abb\u0003\u0002\u0002\u0002\u02ac\u02ad",
    "\u0007a\u0002\u0002\u02ad\u02ae\u0007C\u0002\u0002\u02ae\u02af\u0007",
    "n\u0002\u0002\u02af\u02b0\u0007k\u0002\u0002\u02b0\u02b1\u0007i\u0002",
    "\u0002\u02b1\u02b2\u0007p\u0002\u0002\u02b2\u02b3\u0007c\u0002\u0002",
    "\u02b3\u02b4\u0007u\u0002\u0002\u02b4d\u0003\u0002\u0002\u0002\u02b5",
    "\u02b6\u0007a\u0002\u0002\u02b6\u02b7\u0007C\u0002\u0002\u02b7\u02b8",
    "\u0007n\u0002\u0002\u02b8\u02b9\u0007k\u0002\u0002\u02b9\u02ba\u0007",
    "i\u0002\u0002\u02ba\u02bb\u0007p\u0002\u0002\u02bb\u02bc\u0007q\u0002",
    "\u0002\u02bc\u02bd\u0007h\u0002\u0002\u02bdf\u0003\u0002\u0002\u0002",
    "\u02be\u02bf\u0007a\u0002\u0002\u02bf\u02c0\u0007C\u0002\u0002\u02c0",
    "\u02c1\u0007v\u0002\u0002\u02c1\u02c2\u0007q\u0002\u0002\u02c2\u02c3",
    "\u0007o\u0002\u0002\u02c3\u02c4\u0007k\u0002\u0002\u02c4\u02c5\u0007",
    "e\u0002\u0002\u02c5h\u0003\u0002\u0002\u0002\u02c6\u02c7\u0007a\u0002",
    "\u0002\u02c7\u02c8\u0007D\u0002\u0002\u02c8\u02c9\u0007q\u0002\u0002",
    "\u02c9\u02ca\u0007q\u0002\u0002\u02ca\u02cb\u0007n\u0002\u0002\u02cb",
    "j\u0003\u0002\u0002\u0002\u02cc\u02cd\u0007a\u0002\u0002\u02cd\u02ce",
    "\u0007E\u0002\u0002\u02ce\u02cf\u0007q\u0002\u0002\u02cf\u02d0\u0007",
    "o\u0002\u0002\u02d0\u02d1\u0007r\u0002\u0002\u02d1\u02d2\u0007n\u0002",
    "\u0002\u02d2\u02d3\u0007g\u0002\u0002\u02d3\u02d4\u0007z\u0002\u0002",
    "\u02d4l\u0003\u0002\u0002\u0002\u02d5\u02d6\u0007a\u0002\u0002\u02d6",
    "\u02d7\u0007I\u0002\u0002\u02d7\u02d8\u0007g\u0002\u0002\u02d8\u02d9",
    "\u0007p\u0002\u0002\u02d9\u02da\u0007g\u0002\u0002\u02da\u02db\u0007",
    "t\u0002\u0002\u02db\u02dc\u0007k\u0002\u0002\u02dc\u02dd\u0007e\u0002",
    "\u0002\u02ddn\u0003\u0002\u0002\u0002\u02de\u02df\u0007a\u0002\u0002",
    "\u02df\u02e0\u0007K\u0002\u0002\u02e0\u02e1\u0007o\u0002\u0002\u02e1",
    "\u02e2\u0007c\u0002\u0002\u02e2\u02e3\u0007i\u0002\u0002\u02e3\u02e4",
    "\u0007k\u0002\u0002\u02e4\u02e5\u0007p\u0002\u0002\u02e5\u02e6\u0007",
    "c\u0002\u0002\u02e6\u02e7\u0007t\u0002\u0002\u02e7\u02e8\u0007{\u0002",
    "\u0002\u02e8p\u0003\u0002\u0002\u0002\u02e9\u02ea\u0007a\u0002\u0002",
    "\u02ea\u02eb\u0007P\u0002\u0002\u02eb\u02ec\u0007q\u0002\u0002\u02ec",
    "\u02ed\u0007t\u0002\u0002\u02ed\u02ee\u0007g\u0002\u0002\u02ee\u02ef",
    "\u0007v\u0002\u0002\u02ef\u02f0\u0007w\u0002\u0002\u02f0\u02f1\u0007",
    "t\u0002\u0002\u02f1\u02f2\u0007p\u0002\u0002\u02f2r\u0003\u0002\u0002",
    "\u0002\u02f3\u02f4\u0007a\u0002\u0002\u02f4\u02f5\u0007U\u0002\u0002",
    "\u02f5\u02f6\u0007v\u0002\u0002\u02f6\u02f7\u0007c\u0002\u0002\u02f7",
    "\u02f8\u0007v\u0002\u0002\u02f8\u02f9\u0007k\u0002\u0002\u02f9\u02fa",
    "\u0007e\u0002\u0002\u02fa\u02fb\u0007a\u0002\u0002\u02fb\u02fc\u0007",
    "c\u0002\u0002\u02fc\u02fd\u0007u\u0002\u0002\u02fd\u02fe\u0007u\u0002",
    "\u0002\u02fe\u02ff\u0007g\u0002\u0002\u02ff\u0300\u0007t\u0002\u0002",
    "\u0300\u0301\u0007v\u0002\u0002\u0301t\u0003\u0002\u0002\u0002\u0302",
    "\u0303\u0007a\u0002\u0002\u0303\u0304\u0007V\u0002\u0002\u0304\u0305",
    "\u0007j\u0002\u0002\u0305\u0306\u0007t\u0002\u0002\u0306\u0307\u0007",
    "g\u0002\u0002\u0307\u0308\u0007c\u0002\u0002\u0308\u0309\u0007f\u0002",
    "\u0002\u0309\u030a\u0007a\u0002\u0002\u030a\u030b\u0007n\u0002\u0002",
    "\u030b\u030c\u0007q\u0002\u0002\u030c\u030d\u0007e\u0002\u0002\u030d",
    "\u030e\u0007c\u0002\u0002\u030e\u030f\u0007n\u0002\u0002\u030fv\u0003",
    "\u0002\u0002\u0002\u0310\u0311\u0007*\u0002\u0002\u0311x\u0003\u0002",
    "\u0002\u0002\u0312\u0313\u0007+\u0002\u0002\u0313z\u0003\u0002\u0002",
    "\u0002\u0314\u0315\u0007]\u0002\u0002\u0315|\u0003\u0002\u0002\u0002",
    "\u0316\u0317\u0007_\u0002\u0002\u0317~\u0003\u0002\u0002\u0002\u0318",
    "\u0319\u0007}\u0002\u0002\u0319\u0080\u0003\u0002\u0002\u0002\u031a",
    "\u031b\u0007\u007f\u0002\u0002\u031b\u0082\u0003\u0002\u0002\u0002\u031c",
    "\u031d\u0007>\u0002\u0002\u031d\u0084\u0003\u0002\u0002\u0002\u031e",
    "\u031f\u0007>\u0002\u0002\u031f\u0320\u0007?\u0002\u0002\u0320\u0086",
    "\u0003\u0002\u0002\u0002\u0321\u0322\u0007@\u0002\u0002\u0322\u0088",
    "\u0003\u0002\u0002\u0002\u0323\u0324\u0007@\u0002\u0002\u0324\u0325",
    "\u0007?\u0002\u0002\u0325\u008a\u0003\u0002\u0002\u0002\u0326\u0327",
    "\u0007>\u0002\u0002\u0327\u0328\u0007>\u0002\u0002\u0328\u008c\u0003",
    "\u0002\u0002\u0002\u0329\u032a\u0007@\u0002\u0002\u032a\u032b\u0007",
    "@\u0002\u0002\u032b\u008e\u0003\u0002\u0002\u0002\u032c\u032d\u0007",
    "-\u0002\u0002\u032d\u0090\u0003\u0002\u0002\u0002\u032e\u032f\u0007",
    "-\u0002\u0002\u032f\u0330\u0007-\u0002\u0002\u0330\u0092\u0003\u0002",
    "\u0002\u0002\u0331\u0332\u0007/\u0002\u0002\u0332\u0094\u0003\u0002",
    "\u0002\u0002\u0333\u0334\u0007/\u0002\u0002\u0334\u0335\u0007/\u0002",
    "\u0002\u0335\u0096\u0003\u0002\u0002\u0002\u0336\u0337\u0007,\u0002",
    "\u0002\u0337\u0098\u0003\u0002\u0002\u0002\u0338\u0339\u00071\u0002",
    "\u0002\u0339\u009a\u0003\u0002\u0002\u0002\u033a\u033b\u0007\'\u0002",
    "\u0002\u033b\u009c\u0003\u0002\u0002\u0002\u033c\u033d\u0007(\u0002",
    "\u0002\u033d\u009e\u0003\u0002\u0002\u0002\u033e\u033f\u0007~\u0002",
    "\u0002\u033f\u00a0\u0003\u0002\u0002\u0002\u0340\u0341\u0007(\u0002",
    "\u0002\u0341\u0342\u0007(\u0002\u0002\u0342\u00a2\u0003\u0002\u0002",
    "\u0002\u0343\u0344\u0007~\u0002\u0002\u0344\u0345\u0007~\u0002\u0002",
    "\u0345\u00a4\u0003\u0002\u0002\u0002\u0346\u0347\u0007`\u0002\u0002",
    "\u0347\u00a6\u0003\u0002\u0002\u0002\u0348\u0349\u0007#\u0002\u0002",
    "\u0349\u00a8\u0003\u0002\u0002\u0002\u034a\u034b\u0007\u0080\u0002\u0002",
    "\u034b\u00aa\u0003\u0002\u0002\u0002\u034c\u034d\u0007A\u0002\u0002",
    "\u034d\u00ac\u0003\u0002\u0002\u0002\u034e\u034f\u0007<\u0002\u0002",
    "\u034f\u00ae\u0003\u0002\u0002\u0002\u0350\u0351\u0007=\u0002\u0002",
    "\u0351\u00b0\u0003\u0002\u0002\u0002\u0352\u0353\u0007.\u0002\u0002",
    "\u0353\u00b2\u0003\u0002\u0002\u0002\u0354\u0355\u0007?\u0002\u0002",
    "\u0355\u00b4\u0003\u0002\u0002\u0002\u0356\u0357\u0007,\u0002\u0002",
    "\u0357\u0358\u0007?\u0002\u0002\u0358\u00b6\u0003\u0002\u0002\u0002",
    "\u0359\u035a\u00071\u0002\u0002\u035a\u035b\u0007?\u0002\u0002\u035b",
    "\u00b8\u0003\u0002\u0002\u0002\u035c\u035d\u0007\'\u0002\u0002\u035d",
    "\u035e\u0007?\u0002\u0002\u035e\u00ba\u0003\u0002\u0002\u0002\u035f",
    "\u0360\u0007-\u0002\u0002\u0360\u0361\u0007?\u0002\u0002\u0361\u00bc",
    "\u0003\u0002\u0002\u0002\u0362\u0363\u0007/\u0002\u0002\u0363\u0364",
    "\u0007?\u0002\u0002\u0364\u00be\u0003\u0002\u0002\u0002\u0365\u0366",
    "\u0007>\u0002\u0002\u0366\u0367\u0007>\u0002\u0002\u0367\u0368\u0007",
    "?\u0002\u0002\u0368\u00c0\u0003\u0002\u0002\u0002\u0369\u036a\u0007",
    "@\u0002\u0002\u036a\u036b\u0007@\u0002\u0002\u036b\u036c\u0007?\u0002",
    "\u0002\u036c\u00c2\u0003\u0002\u0002\u0002\u036d\u036e\u0007(\u0002",
    "\u0002\u036e\u036f\u0007?\u0002\u0002\u036f\u00c4\u0003\u0002\u0002",
    "\u0002\u0370\u0371\u0007`\u0002\u0002\u0371\u0372\u0007?\u0002\u0002",
    "\u0372\u00c6\u0003\u0002\u0002\u0002\u0373\u0374\u0007~\u0002\u0002",
    "\u0374\u0375\u0007?\u0002\u0002\u0375\u00c8\u0003\u0002\u0002\u0002",
    "\u0376\u0377\u0007?\u0002\u0002\u0377\u0378\u0007?\u0002\u0002\u0378",
    "\u00ca\u0003\u0002\u0002\u0002\u0379\u037a\u0007#\u0002\u0002\u037a",
    "\u037b\u0007?\u0002\u0002\u037b\u00cc\u0003\u0002\u0002\u0002\u037c",
    "\u037d\u0007/\u0002\u0002\u037d\u037e\u0007@\u0002\u0002\u037e\u00ce",
    "\u0003\u0002\u0002\u0002\u037f\u0380\u00070\u0002\u0002\u0380\u00d0",
    "\u0003\u0002\u0002\u0002\u0381\u0382\u00070\u0002\u0002\u0382\u0383",
    "\u00070\u0002\u0002\u0383\u0384\u00070\u0002\u0002\u0384\u00d2\u0003",
    "\u0002\u0002\u0002\u0385\u038a\u0005\u00d5k\u0002\u0386\u0389\u0005",
    "\u00d5k\u0002\u0387\u0389\u0005\u00d9m\u0002\u0388\u0386\u0003\u0002",
    "\u0002\u0002\u0388\u0387\u0003\u0002\u0002\u0002\u0389\u038c\u0003\u0002",
    "\u0002\u0002\u038a\u0388\u0003\u0002\u0002\u0002\u038a\u038b\u0003\u0002",
    "\u0002\u0002\u038b\u00d4\u0003\u0002\u0002\u0002\u038c\u038a\u0003\u0002",
    "\u0002\u0002\u038d\u0390\u0005\u00d7l\u0002\u038e\u0390\u0005\u00db",
    "n\u0002\u038f\u038d\u0003\u0002\u0002\u0002\u038f\u038e\u0003\u0002",
    "\u0002\u0002\u0390\u00d6\u0003\u0002\u0002\u0002\u0391\u0392\t\u0002",
    "\u0002\u0002\u0392\u00d8\u0003\u0002\u0002\u0002\u0393\u0394\t\u0003",
    "\u0002\u0002\u0394\u00da\u0003\u0002\u0002\u0002\u0395\u0396\u0007^",
    "\u0002\u0002\u0396\u0397\u0007w\u0002\u0002\u0397\u0398\u0003\u0002",
    "\u0002\u0002\u0398\u03a0\u0005\u00ddo\u0002\u0399\u039a\u0007^\u0002",
    "\u0002\u039a\u039b\u0007W\u0002\u0002\u039b\u039c\u0003\u0002\u0002",
    "\u0002\u039c\u039d\u0005\u00ddo\u0002\u039d\u039e\u0005\u00ddo\u0002",
    "\u039e\u03a0\u0003\u0002\u0002\u0002\u039f\u0395\u0003\u0002\u0002\u0002",
    "\u039f\u0399\u0003\u0002\u0002\u0002\u03a0\u00dc\u0003\u0002\u0002\u0002",
    "\u03a1\u03a2\u0005\u00f1y\u0002\u03a2\u03a3\u0005\u00f1y\u0002\u03a3",
    "\u03a4\u0005\u00f1y\u0002\u03a4\u03a5\u0005\u00f1y\u0002\u03a5\u00de",
    "\u0003\u0002\u0002\u0002\u03a6\u03aa\u0005\u00e1q\u0002\u03a7\u03aa",
    "\u0005\u00fb~\u0002\u03a8\u03aa\u0005\u0111\u0089\u0002\u03a9\u03a6",
    "\u0003\u0002\u0002\u0002\u03a9\u03a7\u0003\u0002\u0002\u0002\u03a9\u03a8",
    "\u0003\u0002\u0002\u0002\u03aa\u00e0\u0003\u0002\u0002\u0002\u03ab\u03ad",
    "\u0005\u00e5s\u0002\u03ac\u03ae\u0005\u00f3z\u0002\u03ad\u03ac\u0003",
    "\u0002\u0002\u0002\u03ad\u03ae\u0003\u0002\u0002\u0002\u03ae\u03b9\u0003",
    "\u0002\u0002\u0002\u03af\u03b1\u0005\u00e7t\u0002\u03b0\u03b2\u0005",
    "\u00f3z\u0002\u03b1\u03b0\u0003\u0002\u0002\u0002\u03b1\u03b2\u0003",
    "\u0002\u0002\u0002\u03b2\u03b9\u0003\u0002\u0002\u0002\u03b3\u03b5\u0005",
    "\u00e9u\u0002\u03b4\u03b6\u0005\u00f3z\u0002\u03b5\u03b4\u0003\u0002",
    "\u0002\u0002\u03b5\u03b6\u0003\u0002\u0002\u0002\u03b6\u03b9\u0003\u0002",
    "\u0002\u0002\u03b7\u03b9\u0005\u00e3r\u0002\u03b8\u03ab\u0003\u0002",
    "\u0002\u0002\u03b8\u03af\u0003\u0002\u0002\u0002\u03b8\u03b3\u0003\u0002",
    "\u0002\u0002\u03b8\u03b7\u0003\u0002\u0002\u0002\u03b9\u00e2\u0003\u0002",
    "\u0002\u0002\u03ba\u03bb\u00072\u0002\u0002\u03bb\u03bd\t\u0004\u0002",
    "\u0002\u03bc\u03be\t\u0005\u0002\u0002\u03bd\u03bc\u0003\u0002\u0002",
    "\u0002\u03be\u03bf\u0003\u0002\u0002\u0002\u03bf\u03bd\u0003\u0002\u0002",
    "\u0002\u03bf\u03c0\u0003\u0002\u0002\u0002\u03c0\u00e4\u0003\u0002\u0002",
    "\u0002\u03c1\u03c5\u0005\u00edw\u0002\u03c2\u03c4\u0005\u00d9m\u0002",
    "\u03c3\u03c2\u0003\u0002\u0002\u0002\u03c4\u03c7\u0003\u0002\u0002\u0002",
    "\u03c5\u03c3\u0003\u0002\u0002\u0002\u03c5\u03c6\u0003\u0002\u0002\u0002",
    "\u03c6\u00e6\u0003\u0002\u0002\u0002\u03c7\u03c5\u0003\u0002\u0002\u0002",
    "\u03c8\u03cc\u00072\u0002\u0002\u03c9\u03cb\u0005\u00efx\u0002\u03ca",
    "\u03c9\u0003\u0002\u0002\u0002\u03cb\u03ce\u0003\u0002\u0002\u0002\u03cc",
    "\u03ca\u0003\u0002\u0002\u0002\u03cc\u03cd\u0003\u0002\u0002\u0002\u03cd",
    "\u00e8\u0003\u0002\u0002\u0002\u03ce\u03cc\u0003\u0002\u0002\u0002\u03cf",
    "\u03d1\u0005\u00ebv\u0002\u03d0\u03d2\u0005\u00f1y\u0002\u03d1\u03d0",
    "\u0003\u0002\u0002\u0002\u03d2\u03d3\u0003\u0002\u0002\u0002\u03d3\u03d1",
    "\u0003\u0002\u0002\u0002\u03d3\u03d4\u0003\u0002\u0002\u0002\u03d4\u00ea",
    "\u0003\u0002\u0002\u0002\u03d5\u03d6\u00072\u0002\u0002\u03d6\u03d7",
    "\t\u0006\u0002\u0002\u03d7\u00ec\u0003\u0002\u0002\u0002\u03d8\u03d9",
    "\t\u0007\u0002\u0002\u03d9\u00ee\u0003\u0002\u0002\u0002\u03da\u03db",
    "\t\b\u0002\u0002\u03db\u00f0\u0003\u0002\u0002\u0002\u03dc\u03dd\t\t",
    "\u0002\u0002\u03dd\u00f2\u0003\u0002\u0002\u0002\u03de\u03e0\u0005\u00f5",
    "{\u0002\u03df\u03e1\u0005\u00f7|\u0002\u03e0\u03df\u0003\u0002\u0002",
    "\u0002\u03e0\u03e1\u0003\u0002\u0002\u0002\u03e1\u03ee\u0003\u0002\u0002",
    "\u0002\u03e2\u03e3\u0005\u00f5{\u0002\u03e3\u03e4\u0005\u00f9}\u0002",
    "\u03e4\u03ee\u0003\u0002\u0002\u0002\u03e5\u03e7\u0005\u00f7|\u0002",
    "\u03e6\u03e8\u0005\u00f5{\u0002\u03e7\u03e6\u0003\u0002\u0002\u0002",
    "\u03e7\u03e8\u0003\u0002\u0002\u0002\u03e8\u03ee\u0003\u0002\u0002\u0002",
    "\u03e9\u03eb\u0005\u00f9}\u0002\u03ea\u03ec\u0005\u00f5{\u0002\u03eb",
    "\u03ea\u0003\u0002\u0002\u0002\u03eb\u03ec\u0003\u0002\u0002\u0002\u03ec",
    "\u03ee\u0003\u0002\u0002\u0002\u03ed\u03de\u0003\u0002\u0002\u0002\u03ed",
    "\u03e2\u0003\u0002\u0002\u0002\u03ed\u03e5\u0003\u0002\u0002\u0002\u03ed",
    "\u03e9\u0003\u0002\u0002\u0002\u03ee\u00f4\u0003\u0002\u0002\u0002\u03ef",
    "\u03f0\t\n\u0002\u0002\u03f0\u00f6\u0003\u0002\u0002\u0002\u03f1\u03f2",
    "\t\u000b\u0002\u0002\u03f2\u00f8\u0003\u0002\u0002\u0002\u03f3\u03f4",
    "\u0007n\u0002\u0002\u03f4\u03f8\u0007n\u0002\u0002\u03f5\u03f6\u0007",
    "N\u0002\u0002\u03f6\u03f8\u0007N\u0002\u0002\u03f7\u03f3\u0003\u0002",
    "\u0002\u0002\u03f7\u03f5\u0003\u0002\u0002\u0002\u03f8\u00fa\u0003\u0002",
    "\u0002\u0002\u03f9\u03fc\u0005\u00fd\u007f\u0002\u03fa\u03fc\u0005\u00ff",
    "\u0080\u0002\u03fb\u03f9\u0003\u0002\u0002\u0002\u03fb\u03fa\u0003\u0002",
    "\u0002\u0002\u03fc\u00fc\u0003\u0002\u0002\u0002\u03fd\u03ff\u0005\u0101",
    "\u0081\u0002\u03fe\u0400\u0005\u0103\u0082\u0002\u03ff\u03fe\u0003\u0002",
    "\u0002\u0002\u03ff\u0400\u0003\u0002\u0002\u0002\u0400\u0402\u0003\u0002",
    "\u0002\u0002\u0401\u0403\u0005\u010f\u0088\u0002\u0402\u0401\u0003\u0002",
    "\u0002\u0002\u0402\u0403\u0003\u0002\u0002\u0002\u0403\u040a\u0003\u0002",
    "\u0002\u0002\u0404\u0405\u0005\u0107\u0084\u0002\u0405\u0407\u0005\u0103",
    "\u0082\u0002\u0406\u0408\u0005\u010f\u0088\u0002\u0407\u0406\u0003\u0002",
    "\u0002\u0002\u0407\u0408\u0003\u0002\u0002\u0002\u0408\u040a\u0003\u0002",
    "\u0002\u0002\u0409\u03fd\u0003\u0002\u0002\u0002\u0409\u0404\u0003\u0002",
    "\u0002\u0002\u040a\u00fe\u0003\u0002\u0002\u0002\u040b\u040c\u0005\u00eb",
    "v\u0002\u040c\u040d\u0005\u0109\u0085\u0002\u040d\u040f\u0005\u010b",
    "\u0086\u0002\u040e\u0410\u0005\u010f\u0088\u0002\u040f\u040e\u0003\u0002",
    "\u0002\u0002\u040f\u0410\u0003\u0002\u0002\u0002\u0410\u0418\u0003\u0002",
    "\u0002\u0002\u0411\u0412\u0005\u00ebv\u0002\u0412\u0413\u0005\u010d",
    "\u0087\u0002\u0413\u0415\u0005\u010b\u0086\u0002\u0414\u0416\u0005\u010f",
    "\u0088\u0002\u0415\u0414\u0003\u0002\u0002\u0002\u0415\u0416\u0003\u0002",
    "\u0002\u0002\u0416\u0418\u0003\u0002\u0002\u0002\u0417\u040b\u0003\u0002",
    "\u0002\u0002\u0417\u0411\u0003\u0002\u0002\u0002\u0418\u0100\u0003\u0002",
    "\u0002\u0002\u0419\u041b\u0005\u0107\u0084\u0002\u041a\u0419\u0003\u0002",
    "\u0002\u0002\u041a\u041b\u0003\u0002\u0002\u0002\u041b\u041c\u0003\u0002",
    "\u0002\u0002\u041c\u041d\u00070\u0002\u0002\u041d\u0422\u0005\u0107",
    "\u0084\u0002\u041e\u041f\u0005\u0107\u0084\u0002\u041f\u0420\u00070",
    "\u0002\u0002\u0420\u0422\u0003\u0002\u0002\u0002\u0421\u041a\u0003\u0002",
    "\u0002\u0002\u0421\u041e\u0003\u0002\u0002\u0002\u0422\u0102\u0003\u0002",
    "\u0002\u0002\u0423\u0425\u0007g\u0002\u0002\u0424\u0426\u0005\u0105",
    "\u0083\u0002\u0425\u0424\u0003\u0002\u0002\u0002\u0425\u0426\u0003\u0002",
    "\u0002\u0002\u0426\u0427\u0003\u0002\u0002\u0002\u0427\u042e\u0005\u0107",
    "\u0084\u0002\u0428\u042a\u0007G\u0002\u0002\u0429\u042b\u0005\u0105",
    "\u0083\u0002\u042a\u0429\u0003\u0002\u0002\u0002\u042a\u042b\u0003\u0002",
    "\u0002\u0002\u042b\u042c\u0003\u0002\u0002\u0002\u042c\u042e\u0005\u0107",
    "\u0084\u0002\u042d\u0423\u0003\u0002\u0002\u0002\u042d\u0428\u0003\u0002",
    "\u0002\u0002\u042e\u0104\u0003\u0002\u0002\u0002\u042f\u0430\t\f\u0002",
    "\u0002\u0430\u0106\u0003\u0002\u0002\u0002\u0431\u0433\u0005\u00d9m",
    "\u0002\u0432\u0431\u0003\u0002\u0002\u0002\u0433\u0434\u0003\u0002\u0002",
    "\u0002\u0434\u0432\u0003\u0002\u0002\u0002\u0434\u0435\u0003\u0002\u0002",
    "\u0002\u0435\u0108\u0003\u0002\u0002\u0002\u0436\u0438\u0005\u010d\u0087",
    "\u0002\u0437\u0436\u0003\u0002\u0002\u0002\u0437\u0438\u0003\u0002\u0002",
    "\u0002\u0438\u0439\u0003\u0002\u0002\u0002\u0439\u043a\u00070\u0002",
    "\u0002\u043a\u043f\u0005\u010d\u0087\u0002\u043b\u043c\u0005\u010d\u0087",
    "\u0002\u043c\u043d\u00070\u0002\u0002\u043d\u043f\u0003\u0002\u0002",
    "\u0002\u043e\u0437\u0003\u0002\u0002\u0002\u043e\u043b\u0003\u0002\u0002",
    "\u0002\u043f\u010a\u0003\u0002\u0002\u0002\u0440\u0442\u0007r\u0002",
    "\u0002\u0441\u0443\u0005\u0105\u0083\u0002\u0442\u0441\u0003\u0002\u0002",
    "\u0002\u0442\u0443\u0003\u0002\u0002\u0002\u0443\u0444\u0003\u0002\u0002",
    "\u0002\u0444\u044b\u0005\u0107\u0084\u0002\u0445\u0447\u0007R\u0002",
    "\u0002\u0446\u0448\u0005\u0105\u0083\u0002\u0447\u0446\u0003\u0002\u0002",
    "\u0002\u0447\u0448\u0003\u0002\u0002\u0002\u0448\u0449\u0003\u0002\u0002",
    "\u0002\u0449\u044b\u0005\u0107\u0084\u0002\u044a\u0440\u0003\u0002\u0002",
    "\u0002\u044a\u0445\u0003\u0002\u0002\u0002\u044b\u010c\u0003\u0002\u0002",
    "\u0002\u044c\u044e\u0005\u00f1y\u0002\u044d\u044c\u0003\u0002\u0002",
    "\u0002\u044e\u044f\u0003\u0002\u0002\u0002\u044f\u044d\u0003\u0002\u0002",
    "\u0002\u044f\u0450\u0003\u0002\u0002\u0002\u0450\u010e\u0003\u0002\u0002",
    "\u0002\u0451\u0452\t\r\u0002\u0002\u0452\u0110\u0003\u0002\u0002\u0002",
    "\u0453\u0454\u0007)\u0002\u0002\u0454\u0455\u0005\u0113\u008a\u0002",
    "\u0455\u0456\u0007)\u0002\u0002\u0456\u046a\u0003\u0002\u0002\u0002",
    "\u0457\u0458\u0007N\u0002\u0002\u0458\u0459\u0007)\u0002\u0002\u0459",
    "\u045a\u0003\u0002\u0002\u0002\u045a\u045b\u0005\u0113\u008a\u0002\u045b",
    "\u045c\u0007)\u0002\u0002\u045c\u046a\u0003\u0002\u0002\u0002\u045d",
    "\u045e\u0007w\u0002\u0002\u045e\u045f\u0007)\u0002\u0002\u045f\u0460",
    "\u0003\u0002\u0002\u0002\u0460\u0461\u0005\u0113\u008a\u0002\u0461\u0462",
    "\u0007)\u0002\u0002\u0462\u046a\u0003\u0002\u0002\u0002\u0463\u0464",
    "\u0007W\u0002\u0002\u0464\u0465\u0007)\u0002\u0002\u0465\u0466\u0003",
    "\u0002\u0002\u0002\u0466\u0467\u0005\u0113\u008a\u0002\u0467\u0468\u0007",
    ")\u0002\u0002\u0468\u046a\u0003\u0002\u0002\u0002\u0469\u0453\u0003",
    "\u0002\u0002\u0002\u0469\u0457\u0003\u0002\u0002\u0002\u0469\u045d\u0003",
    "\u0002\u0002\u0002\u0469\u0463\u0003\u0002\u0002\u0002\u046a\u0112\u0003",
    "\u0002\u0002\u0002\u046b\u046d\u0005\u0115\u008b\u0002\u046c\u046b\u0003",
    "\u0002\u0002\u0002\u046d\u046e\u0003\u0002\u0002\u0002\u046e\u046c\u0003",
    "\u0002\u0002\u0002\u046e\u046f\u0003\u0002\u0002\u0002\u046f\u0114\u0003",
    "\u0002\u0002\u0002\u0470\u0473\n\u000e\u0002\u0002\u0471\u0473\u0005",
    "\u0117\u008c\u0002\u0472\u0470\u0003\u0002\u0002\u0002\u0472\u0471\u0003",
    "\u0002\u0002\u0002\u0473\u0116\u0003\u0002\u0002\u0002\u0474\u0479\u0005",
    "\u0119\u008d\u0002\u0475\u0479\u0005\u011b\u008e\u0002\u0476\u0479\u0005",
    "\u011d\u008f\u0002\u0477\u0479\u0005\u00dbn\u0002\u0478\u0474\u0003",
    "\u0002\u0002\u0002\u0478\u0475\u0003\u0002\u0002\u0002\u0478\u0476\u0003",
    "\u0002\u0002\u0002\u0478\u0477\u0003\u0002\u0002\u0002\u0479\u0118\u0003",
    "\u0002\u0002\u0002\u047a\u047b\u0007^\u0002\u0002\u047b\u047c\t\u000f",
    "\u0002\u0002\u047c\u011a\u0003\u0002\u0002\u0002\u047d\u047e\u0007^",
    "\u0002\u0002\u047e\u0489\u0005\u00efx\u0002\u047f\u0480\u0007^\u0002",
    "\u0002\u0480\u0481\u0005\u00efx\u0002\u0481\u0482\u0005\u00efx\u0002",
    "\u0482\u0489\u0003\u0002\u0002\u0002\u0483\u0484\u0007^\u0002\u0002",
    "\u0484\u0485\u0005\u00efx\u0002\u0485\u0486\u0005\u00efx\u0002\u0486",
    "\u0487\u0005\u00efx\u0002\u0487\u0489\u0003\u0002\u0002\u0002\u0488",
    "\u047d\u0003\u0002\u0002\u0002\u0488\u047f\u0003\u0002\u0002\u0002\u0488",
    "\u0483\u0003\u0002\u0002\u0002\u0489\u011c\u0003\u0002\u0002\u0002\u048a",
    "\u048b\u0007^\u0002\u0002\u048b\u048c\u0007z\u0002\u0002\u048c\u048e",
    "\u0003\u0002\u0002\u0002\u048d\u048f\u0005\u00f1y\u0002\u048e\u048d",
    "\u0003\u0002\u0002\u0002\u048f\u0490\u0003\u0002\u0002\u0002\u0490\u048e",
    "\u0003\u0002\u0002\u0002\u0490\u0491\u0003\u0002\u0002\u0002\u0491\u011e",
    "\u0003\u0002\u0002\u0002\u0492\u0494\u0005\u0121\u0091\u0002\u0493\u0492",
    "\u0003\u0002\u0002\u0002\u0493\u0494\u0003\u0002\u0002\u0002\u0494\u0495",
    "\u0003\u0002\u0002\u0002\u0495\u0497\u0007$\u0002\u0002\u0496\u0498",
    "\u0005\u0123\u0092\u0002\u0497\u0496\u0003\u0002\u0002\u0002\u0497\u0498",
    "\u0003\u0002\u0002\u0002\u0498\u0499\u0003\u0002\u0002\u0002\u0499\u049a",
    "\u0007$\u0002\u0002\u049a\u0120\u0003\u0002\u0002\u0002\u049b\u049c",
    "\u0007w\u0002\u0002\u049c\u049f\u0007:\u0002\u0002\u049d\u049f\t\u0010",
    "\u0002\u0002\u049e\u049b\u0003\u0002\u0002\u0002\u049e\u049d\u0003\u0002",
    "\u0002\u0002\u049f\u0122\u0003\u0002\u0002\u0002\u04a0\u04a2\u0005\u0125",
    "\u0093\u0002\u04a1\u04a0\u0003\u0002\u0002\u0002\u04a2\u04a3\u0003\u0002",
    "\u0002\u0002\u04a3\u04a1\u0003\u0002\u0002\u0002\u04a3\u04a4\u0003\u0002",
    "\u0002\u0002\u04a4\u0124\u0003\u0002\u0002\u0002\u04a5\u04ad\n\u0011",
    "\u0002\u0002\u04a6\u04ad\u0005\u0117\u008c\u0002\u04a7\u04a8\u0007^",
    "\u0002\u0002\u04a8\u04ad\u0007\f\u0002\u0002\u04a9\u04aa\u0007^\u0002",
    "\u0002\u04aa\u04ab\u0007\u000f\u0002\u0002\u04ab\u04ad\u0007\f\u0002",
    "\u0002\u04ac\u04a5\u0003\u0002\u0002\u0002\u04ac\u04a6\u0003\u0002\u0002",
    "\u0002\u04ac\u04a7\u0003\u0002\u0002\u0002\u04ac\u04a9\u0003\u0002\u0002",
    "\u0002\u04ad\u0126\u0003\u0002\u0002\u0002\u04ae\u04b0\u0007%\u0002",
    "\u0002\u04af\u04b1\u0005\u0131\u0099\u0002\u04b0\u04af\u0003\u0002\u0002",
    "\u0002\u04b0\u04b1\u0003\u0002\u0002\u0002\u04b1\u04b2\u0003\u0002\u0002",
    "\u0002\u04b2\u04b3\u0007f\u0002\u0002\u04b3\u04b4\u0007g\u0002\u0002",
    "\u04b4\u04b5\u0007h\u0002\u0002\u04b5\u04b6\u0007k\u0002\u0002\u04b6",
    "\u04b7\u0007p\u0002\u0002\u04b7\u04b8\u0007g\u0002\u0002\u04b8\u04bc",
    "\u0003\u0002\u0002\u0002\u04b9\u04bb\n\u0012\u0002\u0002\u04ba\u04b9",
    "\u0003\u0002\u0002\u0002\u04bb\u04be\u0003\u0002\u0002\u0002\u04bc\u04ba",
    "\u0003\u0002\u0002\u0002\u04bc\u04bd\u0003\u0002\u0002\u0002\u04bd\u04bf",
    "\u0003\u0002\u0002\u0002\u04be\u04bc\u0003\u0002\u0002\u0002\u04bf\u04c0",
    "\b\u0094\u0002\u0002\u04c0\u0128\u0003\u0002\u0002\u0002\u04c1\u04c2",
    "\u0007c\u0002\u0002\u04c2\u04c3\u0007u\u0002\u0002\u04c3\u04c4\u0007",
    "o\u0002\u0002\u04c4\u04c8\u0003\u0002\u0002\u0002\u04c5\u04c7\n\u0013",
    "\u0002\u0002\u04c6\u04c5\u0003\u0002\u0002\u0002\u04c7\u04ca\u0003\u0002",
    "\u0002\u0002\u04c8\u04c6\u0003\u0002\u0002\u0002\u04c8\u04c9\u0003\u0002",
    "\u0002\u0002\u04c9\u04cb\u0003\u0002\u0002\u0002\u04ca\u04c8\u0003\u0002",
    "\u0002\u0002\u04cb\u04cf\u0007}\u0002\u0002\u04cc\u04ce\n\u0014\u0002",
    "\u0002\u04cd\u04cc\u0003\u0002\u0002\u0002\u04ce\u04d1\u0003\u0002\u0002",
    "\u0002\u04cf\u04cd\u0003\u0002\u0002\u0002\u04cf\u04d0\u0003\u0002\u0002",
    "\u0002\u04d0\u04d2\u0003\u0002\u0002\u0002\u04d1\u04cf\u0003\u0002\u0002",
    "\u0002\u04d2\u04d3\u0007\u007f\u0002\u0002\u04d3\u04d4\u0003\u0002\u0002",
    "\u0002\u04d4\u04d5\b\u0095\u0002\u0002\u04d5\u012a\u0003\u0002\u0002",
    "\u0002\u04d6\u04d7\u0007%\u0002\u0002\u04d7\u04d8\u0007n\u0002\u0002",
    "\u04d8\u04d9\u0007k\u0002\u0002\u04d9\u04da\u0007p\u0002\u0002\u04da",
    "\u04db\u0007g\u0002\u0002\u04db\u04df\u0003\u0002\u0002\u0002\u04dc",
    "\u04de\u0005\u0131\u0099\u0002\u04dd\u04dc\u0003\u0002\u0002\u0002\u04de",
    "\u04e1\u0003\u0002\u0002\u0002\u04df\u04dd\u0003\u0002\u0002\u0002\u04df",
    "\u04e0\u0003\u0002\u0002\u0002\u04e0\u04e5\u0003\u0002\u0002\u0002\u04e1",
    "\u04df\u0003\u0002\u0002\u0002\u04e2\u04e4\n\u0015\u0002\u0002\u04e3",
    "\u04e2\u0003\u0002\u0002\u0002\u04e4\u04e7\u0003\u0002\u0002\u0002\u04e5",
    "\u04e3\u0003\u0002\u0002\u0002\u04e5\u04e6\u0003\u0002\u0002\u0002\u04e6",
    "\u04e8\u0003\u0002\u0002\u0002\u04e7\u04e5\u0003\u0002\u0002\u0002\u04e8",
    "\u04e9\b\u0096\u0002\u0002\u04e9\u012c\u0003\u0002\u0002\u0002\u04ea",
    "\u04ec\u0007%\u0002\u0002\u04eb\u04ed\u0005\u0131\u0099\u0002\u04ec",
    "\u04eb\u0003\u0002\u0002\u0002\u04ec\u04ed\u0003\u0002\u0002\u0002\u04ed",
    "\u04ee\u0003\u0002\u0002\u0002\u04ee\u04f0\u0005\u00e5s\u0002\u04ef",
    "\u04f1\u0005\u0131\u0099\u0002\u04f0\u04ef\u0003\u0002\u0002\u0002\u04f0",
    "\u04f1\u0003\u0002\u0002\u0002\u04f1\u04f2\u0003\u0002\u0002\u0002\u04f2",
    "\u04f6\u0005\u011f\u0090\u0002\u04f3\u04f5\n\u0015\u0002\u0002\u04f4",
    "\u04f3\u0003\u0002\u0002\u0002\u04f5\u04f8\u0003\u0002\u0002\u0002\u04f6",
    "\u04f4\u0003\u0002\u0002\u0002\u04f6\u04f7\u0003\u0002\u0002\u0002\u04f7",
    "\u04f9\u0003\u0002\u0002\u0002\u04f8\u04f6\u0003\u0002\u0002\u0002\u04f9",
    "\u04fa\b\u0097\u0002\u0002\u04fa\u012e\u0003\u0002\u0002\u0002\u04fb",
    "\u04fd\u0007%\u0002\u0002\u04fc\u04fe\u0005\u0131\u0099\u0002\u04fd",
    "\u04fc\u0003\u0002\u0002\u0002\u04fd\u04fe\u0003\u0002\u0002\u0002\u04fe",
    "\u04ff\u0003\u0002\u0002\u0002\u04ff\u0500\u0007r\u0002\u0002\u0500",
    "\u0501\u0007t\u0002\u0002\u0501\u0502\u0007c\u0002\u0002\u0502\u0503",
    "\u0007i\u0002\u0002\u0503\u0504\u0007o\u0002\u0002\u0504\u0505\u0007",
    "c\u0002\u0002\u0505\u0506\u0003\u0002\u0002\u0002\u0506\u050a\u0005",
    "\u0131\u0099\u0002\u0507\u0509\n\u0015\u0002\u0002\u0508\u0507\u0003",
    "\u0002\u0002\u0002\u0509\u050c\u0003\u0002\u0002\u0002\u050a\u0508\u0003",
    "\u0002\u0002\u0002\u050a\u050b\u0003\u0002\u0002\u0002\u050b\u050d\u0003",
    "\u0002\u0002\u0002\u050c\u050a\u0003\u0002\u0002\u0002\u050d\u050e\b",
    "\u0098\u0002\u0002\u050e\u0130\u0003\u0002\u0002\u0002\u050f\u0511\t",
    "\u0016\u0002\u0002\u0510\u050f\u0003\u0002\u0002\u0002\u0511\u0512\u0003",
    "\u0002\u0002\u0002\u0512\u0510\u0003\u0002\u0002\u0002\u0512\u0513\u0003",
    "\u0002\u0002\u0002\u0513\u0514\u0003\u0002\u0002\u0002\u0514\u0515\b",
    "\u0099\u0002\u0002\u0515\u0132\u0003\u0002\u0002\u0002\u0516\u0518\u0007",
    "\u000f\u0002\u0002\u0517\u0519\u0007\f\u0002\u0002\u0518\u0517\u0003",
    "\u0002\u0002\u0002\u0518\u0519\u0003\u0002\u0002\u0002\u0519\u051c\u0003",
    "\u0002\u0002\u0002\u051a\u051c\u0007\f\u0002\u0002\u051b\u0516\u0003",
    "\u0002\u0002\u0002\u051b\u051a\u0003\u0002\u0002\u0002\u051c\u051d\u0003",
    "\u0002\u0002\u0002\u051d\u051e\b\u009a\u0002\u0002\u051e\u0134\u0003",
    "\u0002\u0002\u0002\u051f\u0520\u00071\u0002\u0002\u0520\u0521\u0007",
    ",\u0002\u0002\u0521\u0525\u0003\u0002\u0002\u0002\u0522\u0524\u000b",
    "\u0002\u0002\u0002\u0523\u0522\u0003\u0002\u0002\u0002\u0524\u0527\u0003",
    "\u0002\u0002\u0002\u0525\u0526\u0003\u0002\u0002\u0002\u0525\u0523\u0003",
    "\u0002\u0002\u0002\u0526\u0528\u0003\u0002\u0002\u0002\u0527\u0525\u0003",
    "\u0002\u0002\u0002\u0528\u0529\u0007,\u0002\u0002\u0529\u052a\u0007",
    "1\u0002\u0002\u052a\u052b\u0003\u0002\u0002\u0002\u052b\u052c\b\u009b",
    "\u0002\u0002\u052c\u0136\u0003\u0002\u0002\u0002\u052d\u052e\u00071",
    "\u0002\u0002\u052e\u052f\u00071\u0002\u0002\u052f\u0533\u0003\u0002",
    "\u0002\u0002\u0530\u0532\n\u0015\u0002\u0002\u0531\u0530\u0003\u0002",
    "\u0002\u0002\u0532\u0535\u0003\u0002\u0002\u0002\u0533\u0531\u0003\u0002",
    "\u0002\u0002\u0533\u0534\u0003\u0002\u0002\u0002\u0534\u0536\u0003\u0002",
    "\u0002\u0002\u0535\u0533\u0003\u0002\u0002\u0002\u0536\u0537\b\u009c",
    "\u0002\u0002\u0537\u0138\u0003\u0002\u0002\u0002D\u0002\u0388\u038a",
    "\u038f\u039f\u03a9\u03ad\u03b1\u03b5\u03b8\u03bf\u03c5\u03cc\u03d3\u03e0",
    "\u03e7\u03eb\u03ed\u03f7\u03fb\u03ff\u0402\u0407\u0409\u040f\u0415\u0417",
    "\u041a\u0421\u0425\u042a\u042d\u0434\u0437\u043e\u0442\u0447\u044a\u044f",
    "\u0469\u046e\u0472\u0478\u0488\u0490\u0493\u0497\u049e\u04a3\u04ac\u04b0",
    "\u04bc\u04c8\u04cf\u04df\u04e5\u04ec\u04f0\u04f6\u04fd\u050a\u0512\u0518",
    "\u051b\u0525\u0533\u0003\b\u0002\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function CLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

CLexer.prototype = Object.create(antlr4.Lexer.prototype);
CLexer.prototype.constructor = CLexer;

Object.defineProperty(CLexer.prototype, "atn", {
        get : function() {
                return atn;
        }
});

CLexer.EOF = antlr4.Token.EOF;
CLexer.T__0 = 1;
CLexer.T__1 = 2;
CLexer.T__2 = 3;
CLexer.T__3 = 4;
CLexer.T__4 = 5;
CLexer.T__5 = 6;
CLexer.T__6 = 7;
CLexer.T__7 = 8;
CLexer.T__8 = 9;
CLexer.T__9 = 10;
CLexer.T__10 = 11;
CLexer.T__11 = 12;
CLexer.T__12 = 13;
CLexer.T__13 = 14;
CLexer.Auto = 15;
CLexer.Break = 16;
CLexer.Case = 17;
CLexer.Char = 18;
CLexer.Const = 19;
CLexer.Continue = 20;
CLexer.Default = 21;
CLexer.Do = 22;
CLexer.Double = 23;
CLexer.Else = 24;
CLexer.Enum = 25;
CLexer.Extern = 26;
CLexer.Float = 27;
CLexer.For = 28;
CLexer.Goto = 29;
CLexer.If = 30;
CLexer.Inline = 31;
CLexer.Int = 32;
CLexer.Long = 33;
CLexer.Register = 34;
CLexer.Restrict = 35;
CLexer.Return = 36;
CLexer.Short = 37;
CLexer.Signed = 38;
CLexer.Sizeof = 39;
CLexer.Static = 40;
CLexer.Struct = 41;
CLexer.Switch = 42;
CLexer.Typedef = 43;
CLexer.Union = 44;
CLexer.Unsigned = 45;
CLexer.Void = 46;
CLexer.Volatile = 47;
CLexer.While = 48;
CLexer.Alignas = 49;
CLexer.Alignof = 50;
CLexer.Atomic = 51;
CLexer.Bool = 52;
CLexer.Complex = 53;
CLexer.Generic = 54;
CLexer.Imaginary = 55;
CLexer.Noreturn = 56;
CLexer.StaticAssert = 57;
CLexer.ThreadLocal = 58;
CLexer.LeftParen = 59;
CLexer.RightParen = 60;
CLexer.LeftBracket = 61;
CLexer.RightBracket = 62;
CLexer.LeftBrace = 63;
CLexer.RightBrace = 64;
CLexer.Less = 65;
CLexer.LessEqual = 66;
CLexer.Greater = 67;
CLexer.GreaterEqual = 68;
CLexer.LeftShift = 69;
CLexer.RightShift = 70;
CLexer.Plus = 71;
CLexer.PlusPlus = 72;
CLexer.Minus = 73;
CLexer.MinusMinus = 74;
CLexer.Star = 75;
CLexer.Div = 76;
CLexer.Mod = 77;
CLexer.And = 78;
CLexer.Or = 79;
CLexer.AndAnd = 80;
CLexer.OrOr = 81;
CLexer.Caret = 82;
CLexer.Not = 83;
CLexer.Tilde = 84;
CLexer.Question = 85;
CLexer.Colon = 86;
CLexer.Semi = 87;
CLexer.Comma = 88;
CLexer.Assign = 89;
CLexer.StarAssign = 90;
CLexer.DivAssign = 91;
CLexer.ModAssign = 92;
CLexer.PlusAssign = 93;
CLexer.MinusAssign = 94;
CLexer.LeftShiftAssign = 95;
CLexer.RightShiftAssign = 96;
CLexer.AndAssign = 97;
CLexer.XorAssign = 98;
CLexer.OrAssign = 99;
CLexer.Equal = 100;
CLexer.NotEqual = 101;
CLexer.Arrow = 102;
CLexer.Dot = 103;
CLexer.Ellipsis = 104;
CLexer.Identifier = 105;
CLexer.Constant = 106;
CLexer.DigitSequence = 107;
CLexer.StringLiteral = 108;
CLexer.ComplexDefine = 109;
CLexer.AsmBlock = 110;
CLexer.LineAfterPreprocessing = 111;
CLexer.LineDirective = 112;
CLexer.PragmaDirective = 113;
CLexer.Whitespace = 114;
CLexer.Newline = 115;
CLexer.BlockComment = 116;
CLexer.LineComment = 117;

CLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

CLexer.prototype.modeNames = [ "DEFAULT_MODE" ];

CLexer.prototype.literalNames = [ null, "'__extension__'", "'__builtin_va_arg'", 
                                  "'__builtin_offsetof'", "'__m128'", "'__m128d'", 
                                  "'__m128i'", "'__typeof__'", "'__inline__'", 
                                  "'__stdcall'", "'__declspec'", "'__asm'", 
                                  "'__attribute__'", "'__asm__'", "'__volatile__'", 
                                  "'auto'", "'break'", "'case'", "'char'", 
                                  "'const'", "'continue'", "'default'", 
                                  "'do'", "'double'", "'else'", "'enum'", 
                                  "'extern'", "'float'", "'for'", "'goto'", 
                                  "'if'", "'inline'", "'int'", "'long'", 
                                  "'register'", "'restrict'", "'return'", 
                                  "'short'", "'signed'", "'sizeof'", "'static'", 
                                  "'struct'", "'switch'", "'typedef'", "'union'", 
                                  "'unsigned'", "'void'", "'volatile'", 
                                  "'while'", "'_Alignas'", "'_Alignof'", 
                                  "'_Atomic'", "'_Bool'", "'_Complex'", 
                                  "'_Generic'", "'_Imaginary'", "'_Noreturn'", 
                                  "'_Static_assert'", "'_Thread_local'", 
                                  "'('", "')'", "'['", "']'", "'{'", "'}'", 
                                  "'<'", "'<='", "'>'", "'>='", "'<<'", 
                                  "'>>'", "'+'", "'++'", "'-'", "'--'", 
                                  "'*'", "'/'", "'%'", "'&'", "'|'", "'&&'", 
                                  "'||'", "'^'", "'!'", "'~'", "'?'", "':'", 
                                  "';'", "','", "'='", "'*='", "'/='", "'%='", 
                                  "'+='", "'-='", "'<<='", "'>>='", "'&='", 
                                  "'^='", "'|='", "'=='", "'!='", "'->'", 
                                  "'.'", "'...'" ];

CLexer.prototype.symbolicNames = [ null, null, null, null, null, null, null, 
                                   null, null, null, null, null, null, null, 
                                   null, "Auto", "Break", "Case", "Char", 
                                   "Const", "Continue", "Default", "Do", 
                                   "Double", "Else", "Enum", "Extern", "Float", 
                                   "For", "Goto", "If", "Inline", "Int", 
                                   "Long", "Register", "Restrict", "Return", 
                                   "Short", "Signed", "Sizeof", "Static", 
                                   "Struct", "Switch", "Typedef", "Union", 
                                   "Unsigned", "Void", "Volatile", "While", 
                                   "Alignas", "Alignof", "Atomic", "Bool", 
                                   "Complex", "Generic", "Imaginary", "Noreturn", 
                                   "StaticAssert", "ThreadLocal", "LeftParen", 
                                   "RightParen", "LeftBracket", "RightBracket", 
                                   "LeftBrace", "RightBrace", "Less", "LessEqual", 
                                   "Greater", "GreaterEqual", "LeftShift", 
                                   "RightShift", "Plus", "PlusPlus", "Minus", 
                                   "MinusMinus", "Star", "Div", "Mod", "And", 
                                   "Or", "AndAnd", "OrOr", "Caret", "Not", 
                                   "Tilde", "Question", "Colon", "Semi", 
                                   "Comma", "Assign", "StarAssign", "DivAssign", 
                                   "ModAssign", "PlusAssign", "MinusAssign", 
                                   "LeftShiftAssign", "RightShiftAssign", 
                                   "AndAssign", "XorAssign", "OrAssign", 
                                   "Equal", "NotEqual", "Arrow", "Dot", 
                                   "Ellipsis", "Identifier", "Constant", 
                                   "DigitSequence", "StringLiteral", "ComplexDefine", 
                                   "AsmBlock", "LineAfterPreprocessing", 
                                   "LineDirective", "PragmaDirective", "Whitespace", 
                                   "Newline", "BlockComment", "LineComment" ];

CLexer.prototype.ruleNames = [ "T__0", "T__1", "T__2", "T__3", "T__4", "T__5", 
                               "T__6", "T__7", "T__8", "T__9", "T__10", 
                               "T__11", "T__12", "T__13", "Auto", "Break", 
                               "Case", "Char", "Const", "Continue", "Default", 
                               "Do", "Double", "Else", "Enum", "Extern", 
                               "Float", "For", "Goto", "If", "Inline", "Int", 
                               "Long", "Register", "Restrict", "Return", 
                               "Short", "Signed", "Sizeof", "Static", "Struct", 
                               "Switch", "Typedef", "Union", "Unsigned", 
                               "Void", "Volatile", "While", "Alignas", "Alignof", 
                               "Atomic", "Bool", "Complex", "Generic", "Imaginary", 
                               "Noreturn", "StaticAssert", "ThreadLocal", 
                               "LeftParen", "RightParen", "LeftBracket", 
                               "RightBracket", "LeftBrace", "RightBrace", 
                               "Less", "LessEqual", "Greater", "GreaterEqual", 
                               "LeftShift", "RightShift", "Plus", "PlusPlus", 
                               "Minus", "MinusMinus", "Star", "Div", "Mod", 
                               "And", "Or", "AndAnd", "OrOr", "Caret", "Not", 
                               "Tilde", "Question", "Colon", "Semi", "Comma", 
                               "Assign", "StarAssign", "DivAssign", "ModAssign", 
                               "PlusAssign", "MinusAssign", "LeftShiftAssign", 
                               "RightShiftAssign", "AndAssign", "XorAssign", 
                               "OrAssign", "Equal", "NotEqual", "Arrow", 
                               "Dot", "Ellipsis", "Identifier", "IdentifierNondigit", 
                               "Nondigit", "Digit", "UniversalCharacterName", 
                               "HexQuad", "Constant", "IntegerConstant", 
                               "BinaryConstant", "DecimalConstant", "OctalConstant", 
                               "HexadecimalConstant", "HexadecimalPrefix", 
                               "NonzeroDigit", "OctalDigit", "HexadecimalDigit", 
                               "IntegerSuffix", "UnsignedSuffix", "LongSuffix", 
                               "LongLongSuffix", "FloatingConstant", "DecimalFloatingConstant", 
                               "HexadecimalFloatingConstant", "FractionalConstant", 
                               "ExponentPart", "Sign", "DigitSequence", 
                               "HexadecimalFractionalConstant", "BinaryExponentPart", 
                               "HexadecimalDigitSequence", "FloatingSuffix", 
                               "CharacterConstant", "CCharSequence", "CChar", 
                               "EscapeSequence", "SimpleEscapeSequence", 
                               "OctalEscapeSequence", "HexadecimalEscapeSequence", 
                               "StringLiteral", "EncodingPrefix", "SCharSequence", 
                               "SChar", "ComplexDefine", "AsmBlock", "LineAfterPreprocessing", 
                               "LineDirective", "PragmaDirective", "Whitespace", 
                               "Newline", "BlockComment", "LineComment" ];

CLexer.prototype.grammarFileName = "C.g4";



exports.CLexer = CLexer;



/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// Generated from C.g4 by ANTLR 4.7.1
// jshint ignore: start
var antlr4 = __webpack_require__(24);
var CVisitor = __webpack_require__(69).CVisitor;

var grammarFileName = "C.g4";

var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003w\u0506\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t",
    "\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007\u0004",
    "\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f\u0004",
    "\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004",
    "\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t",
    "\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004",
    "\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b\t",
    "\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e\t\u001e\u0004",
    "\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#\t#\u0004$\t$\u0004",
    "%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004*\t*\u0004+\t+\u0004",
    ",\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u00041\t1\u00042\t2\u0004",
    "3\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u00048\t8\u00049\t9\u0004",
    ":\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004?\t?\u0004@\t@\u0004",
    "A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004F\tF\u0004G\tG\u0004",
    "H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004M\tM\u0004N\tN\u0004",
    "O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004T\tT\u0004U\tU\u0004",
    "V\tV\u0004W\tW\u0004X\tX\u0003\u0002\u0003\u0002\u0003\u0002\u0006\u0002",
    "\u00b4\n\u0002\r\u0002\u000e\u0002\u00b5\u0003\u0002\u0003\u0002\u0003",
    "\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0005\u0002\u00be\n\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0005\u0002\u00d2\n\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0007\u0004\u00e1\n\u0004",
    "\f\u0004\u000e\u0004\u00e4\u000b\u0004\u0003\u0005\u0003\u0005\u0003",
    "\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0005\u0005\u00ed",
    "\n\u0005\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0005\u0006",
    "\u0111\n\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003",
    "\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0005\u0006\u011b\n\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0007\u0006",
    "\u0128\n\u0006\f\u0006\u000e\u0006\u012b\u000b\u0006\u0003\u0007\u0003",
    "\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0007\u0007\u0133",
    "\n\u0007\f\u0007\u000e\u0007\u0136\u000b\u0007\u0003\b\u0003\b\u0003",
    "\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003",
    "\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003",
    "\b\u0003\b\u0005\b\u014e\n\b\u0003\t\u0003\t\u0003\n\u0003\n\u0003\n",
    "\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0005\n\u015f\n\n\u0003\u000b\u0003\u000b\u0003\u000b\u0003",
    "\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003",
    "\u000b\u0003\u000b\u0003\u000b\u0007\u000b\u016d\n\u000b\f\u000b\u000e",
    "\u000b\u0170\u000b\u000b\u0003\f\u0003\f\u0003\f\u0003\f\u0003\f\u0003",
    "\f\u0003\f\u0003\f\u0003\f\u0007\f\u017b\n\f\f\f\u000e\f\u017e\u000b",
    "\f\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0007\r\u0189\n\r\f\r\u000e\r\u018c\u000b\r\u0003\u000e\u0003\u000e",
    "\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e",
    "\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e",
    "\u0003\u000e\u0007\u000e\u019d\n\u000e\f\u000e\u000e\u000e\u01a0\u000b",
    "\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003",
    "\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0007\u000f\u01ab\n\u000f",
    "\f\u000f\u000e\u000f\u01ae\u000b\u000f\u0003\u0010\u0003\u0010\u0003",
    "\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0007\u0010\u01b6\n\u0010",
    "\f\u0010\u000e\u0010\u01b9\u000b\u0010\u0003\u0011\u0003\u0011\u0003",
    "\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0007\u0011\u01c1\n\u0011",
    "\f\u0011\u000e\u0011\u01c4\u000b\u0011\u0003\u0012\u0003\u0012\u0003",
    "\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0007\u0012\u01cc\n\u0012",
    "\f\u0012\u000e\u0012\u01cf\u000b\u0012\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0007\u0013\u01d7\n\u0013",
    "\f\u0013\u000e\u0013\u01da\u000b\u0013\u0003\u0014\u0003\u0014\u0003",
    "\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0007\u0014\u01e2\n\u0014",
    "\f\u0014\u000e\u0014\u01e5\u000b\u0014\u0003\u0015\u0003\u0015\u0003",
    "\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0005\u0015\u01ed\n\u0015",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0005\u0016\u01f5\n\u0016\u0003\u0017\u0003\u0017\u0003\u0018\u0003",
    "\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0007\u0018\u01ff",
    "\n\u0018\f\u0018\u000e\u0018\u0202\u000b\u0018\u0003\u0019\u0003\u0019",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a",
    "\u0003\u001a\u0003\u001a\u0005\u001a\u020e\n\u001a\u0003\u001b\u0006",
    "\u001b\u0211\n\u001b\r\u001b\u000e\u001b\u0212\u0003\u001c\u0006\u001c",
    "\u0216\n\u001c\r\u001c\u000e\u001c\u0217\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0005\u001d\u021f\n\u001d\u0003\u001e",
    "\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0007\u001e",
    "\u0227\n\u001e\f\u001e\u000e\u001e\u022a\u000b\u001e\u0003\u001f\u0003",
    "\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0005\u001f\u0231\n\u001f",
    "\u0003 \u0003 \u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003",
    "!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0005!\u0243\n!\u0003\"",
    "\u0003\"\u0005\"\u0247\n\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003",
    "\"\u0003\"\u0005\"\u0250\n\"\u0003#\u0003#\u0003$\u0003$\u0003$\u0003",
    "$\u0003$\u0007$\u0259\n$\f$\u000e$\u025c\u000b$\u0003%\u0003%\u0005",
    "%\u0260\n%\u0003%\u0003%\u0003%\u0005%\u0265\n%\u0003&\u0003&\u0005",
    "&\u0269\n&\u0003&\u0003&\u0005&\u026d\n&\u0005&\u026f\n&\u0003\'\u0003",
    "\'\u0003\'\u0003\'\u0003\'\u0003\'\u0007\'\u0277\n\'\f\'\u000e\'\u027a",
    "\u000b\'\u0003(\u0003(\u0005(\u027e\n(\u0003(\u0003(\u0005(\u0282\n",
    "(\u0003)\u0003)\u0005)\u0286\n)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003",
    ")\u0005)\u028e\n)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0005",
    ")\u0297\n)\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0007*\u029f\n",
    "*\f*\u000e*\u02a2\u000b*\u0003+\u0003+\u0003+\u0003+\u0003+\u0005+\u02a9",
    "\n+\u0003,\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003.\u0003.\u0003",
    "/\u0003/\u0003/\u0003/\u0003/\u0003/\u0005/\u02ba\n/\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00050\u02c6\n0\u0003",
    "1\u00051\u02c9\n1\u00031\u00031\u00071\u02cd\n1\f1\u000e1\u02d0\u000b",
    "1\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u0005",
    "2\u02db\n2\u00032\u00032\u00032\u00052\u02e0\n2\u00032\u00052\u02e3",
    "\n2\u00032\u00032\u00032\u00032\u00032\u00052\u02ea\n2\u00032\u0003",
    "2\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u0003",
    "2\u00032\u00052\u02f9\n2\u00032\u00032\u00032\u00032\u00032\u00032\u0003",
    "2\u00032\u00032\u00032\u00052\u0305\n2\u00032\u00072\u0308\n2\f2\u000e",
    "2\u030b\u000b2\u00033\u00033\u00033\u00063\u0310\n3\r3\u000e3\u0311",
    "\u00033\u00033\u00053\u0316\n3\u00034\u00034\u00034\u00034\u00034\u0003",
    "4\u00034\u00035\u00035\u00035\u00075\u0322\n5\f5\u000e5\u0325\u000b",
    "5\u00035\u00055\u0328\n5\u00036\u00036\u00036\u00056\u032d\n6\u0003",
    "6\u00056\u0330\n6\u00036\u00056\u0333\n6\u00037\u00037\u00037\u0003",
    "7\u00037\u00077\u033a\n7\f7\u000e7\u033d\u000b7\u00038\u00038\u0005",
    "8\u0341\n8\u00038\u00038\u00058\u0345\n8\u00038\u00038\u00038\u0005",
    "8\u034a\n8\u00038\u00038\u00058\u034e\n8\u00038\u00058\u0351\n8\u0003",
    "9\u00039\u00039\u00039\u00039\u00079\u0358\n9\f9\u000e9\u035b\u000b",
    "9\u0003:\u0003:\u0003:\u0003:\u0003:\u0005:\u0362\n:\u0003;\u0003;\u0003",
    ";\u0003;\u0003;\u0003;\u0007;\u036a\n;\f;\u000e;\u036d\u000b;\u0003",
    "<\u0003<\u0003<\u0003<\u0003<\u0005<\u0374\n<\u0005<\u0376\n<\u0003",
    "=\u0003=\u0003=\u0003=\u0003=\u0003=\u0007=\u037e\n=\f=\u000e=\u0381",
    "\u000b=\u0003>\u0003>\u0005>\u0385\n>\u0003?\u0003?\u0005?\u0389\n?",
    "\u0003?\u0003?\u0007?\u038d\n?\f?\u000e?\u0390\u000b?\u0005?\u0392\n",
    "?\u0003@\u0003@\u0003@\u0003@\u0003@\u0007@\u0399\n@\f@\u000e@\u039c",
    "\u000b@\u0003@\u0003@\u0005@\u03a0\n@\u0003@\u0005@\u03a3\n@\u0003@",
    "\u0003@\u0003@\u0003@\u0005@\u03a9\n@\u0003@\u0003@\u0003@\u0003@\u0003",
    "@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0005",
    "@\u03b9\n@\u0003@\u0003@\u0007@\u03bd\n@\f@\u000e@\u03c0\u000b@\u0005",
    "@\u03c2\n@\u0003@\u0003@\u0003@\u0005@\u03c7\n@\u0003@\u0005@\u03ca",
    "\n@\u0003@\u0003@\u0003@\u0003@\u0003@\u0005@\u03d1\n@\u0003@\u0003",
    "@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003",
    "@\u0003@\u0003@\u0003@\u0003@\u0003@\u0005@\u03e4\n@\u0003@\u0003@\u0007",
    "@\u03e8\n@\f@\u000e@\u03eb\u000b@\u0007@\u03ed\n@\f@\u000e@\u03f0\u000b",
    "@\u0003A\u0003A\u0003B\u0003B\u0003B\u0003B\u0003B\u0003B\u0003B\u0003",
    "B\u0003B\u0003B\u0005B\u03fe\nB\u0003C\u0003C\u0005C\u0402\nC\u0003",
    "C\u0003C\u0003C\u0003C\u0003C\u0005C\u0409\nC\u0003C\u0007C\u040c\n",
    "C\fC\u000eC\u040f\u000bC\u0003D\u0003D\u0003D\u0003E\u0003E\u0003E\u0003",
    "E\u0003E\u0007E\u0419\nE\fE\u000eE\u041c\u000bE\u0003F\u0003F\u0003",
    "F\u0003F\u0003F\u0003F\u0005F\u0424\nF\u0003G\u0003G\u0003G\u0003G\u0003",
    "G\u0006G\u042b\nG\rG\u000eG\u042c\u0003G\u0003G\u0003G\u0003H\u0003",
    "H\u0003H\u0003H\u0003H\u0003H\u0003H\u0003H\u0003H\u0003H\u0003H\u0003",
    "H\u0007H\u043e\nH\fH\u000eH\u0441\u000bH\u0005H\u0443\nH\u0003H\u0003",
    "H\u0003H\u0003H\u0007H\u0449\nH\fH\u000eH\u044c\u000bH\u0005H\u044e",
    "\nH\u0007H\u0450\nH\fH\u000eH\u0453\u000bH\u0003H\u0003H\u0005H\u0457",
    "\nH\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003",
    "I\u0003I\u0005I\u0464\nI\u0003J\u0003J\u0005J\u0468\nJ\u0003J\u0003",
    "J\u0003K\u0003K\u0003K\u0003K\u0003K\u0007K\u0471\nK\fK\u000eK\u0474",
    "\u000bK\u0003L\u0003L\u0005L\u0478\nL\u0003M\u0005M\u047b\nM\u0003M",
    "\u0003M\u0003N\u0003N\u0003N\u0003N\u0003N\u0003N\u0003N\u0005N\u0486",
    "\nN\u0003N\u0003N\u0003N\u0003N\u0003N\u0003N\u0005N\u048e\nN\u0003",
    "O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003",
    "O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0003O\u0005",
    "O\u04a4\nO\u0003P\u0003P\u0003P\u0005P\u04a9\nP\u0003P\u0003P\u0005",
    "P\u04ad\nP\u0003P\u0005P\u04b0\nP\u0003P\u0003P\u0005P\u04b4\nP\u0003",
    "P\u0003P\u0005P\u04b8\nP\u0005P\u04ba\nP\u0003Q\u0003Q\u0003Q\u0003",
    "Q\u0005Q\u04c0\nQ\u0003R\u0003R\u0003R\u0003R\u0003R\u0003R\u0007R\u04c8",
    "\nR\fR\u000eR\u04cb\u000bR\u0003S\u0003S\u0003S\u0003S\u0003S\u0003",
    "S\u0003S\u0003S\u0003S\u0005S\u04d6\nS\u0003S\u0003S\u0003S\u0003S\u0003",
    "S\u0005S\u04dd\nS\u0003T\u0005T\u04e0\nT\u0003T\u0003T\u0003U\u0003",
    "U\u0003U\u0003U\u0003U\u0007U\u04e9\nU\fU\u000eU\u04ec\u000bU\u0003",
    "V\u0003V\u0003V\u0005V\u04f1\nV\u0003W\u0005W\u04f4\nW\u0003W\u0003",
    "W\u0005W\u04f8\nW\u0003W\u0003W\u0003X\u0003X\u0003X\u0003X\u0003X\u0007",
    "X\u0501\nX\fX\u000eX\u0504\u000bX\u0003X\u0002\u001f\u0006\n\f\u0014",
    "\u0016\u0018\u001a\u001c\u001e \"$&.:FLRbptx~\u0084\u0088\u0094\u00a2",
    "\u00a8\u00aeY\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016",
    "\u0018\u001a\u001c\u001e \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp",
    "rtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092",
    "\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa",
    "\u00ac\u00ae\u0002\u000e\u0007\u0002IIKKMMPPUV\u0003\u0002[e\b\u0002",
    "\u0011\u0011\u001c\u001c$$**--<<\n\u0002\u0006\b\u0014\u0014\u0019\u0019",
    "\u001d\u001d\"#\'(/067\u0003\u0002\u0006\b\u0004\u0002++..\u0006\u0002",
    "\u0015\u0015%%1155\u0005\u0002\n\u000b!!::\u0004\u0002=>ZZ\u0003\u0002",
    "=>\u0004\u0002\r\r\u000f\u000f\u0004\u0002\u0010\u001011\u0002\u0578",
    "\u0002\u00d1\u0003\u0002\u0002\u0002\u0004\u00d3\u0003\u0002\u0002\u0002",
    "\u0006\u00da\u0003\u0002\u0002\u0002\b\u00ec\u0003\u0002\u0002\u0002",
    "\n\u0110\u0003\u0002\u0002\u0002\f\u012c\u0003\u0002\u0002\u0002\u000e",
    "\u014d\u0003\u0002\u0002\u0002\u0010\u014f\u0003\u0002\u0002\u0002\u0012",
    "\u015e\u0003\u0002\u0002\u0002\u0014\u0160\u0003\u0002\u0002\u0002\u0016",
    "\u0171\u0003\u0002\u0002\u0002\u0018\u017f\u0003\u0002\u0002\u0002\u001a",
    "\u018d\u0003\u0002\u0002\u0002\u001c\u01a1\u0003\u0002\u0002\u0002\u001e",
    "\u01af\u0003\u0002\u0002\u0002 \u01ba\u0003\u0002\u0002\u0002\"\u01c5",
    "\u0003\u0002\u0002\u0002$\u01d0\u0003\u0002\u0002\u0002&\u01db\u0003",
    "\u0002\u0002\u0002(\u01e6\u0003\u0002\u0002\u0002*\u01f4\u0003\u0002",
    "\u0002\u0002,\u01f6\u0003\u0002\u0002\u0002.\u01f8\u0003\u0002\u0002",
    "\u00020\u0203\u0003\u0002\u0002\u00022\u020d\u0003\u0002\u0002\u0002",
    "4\u0210\u0003\u0002\u0002\u00026\u0215\u0003\u0002\u0002\u00028\u021e",
    "\u0003\u0002\u0002\u0002:\u0220\u0003\u0002\u0002\u0002<\u0230\u0003",
    "\u0002\u0002\u0002>\u0232\u0003\u0002\u0002\u0002@\u0242\u0003\u0002",
    "\u0002\u0002B\u024f\u0003\u0002\u0002\u0002D\u0251\u0003\u0002\u0002",
    "\u0002F\u0253\u0003\u0002\u0002\u0002H\u0264\u0003\u0002\u0002\u0002",
    "J\u026e\u0003\u0002\u0002\u0002L\u0270\u0003\u0002\u0002\u0002N\u0281",
    "\u0003\u0002\u0002\u0002P\u0296\u0003\u0002\u0002\u0002R\u0298\u0003",
    "\u0002\u0002\u0002T\u02a8\u0003\u0002\u0002\u0002V\u02aa\u0003\u0002",
    "\u0002\u0002X\u02ac\u0003\u0002\u0002\u0002Z\u02b1\u0003\u0002\u0002",
    "\u0002\\\u02b9\u0003\u0002\u0002\u0002^\u02c5\u0003\u0002\u0002\u0002",
    "`\u02c8\u0003\u0002\u0002\u0002b\u02da\u0003\u0002\u0002\u0002d\u0315",
    "\u0003\u0002\u0002\u0002f\u0317\u0003\u0002\u0002\u0002h\u0327\u0003",
    "\u0002\u0002\u0002j\u0332\u0003\u0002\u0002\u0002l\u033b\u0003\u0002",
    "\u0002\u0002n\u0350\u0003\u0002\u0002\u0002p\u0352\u0003\u0002\u0002",
    "\u0002r\u0361\u0003\u0002\u0002\u0002t\u0363\u0003\u0002\u0002\u0002",
    "v\u0375\u0003\u0002\u0002\u0002x\u0377\u0003\u0002\u0002\u0002z\u0382",
    "\u0003\u0002\u0002\u0002|\u0391\u0003\u0002\u0002\u0002~\u03c1\u0003",
    "\u0002\u0002\u0002\u0080\u03f1\u0003\u0002\u0002\u0002\u0082\u03fd\u0003",
    "\u0002\u0002\u0002\u0084\u03ff\u0003\u0002\u0002\u0002\u0086\u0410\u0003",
    "\u0002\u0002\u0002\u0088\u0413\u0003\u0002\u0002\u0002\u008a\u0423\u0003",
    "\u0002\u0002\u0002\u008c\u0425\u0003\u0002\u0002\u0002\u008e\u0456\u0003",
    "\u0002\u0002\u0002\u0090\u0463\u0003\u0002\u0002\u0002\u0092\u0465\u0003",
    "\u0002\u0002\u0002\u0094\u046b\u0003\u0002\u0002\u0002\u0096\u0477\u0003",
    "\u0002\u0002\u0002\u0098\u047a\u0003\u0002\u0002\u0002\u009a\u048d\u0003",
    "\u0002\u0002\u0002\u009c\u04a3\u0003\u0002\u0002\u0002\u009e\u04b9\u0003",
    "\u0002\u0002\u0002\u00a0\u04bf\u0003\u0002\u0002\u0002\u00a2\u04c1\u0003",
    "\u0002\u0002\u0002\u00a4\u04dc\u0003\u0002\u0002\u0002\u00a6\u04df\u0003",
    "\u0002\u0002\u0002\u00a8\u04e3\u0003\u0002\u0002\u0002\u00aa\u04f0\u0003",
    "\u0002\u0002\u0002\u00ac\u04f3\u0003\u0002\u0002\u0002\u00ae\u04fb\u0003",
    "\u0002\u0002\u0002\u00b0\u00d2\u0007k\u0002\u0002\u00b1\u00d2\u0007",
    "l\u0002\u0002\u00b2\u00b4\u0007n\u0002\u0002\u00b3\u00b2\u0003\u0002",
    "\u0002\u0002\u00b4\u00b5\u0003\u0002\u0002\u0002\u00b5\u00b3\u0003\u0002",
    "\u0002\u0002\u00b5\u00b6\u0003\u0002\u0002\u0002\u00b6\u00d2\u0003\u0002",
    "\u0002\u0002\u00b7\u00b8\u0007=\u0002\u0002\u00b8\u00b9\u0005.\u0018",
    "\u0002\u00b9\u00ba\u0007>\u0002\u0002\u00ba\u00d2\u0003\u0002\u0002",
    "\u0002\u00bb\u00d2\u0005\u0004\u0003\u0002\u00bc\u00be\u0007\u0003\u0002",
    "\u0002\u00bd\u00bc\u0003\u0002\u0002\u0002\u00bd\u00be\u0003\u0002\u0002",
    "\u0002\u00be\u00bf\u0003\u0002\u0002\u0002\u00bf\u00c0\u0007=\u0002",
    "\u0002\u00c0\u00c1\u0005\u0092J\u0002\u00c1\u00c2\u0007>\u0002\u0002",
    "\u00c2\u00d2\u0003\u0002\u0002\u0002\u00c3\u00c4\u0007\u0004\u0002\u0002",
    "\u00c4\u00c5\u0007=\u0002\u0002\u00c5\u00c6\u0005\u000e\b\u0002\u00c6",
    "\u00c7\u0007Z\u0002\u0002\u00c7\u00c8\u0005z>\u0002\u00c8\u00c9\u0007",
    ">\u0002\u0002\u00c9\u00d2\u0003\u0002\u0002\u0002\u00ca\u00cb\u0007",
    "\u0005\u0002\u0002\u00cb\u00cc\u0007=\u0002\u0002\u00cc\u00cd\u0005",
    "z>\u0002\u00cd\u00ce\u0007Z\u0002\u0002\u00ce\u00cf\u0005\u000e\b\u0002",
    "\u00cf\u00d0\u0007>\u0002\u0002\u00d0\u00d2\u0003\u0002\u0002\u0002",
    "\u00d1\u00b0\u0003\u0002\u0002\u0002\u00d1\u00b1\u0003\u0002\u0002\u0002",
    "\u00d1\u00b3\u0003\u0002\u0002\u0002\u00d1\u00b7\u0003\u0002\u0002\u0002",
    "\u00d1\u00bb\u0003\u0002\u0002\u0002\u00d1\u00bd\u0003\u0002\u0002\u0002",
    "\u00d1\u00c3\u0003\u0002\u0002\u0002\u00d1\u00ca\u0003\u0002\u0002\u0002",
    "\u00d2\u0003\u0003\u0002\u0002\u0002\u00d3\u00d4\u00078\u0002\u0002",
    "\u00d4\u00d5\u0007=\u0002\u0002\u00d5\u00d6\u0005*\u0016\u0002\u00d6",
    "\u00d7\u0007Z\u0002\u0002\u00d7\u00d8\u0005\u0006\u0004\u0002\u00d8",
    "\u00d9\u0007>\u0002\u0002\u00d9\u0005\u0003\u0002\u0002\u0002\u00da",
    "\u00db\b\u0004\u0001\u0002\u00db\u00dc\u0005\b\u0005\u0002\u00dc\u00e2",
    "\u0003\u0002\u0002\u0002\u00dd\u00de\f\u0003\u0002\u0002\u00de\u00df",
    "\u0007Z\u0002\u0002\u00df\u00e1\u0005\b\u0005\u0002\u00e0\u00dd\u0003",
    "\u0002\u0002\u0002\u00e1\u00e4\u0003\u0002\u0002\u0002\u00e2\u00e0\u0003",
    "\u0002\u0002\u0002\u00e2\u00e3\u0003\u0002\u0002\u0002\u00e3\u0007\u0003",
    "\u0002\u0002\u0002\u00e4\u00e2\u0003\u0002\u0002\u0002\u00e5\u00e6\u0005",
    "z>\u0002\u00e6\u00e7\u0007X\u0002\u0002\u00e7\u00e8\u0005*\u0016\u0002",
    "\u00e8\u00ed\u0003\u0002\u0002\u0002\u00e9\u00ea\u0007\u0017\u0002\u0002",
    "\u00ea\u00eb\u0007X\u0002\u0002\u00eb\u00ed\u0005*\u0016\u0002\u00ec",
    "\u00e5\u0003\u0002\u0002\u0002\u00ec\u00e9\u0003\u0002\u0002\u0002\u00ed",
    "\t\u0003\u0002\u0002\u0002\u00ee\u00ef\b\u0006\u0001\u0002\u00ef\u0111",
    "\u0005\u0002\u0002\u0002\u00f0\u00f1\u0007=\u0002\u0002\u00f1\u00f2",
    "\u0005z>\u0002\u00f2\u00f3\u0007>\u0002\u0002\u00f3\u00f4\u0007A\u0002",
    "\u0002\u00f4\u00f5\u0005\u0084C\u0002\u00f5\u00f6\u0007B\u0002\u0002",
    "\u00f6\u0111\u0003\u0002\u0002\u0002\u00f7\u00f8\u0007=\u0002\u0002",
    "\u00f8\u00f9\u0005z>\u0002\u00f9\u00fa\u0007>\u0002\u0002\u00fa\u00fb",
    "\u0007A\u0002\u0002\u00fb\u00fc\u0005\u0084C\u0002\u00fc\u00fd\u0007",
    "Z\u0002\u0002\u00fd\u00fe\u0007B\u0002\u0002\u00fe\u0111\u0003\u0002",
    "\u0002\u0002\u00ff\u0100\u0007\u0003\u0002\u0002\u0100\u0101\u0007=",
    "\u0002\u0002\u0101\u0102\u0005z>\u0002\u0102\u0103\u0007>\u0002\u0002",
    "\u0103\u0104\u0007A\u0002\u0002\u0104\u0105\u0005\u0084C\u0002\u0105",
    "\u0106\u0007B\u0002\u0002\u0106\u0111\u0003\u0002\u0002\u0002\u0107",
    "\u0108\u0007\u0003\u0002\u0002\u0108\u0109\u0007=\u0002\u0002\u0109",
    "\u010a\u0005z>\u0002\u010a\u010b\u0007>\u0002\u0002\u010b\u010c\u0007",
    "A\u0002\u0002\u010c\u010d\u0005\u0084C\u0002\u010d\u010e\u0007Z\u0002",
    "\u0002\u010e\u010f\u0007B\u0002\u0002\u010f\u0111\u0003\u0002\u0002",
    "\u0002\u0110\u00ee\u0003\u0002\u0002\u0002\u0110\u00f0\u0003\u0002\u0002",
    "\u0002\u0110\u00f7\u0003\u0002\u0002\u0002\u0110\u00ff\u0003\u0002\u0002",
    "\u0002\u0110\u0107\u0003\u0002\u0002\u0002\u0111\u0129\u0003\u0002\u0002",
    "\u0002\u0112\u0113\f\f\u0002\u0002\u0113\u0114\u0007?\u0002\u0002\u0114",
    "\u0115\u0005.\u0018\u0002\u0115\u0116\u0007@\u0002\u0002\u0116\u0128",
    "\u0003\u0002\u0002\u0002\u0117\u0118\f\u000b\u0002\u0002\u0118\u011a",
    "\u0007=\u0002\u0002\u0119\u011b\u0005\f\u0007\u0002\u011a\u0119\u0003",
    "\u0002\u0002\u0002\u011a\u011b\u0003\u0002\u0002\u0002\u011b\u011c\u0003",
    "\u0002\u0002\u0002\u011c\u0128\u0007>\u0002\u0002\u011d\u011e\f\n\u0002",
    "\u0002\u011e\u011f\u0007i\u0002\u0002\u011f\u0128\u0007k\u0002\u0002",
    "\u0120\u0121\f\t\u0002\u0002\u0121\u0122\u0007h\u0002\u0002\u0122\u0128",
    "\u0007k\u0002\u0002\u0123\u0124\f\b\u0002\u0002\u0124\u0128\u0007J\u0002",
    "\u0002\u0125\u0126\f\u0007\u0002\u0002\u0126\u0128\u0007L\u0002\u0002",
    "\u0127\u0112\u0003\u0002\u0002\u0002\u0127\u0117\u0003\u0002\u0002\u0002",
    "\u0127\u011d\u0003\u0002\u0002\u0002\u0127\u0120\u0003\u0002\u0002\u0002",
    "\u0127\u0123\u0003\u0002\u0002\u0002\u0127\u0125\u0003\u0002\u0002\u0002",
    "\u0128\u012b\u0003\u0002\u0002\u0002\u0129\u0127\u0003\u0002\u0002\u0002",
    "\u0129\u012a\u0003\u0002\u0002\u0002\u012a\u000b\u0003\u0002\u0002\u0002",
    "\u012b\u0129\u0003\u0002\u0002\u0002\u012c\u012d\b\u0007\u0001\u0002",
    "\u012d\u012e\u0005*\u0016\u0002\u012e\u0134\u0003\u0002\u0002\u0002",
    "\u012f\u0130\f\u0003\u0002\u0002\u0130\u0131\u0007Z\u0002\u0002\u0131",
    "\u0133\u0005*\u0016\u0002\u0132\u012f\u0003\u0002\u0002\u0002\u0133",
    "\u0136\u0003\u0002\u0002\u0002\u0134\u0132\u0003\u0002\u0002\u0002\u0134",
    "\u0135\u0003\u0002\u0002\u0002\u0135\r\u0003\u0002\u0002\u0002\u0136",
    "\u0134\u0003\u0002\u0002\u0002\u0137\u014e\u0005\n\u0006\u0002\u0138",
    "\u0139\u0007J\u0002\u0002\u0139\u014e\u0005\u000e\b\u0002\u013a\u013b",
    "\u0007L\u0002\u0002\u013b\u014e\u0005\u000e\b\u0002\u013c\u013d\u0005",
    "\u0010\t\u0002\u013d\u013e\u0005\u0012\n\u0002\u013e\u014e\u0003\u0002",
    "\u0002\u0002\u013f\u0140\u0007)\u0002\u0002\u0140\u014e\u0005\u000e",
    "\b\u0002\u0141\u0142\u0007)\u0002\u0002\u0142\u0143\u0007=\u0002\u0002",
    "\u0143\u0144\u0005z>\u0002\u0144\u0145\u0007>\u0002\u0002\u0145\u014e",
    "\u0003\u0002\u0002\u0002\u0146\u0147\u00074\u0002\u0002\u0147\u0148",
    "\u0007=\u0002\u0002\u0148\u0149\u0005z>\u0002\u0149\u014a\u0007>\u0002",
    "\u0002\u014a\u014e\u0003\u0002\u0002\u0002\u014b\u014c\u0007R\u0002",
    "\u0002\u014c\u014e\u0007k\u0002\u0002\u014d\u0137\u0003\u0002\u0002",
    "\u0002\u014d\u0138\u0003\u0002\u0002\u0002\u014d\u013a\u0003\u0002\u0002",
    "\u0002\u014d\u013c\u0003\u0002\u0002\u0002\u014d\u013f\u0003\u0002\u0002",
    "\u0002\u014d\u0141\u0003\u0002\u0002\u0002\u014d\u0146\u0003\u0002\u0002",
    "\u0002\u014d\u014b\u0003\u0002\u0002\u0002\u014e\u000f\u0003\u0002\u0002",
    "\u0002\u014f\u0150\t\u0002\u0002\u0002\u0150\u0011\u0003\u0002\u0002",
    "\u0002\u0151\u015f\u0005\u000e\b\u0002\u0152\u0153\u0007=\u0002\u0002",
    "\u0153\u0154\u0005z>\u0002\u0154\u0155\u0007>\u0002\u0002\u0155\u0156",
    "\u0005\u0012\n\u0002\u0156\u015f\u0003\u0002\u0002\u0002\u0157\u0158",
    "\u0007\u0003\u0002\u0002\u0158\u0159\u0007=\u0002\u0002\u0159\u015a",
    "\u0005z>\u0002\u015a\u015b\u0007>\u0002\u0002\u015b\u015c\u0005\u0012",
    "\n\u0002\u015c\u015f\u0003\u0002\u0002\u0002\u015d\u015f\u0007m\u0002",
    "\u0002\u015e\u0151\u0003\u0002\u0002\u0002\u015e\u0152\u0003\u0002\u0002",
    "\u0002\u015e\u0157\u0003\u0002\u0002\u0002\u015e\u015d\u0003\u0002\u0002",
    "\u0002\u015f\u0013\u0003\u0002\u0002\u0002\u0160\u0161\b\u000b\u0001",
    "\u0002\u0161\u0162\u0005\u0012\n\u0002\u0162\u016e\u0003\u0002\u0002",
    "\u0002\u0163\u0164\f\u0005\u0002\u0002\u0164\u0165\u0007M\u0002\u0002",
    "\u0165\u016d\u0005\u0012\n\u0002\u0166\u0167\f\u0004\u0002\u0002\u0167",
    "\u0168\u0007N\u0002\u0002\u0168\u016d\u0005\u0012\n\u0002\u0169\u016a",
    "\f\u0003\u0002\u0002\u016a\u016b\u0007O\u0002\u0002\u016b\u016d\u0005",
    "\u0012\n\u0002\u016c\u0163\u0003\u0002\u0002\u0002\u016c\u0166\u0003",
    "\u0002\u0002\u0002\u016c\u0169\u0003\u0002\u0002\u0002\u016d\u0170\u0003",
    "\u0002\u0002\u0002\u016e\u016c\u0003\u0002\u0002\u0002\u016e\u016f\u0003",
    "\u0002\u0002\u0002\u016f\u0015\u0003\u0002\u0002\u0002\u0170\u016e\u0003",
    "\u0002\u0002\u0002\u0171\u0172\b\f\u0001\u0002\u0172\u0173\u0005\u0014",
    "\u000b\u0002\u0173\u017c\u0003\u0002\u0002\u0002\u0174\u0175\f\u0004",
    "\u0002\u0002\u0175\u0176\u0007I\u0002\u0002\u0176\u017b\u0005\u0014",
    "\u000b\u0002\u0177\u0178\f\u0003\u0002\u0002\u0178\u0179\u0007K\u0002",
    "\u0002\u0179\u017b\u0005\u0014\u000b\u0002\u017a\u0174\u0003\u0002\u0002",
    "\u0002\u017a\u0177\u0003\u0002\u0002\u0002\u017b\u017e\u0003\u0002\u0002",
    "\u0002\u017c\u017a\u0003\u0002\u0002\u0002\u017c\u017d\u0003\u0002\u0002",
    "\u0002\u017d\u0017\u0003\u0002\u0002\u0002\u017e\u017c\u0003\u0002\u0002",
    "\u0002\u017f\u0180\b\r\u0001\u0002\u0180\u0181\u0005\u0016\f\u0002\u0181",
    "\u018a\u0003\u0002\u0002\u0002\u0182\u0183\f\u0004\u0002\u0002\u0183",
    "\u0184\u0007G\u0002\u0002\u0184\u0189\u0005\u0016\f\u0002\u0185\u0186",
    "\f\u0003\u0002\u0002\u0186\u0187\u0007H\u0002\u0002\u0187\u0189\u0005",
    "\u0016\f\u0002\u0188\u0182\u0003\u0002\u0002\u0002\u0188\u0185\u0003",
    "\u0002\u0002\u0002\u0189\u018c\u0003\u0002\u0002\u0002\u018a\u0188\u0003",
    "\u0002\u0002\u0002\u018a\u018b\u0003\u0002\u0002\u0002\u018b\u0019\u0003",
    "\u0002\u0002\u0002\u018c\u018a\u0003\u0002\u0002\u0002\u018d\u018e\b",
    "\u000e\u0001\u0002\u018e\u018f\u0005\u0018\r\u0002\u018f\u019e\u0003",
    "\u0002\u0002\u0002\u0190\u0191\f\u0006\u0002\u0002\u0191\u0192\u0007",
    "C\u0002\u0002\u0192\u019d\u0005\u0018\r\u0002\u0193\u0194\f\u0005\u0002",
    "\u0002\u0194\u0195\u0007E\u0002\u0002\u0195\u019d\u0005\u0018\r\u0002",
    "\u0196\u0197\f\u0004\u0002\u0002\u0197\u0198\u0007D\u0002\u0002\u0198",
    "\u019d\u0005\u0018\r\u0002\u0199\u019a\f\u0003\u0002\u0002\u019a\u019b",
    "\u0007F\u0002\u0002\u019b\u019d\u0005\u0018\r\u0002\u019c\u0190\u0003",
    "\u0002\u0002\u0002\u019c\u0193\u0003\u0002\u0002\u0002\u019c\u0196\u0003",
    "\u0002\u0002\u0002\u019c\u0199\u0003\u0002\u0002\u0002\u019d\u01a0\u0003",
    "\u0002\u0002\u0002\u019e\u019c\u0003\u0002\u0002\u0002\u019e\u019f\u0003",
    "\u0002\u0002\u0002\u019f\u001b\u0003\u0002\u0002\u0002\u01a0\u019e\u0003",
    "\u0002\u0002\u0002\u01a1\u01a2\b\u000f\u0001\u0002\u01a2\u01a3\u0005",
    "\u001a\u000e\u0002\u01a3\u01ac\u0003\u0002\u0002\u0002\u01a4\u01a5\f",
    "\u0004\u0002\u0002\u01a5\u01a6\u0007f\u0002\u0002\u01a6\u01ab\u0005",
    "\u001a\u000e\u0002\u01a7\u01a8\f\u0003\u0002\u0002\u01a8\u01a9\u0007",
    "g\u0002\u0002\u01a9\u01ab\u0005\u001a\u000e\u0002\u01aa\u01a4\u0003",
    "\u0002\u0002\u0002\u01aa\u01a7\u0003\u0002\u0002\u0002\u01ab\u01ae\u0003",
    "\u0002\u0002\u0002\u01ac\u01aa\u0003\u0002\u0002\u0002\u01ac\u01ad\u0003",
    "\u0002\u0002\u0002\u01ad\u001d\u0003\u0002\u0002\u0002\u01ae\u01ac\u0003",
    "\u0002\u0002\u0002\u01af\u01b0\b\u0010\u0001\u0002\u01b0\u01b1\u0005",
    "\u001c\u000f\u0002\u01b1\u01b7\u0003\u0002\u0002\u0002\u01b2\u01b3\f",
    "\u0003\u0002\u0002\u01b3\u01b4\u0007P\u0002\u0002\u01b4\u01b6\u0005",
    "\u001c\u000f\u0002\u01b5\u01b2\u0003\u0002\u0002\u0002\u01b6\u01b9\u0003",
    "\u0002\u0002\u0002\u01b7\u01b5\u0003\u0002\u0002\u0002\u01b7\u01b8\u0003",
    "\u0002\u0002\u0002\u01b8\u001f\u0003\u0002\u0002\u0002\u01b9\u01b7\u0003",
    "\u0002\u0002\u0002\u01ba\u01bb\b\u0011\u0001\u0002\u01bb\u01bc\u0005",
    "\u001e\u0010\u0002\u01bc\u01c2\u0003\u0002\u0002\u0002\u01bd\u01be\f",
    "\u0003\u0002\u0002\u01be\u01bf\u0007T\u0002\u0002\u01bf\u01c1\u0005",
    "\u001e\u0010\u0002\u01c0\u01bd\u0003\u0002\u0002\u0002\u01c1\u01c4\u0003",
    "\u0002\u0002\u0002\u01c2\u01c0\u0003\u0002\u0002\u0002\u01c2\u01c3\u0003",
    "\u0002\u0002\u0002\u01c3!\u0003\u0002\u0002\u0002\u01c4\u01c2\u0003",
    "\u0002\u0002\u0002\u01c5\u01c6\b\u0012\u0001\u0002\u01c6\u01c7\u0005",
    " \u0011\u0002\u01c7\u01cd\u0003\u0002\u0002\u0002\u01c8\u01c9\f\u0003",
    "\u0002\u0002\u01c9\u01ca\u0007Q\u0002\u0002\u01ca\u01cc\u0005 \u0011",
    "\u0002\u01cb\u01c8\u0003\u0002\u0002\u0002\u01cc\u01cf\u0003\u0002\u0002",
    "\u0002\u01cd\u01cb\u0003\u0002\u0002\u0002\u01cd\u01ce\u0003\u0002\u0002",
    "\u0002\u01ce#\u0003\u0002\u0002\u0002\u01cf\u01cd\u0003\u0002\u0002",
    "\u0002\u01d0\u01d1\b\u0013\u0001\u0002\u01d1\u01d2\u0005\"\u0012\u0002",
    "\u01d2\u01d8\u0003\u0002\u0002\u0002\u01d3\u01d4\f\u0003\u0002\u0002",
    "\u01d4\u01d5\u0007R\u0002\u0002\u01d5\u01d7\u0005\"\u0012\u0002\u01d6",
    "\u01d3\u0003\u0002\u0002\u0002\u01d7\u01da\u0003\u0002\u0002\u0002\u01d8",
    "\u01d6\u0003\u0002\u0002\u0002\u01d8\u01d9\u0003\u0002\u0002\u0002\u01d9",
    "%\u0003\u0002\u0002\u0002\u01da\u01d8\u0003\u0002\u0002\u0002\u01db",
    "\u01dc\b\u0014\u0001\u0002\u01dc\u01dd\u0005$\u0013\u0002\u01dd\u01e3",
    "\u0003\u0002\u0002\u0002\u01de\u01df\f\u0003\u0002\u0002\u01df\u01e0",
    "\u0007S\u0002\u0002\u01e0\u01e2\u0005$\u0013\u0002\u01e1\u01de\u0003",
    "\u0002\u0002\u0002\u01e2\u01e5\u0003\u0002\u0002\u0002\u01e3\u01e1\u0003",
    "\u0002\u0002\u0002\u01e3\u01e4\u0003\u0002\u0002\u0002\u01e4\'\u0003",
    "\u0002\u0002\u0002\u01e5\u01e3\u0003\u0002\u0002\u0002\u01e6\u01ec\u0005",
    "&\u0014\u0002\u01e7\u01e8\u0007W\u0002\u0002\u01e8\u01e9\u0005.\u0018",
    "\u0002\u01e9\u01ea\u0007X\u0002\u0002\u01ea\u01eb\u0005(\u0015\u0002",
    "\u01eb\u01ed\u0003\u0002\u0002\u0002\u01ec\u01e7\u0003\u0002\u0002\u0002",
    "\u01ec\u01ed\u0003\u0002\u0002\u0002\u01ed)\u0003\u0002\u0002\u0002",
    "\u01ee\u01f5\u0005(\u0015\u0002\u01ef\u01f0\u0005\u000e\b\u0002\u01f0",
    "\u01f1\u0005,\u0017\u0002\u01f1\u01f2\u0005*\u0016\u0002\u01f2\u01f5",
    "\u0003\u0002\u0002\u0002\u01f3\u01f5\u0007m\u0002\u0002\u01f4\u01ee",
    "\u0003\u0002\u0002\u0002\u01f4\u01ef\u0003\u0002\u0002\u0002\u01f4\u01f3",
    "\u0003\u0002\u0002\u0002\u01f5+\u0003\u0002\u0002\u0002\u01f6\u01f7",
    "\t\u0003\u0002\u0002\u01f7-\u0003\u0002\u0002\u0002\u01f8\u01f9\b\u0018",
    "\u0001\u0002\u01f9\u01fa\u0005*\u0016\u0002\u01fa\u0200\u0003\u0002",
    "\u0002\u0002\u01fb\u01fc\f\u0003\u0002\u0002\u01fc\u01fd\u0007Z\u0002",
    "\u0002\u01fd\u01ff\u0005*\u0016\u0002\u01fe\u01fb\u0003\u0002\u0002",
    "\u0002\u01ff\u0202\u0003\u0002\u0002\u0002\u0200\u01fe\u0003\u0002\u0002",
    "\u0002\u0200\u0201\u0003\u0002\u0002\u0002\u0201/\u0003\u0002\u0002",
    "\u0002\u0202\u0200\u0003\u0002\u0002\u0002\u0203\u0204\u0005(\u0015",
    "\u0002\u02041\u0003\u0002\u0002\u0002\u0205\u0206\u00054\u001b\u0002",
    "\u0206\u0207\u0005:\u001e\u0002\u0207\u0208\u0007Y\u0002\u0002\u0208",
    "\u020e\u0003\u0002\u0002\u0002\u0209\u020a\u00054\u001b\u0002\u020a",
    "\u020b\u0007Y\u0002\u0002\u020b\u020e\u0003\u0002\u0002\u0002\u020c",
    "\u020e\u0005\u008cG\u0002\u020d\u0205\u0003\u0002\u0002\u0002\u020d",
    "\u0209\u0003\u0002\u0002\u0002\u020d\u020c\u0003\u0002\u0002\u0002\u020e",
    "3\u0003\u0002\u0002\u0002\u020f\u0211\u00058\u001d\u0002\u0210\u020f",
    "\u0003\u0002\u0002\u0002\u0211\u0212\u0003\u0002\u0002\u0002\u0212\u0210",
    "\u0003\u0002\u0002\u0002\u0212\u0213\u0003\u0002\u0002\u0002\u02135",
    "\u0003\u0002\u0002\u0002\u0214\u0216\u00058\u001d\u0002\u0215\u0214",
    "\u0003\u0002\u0002\u0002\u0216\u0217\u0003\u0002\u0002\u0002\u0217\u0215",
    "\u0003\u0002\u0002\u0002\u0217\u0218\u0003\u0002\u0002\u0002\u02187",
    "\u0003\u0002\u0002\u0002\u0219\u021f\u0005> \u0002\u021a\u021f\u0005",
    "@!\u0002\u021b\u021f\u0005Z.\u0002\u021c\u021f\u0005\\/\u0002\u021d",
    "\u021f\u0005^0\u0002\u021e\u0219\u0003\u0002\u0002\u0002\u021e\u021a",
    "\u0003\u0002\u0002\u0002\u021e\u021b\u0003\u0002\u0002\u0002\u021e\u021c",
    "\u0003\u0002\u0002\u0002\u021e\u021d\u0003\u0002\u0002\u0002\u021f9",
    "\u0003\u0002\u0002\u0002\u0220\u0221\b\u001e\u0001\u0002\u0221\u0222",
    "\u0005<\u001f\u0002\u0222\u0228\u0003\u0002\u0002\u0002\u0223\u0224",
    "\f\u0003\u0002\u0002\u0224\u0225\u0007Z\u0002\u0002\u0225\u0227\u0005",
    "<\u001f\u0002\u0226\u0223\u0003\u0002\u0002\u0002\u0227\u022a\u0003",
    "\u0002\u0002\u0002\u0228\u0226\u0003\u0002\u0002\u0002\u0228\u0229\u0003",
    "\u0002\u0002\u0002\u0229;\u0003\u0002\u0002\u0002\u022a\u0228\u0003",
    "\u0002\u0002\u0002\u022b\u0231\u0005`1\u0002\u022c\u022d\u0005`1\u0002",
    "\u022d\u022e\u0007[\u0002\u0002\u022e\u022f\u0005\u0082B\u0002\u022f",
    "\u0231\u0003\u0002\u0002\u0002\u0230\u022b\u0003\u0002\u0002\u0002\u0230",
    "\u022c\u0003\u0002\u0002\u0002\u0231=\u0003\u0002\u0002\u0002\u0232",
    "\u0233\t\u0004\u0002\u0002\u0233?\u0003\u0002\u0002\u0002\u0234\u0243",
    "\t\u0005\u0002\u0002\u0235\u0236\u0007\u0003\u0002\u0002\u0236\u0237",
    "\u0007=\u0002\u0002\u0237\u0238\t\u0006\u0002\u0002\u0238\u0243\u0007",
    ">\u0002\u0002\u0239\u0243\u0005X-\u0002\u023a\u0243\u0005B\"\u0002\u023b",
    "\u0243\u0005P)\u0002\u023c\u0243\u0005\u0080A\u0002\u023d\u023e\u0007",
    "\t\u0002\u0002\u023e\u023f\u0007=\u0002\u0002\u023f\u0240\u00050\u0019",
    "\u0002\u0240\u0241\u0007>\u0002\u0002\u0241\u0243\u0003\u0002\u0002",
    "\u0002\u0242\u0234\u0003\u0002\u0002\u0002\u0242\u0235\u0003\u0002\u0002",
    "\u0002\u0242\u0239\u0003\u0002\u0002\u0002\u0242\u023a\u0003\u0002\u0002",
    "\u0002\u0242\u023b\u0003\u0002\u0002\u0002\u0242\u023c\u0003\u0002\u0002",
    "\u0002\u0242\u023d\u0003\u0002\u0002\u0002\u0243A\u0003\u0002\u0002",
    "\u0002\u0244\u0246\u0005D#\u0002\u0245\u0247\u0007k\u0002\u0002\u0246",
    "\u0245\u0003\u0002\u0002\u0002\u0246\u0247\u0003\u0002\u0002\u0002\u0247",
    "\u0248\u0003\u0002\u0002\u0002\u0248\u0249\u0007A\u0002\u0002\u0249",
    "\u024a\u0005F$\u0002\u024a\u024b\u0007B\u0002\u0002\u024b\u0250\u0003",
    "\u0002\u0002\u0002\u024c\u024d\u0005D#\u0002\u024d\u024e\u0007k\u0002",
    "\u0002\u024e\u0250\u0003\u0002\u0002\u0002\u024f\u0244\u0003\u0002\u0002",
    "\u0002\u024f\u024c\u0003\u0002\u0002\u0002\u0250C\u0003\u0002\u0002",
    "\u0002\u0251\u0252\t\u0007\u0002\u0002\u0252E\u0003\u0002\u0002\u0002",
    "\u0253\u0254\b$\u0001\u0002\u0254\u0255\u0005H%\u0002\u0255\u025a\u0003",
    "\u0002\u0002\u0002\u0256\u0257\f\u0003\u0002\u0002\u0257\u0259\u0005",
    "H%\u0002\u0258\u0256\u0003\u0002\u0002\u0002\u0259\u025c\u0003\u0002",
    "\u0002\u0002\u025a\u0258\u0003\u0002\u0002\u0002\u025a\u025b\u0003\u0002",
    "\u0002\u0002\u025bG\u0003\u0002\u0002\u0002\u025c\u025a\u0003\u0002",
    "\u0002\u0002\u025d\u025f\u0005J&\u0002\u025e\u0260\u0005L\'\u0002\u025f",
    "\u025e\u0003\u0002\u0002\u0002\u025f\u0260\u0003\u0002\u0002\u0002\u0260",
    "\u0261\u0003\u0002\u0002\u0002\u0261\u0262\u0007Y\u0002\u0002\u0262",
    "\u0265\u0003\u0002\u0002\u0002\u0263\u0265\u0005\u008cG\u0002\u0264",
    "\u025d\u0003\u0002\u0002\u0002\u0264\u0263\u0003\u0002\u0002\u0002\u0265",
    "I\u0003\u0002\u0002\u0002\u0266\u0268\u0005@!\u0002\u0267\u0269\u0005",
    "J&\u0002\u0268\u0267\u0003\u0002\u0002\u0002\u0268\u0269\u0003\u0002",
    "\u0002\u0002\u0269\u026f\u0003\u0002\u0002\u0002\u026a\u026c\u0005Z",
    ".\u0002\u026b\u026d\u0005J&\u0002\u026c\u026b\u0003\u0002\u0002\u0002",
    "\u026c\u026d\u0003\u0002\u0002\u0002\u026d\u026f\u0003\u0002\u0002\u0002",
    "\u026e\u0266\u0003\u0002\u0002\u0002\u026e\u026a\u0003\u0002\u0002\u0002",
    "\u026fK\u0003\u0002\u0002\u0002\u0270\u0271\b\'\u0001\u0002\u0271\u0272",
    "\u0005N(\u0002\u0272\u0278\u0003\u0002\u0002\u0002\u0273\u0274\f\u0003",
    "\u0002\u0002\u0274\u0275\u0007Z\u0002\u0002\u0275\u0277\u0005N(\u0002",
    "\u0276\u0273\u0003\u0002\u0002\u0002\u0277\u027a\u0003\u0002\u0002\u0002",
    "\u0278\u0276\u0003\u0002\u0002\u0002\u0278\u0279\u0003\u0002\u0002\u0002",
    "\u0279M\u0003\u0002\u0002\u0002\u027a\u0278\u0003\u0002\u0002\u0002",
    "\u027b\u0282\u0005`1\u0002\u027c\u027e\u0005`1\u0002\u027d\u027c\u0003",
    "\u0002\u0002\u0002\u027d\u027e\u0003\u0002\u0002\u0002\u027e\u027f\u0003",
    "\u0002\u0002\u0002\u027f\u0280\u0007X\u0002\u0002\u0280\u0282\u0005",
    "0\u0019\u0002\u0281\u027b\u0003\u0002\u0002\u0002\u0281\u027d\u0003",
    "\u0002\u0002\u0002\u0282O\u0003\u0002\u0002\u0002\u0283\u0285\u0007",
    "\u001b\u0002\u0002\u0284\u0286\u0007k\u0002\u0002\u0285\u0284\u0003",
    "\u0002\u0002\u0002\u0285\u0286\u0003\u0002\u0002\u0002\u0286\u0287\u0003",
    "\u0002\u0002\u0002\u0287\u0288\u0007A\u0002\u0002\u0288\u0289\u0005",
    "R*\u0002\u0289\u028a\u0007B\u0002\u0002\u028a\u0297\u0003\u0002\u0002",
    "\u0002\u028b\u028d\u0007\u001b\u0002\u0002\u028c\u028e\u0007k\u0002",
    "\u0002\u028d\u028c\u0003\u0002\u0002\u0002\u028d\u028e\u0003\u0002\u0002",
    "\u0002\u028e\u028f\u0003\u0002\u0002\u0002\u028f\u0290\u0007A\u0002",
    "\u0002\u0290\u0291\u0005R*\u0002\u0291\u0292\u0007Z\u0002\u0002\u0292",
    "\u0293\u0007B\u0002\u0002\u0293\u0297\u0003\u0002\u0002\u0002\u0294",
    "\u0295\u0007\u001b\u0002\u0002\u0295\u0297\u0007k\u0002\u0002\u0296",
    "\u0283\u0003\u0002\u0002\u0002\u0296\u028b\u0003\u0002\u0002\u0002\u0296",
    "\u0294\u0003\u0002\u0002\u0002\u0297Q\u0003\u0002\u0002\u0002\u0298",
    "\u0299\b*\u0001\u0002\u0299\u029a\u0005T+\u0002\u029a\u02a0\u0003\u0002",
    "\u0002\u0002\u029b\u029c\f\u0003\u0002\u0002\u029c\u029d\u0007Z\u0002",
    "\u0002\u029d\u029f\u0005T+\u0002\u029e\u029b\u0003\u0002\u0002\u0002",
    "\u029f\u02a2\u0003\u0002\u0002\u0002\u02a0\u029e\u0003\u0002\u0002\u0002",
    "\u02a0\u02a1\u0003\u0002\u0002\u0002\u02a1S\u0003\u0002\u0002\u0002",
    "\u02a2\u02a0\u0003\u0002\u0002\u0002\u02a3\u02a9\u0005V,\u0002\u02a4",
    "\u02a5\u0005V,\u0002\u02a5\u02a6\u0007[\u0002\u0002\u02a6\u02a7\u0005",
    "0\u0019\u0002\u02a7\u02a9\u0003\u0002\u0002\u0002\u02a8\u02a3\u0003",
    "\u0002\u0002\u0002\u02a8\u02a4\u0003\u0002\u0002\u0002\u02a9U\u0003",
    "\u0002\u0002\u0002\u02aa\u02ab\u0007k\u0002\u0002\u02abW\u0003\u0002",
    "\u0002\u0002\u02ac\u02ad\u00075\u0002\u0002\u02ad\u02ae\u0007=\u0002",
    "\u0002\u02ae\u02af\u0005z>\u0002\u02af\u02b0\u0007>\u0002\u0002\u02b0",
    "Y\u0003\u0002\u0002\u0002\u02b1\u02b2\t\b\u0002\u0002\u02b2[\u0003\u0002",
    "\u0002\u0002\u02b3\u02ba\t\t\u0002\u0002\u02b4\u02ba\u0005f4\u0002\u02b5",
    "\u02b6\u0007\f\u0002\u0002\u02b6\u02b7\u0007=\u0002\u0002\u02b7\u02b8",
    "\u0007k\u0002\u0002\u02b8\u02ba\u0007>\u0002\u0002\u02b9\u02b3\u0003",
    "\u0002\u0002\u0002\u02b9\u02b4\u0003\u0002\u0002\u0002\u02b9\u02b5\u0003",
    "\u0002\u0002\u0002\u02ba]\u0003\u0002\u0002\u0002\u02bb\u02bc\u0007",
    "3\u0002\u0002\u02bc\u02bd\u0007=\u0002\u0002\u02bd\u02be\u0005z>\u0002",
    "\u02be\u02bf\u0007>\u0002\u0002\u02bf\u02c6\u0003\u0002\u0002\u0002",
    "\u02c0\u02c1\u00073\u0002\u0002\u02c1\u02c2\u0007=\u0002\u0002\u02c2",
    "\u02c3\u00050\u0019\u0002\u02c3\u02c4\u0007>\u0002\u0002\u02c4\u02c6",
    "\u0003\u0002\u0002\u0002\u02c5\u02bb\u0003\u0002\u0002\u0002\u02c5\u02c0",
    "\u0003\u0002\u0002\u0002\u02c6_\u0003\u0002\u0002\u0002\u02c7\u02c9",
    "\u0005n8\u0002\u02c8\u02c7\u0003\u0002\u0002\u0002\u02c8\u02c9\u0003",
    "\u0002\u0002\u0002\u02c9\u02ca\u0003\u0002\u0002\u0002\u02ca\u02ce\u0005",
    "b2\u0002\u02cb\u02cd\u0005d3\u0002\u02cc\u02cb\u0003\u0002\u0002\u0002",
    "\u02cd\u02d0\u0003\u0002\u0002\u0002\u02ce\u02cc\u0003\u0002\u0002\u0002",
    "\u02ce\u02cf\u0003\u0002\u0002\u0002\u02cfa\u0003\u0002\u0002\u0002",
    "\u02d0\u02ce\u0003\u0002\u0002\u0002\u02d1\u02d2\b2\u0001\u0002\u02d2",
    "\u02db\u0007k\u0002\u0002\u02d3\u02d4\u0007=\u0002\u0002\u02d4\u02d5",
    "\u0005`1\u0002\u02d5\u02d6\u0007>\u0002\u0002\u02d6\u02db\u0003\u0002",
    "\u0002\u0002\u02d7\u02d8\u0007k\u0002\u0002\u02d8\u02d9\u0007X\u0002",
    "\u0002\u02d9\u02db\u0007m\u0002\u0002\u02da\u02d1\u0003\u0002\u0002",
    "\u0002\u02da\u02d3\u0003\u0002\u0002\u0002\u02da\u02d7\u0003\u0002\u0002",
    "\u0002\u02db\u0309\u0003\u0002\u0002\u0002\u02dc\u02dd\f\t\u0002\u0002",
    "\u02dd\u02df\u0007?\u0002\u0002\u02de\u02e0\u0005p9\u0002\u02df\u02de",
    "\u0003\u0002\u0002\u0002\u02df\u02e0\u0003\u0002\u0002\u0002\u02e0\u02e2",
    "\u0003\u0002\u0002\u0002\u02e1\u02e3\u0005*\u0016\u0002\u02e2\u02e1",
    "\u0003\u0002\u0002\u0002\u02e2\u02e3\u0003\u0002\u0002\u0002\u02e3\u02e4",
    "\u0003\u0002\u0002\u0002\u02e4\u0308\u0007@\u0002\u0002\u02e5\u02e6",
    "\f\b\u0002\u0002\u02e6\u02e7\u0007?\u0002\u0002\u02e7\u02e9\u0007*\u0002",
    "\u0002\u02e8\u02ea\u0005p9\u0002\u02e9\u02e8\u0003\u0002\u0002\u0002",
    "\u02e9\u02ea\u0003\u0002\u0002\u0002\u02ea\u02eb\u0003\u0002\u0002\u0002",
    "\u02eb\u02ec\u0005*\u0016\u0002\u02ec\u02ed\u0007@\u0002\u0002\u02ed",
    "\u0308\u0003\u0002\u0002\u0002\u02ee\u02ef\f\u0007\u0002\u0002\u02ef",
    "\u02f0\u0007?\u0002\u0002\u02f0\u02f1\u0005p9\u0002\u02f1\u02f2\u0007",
    "*\u0002\u0002\u02f2\u02f3\u0005*\u0016\u0002\u02f3\u02f4\u0007@\u0002",
    "\u0002\u02f4\u0308\u0003\u0002\u0002\u0002\u02f5\u02f6\f\u0006\u0002",
    "\u0002\u02f6\u02f8\u0007?\u0002\u0002\u02f7\u02f9\u0005p9\u0002\u02f8",
    "\u02f7\u0003\u0002\u0002\u0002\u02f8\u02f9\u0003\u0002\u0002\u0002\u02f9",
    "\u02fa\u0003\u0002\u0002\u0002\u02fa\u02fb\u0007M\u0002\u0002\u02fb",
    "\u0308\u0007@\u0002\u0002\u02fc\u02fd\f\u0005\u0002\u0002\u02fd\u02fe",
    "\u0007=\u0002\u0002\u02fe\u02ff\u0005r:\u0002\u02ff\u0300\u0007>\u0002",
    "\u0002\u0300\u0308\u0003\u0002\u0002\u0002\u0301\u0302\f\u0004\u0002",
    "\u0002\u0302\u0304\u0007=\u0002\u0002\u0303\u0305\u0005x=\u0002\u0304",
    "\u0303\u0003\u0002\u0002\u0002\u0304\u0305\u0003\u0002\u0002\u0002\u0305",
    "\u0306\u0003\u0002\u0002\u0002\u0306\u0308\u0007>\u0002\u0002\u0307",
    "\u02dc\u0003\u0002\u0002\u0002\u0307\u02e5\u0003\u0002\u0002\u0002\u0307",
    "\u02ee\u0003\u0002\u0002\u0002\u0307\u02f5\u0003\u0002\u0002\u0002\u0307",
    "\u02fc\u0003\u0002\u0002\u0002\u0307\u0301\u0003\u0002\u0002\u0002\u0308",
    "\u030b\u0003\u0002\u0002\u0002\u0309\u0307\u0003\u0002\u0002\u0002\u0309",
    "\u030a\u0003\u0002\u0002\u0002\u030ac\u0003\u0002\u0002\u0002\u030b",
    "\u0309\u0003\u0002\u0002\u0002\u030c\u030d\u0007\r\u0002\u0002\u030d",
    "\u030f\u0007=\u0002\u0002\u030e\u0310\u0007n\u0002\u0002\u030f\u030e",
    "\u0003\u0002\u0002\u0002\u0310\u0311\u0003\u0002\u0002\u0002\u0311\u030f",
    "\u0003\u0002\u0002\u0002\u0311\u0312\u0003\u0002\u0002\u0002\u0312\u0313",
    "\u0003\u0002\u0002\u0002\u0313\u0316\u0007>\u0002\u0002\u0314\u0316",
    "\u0005f4\u0002\u0315\u030c\u0003\u0002\u0002\u0002\u0315\u0314\u0003",
    "\u0002\u0002\u0002\u0316e\u0003\u0002\u0002\u0002\u0317\u0318\u0007",
    "\u000e\u0002\u0002\u0318\u0319\u0007=\u0002\u0002\u0319\u031a\u0007",
    "=\u0002\u0002\u031a\u031b\u0005h5\u0002\u031b\u031c\u0007>\u0002\u0002",
    "\u031c\u031d\u0007>\u0002\u0002\u031dg\u0003\u0002\u0002\u0002\u031e",
    "\u0323\u0005j6\u0002\u031f\u0320\u0007Z\u0002\u0002\u0320\u0322\u0005",
    "j6\u0002\u0321\u031f\u0003\u0002\u0002\u0002\u0322\u0325\u0003\u0002",
    "\u0002\u0002\u0323\u0321\u0003\u0002\u0002\u0002\u0323\u0324\u0003\u0002",
    "\u0002\u0002\u0324\u0328\u0003\u0002\u0002\u0002\u0325\u0323\u0003\u0002",
    "\u0002\u0002\u0326\u0328\u0003\u0002\u0002\u0002\u0327\u031e\u0003\u0002",
    "\u0002\u0002\u0327\u0326\u0003\u0002\u0002\u0002\u0328i\u0003\u0002",
    "\u0002\u0002\u0329\u032f\n\n\u0002\u0002\u032a\u032c\u0007=\u0002\u0002",
    "\u032b\u032d\u0005\f\u0007\u0002\u032c\u032b\u0003\u0002\u0002\u0002",
    "\u032c\u032d\u0003\u0002\u0002\u0002\u032d\u032e\u0003\u0002\u0002\u0002",
    "\u032e\u0330\u0007>\u0002\u0002\u032f\u032a\u0003\u0002\u0002\u0002",
    "\u032f\u0330\u0003\u0002\u0002\u0002\u0330\u0333\u0003\u0002\u0002\u0002",
    "\u0331\u0333\u0003\u0002\u0002\u0002\u0332\u0329\u0003\u0002\u0002\u0002",
    "\u0332\u0331\u0003\u0002\u0002\u0002\u0333k\u0003\u0002\u0002\u0002",
    "\u0334\u033a\n\u000b\u0002\u0002\u0335\u0336\u0007=\u0002\u0002\u0336",
    "\u0337\u0005l7\u0002\u0337\u0338\u0007>\u0002\u0002\u0338\u033a\u0003",
    "\u0002\u0002\u0002\u0339\u0334\u0003\u0002\u0002\u0002\u0339\u0335\u0003",
    "\u0002\u0002\u0002\u033a\u033d\u0003\u0002\u0002\u0002\u033b\u0339\u0003",
    "\u0002\u0002\u0002\u033b\u033c\u0003\u0002\u0002\u0002\u033cm\u0003",
    "\u0002\u0002\u0002\u033d\u033b\u0003\u0002\u0002\u0002\u033e\u0340\u0007",
    "M\u0002\u0002\u033f\u0341\u0005p9\u0002\u0340\u033f\u0003\u0002\u0002",
    "\u0002\u0340\u0341\u0003\u0002\u0002\u0002\u0341\u0351\u0003\u0002\u0002",
    "\u0002\u0342\u0344\u0007M\u0002\u0002\u0343\u0345\u0005p9\u0002\u0344",
    "\u0343\u0003\u0002\u0002\u0002\u0344\u0345\u0003\u0002\u0002\u0002\u0345",
    "\u0346\u0003\u0002\u0002\u0002\u0346\u0351\u0005n8\u0002\u0347\u0349",
    "\u0007T\u0002\u0002\u0348\u034a\u0005p9\u0002\u0349\u0348\u0003\u0002",
    "\u0002\u0002\u0349\u034a\u0003\u0002\u0002\u0002\u034a\u0351\u0003\u0002",
    "\u0002\u0002\u034b\u034d\u0007T\u0002\u0002\u034c\u034e\u0005p9\u0002",
    "\u034d\u034c\u0003\u0002\u0002\u0002\u034d\u034e\u0003\u0002\u0002\u0002",
    "\u034e\u034f\u0003\u0002\u0002\u0002\u034f\u0351\u0005n8\u0002\u0350",
    "\u033e\u0003\u0002\u0002\u0002\u0350\u0342\u0003\u0002\u0002\u0002\u0350",
    "\u0347\u0003\u0002\u0002\u0002\u0350\u034b\u0003\u0002\u0002\u0002\u0351",
    "o\u0003\u0002\u0002\u0002\u0352\u0353\b9\u0001\u0002\u0353\u0354\u0005",
    "Z.\u0002\u0354\u0359\u0003\u0002\u0002\u0002\u0355\u0356\f\u0003\u0002",
    "\u0002\u0356\u0358\u0005Z.\u0002\u0357\u0355\u0003\u0002\u0002\u0002",
    "\u0358\u035b\u0003\u0002\u0002\u0002\u0359\u0357\u0003\u0002\u0002\u0002",
    "\u0359\u035a\u0003\u0002\u0002\u0002\u035aq\u0003\u0002\u0002\u0002",
    "\u035b\u0359\u0003\u0002\u0002\u0002\u035c\u0362\u0005t;\u0002\u035d",
    "\u035e\u0005t;\u0002\u035e\u035f\u0007Z\u0002\u0002\u035f\u0360\u0007",
    "j\u0002\u0002\u0360\u0362\u0003\u0002\u0002\u0002\u0361\u035c\u0003",
    "\u0002\u0002\u0002\u0361\u035d\u0003\u0002\u0002\u0002\u0362s\u0003",
    "\u0002\u0002\u0002\u0363\u0364\b;\u0001\u0002\u0364\u0365\u0005v<\u0002",
    "\u0365\u036b\u0003\u0002\u0002\u0002\u0366\u0367\f\u0003\u0002\u0002",
    "\u0367\u0368\u0007Z\u0002\u0002\u0368\u036a\u0005v<\u0002\u0369\u0366",
    "\u0003\u0002\u0002\u0002\u036a\u036d\u0003\u0002\u0002\u0002\u036b\u0369",
    "\u0003\u0002\u0002\u0002\u036b\u036c\u0003\u0002\u0002\u0002\u036cu",
    "\u0003\u0002\u0002\u0002\u036d\u036b\u0003\u0002\u0002\u0002\u036e\u036f",
    "\u00054\u001b\u0002\u036f\u0370\u0005`1\u0002\u0370\u0376\u0003\u0002",
    "\u0002\u0002\u0371\u0373\u00056\u001c\u0002\u0372\u0374\u0005|?\u0002",
    "\u0373\u0372\u0003\u0002\u0002\u0002\u0373\u0374\u0003\u0002\u0002\u0002",
    "\u0374\u0376\u0003\u0002\u0002\u0002\u0375\u036e\u0003\u0002\u0002\u0002",
    "\u0375\u0371\u0003\u0002\u0002\u0002\u0376w\u0003\u0002\u0002\u0002",
    "\u0377\u0378\b=\u0001\u0002\u0378\u0379\u0007k\u0002\u0002\u0379\u037f",
    "\u0003\u0002\u0002\u0002\u037a\u037b\f\u0003\u0002\u0002\u037b\u037c",
    "\u0007Z\u0002\u0002\u037c\u037e\u0007k\u0002\u0002\u037d\u037a\u0003",
    "\u0002\u0002\u0002\u037e\u0381\u0003\u0002\u0002\u0002\u037f\u037d\u0003",
    "\u0002\u0002\u0002\u037f\u0380\u0003\u0002\u0002\u0002\u0380y\u0003",
    "\u0002\u0002\u0002\u0381\u037f\u0003\u0002\u0002\u0002\u0382\u0384\u0005",
    "J&\u0002\u0383\u0385\u0005|?\u0002\u0384\u0383\u0003\u0002\u0002\u0002",
    "\u0384\u0385\u0003\u0002\u0002\u0002\u0385{\u0003\u0002\u0002\u0002",
    "\u0386\u0392\u0005n8\u0002\u0387\u0389\u0005n8\u0002\u0388\u0387\u0003",
    "\u0002\u0002\u0002\u0388\u0389\u0003\u0002\u0002\u0002\u0389\u038a\u0003",
    "\u0002\u0002\u0002\u038a\u038e\u0005~@\u0002\u038b\u038d\u0005d3\u0002",
    "\u038c\u038b\u0003\u0002\u0002\u0002\u038d\u0390\u0003\u0002\u0002\u0002",
    "\u038e\u038c\u0003\u0002\u0002\u0002\u038e\u038f\u0003\u0002\u0002\u0002",
    "\u038f\u0392\u0003\u0002\u0002\u0002\u0390\u038e\u0003\u0002\u0002\u0002",
    "\u0391\u0386\u0003\u0002\u0002\u0002\u0391\u0388\u0003\u0002\u0002\u0002",
    "\u0392}\u0003\u0002\u0002\u0002\u0393\u0394\b@\u0001\u0002\u0394\u0395",
    "\u0007=\u0002\u0002\u0395\u0396\u0005|?\u0002\u0396\u039a\u0007>\u0002",
    "\u0002\u0397\u0399\u0005d3\u0002\u0398\u0397\u0003\u0002\u0002\u0002",
    "\u0399\u039c\u0003\u0002\u0002\u0002\u039a\u0398\u0003\u0002\u0002\u0002",
    "\u039a\u039b\u0003\u0002\u0002\u0002\u039b\u03c2\u0003\u0002\u0002\u0002",
    "\u039c\u039a\u0003\u0002\u0002\u0002\u039d\u039f\u0007?\u0002\u0002",
    "\u039e\u03a0\u0005p9\u0002\u039f\u039e\u0003\u0002\u0002\u0002\u039f",
    "\u03a0\u0003\u0002\u0002\u0002\u03a0\u03a2\u0003\u0002\u0002\u0002\u03a1",
    "\u03a3\u0005*\u0016\u0002\u03a2\u03a1\u0003\u0002\u0002\u0002\u03a2",
    "\u03a3\u0003\u0002\u0002\u0002\u03a3\u03a4\u0003\u0002\u0002\u0002\u03a4",
    "\u03c2\u0007@\u0002\u0002\u03a5\u03a6\u0007?\u0002\u0002\u03a6\u03a8",
    "\u0007*\u0002\u0002\u03a7\u03a9\u0005p9\u0002\u03a8\u03a7\u0003\u0002",
    "\u0002\u0002\u03a8\u03a9\u0003\u0002\u0002\u0002\u03a9\u03aa\u0003\u0002",
    "\u0002\u0002\u03aa\u03ab\u0005*\u0016\u0002\u03ab\u03ac\u0007@\u0002",
    "\u0002\u03ac\u03c2\u0003\u0002\u0002\u0002\u03ad\u03ae\u0007?\u0002",
    "\u0002\u03ae\u03af\u0005p9\u0002\u03af\u03b0\u0007*\u0002\u0002\u03b0",
    "\u03b1\u0005*\u0016\u0002\u03b1\u03b2\u0007@\u0002\u0002\u03b2\u03c2",
    "\u0003\u0002\u0002\u0002\u03b3\u03b4\u0007?\u0002\u0002\u03b4\u03b5",
    "\u0007M\u0002\u0002\u03b5\u03c2\u0007@\u0002\u0002\u03b6\u03b8\u0007",
    "=\u0002\u0002\u03b7\u03b9\u0005r:\u0002\u03b8\u03b7\u0003\u0002\u0002",
    "\u0002\u03b8\u03b9\u0003\u0002\u0002\u0002\u03b9\u03ba\u0003\u0002\u0002",
    "\u0002\u03ba\u03be\u0007>\u0002\u0002\u03bb\u03bd\u0005d3\u0002\u03bc",
    "\u03bb\u0003\u0002\u0002\u0002\u03bd\u03c0\u0003\u0002\u0002\u0002\u03be",
    "\u03bc\u0003\u0002\u0002\u0002\u03be\u03bf\u0003\u0002\u0002\u0002\u03bf",
    "\u03c2\u0003\u0002\u0002\u0002\u03c0\u03be\u0003\u0002\u0002\u0002\u03c1",
    "\u0393\u0003\u0002\u0002\u0002\u03c1\u039d\u0003\u0002\u0002\u0002\u03c1",
    "\u03a5\u0003\u0002\u0002\u0002\u03c1\u03ad\u0003\u0002\u0002\u0002\u03c1",
    "\u03b3\u0003\u0002\u0002\u0002\u03c1\u03b6\u0003\u0002\u0002\u0002\u03c2",
    "\u03ee\u0003\u0002\u0002\u0002\u03c3\u03c4\f\u0007\u0002\u0002\u03c4",
    "\u03c6\u0007?\u0002\u0002\u03c5\u03c7\u0005p9\u0002\u03c6\u03c5\u0003",
    "\u0002\u0002\u0002\u03c6\u03c7\u0003\u0002\u0002\u0002\u03c7\u03c9\u0003",
    "\u0002\u0002\u0002\u03c8\u03ca\u0005*\u0016\u0002\u03c9\u03c8\u0003",
    "\u0002\u0002\u0002\u03c9\u03ca\u0003\u0002\u0002\u0002\u03ca\u03cb\u0003",
    "\u0002\u0002\u0002\u03cb\u03ed\u0007@\u0002\u0002\u03cc\u03cd\f\u0006",
    "\u0002\u0002\u03cd\u03ce\u0007?\u0002\u0002\u03ce\u03d0\u0007*\u0002",
    "\u0002\u03cf\u03d1\u0005p9\u0002\u03d0\u03cf\u0003\u0002\u0002\u0002",
    "\u03d0\u03d1\u0003\u0002\u0002\u0002\u03d1\u03d2\u0003\u0002\u0002\u0002",
    "\u03d2\u03d3\u0005*\u0016\u0002\u03d3\u03d4\u0007@\u0002\u0002\u03d4",
    "\u03ed\u0003\u0002\u0002\u0002\u03d5\u03d6\f\u0005\u0002\u0002\u03d6",
    "\u03d7\u0007?\u0002\u0002\u03d7\u03d8\u0005p9\u0002\u03d8\u03d9\u0007",
    "*\u0002\u0002\u03d9\u03da\u0005*\u0016\u0002\u03da\u03db\u0007@\u0002",
    "\u0002\u03db\u03ed\u0003\u0002\u0002\u0002\u03dc\u03dd\f\u0004\u0002",
    "\u0002\u03dd\u03de\u0007?\u0002\u0002\u03de\u03df\u0007M\u0002\u0002",
    "\u03df\u03ed\u0007@\u0002\u0002\u03e0\u03e1\f\u0003\u0002\u0002\u03e1",
    "\u03e3\u0007=\u0002\u0002\u03e2\u03e4\u0005r:\u0002\u03e3\u03e2\u0003",
    "\u0002\u0002\u0002\u03e3\u03e4\u0003\u0002\u0002\u0002\u03e4\u03e5\u0003",
    "\u0002\u0002\u0002\u03e5\u03e9\u0007>\u0002\u0002\u03e6\u03e8\u0005",
    "d3\u0002\u03e7\u03e6\u0003\u0002\u0002\u0002\u03e8\u03eb\u0003\u0002",
    "\u0002\u0002\u03e9\u03e7\u0003\u0002\u0002\u0002\u03e9\u03ea\u0003\u0002",
    "\u0002\u0002\u03ea\u03ed\u0003\u0002\u0002\u0002\u03eb\u03e9\u0003\u0002",
    "\u0002\u0002\u03ec\u03c3\u0003\u0002\u0002\u0002\u03ec\u03cc\u0003\u0002",
    "\u0002\u0002\u03ec\u03d5\u0003\u0002\u0002\u0002\u03ec\u03dc\u0003\u0002",
    "\u0002\u0002\u03ec\u03e0\u0003\u0002\u0002\u0002\u03ed\u03f0\u0003\u0002",
    "\u0002\u0002\u03ee\u03ec\u0003\u0002\u0002\u0002\u03ee\u03ef\u0003\u0002",
    "\u0002\u0002\u03ef\u007f\u0003\u0002\u0002\u0002\u03f0\u03ee\u0003\u0002",
    "\u0002\u0002\u03f1\u03f2\u0007k\u0002\u0002\u03f2\u0081\u0003\u0002",
    "\u0002\u0002\u03f3\u03fe\u0005*\u0016\u0002\u03f4\u03f5\u0007A\u0002",
    "\u0002\u03f5\u03f6\u0005\u0084C\u0002\u03f6\u03f7\u0007B\u0002\u0002",
    "\u03f7\u03fe\u0003\u0002\u0002\u0002\u03f8\u03f9\u0007A\u0002\u0002",
    "\u03f9\u03fa\u0005\u0084C\u0002\u03fa\u03fb\u0007Z\u0002\u0002\u03fb",
    "\u03fc\u0007B\u0002\u0002\u03fc\u03fe\u0003\u0002\u0002\u0002\u03fd",
    "\u03f3\u0003\u0002\u0002\u0002\u03fd\u03f4\u0003\u0002\u0002\u0002\u03fd",
    "\u03f8\u0003\u0002\u0002\u0002\u03fe\u0083\u0003\u0002\u0002\u0002\u03ff",
    "\u0401\bC\u0001\u0002\u0400\u0402\u0005\u0086D\u0002\u0401\u0400\u0003",
    "\u0002\u0002\u0002\u0401\u0402\u0003\u0002\u0002\u0002\u0402\u0403\u0003",
    "\u0002\u0002\u0002\u0403\u0404\u0005\u0082B\u0002\u0404\u040d\u0003",
    "\u0002\u0002\u0002\u0405\u0406\f\u0003\u0002\u0002\u0406\u0408\u0007",
    "Z\u0002\u0002\u0407\u0409\u0005\u0086D\u0002\u0408\u0407\u0003\u0002",
    "\u0002\u0002\u0408\u0409\u0003\u0002\u0002\u0002\u0409\u040a\u0003\u0002",
    "\u0002\u0002\u040a\u040c\u0005\u0082B\u0002\u040b\u0405\u0003\u0002",
    "\u0002\u0002\u040c\u040f\u0003\u0002\u0002\u0002\u040d\u040b\u0003\u0002",
    "\u0002\u0002\u040d\u040e\u0003\u0002\u0002\u0002\u040e\u0085\u0003\u0002",
    "\u0002\u0002\u040f\u040d\u0003\u0002\u0002\u0002\u0410\u0411\u0005\u0088",
    "E\u0002\u0411\u0412\u0007[\u0002\u0002\u0412\u0087\u0003\u0002\u0002",
    "\u0002\u0413\u0414\bE\u0001\u0002\u0414\u0415\u0005\u008aF\u0002\u0415",
    "\u041a\u0003\u0002\u0002\u0002\u0416\u0417\f\u0003\u0002\u0002\u0417",
    "\u0419\u0005\u008aF\u0002\u0418\u0416\u0003\u0002\u0002\u0002\u0419",
    "\u041c\u0003\u0002\u0002\u0002\u041a\u0418\u0003\u0002\u0002\u0002\u041a",
    "\u041b\u0003\u0002\u0002\u0002\u041b\u0089\u0003\u0002\u0002\u0002\u041c",
    "\u041a\u0003\u0002\u0002\u0002\u041d\u041e\u0007?\u0002\u0002\u041e",
    "\u041f\u00050\u0019\u0002\u041f\u0420\u0007@\u0002\u0002\u0420\u0424",
    "\u0003\u0002\u0002\u0002\u0421\u0422\u0007i\u0002\u0002\u0422\u0424",
    "\u0007k\u0002\u0002\u0423\u041d\u0003\u0002\u0002\u0002\u0423\u0421",
    "\u0003\u0002\u0002\u0002\u0424\u008b\u0003\u0002\u0002\u0002\u0425\u0426",
    "\u0007;\u0002\u0002\u0426\u0427\u0007=\u0002\u0002\u0427\u0428\u0005",
    "0\u0019\u0002\u0428\u042a\u0007Z\u0002\u0002\u0429\u042b\u0007n\u0002",
    "\u0002\u042a\u0429\u0003\u0002\u0002\u0002\u042b\u042c\u0003\u0002\u0002",
    "\u0002\u042c\u042a\u0003\u0002\u0002\u0002\u042c\u042d\u0003\u0002\u0002",
    "\u0002\u042d\u042e\u0003\u0002\u0002\u0002\u042e\u042f\u0007>\u0002",
    "\u0002\u042f\u0430\u0007Y\u0002\u0002\u0430\u008d\u0003\u0002\u0002",
    "\u0002\u0431\u0457\u0005\u0090I\u0002\u0432\u0457\u0005\u0092J\u0002",
    "\u0433\u0457\u0005\u0098M\u0002\u0434\u0457\u0005\u009aN\u0002\u0435",
    "\u0457\u0005\u009cO\u0002\u0436\u0457\u0005\u00a4S\u0002\u0437\u0438",
    "\t\f\u0002\u0002\u0438\u0439\t\r\u0002\u0002\u0439\u0442\u0007=\u0002",
    "\u0002\u043a\u043f\u0005&\u0014\u0002\u043b\u043c\u0007Z\u0002\u0002",
    "\u043c\u043e\u0005&\u0014\u0002\u043d\u043b\u0003\u0002\u0002\u0002",
    "\u043e\u0441\u0003\u0002\u0002\u0002\u043f\u043d\u0003\u0002\u0002\u0002",
    "\u043f\u0440\u0003\u0002\u0002\u0002\u0440\u0443\u0003\u0002\u0002\u0002",
    "\u0441\u043f\u0003\u0002\u0002\u0002\u0442\u043a\u0003\u0002\u0002\u0002",
    "\u0442\u0443\u0003\u0002\u0002\u0002\u0443\u0451\u0003\u0002\u0002\u0002",
    "\u0444\u044d\u0007X\u0002\u0002\u0445\u044a\u0005&\u0014\u0002\u0446",
    "\u0447\u0007Z\u0002\u0002\u0447\u0449\u0005&\u0014\u0002\u0448\u0446",
    "\u0003\u0002\u0002\u0002\u0449\u044c\u0003\u0002\u0002\u0002\u044a\u0448",
    "\u0003\u0002\u0002\u0002\u044a\u044b\u0003\u0002\u0002\u0002\u044b\u044e",
    "\u0003\u0002\u0002\u0002\u044c\u044a\u0003\u0002\u0002\u0002\u044d\u0445",
    "\u0003\u0002\u0002\u0002\u044d\u044e\u0003\u0002\u0002\u0002\u044e\u0450",
    "\u0003\u0002\u0002\u0002\u044f\u0444\u0003\u0002\u0002\u0002\u0450\u0453",
    "\u0003\u0002\u0002\u0002\u0451\u044f\u0003\u0002\u0002\u0002\u0451\u0452",
    "\u0003\u0002\u0002\u0002\u0452\u0454\u0003\u0002\u0002\u0002\u0453\u0451",
    "\u0003\u0002\u0002\u0002\u0454\u0455\u0007>\u0002\u0002\u0455\u0457",
    "\u0007Y\u0002\u0002\u0456\u0431\u0003\u0002\u0002\u0002\u0456\u0432",
    "\u0003\u0002\u0002\u0002\u0456\u0433\u0003\u0002\u0002\u0002\u0456\u0434",
    "\u0003\u0002\u0002\u0002\u0456\u0435\u0003\u0002\u0002\u0002\u0456\u0436",
    "\u0003\u0002\u0002\u0002\u0456\u0437\u0003\u0002\u0002\u0002\u0457\u008f",
    "\u0003\u0002\u0002\u0002\u0458\u0459\u0007k\u0002\u0002\u0459\u045a",
    "\u0007X\u0002\u0002\u045a\u0464\u0005\u008eH\u0002\u045b\u045c\u0007",
    "\u0013\u0002\u0002\u045c\u045d\u00050\u0019\u0002\u045d\u045e\u0007",
    "X\u0002\u0002\u045e\u045f\u0005\u008eH\u0002\u045f\u0464\u0003\u0002",
    "\u0002\u0002\u0460\u0461\u0007\u0017\u0002\u0002\u0461\u0462\u0007X",
    "\u0002\u0002\u0462\u0464\u0005\u008eH\u0002\u0463\u0458\u0003\u0002",
    "\u0002\u0002\u0463\u045b\u0003\u0002\u0002\u0002\u0463\u0460\u0003\u0002",
    "\u0002\u0002\u0464\u0091\u0003\u0002\u0002\u0002\u0465\u0467\u0007A",
    "\u0002\u0002\u0466\u0468\u0005\u0094K\u0002\u0467\u0466\u0003\u0002",
    "\u0002\u0002\u0467\u0468\u0003\u0002\u0002\u0002\u0468\u0469\u0003\u0002",
    "\u0002\u0002\u0469\u046a\u0007B\u0002\u0002\u046a\u0093\u0003\u0002",
    "\u0002\u0002\u046b\u046c\bK\u0001\u0002\u046c\u046d\u0005\u0096L\u0002",
    "\u046d\u0472\u0003\u0002\u0002\u0002\u046e\u046f\f\u0003\u0002\u0002",
    "\u046f\u0471\u0005\u0096L\u0002\u0470\u046e\u0003\u0002\u0002\u0002",
    "\u0471\u0474\u0003\u0002\u0002\u0002\u0472\u0470\u0003\u0002\u0002\u0002",
    "\u0472\u0473\u0003\u0002\u0002\u0002\u0473\u0095\u0003\u0002\u0002\u0002",
    "\u0474\u0472\u0003\u0002\u0002\u0002\u0475\u0478\u00052\u001a\u0002",
    "\u0476\u0478\u0005\u008eH\u0002\u0477\u0475\u0003\u0002\u0002\u0002",
    "\u0477\u0476\u0003\u0002\u0002\u0002\u0478\u0097\u0003\u0002\u0002\u0002",
    "\u0479\u047b\u0005.\u0018\u0002\u047a\u0479\u0003\u0002\u0002\u0002",
    "\u047a\u047b\u0003\u0002\u0002\u0002\u047b\u047c\u0003\u0002\u0002\u0002",
    "\u047c\u047d\u0007Y\u0002\u0002\u047d\u0099\u0003\u0002\u0002\u0002",
    "\u047e\u047f\u0007 \u0002\u0002\u047f\u0480\u0007=\u0002\u0002\u0480",
    "\u0481\u0005.\u0018\u0002\u0481\u0482\u0007>\u0002\u0002\u0482\u0485",
    "\u0005\u008eH\u0002\u0483\u0484\u0007\u001a\u0002\u0002\u0484\u0486",
    "\u0005\u008eH\u0002\u0485\u0483\u0003\u0002\u0002\u0002\u0485\u0486",
    "\u0003\u0002\u0002\u0002\u0486\u048e\u0003\u0002\u0002\u0002\u0487\u0488",
    "\u0007,\u0002\u0002\u0488\u0489\u0007=\u0002\u0002\u0489\u048a\u0005",
    ".\u0018\u0002\u048a\u048b\u0007>\u0002\u0002\u048b\u048c\u0005\u008e",
    "H\u0002\u048c\u048e\u0003\u0002\u0002\u0002\u048d\u047e\u0003\u0002",
    "\u0002\u0002\u048d\u0487\u0003\u0002\u0002\u0002\u048e\u009b\u0003\u0002",
    "\u0002\u0002\u048f\u0490\u00072\u0002\u0002\u0490\u0491\u0007=\u0002",
    "\u0002\u0491\u0492\u0005.\u0018\u0002\u0492\u0493\u0007>\u0002\u0002",
    "\u0493\u0494\u0005\u008eH\u0002\u0494\u04a4\u0003\u0002\u0002\u0002",
    "\u0495\u0496\u0007\u0018\u0002\u0002\u0496\u0497\u0005\u008eH\u0002",
    "\u0497\u0498\u00072\u0002\u0002\u0498\u0499\u0007=\u0002\u0002\u0499",
    "\u049a\u0005.\u0018\u0002\u049a\u049b\u0007>\u0002\u0002\u049b\u049c",
    "\u0007Y\u0002\u0002\u049c\u04a4\u0003\u0002\u0002\u0002\u049d\u049e",
    "\u0007\u001e\u0002\u0002\u049e\u049f\u0007=\u0002\u0002\u049f\u04a0",
    "\u0005\u009eP\u0002\u04a0\u04a1\u0007>\u0002\u0002\u04a1\u04a2\u0005",
    "\u008eH\u0002\u04a2\u04a4\u0003\u0002\u0002\u0002\u04a3\u048f\u0003",
    "\u0002\u0002\u0002\u04a3\u0495\u0003\u0002\u0002\u0002\u04a3\u049d\u0003",
    "\u0002\u0002\u0002\u04a4\u009d\u0003\u0002\u0002\u0002\u04a5\u04a6\u0005",
    "\u00a0Q\u0002\u04a6\u04a8\u0007Y\u0002\u0002\u04a7\u04a9\u0005\u00a2",
    "R\u0002\u04a8\u04a7\u0003\u0002\u0002\u0002\u04a8\u04a9\u0003\u0002",
    "\u0002\u0002\u04a9\u04aa\u0003\u0002\u0002\u0002\u04aa\u04ac\u0007Y",
    "\u0002\u0002\u04ab\u04ad\u0005\u00a2R\u0002\u04ac\u04ab\u0003\u0002",
    "\u0002\u0002\u04ac\u04ad\u0003\u0002\u0002\u0002\u04ad\u04ba\u0003\u0002",
    "\u0002\u0002\u04ae\u04b0\u0005.\u0018\u0002\u04af\u04ae\u0003\u0002",
    "\u0002\u0002\u04af\u04b0\u0003\u0002\u0002\u0002\u04b0\u04b1\u0003\u0002",
    "\u0002\u0002\u04b1\u04b3\u0007Y\u0002\u0002\u04b2\u04b4\u0005\u00a2",
    "R\u0002\u04b3\u04b2\u0003\u0002\u0002\u0002\u04b3\u04b4\u0003\u0002",
    "\u0002\u0002\u04b4\u04b5\u0003\u0002\u0002\u0002\u04b5\u04b7\u0007Y",
    "\u0002\u0002\u04b6\u04b8\u0005\u00a2R\u0002\u04b7\u04b6\u0003\u0002",
    "\u0002\u0002\u04b7\u04b8\u0003\u0002\u0002\u0002\u04b8\u04ba\u0003\u0002",
    "\u0002\u0002\u04b9\u04a5\u0003\u0002\u0002\u0002\u04b9\u04af\u0003\u0002",
    "\u0002\u0002\u04ba\u009f\u0003\u0002\u0002\u0002\u04bb\u04bc\u00054",
    "\u001b\u0002\u04bc\u04bd\u0005:\u001e\u0002\u04bd\u04c0\u0003\u0002",
    "\u0002\u0002\u04be\u04c0\u00054\u001b\u0002\u04bf\u04bb\u0003\u0002",
    "\u0002\u0002\u04bf\u04be\u0003\u0002\u0002\u0002\u04c0\u00a1\u0003\u0002",
    "\u0002\u0002\u04c1\u04c2\bR\u0001\u0002\u04c2\u04c3\u0005*\u0016\u0002",
    "\u04c3\u04c9\u0003\u0002\u0002\u0002\u04c4\u04c5\f\u0003\u0002\u0002",
    "\u04c5\u04c6\u0007Z\u0002\u0002\u04c6\u04c8\u0005*\u0016\u0002\u04c7",
    "\u04c4\u0003\u0002\u0002\u0002\u04c8\u04cb\u0003\u0002\u0002\u0002\u04c9",
    "\u04c7\u0003\u0002\u0002\u0002\u04c9\u04ca\u0003\u0002\u0002\u0002\u04ca",
    "\u00a3\u0003\u0002\u0002\u0002\u04cb\u04c9\u0003\u0002\u0002\u0002\u04cc",
    "\u04cd\u0007\u001f\u0002\u0002\u04cd\u04ce\u0007k\u0002\u0002\u04ce",
    "\u04dd\u0007Y\u0002\u0002\u04cf\u04d0\u0007\u0016\u0002\u0002\u04d0",
    "\u04dd\u0007Y\u0002\u0002\u04d1\u04d2\u0007\u0012\u0002\u0002\u04d2",
    "\u04dd\u0007Y\u0002\u0002\u04d3\u04d5\u0007&\u0002\u0002\u04d4\u04d6",
    "\u0005.\u0018\u0002\u04d5\u04d4\u0003\u0002\u0002\u0002\u04d5\u04d6",
    "\u0003\u0002\u0002\u0002\u04d6\u04d7\u0003\u0002\u0002\u0002\u04d7\u04dd",
    "\u0007Y\u0002\u0002\u04d8\u04d9\u0007\u001f\u0002\u0002\u04d9\u04da",
    "\u0005\u000e\b\u0002\u04da\u04db\u0007Y\u0002\u0002\u04db\u04dd\u0003",
    "\u0002\u0002\u0002\u04dc\u04cc\u0003\u0002\u0002\u0002\u04dc\u04cf\u0003",
    "\u0002\u0002\u0002\u04dc\u04d1\u0003\u0002\u0002\u0002\u04dc\u04d3\u0003",
    "\u0002\u0002\u0002\u04dc\u04d8\u0003\u0002\u0002\u0002\u04dd\u00a5\u0003",
    "\u0002\u0002\u0002\u04de\u04e0\u0005\u00a8U\u0002\u04df\u04de\u0003",
    "\u0002\u0002\u0002\u04df\u04e0\u0003\u0002\u0002\u0002\u04e0\u04e1\u0003",
    "\u0002\u0002\u0002\u04e1\u04e2\u0007\u0002\u0002\u0003\u04e2\u00a7\u0003",
    "\u0002\u0002\u0002\u04e3\u04e4\bU\u0001\u0002\u04e4\u04e5\u0005\u00aa",
    "V\u0002\u04e5\u04ea\u0003\u0002\u0002\u0002\u04e6\u04e7\f\u0003\u0002",
    "\u0002\u04e7\u04e9\u0005\u00aaV\u0002\u04e8\u04e6\u0003\u0002\u0002",
    "\u0002\u04e9\u04ec\u0003\u0002\u0002\u0002\u04ea\u04e8\u0003\u0002\u0002",
    "\u0002\u04ea\u04eb\u0003\u0002\u0002\u0002\u04eb\u00a9\u0003\u0002\u0002",
    "\u0002\u04ec\u04ea\u0003\u0002\u0002\u0002\u04ed\u04f1\u0005\u00acW",
    "\u0002\u04ee\u04f1\u00052\u001a\u0002\u04ef\u04f1\u0007Y\u0002\u0002",
    "\u04f0\u04ed\u0003\u0002\u0002\u0002\u04f0\u04ee\u0003\u0002\u0002\u0002",
    "\u04f0\u04ef\u0003\u0002\u0002\u0002\u04f1\u00ab\u0003\u0002\u0002\u0002",
    "\u04f2\u04f4\u00054\u001b\u0002\u04f3\u04f2\u0003\u0002\u0002\u0002",
    "\u04f3\u04f4\u0003\u0002\u0002\u0002\u04f4\u04f5\u0003\u0002\u0002\u0002",
    "\u04f5\u04f7\u0005`1\u0002\u04f6\u04f8\u0005\u00aeX\u0002\u04f7\u04f6",
    "\u0003\u0002\u0002\u0002\u04f7\u04f8\u0003\u0002\u0002\u0002\u04f8\u04f9",
    "\u0003\u0002\u0002\u0002\u04f9\u04fa\u0005\u0092J\u0002\u04fa\u00ad",
    "\u0003\u0002\u0002\u0002\u04fb\u04fc\bX\u0001\u0002\u04fc\u04fd\u0005",
    "2\u001a\u0002\u04fd\u0502\u0003\u0002\u0002\u0002\u04fe\u04ff\f\u0003",
    "\u0002\u0002\u04ff\u0501\u00052\u001a\u0002\u0500\u04fe\u0003\u0002",
    "\u0002\u0002\u0501\u0504\u0003\u0002\u0002\u0002\u0502\u0500\u0003\u0002",
    "\u0002\u0002\u0502\u0503\u0003\u0002\u0002\u0002\u0503\u00af\u0003\u0002",
    "\u0002\u0002\u0504\u0502\u0003\u0002\u0002\u0002\u008e\u00b5\u00bd\u00d1",
    "\u00e2\u00ec\u0110\u011a\u0127\u0129\u0134\u014d\u015e\u016c\u016e\u017a",
    "\u017c\u0188\u018a\u019c\u019e\u01aa\u01ac\u01b7\u01c2\u01cd\u01d8\u01e3",
    "\u01ec\u01f4\u0200\u020d\u0212\u0217\u021e\u0228\u0230\u0242\u0246\u024f",
    "\u025a\u025f\u0264\u0268\u026c\u026e\u0278\u027d\u0281\u0285\u028d\u0296",
    "\u02a0\u02a8\u02b9\u02c5\u02c8\u02ce\u02da\u02df\u02e2\u02e9\u02f8\u0304",
    "\u0307\u0309\u0311\u0315\u0323\u0327\u032c\u032f\u0332\u0339\u033b\u0340",
    "\u0344\u0349\u034d\u0350\u0359\u0361\u036b\u0373\u0375\u037f\u0384\u0388",
    "\u038e\u0391\u039a\u039f\u03a2\u03a8\u03b8\u03be\u03c1\u03c6\u03c9\u03d0",
    "\u03e3\u03e9\u03ec\u03ee\u03fd\u0401\u0408\u040d\u041a\u0423\u042c\u043f",
    "\u0442\u044a\u044d\u0451\u0456\u0463\u0467\u0472\u0477\u047a\u0485\u048d",
    "\u04a3\u04a8\u04ac\u04af\u04b3\u04b7\u04b9\u04bf\u04c9\u04d5\u04dc\u04df",
    "\u04ea\u04f0\u04f3\u04f7\u0502"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "'__extension__'", "'__builtin_va_arg'", "'__builtin_offsetof'", 
                     "'__m128'", "'__m128d'", "'__m128i'", "'__typeof__'", 
                     "'__inline__'", "'__stdcall'", "'__declspec'", "'__asm'", 
                     "'__attribute__'", "'__asm__'", "'__volatile__'", "'auto'", 
                     "'break'", "'case'", "'char'", "'const'", "'continue'", 
                     "'default'", "'do'", "'double'", "'else'", "'enum'", 
                     "'extern'", "'float'", "'for'", "'goto'", "'if'", "'inline'", 
                     "'int'", "'long'", "'register'", "'restrict'", "'return'", 
                     "'short'", "'signed'", "'sizeof'", "'static'", "'struct'", 
                     "'switch'", "'typedef'", "'union'", "'unsigned'", "'void'", 
                     "'volatile'", "'while'", "'_Alignas'", "'_Alignof'", 
                     "'_Atomic'", "'_Bool'", "'_Complex'", "'_Generic'", 
                     "'_Imaginary'", "'_Noreturn'", "'_Static_assert'", 
                     "'_Thread_local'", "'('", "')'", "'['", "']'", "'{'", 
                     "'}'", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'", 
                     "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", 
                     "'&'", "'|'", "'&&'", "'||'", "'^'", "'!'", "'~'", 
                     "'?'", "':'", "';'", "','", "'='", "'*='", "'/='", 
                     "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", 
                     "'|='", "'=='", "'!='", "'->'", "'.'", "'...'" ];

var symbolicNames = [ null, null, null, null, null, null, null, null, null, 
                      null, null, null, null, null, null, "Auto", "Break", 
                      "Case", "Char", "Const", "Continue", "Default", "Do", 
                      "Double", "Else", "Enum", "Extern", "Float", "For", 
                      "Goto", "If", "Inline", "Int", "Long", "Register", 
                      "Restrict", "Return", "Short", "Signed", "Sizeof", 
                      "Static", "Struct", "Switch", "Typedef", "Union", 
                      "Unsigned", "Void", "Volatile", "While", "Alignas", 
                      "Alignof", "Atomic", "Bool", "Complex", "Generic", 
                      "Imaginary", "Noreturn", "StaticAssert", "ThreadLocal", 
                      "LeftParen", "RightParen", "LeftBracket", "RightBracket", 
                      "LeftBrace", "RightBrace", "Less", "LessEqual", "Greater", 
                      "GreaterEqual", "LeftShift", "RightShift", "Plus", 
                      "PlusPlus", "Minus", "MinusMinus", "Star", "Div", 
                      "Mod", "And", "Or", "AndAnd", "OrOr", "Caret", "Not", 
                      "Tilde", "Question", "Colon", "Semi", "Comma", "Assign", 
                      "StarAssign", "DivAssign", "ModAssign", "PlusAssign", 
                      "MinusAssign", "LeftShiftAssign", "RightShiftAssign", 
                      "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual", 
                      "Arrow", "Dot", "Ellipsis", "Identifier", "Constant", 
                      "DigitSequence", "StringLiteral", "ComplexDefine", 
                      "AsmBlock", "LineAfterPreprocessing", "LineDirective", 
                      "PragmaDirective", "Whitespace", "Newline", "BlockComment", 
                      "LineComment" ];

var ruleNames =  [ "primaryExpression", "genericSelection", "genericAssocList", 
                   "genericAssociation", "postfixExpression", "argumentExpressionList", 
                   "unaryExpression", "unaryOperator", "castExpression", 
                   "multiplicativeExpression", "additiveExpression", "shiftExpression", 
                   "relationalExpression", "equalityExpression", "andExpression", 
                   "exclusiveOrExpression", "inclusiveOrExpression", "logicalAndExpression", 
                   "logicalOrExpression", "conditionalExpression", "assignmentExpression", 
                   "assignmentOperator", "expression", "constantExpression", 
                   "declaration", "declarationSpecifiers", "declarationSpecifiers2", 
                   "declarationSpecifier", "initDeclaratorList", "initDeclarator", 
                   "storageClassSpecifier", "typeSpecifier", "structOrUnionSpecifier", 
                   "structOrUnion", "structDeclarationList", "structDeclaration", 
                   "specifierQualifierList", "structDeclaratorList", "structDeclarator", 
                   "enumSpecifier", "enumeratorList", "enumerator", "enumerationConstant", 
                   "atomicTypeSpecifier", "typeQualifier", "functionSpecifier", 
                   "alignmentSpecifier", "declarator", "directDeclarator", 
                   "gccDeclaratorExtension", "gccAttributeSpecifier", "gccAttributeList", 
                   "gccAttribute", "nestedParenthesesBlock", "pointer", 
                   "typeQualifierList", "parameterTypeList", "parameterList", 
                   "parameterDeclaration", "identifierList", "typeName", 
                   "abstractDeclarator", "directAbstractDeclarator", "typedefName", 
                   "initializer", "initializerList", "designation", "designatorList", 
                   "designator", "staticAssertDeclaration", "statement", 
                   "labeledStatement", "compoundStatement", "blockItemList", 
                   "blockItem", "expressionStatement", "selectionStatement", 
                   "iterationStatement", "forCondition", "forDeclaration", 
                   "forExpression", "jumpStatement", "compilationUnit", 
                   "translationUnit", "externalDeclaration", "functionDefinition", 
                   "declarationList" ];

function CParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

CParser.prototype = Object.create(antlr4.Parser.prototype);
CParser.prototype.constructor = CParser;

Object.defineProperty(CParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

CParser.EOF = antlr4.Token.EOF;
CParser.T__0 = 1;
CParser.T__1 = 2;
CParser.T__2 = 3;
CParser.T__3 = 4;
CParser.T__4 = 5;
CParser.T__5 = 6;
CParser.T__6 = 7;
CParser.T__7 = 8;
CParser.T__8 = 9;
CParser.T__9 = 10;
CParser.T__10 = 11;
CParser.T__11 = 12;
CParser.T__12 = 13;
CParser.T__13 = 14;
CParser.Auto = 15;
CParser.Break = 16;
CParser.Case = 17;
CParser.Char = 18;
CParser.Const = 19;
CParser.Continue = 20;
CParser.Default = 21;
CParser.Do = 22;
CParser.Double = 23;
CParser.Else = 24;
CParser.Enum = 25;
CParser.Extern = 26;
CParser.Float = 27;
CParser.For = 28;
CParser.Goto = 29;
CParser.If = 30;
CParser.Inline = 31;
CParser.Int = 32;
CParser.Long = 33;
CParser.Register = 34;
CParser.Restrict = 35;
CParser.Return = 36;
CParser.Short = 37;
CParser.Signed = 38;
CParser.Sizeof = 39;
CParser.Static = 40;
CParser.Struct = 41;
CParser.Switch = 42;
CParser.Typedef = 43;
CParser.Union = 44;
CParser.Unsigned = 45;
CParser.Void = 46;
CParser.Volatile = 47;
CParser.While = 48;
CParser.Alignas = 49;
CParser.Alignof = 50;
CParser.Atomic = 51;
CParser.Bool = 52;
CParser.Complex = 53;
CParser.Generic = 54;
CParser.Imaginary = 55;
CParser.Noreturn = 56;
CParser.StaticAssert = 57;
CParser.ThreadLocal = 58;
CParser.LeftParen = 59;
CParser.RightParen = 60;
CParser.LeftBracket = 61;
CParser.RightBracket = 62;
CParser.LeftBrace = 63;
CParser.RightBrace = 64;
CParser.Less = 65;
CParser.LessEqual = 66;
CParser.Greater = 67;
CParser.GreaterEqual = 68;
CParser.LeftShift = 69;
CParser.RightShift = 70;
CParser.Plus = 71;
CParser.PlusPlus = 72;
CParser.Minus = 73;
CParser.MinusMinus = 74;
CParser.Star = 75;
CParser.Div = 76;
CParser.Mod = 77;
CParser.And = 78;
CParser.Or = 79;
CParser.AndAnd = 80;
CParser.OrOr = 81;
CParser.Caret = 82;
CParser.Not = 83;
CParser.Tilde = 84;
CParser.Question = 85;
CParser.Colon = 86;
CParser.Semi = 87;
CParser.Comma = 88;
CParser.Assign = 89;
CParser.StarAssign = 90;
CParser.DivAssign = 91;
CParser.ModAssign = 92;
CParser.PlusAssign = 93;
CParser.MinusAssign = 94;
CParser.LeftShiftAssign = 95;
CParser.RightShiftAssign = 96;
CParser.AndAssign = 97;
CParser.XorAssign = 98;
CParser.OrAssign = 99;
CParser.Equal = 100;
CParser.NotEqual = 101;
CParser.Arrow = 102;
CParser.Dot = 103;
CParser.Ellipsis = 104;
CParser.Identifier = 105;
CParser.Constant = 106;
CParser.DigitSequence = 107;
CParser.StringLiteral = 108;
CParser.ComplexDefine = 109;
CParser.AsmBlock = 110;
CParser.LineAfterPreprocessing = 111;
CParser.LineDirective = 112;
CParser.PragmaDirective = 113;
CParser.Whitespace = 114;
CParser.Newline = 115;
CParser.BlockComment = 116;
CParser.LineComment = 117;

CParser.RULE_primaryExpression = 0;
CParser.RULE_genericSelection = 1;
CParser.RULE_genericAssocList = 2;
CParser.RULE_genericAssociation = 3;
CParser.RULE_postfixExpression = 4;
CParser.RULE_argumentExpressionList = 5;
CParser.RULE_unaryExpression = 6;
CParser.RULE_unaryOperator = 7;
CParser.RULE_castExpression = 8;
CParser.RULE_multiplicativeExpression = 9;
CParser.RULE_additiveExpression = 10;
CParser.RULE_shiftExpression = 11;
CParser.RULE_relationalExpression = 12;
CParser.RULE_equalityExpression = 13;
CParser.RULE_andExpression = 14;
CParser.RULE_exclusiveOrExpression = 15;
CParser.RULE_inclusiveOrExpression = 16;
CParser.RULE_logicalAndExpression = 17;
CParser.RULE_logicalOrExpression = 18;
CParser.RULE_conditionalExpression = 19;
CParser.RULE_assignmentExpression = 20;
CParser.RULE_assignmentOperator = 21;
CParser.RULE_expression = 22;
CParser.RULE_constantExpression = 23;
CParser.RULE_declaration = 24;
CParser.RULE_declarationSpecifiers = 25;
CParser.RULE_declarationSpecifiers2 = 26;
CParser.RULE_declarationSpecifier = 27;
CParser.RULE_initDeclaratorList = 28;
CParser.RULE_initDeclarator = 29;
CParser.RULE_storageClassSpecifier = 30;
CParser.RULE_typeSpecifier = 31;
CParser.RULE_structOrUnionSpecifier = 32;
CParser.RULE_structOrUnion = 33;
CParser.RULE_structDeclarationList = 34;
CParser.RULE_structDeclaration = 35;
CParser.RULE_specifierQualifierList = 36;
CParser.RULE_structDeclaratorList = 37;
CParser.RULE_structDeclarator = 38;
CParser.RULE_enumSpecifier = 39;
CParser.RULE_enumeratorList = 40;
CParser.RULE_enumerator = 41;
CParser.RULE_enumerationConstant = 42;
CParser.RULE_atomicTypeSpecifier = 43;
CParser.RULE_typeQualifier = 44;
CParser.RULE_functionSpecifier = 45;
CParser.RULE_alignmentSpecifier = 46;
CParser.RULE_declarator = 47;
CParser.RULE_directDeclarator = 48;
CParser.RULE_gccDeclaratorExtension = 49;
CParser.RULE_gccAttributeSpecifier = 50;
CParser.RULE_gccAttributeList = 51;
CParser.RULE_gccAttribute = 52;
CParser.RULE_nestedParenthesesBlock = 53;
CParser.RULE_pointer = 54;
CParser.RULE_typeQualifierList = 55;
CParser.RULE_parameterTypeList = 56;
CParser.RULE_parameterList = 57;
CParser.RULE_parameterDeclaration = 58;
CParser.RULE_identifierList = 59;
CParser.RULE_typeName = 60;
CParser.RULE_abstractDeclarator = 61;
CParser.RULE_directAbstractDeclarator = 62;
CParser.RULE_typedefName = 63;
CParser.RULE_initializer = 64;
CParser.RULE_initializerList = 65;
CParser.RULE_designation = 66;
CParser.RULE_designatorList = 67;
CParser.RULE_designator = 68;
CParser.RULE_staticAssertDeclaration = 69;
CParser.RULE_statement = 70;
CParser.RULE_labeledStatement = 71;
CParser.RULE_compoundStatement = 72;
CParser.RULE_blockItemList = 73;
CParser.RULE_blockItem = 74;
CParser.RULE_expressionStatement = 75;
CParser.RULE_selectionStatement = 76;
CParser.RULE_iterationStatement = 77;
CParser.RULE_forCondition = 78;
CParser.RULE_forDeclaration = 79;
CParser.RULE_forExpression = 80;
CParser.RULE_jumpStatement = 81;
CParser.RULE_compilationUnit = 82;
CParser.RULE_translationUnit = 83;
CParser.RULE_externalDeclaration = 84;
CParser.RULE_functionDefinition = 85;
CParser.RULE_declarationList = 86;

function PrimaryExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_primaryExpression;
    return this;
}

PrimaryExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrimaryExpressionContext.prototype.constructor = PrimaryExpressionContext;

PrimaryExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

PrimaryExpressionContext.prototype.Constant = function() {
    return this.getToken(CParser.Constant, 0);
};

PrimaryExpressionContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


PrimaryExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

PrimaryExpressionContext.prototype.genericSelection = function() {
    return this.getTypedRuleContext(GenericSelectionContext,0);
};

PrimaryExpressionContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

PrimaryExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

PrimaryExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

PrimaryExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitPrimaryExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.PrimaryExpressionContext = PrimaryExpressionContext;

CParser.prototype.primaryExpression = function() {

    var localctx = new PrimaryExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, CParser.RULE_primaryExpression);
    var _la = 0; // Token type
    try {
        this.state = 207;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,2,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 174;
            this.match(CParser.Identifier);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 175;
            this.match(CParser.Constant);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 177; 
            this._errHandler.sync(this);
            var _alt = 1;
            do {
            	switch (_alt) {
            	case 1:
            		this.state = 176;
            		this.match(CParser.StringLiteral);
            		break;
            	default:
            		throw new antlr4.error.NoViableAltException(this);
            	}
            	this.state = 179; 
            	this._errHandler.sync(this);
            	_alt = this._interp.adaptivePredict(this._input,0, this._ctx);
            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 181;
            this.match(CParser.LeftParen);
            this.state = 182;
            this.expression(0);
            this.state = 183;
            this.match(CParser.RightParen);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 185;
            this.genericSelection();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 187;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.T__0) {
                this.state = 186;
                this.match(CParser.T__0);
            }

            this.state = 189;
            this.match(CParser.LeftParen);
            this.state = 190;
            this.compoundStatement();
            this.state = 191;
            this.match(CParser.RightParen);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 193;
            this.match(CParser.T__1);
            this.state = 194;
            this.match(CParser.LeftParen);
            this.state = 195;
            this.unaryExpression();
            this.state = 196;
            this.match(CParser.Comma);
            this.state = 197;
            this.typeName();
            this.state = 198;
            this.match(CParser.RightParen);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 200;
            this.match(CParser.T__2);
            this.state = 201;
            this.match(CParser.LeftParen);
            this.state = 202;
            this.typeName();
            this.state = 203;
            this.match(CParser.Comma);
            this.state = 204;
            this.unaryExpression();
            this.state = 205;
            this.match(CParser.RightParen);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericSelectionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericSelection;
    return this;
}

GenericSelectionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericSelectionContext.prototype.constructor = GenericSelectionContext;

GenericSelectionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

GenericSelectionContext.prototype.genericAssocList = function() {
    return this.getTypedRuleContext(GenericAssocListContext,0);
};

GenericSelectionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGenericSelection(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GenericSelectionContext = GenericSelectionContext;

CParser.prototype.genericSelection = function() {

    var localctx = new GenericSelectionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, CParser.RULE_genericSelection);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 209;
        this.match(CParser.Generic);
        this.state = 210;
        this.match(CParser.LeftParen);
        this.state = 211;
        this.assignmentExpression();
        this.state = 212;
        this.match(CParser.Comma);
        this.state = 213;
        this.genericAssocList(0);
        this.state = 214;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericAssocListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericAssocList;
    return this;
}

GenericAssocListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericAssocListContext.prototype.constructor = GenericAssocListContext;

GenericAssocListContext.prototype.genericAssociation = function() {
    return this.getTypedRuleContext(GenericAssociationContext,0);
};

GenericAssocListContext.prototype.genericAssocList = function() {
    return this.getTypedRuleContext(GenericAssocListContext,0);
};

GenericAssocListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGenericAssocList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.genericAssocList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new GenericAssocListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 4;
    this.enterRecursionRule(localctx, 4, CParser.RULE_genericAssocList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 217;
        this.genericAssociation();
        this._ctx.stop = this._input.LT(-1);
        this.state = 224;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,3,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new GenericAssocListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_genericAssocList);
                this.state = 219;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 220;
                this.match(CParser.Comma);
                this.state = 221;
                this.genericAssociation(); 
            }
            this.state = 226;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,3,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function GenericAssociationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericAssociation;
    return this;
}

GenericAssociationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericAssociationContext.prototype.constructor = GenericAssociationContext;

GenericAssociationContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

GenericAssociationContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

GenericAssociationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGenericAssociation(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GenericAssociationContext = GenericAssociationContext;

CParser.prototype.genericAssociation = function() {

    var localctx = new GenericAssociationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, CParser.RULE_genericAssociation);
    try {
        this.state = 234;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.Char:
        case CParser.Const:
        case CParser.Double:
        case CParser.Enum:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Restrict:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Struct:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 227;
            this.typeName();
            this.state = 228;
            this.match(CParser.Colon);
            this.state = 229;
            this.assignmentExpression();
            break;
        case CParser.Default:
            this.enterOuterAlt(localctx, 2);
            this.state = 231;
            this.match(CParser.Default);
            this.state = 232;
            this.match(CParser.Colon);
            this.state = 233;
            this.assignmentExpression();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PostfixExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_postfixExpression;
    return this;
}

PostfixExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PostfixExpressionContext.prototype.constructor = PostfixExpressionContext;

PostfixExpressionContext.prototype.primaryExpression = function() {
    return this.getTypedRuleContext(PrimaryExpressionContext,0);
};

PostfixExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

PostfixExpressionContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

PostfixExpressionContext.prototype.postfixExpression = function() {
    return this.getTypedRuleContext(PostfixExpressionContext,0);
};

PostfixExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

PostfixExpressionContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

PostfixExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

PostfixExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitPostfixExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.postfixExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new PostfixExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 8;
    this.enterRecursionRule(localctx, 8, CParser.RULE_postfixExpression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 270;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,5,this._ctx);
        switch(la_) {
        case 1:
            this.state = 237;
            this.primaryExpression();
            break;

        case 2:
            this.state = 238;
            this.match(CParser.LeftParen);
            this.state = 239;
            this.typeName();
            this.state = 240;
            this.match(CParser.RightParen);
            this.state = 241;
            this.match(CParser.LeftBrace);
            this.state = 242;
            this.initializerList(0);
            this.state = 243;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.state = 245;
            this.match(CParser.LeftParen);
            this.state = 246;
            this.typeName();
            this.state = 247;
            this.match(CParser.RightParen);
            this.state = 248;
            this.match(CParser.LeftBrace);
            this.state = 249;
            this.initializerList(0);
            this.state = 250;
            this.match(CParser.Comma);
            this.state = 251;
            this.match(CParser.RightBrace);
            break;

        case 4:
            this.state = 253;
            this.match(CParser.T__0);
            this.state = 254;
            this.match(CParser.LeftParen);
            this.state = 255;
            this.typeName();
            this.state = 256;
            this.match(CParser.RightParen);
            this.state = 257;
            this.match(CParser.LeftBrace);
            this.state = 258;
            this.initializerList(0);
            this.state = 259;
            this.match(CParser.RightBrace);
            break;

        case 5:
            this.state = 261;
            this.match(CParser.T__0);
            this.state = 262;
            this.match(CParser.LeftParen);
            this.state = 263;
            this.typeName();
            this.state = 264;
            this.match(CParser.RightParen);
            this.state = 265;
            this.match(CParser.LeftBrace);
            this.state = 266;
            this.initializerList(0);
            this.state = 267;
            this.match(CParser.Comma);
            this.state = 268;
            this.match(CParser.RightBrace);
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 295;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,8,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 293;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,7,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 272;
                    if (!( this.precpred(this._ctx, 10))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
                    }
                    this.state = 273;
                    this.match(CParser.LeftBracket);
                    this.state = 274;
                    this.expression(0);
                    this.state = 275;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 277;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 278;
                    this.match(CParser.LeftParen);
                    this.state = 280;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 279;
                        this.argumentExpressionList(0);
                    }

                    this.state = 282;
                    this.match(CParser.RightParen);
                    break;

                case 3:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 283;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 284;
                    this.match(CParser.Dot);
                    this.state = 285;
                    this.match(CParser.Identifier);
                    break;

                case 4:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 286;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 287;
                    this.match(CParser.Arrow);
                    this.state = 288;
                    this.match(CParser.Identifier);
                    break;

                case 5:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 289;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 290;
                    this.match(CParser.PlusPlus);
                    break;

                case 6:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 291;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 292;
                    this.match(CParser.MinusMinus);
                    break;

                } 
            }
            this.state = 297;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,8,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ArgumentExpressionListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_argumentExpressionList;
    return this;
}

ArgumentExpressionListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentExpressionListContext.prototype.constructor = ArgumentExpressionListContext;

ArgumentExpressionListContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

ArgumentExpressionListContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

ArgumentExpressionListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitArgumentExpressionList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.argumentExpressionList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ArgumentExpressionListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 10;
    this.enterRecursionRule(localctx, 10, CParser.RULE_argumentExpressionList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 299;
        this.assignmentExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 306;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,9,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ArgumentExpressionListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_argumentExpressionList);
                this.state = 301;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 302;
                this.match(CParser.Comma);
                this.state = 303;
                this.assignmentExpression(); 
            }
            this.state = 308;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,9,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function UnaryExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_unaryExpression;
    return this;
}

UnaryExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnaryExpressionContext.prototype.constructor = UnaryExpressionContext;

UnaryExpressionContext.prototype.postfixExpression = function() {
    return this.getTypedRuleContext(PostfixExpressionContext,0);
};

UnaryExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

UnaryExpressionContext.prototype.unaryOperator = function() {
    return this.getTypedRuleContext(UnaryOperatorContext,0);
};

UnaryExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

UnaryExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

UnaryExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

UnaryExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitUnaryExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.UnaryExpressionContext = UnaryExpressionContext;

CParser.prototype.unaryExpression = function() {

    var localctx = new UnaryExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, CParser.RULE_unaryExpression);
    try {
        this.state = 331;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 309;
            this.postfixExpression(0);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 310;
            this.match(CParser.PlusPlus);
            this.state = 311;
            this.unaryExpression();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 312;
            this.match(CParser.MinusMinus);
            this.state = 313;
            this.unaryExpression();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 314;
            this.unaryOperator();
            this.state = 315;
            this.castExpression();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 317;
            this.match(CParser.Sizeof);
            this.state = 318;
            this.unaryExpression();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 319;
            this.match(CParser.Sizeof);
            this.state = 320;
            this.match(CParser.LeftParen);
            this.state = 321;
            this.typeName();
            this.state = 322;
            this.match(CParser.RightParen);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 324;
            this.match(CParser.Alignof);
            this.state = 325;
            this.match(CParser.LeftParen);
            this.state = 326;
            this.typeName();
            this.state = 327;
            this.match(CParser.RightParen);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 329;
            this.match(CParser.AndAnd);
            this.state = 330;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function UnaryOperatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_unaryOperator;
    return this;
}

UnaryOperatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnaryOperatorContext.prototype.constructor = UnaryOperatorContext;


UnaryOperatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitUnaryOperator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.UnaryOperatorContext = UnaryOperatorContext;

CParser.prototype.unaryOperator = function() {

    var localctx = new UnaryOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, CParser.RULE_unaryOperator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 333;
        _la = this._input.LA(1);
        if(!(((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CastExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_castExpression;
    return this;
}

CastExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CastExpressionContext.prototype.constructor = CastExpressionContext;

CastExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

CastExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

CastExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

CastExpressionContext.prototype.DigitSequence = function() {
    return this.getToken(CParser.DigitSequence, 0);
};

CastExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitCastExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.CastExpressionContext = CastExpressionContext;

CParser.prototype.castExpression = function() {

    var localctx = new CastExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, CParser.RULE_castExpression);
    try {
        this.state = 348;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,11,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 335;
            this.unaryExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 336;
            this.match(CParser.LeftParen);
            this.state = 337;
            this.typeName();
            this.state = 338;
            this.match(CParser.RightParen);
            this.state = 339;
            this.castExpression();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 341;
            this.match(CParser.T__0);
            this.state = 342;
            this.match(CParser.LeftParen);
            this.state = 343;
            this.typeName();
            this.state = 344;
            this.match(CParser.RightParen);
            this.state = 345;
            this.castExpression();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 347;
            this.match(CParser.DigitSequence);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MultiplicativeExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_multiplicativeExpression;
    return this;
}

MultiplicativeExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MultiplicativeExpressionContext.prototype.constructor = MultiplicativeExpressionContext;

MultiplicativeExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

MultiplicativeExpressionContext.prototype.multiplicativeExpression = function() {
    return this.getTypedRuleContext(MultiplicativeExpressionContext,0);
};

MultiplicativeExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitMultiplicativeExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.multiplicativeExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new MultiplicativeExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 18;
    this.enterRecursionRule(localctx, 18, CParser.RULE_multiplicativeExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 351;
        this.castExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 364;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,13,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 362;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,12,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 353;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 354;
                    this.match(CParser.Star);
                    this.state = 355;
                    this.castExpression();
                    break;

                case 2:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 356;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 357;
                    this.match(CParser.Div);
                    this.state = 358;
                    this.castExpression();
                    break;

                case 3:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 359;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 360;
                    this.match(CParser.Mod);
                    this.state = 361;
                    this.castExpression();
                    break;

                } 
            }
            this.state = 366;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,13,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function AdditiveExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_additiveExpression;
    return this;
}

AdditiveExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AdditiveExpressionContext.prototype.constructor = AdditiveExpressionContext;

AdditiveExpressionContext.prototype.multiplicativeExpression = function() {
    return this.getTypedRuleContext(MultiplicativeExpressionContext,0);
};

AdditiveExpressionContext.prototype.additiveExpression = function() {
    return this.getTypedRuleContext(AdditiveExpressionContext,0);
};

AdditiveExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAdditiveExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.additiveExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new AdditiveExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 20;
    this.enterRecursionRule(localctx, 20, CParser.RULE_additiveExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 368;
        this.multiplicativeExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 378;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,15,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 376;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,14,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new AdditiveExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_additiveExpression);
                    this.state = 370;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 371;
                    this.match(CParser.Plus);
                    this.state = 372;
                    this.multiplicativeExpression(0);
                    break;

                case 2:
                    localctx = new AdditiveExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_additiveExpression);
                    this.state = 373;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 374;
                    this.match(CParser.Minus);
                    this.state = 375;
                    this.multiplicativeExpression(0);
                    break;

                } 
            }
            this.state = 380;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,15,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ShiftExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_shiftExpression;
    return this;
}

ShiftExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ShiftExpressionContext.prototype.constructor = ShiftExpressionContext;

ShiftExpressionContext.prototype.additiveExpression = function() {
    return this.getTypedRuleContext(AdditiveExpressionContext,0);
};

ShiftExpressionContext.prototype.shiftExpression = function() {
    return this.getTypedRuleContext(ShiftExpressionContext,0);
};

ShiftExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitShiftExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.shiftExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ShiftExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 22;
    this.enterRecursionRule(localctx, 22, CParser.RULE_shiftExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 382;
        this.additiveExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 392;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,17,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 390;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,16,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new ShiftExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_shiftExpression);
                    this.state = 384;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 385;
                    this.match(CParser.LeftShift);
                    this.state = 386;
                    this.additiveExpression(0);
                    break;

                case 2:
                    localctx = new ShiftExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_shiftExpression);
                    this.state = 387;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 388;
                    this.match(CParser.RightShift);
                    this.state = 389;
                    this.additiveExpression(0);
                    break;

                } 
            }
            this.state = 394;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,17,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function RelationalExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_relationalExpression;
    return this;
}

RelationalExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RelationalExpressionContext.prototype.constructor = RelationalExpressionContext;

RelationalExpressionContext.prototype.shiftExpression = function() {
    return this.getTypedRuleContext(ShiftExpressionContext,0);
};

RelationalExpressionContext.prototype.relationalExpression = function() {
    return this.getTypedRuleContext(RelationalExpressionContext,0);
};

RelationalExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitRelationalExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.relationalExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new RelationalExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 24;
    this.enterRecursionRule(localctx, 24, CParser.RULE_relationalExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 396;
        this.shiftExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 412;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,19,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 410;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,18,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 398;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 399;
                    this.match(CParser.Less);
                    this.state = 400;
                    this.shiftExpression(0);
                    break;

                case 2:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 401;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 402;
                    this.match(CParser.Greater);
                    this.state = 403;
                    this.shiftExpression(0);
                    break;

                case 3:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 404;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 405;
                    this.match(CParser.LessEqual);
                    this.state = 406;
                    this.shiftExpression(0);
                    break;

                case 4:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 407;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 408;
                    this.match(CParser.GreaterEqual);
                    this.state = 409;
                    this.shiftExpression(0);
                    break;

                } 
            }
            this.state = 414;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,19,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function EqualityExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_equalityExpression;
    return this;
}

EqualityExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EqualityExpressionContext.prototype.constructor = EqualityExpressionContext;

EqualityExpressionContext.prototype.relationalExpression = function() {
    return this.getTypedRuleContext(RelationalExpressionContext,0);
};

EqualityExpressionContext.prototype.equalityExpression = function() {
    return this.getTypedRuleContext(EqualityExpressionContext,0);
};

EqualityExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitEqualityExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.equalityExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new EqualityExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 26;
    this.enterRecursionRule(localctx, 26, CParser.RULE_equalityExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 416;
        this.relationalExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 426;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,21,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 424;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,20,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new EqualityExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_equalityExpression);
                    this.state = 418;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 419;
                    this.match(CParser.Equal);
                    this.state = 420;
                    this.relationalExpression(0);
                    break;

                case 2:
                    localctx = new EqualityExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_equalityExpression);
                    this.state = 421;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 422;
                    this.match(CParser.NotEqual);
                    this.state = 423;
                    this.relationalExpression(0);
                    break;

                } 
            }
            this.state = 428;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,21,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function AndExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_andExpression;
    return this;
}

AndExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AndExpressionContext.prototype.constructor = AndExpressionContext;

AndExpressionContext.prototype.equalityExpression = function() {
    return this.getTypedRuleContext(EqualityExpressionContext,0);
};

AndExpressionContext.prototype.andExpression = function() {
    return this.getTypedRuleContext(AndExpressionContext,0);
};

AndExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAndExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.andExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new AndExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 28;
    this.enterRecursionRule(localctx, 28, CParser.RULE_andExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 430;
        this.equalityExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 437;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,22,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new AndExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_andExpression);
                this.state = 432;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 433;
                this.match(CParser.And);
                this.state = 434;
                this.equalityExpression(0); 
            }
            this.state = 439;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,22,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ExclusiveOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_exclusiveOrExpression;
    return this;
}

ExclusiveOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExclusiveOrExpressionContext.prototype.constructor = ExclusiveOrExpressionContext;

ExclusiveOrExpressionContext.prototype.andExpression = function() {
    return this.getTypedRuleContext(AndExpressionContext,0);
};

ExclusiveOrExpressionContext.prototype.exclusiveOrExpression = function() {
    return this.getTypedRuleContext(ExclusiveOrExpressionContext,0);
};

ExclusiveOrExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitExclusiveOrExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.exclusiveOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExclusiveOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 30;
    this.enterRecursionRule(localctx, 30, CParser.RULE_exclusiveOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 441;
        this.andExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 448;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,23,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ExclusiveOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_exclusiveOrExpression);
                this.state = 443;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 444;
                this.match(CParser.Caret);
                this.state = 445;
                this.andExpression(0); 
            }
            this.state = 450;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,23,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function InclusiveOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_inclusiveOrExpression;
    return this;
}

InclusiveOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InclusiveOrExpressionContext.prototype.constructor = InclusiveOrExpressionContext;

InclusiveOrExpressionContext.prototype.exclusiveOrExpression = function() {
    return this.getTypedRuleContext(ExclusiveOrExpressionContext,0);
};

InclusiveOrExpressionContext.prototype.inclusiveOrExpression = function() {
    return this.getTypedRuleContext(InclusiveOrExpressionContext,0);
};

InclusiveOrExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitInclusiveOrExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.inclusiveOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InclusiveOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 32;
    this.enterRecursionRule(localctx, 32, CParser.RULE_inclusiveOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 452;
        this.exclusiveOrExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 459;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,24,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InclusiveOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_inclusiveOrExpression);
                this.state = 454;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 455;
                this.match(CParser.Or);
                this.state = 456;
                this.exclusiveOrExpression(0); 
            }
            this.state = 461;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,24,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function LogicalAndExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_logicalAndExpression;
    return this;
}

LogicalAndExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LogicalAndExpressionContext.prototype.constructor = LogicalAndExpressionContext;

LogicalAndExpressionContext.prototype.inclusiveOrExpression = function() {
    return this.getTypedRuleContext(InclusiveOrExpressionContext,0);
};

LogicalAndExpressionContext.prototype.logicalAndExpression = function() {
    return this.getTypedRuleContext(LogicalAndExpressionContext,0);
};

LogicalAndExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitLogicalAndExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.logicalAndExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new LogicalAndExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 34;
    this.enterRecursionRule(localctx, 34, CParser.RULE_logicalAndExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 463;
        this.inclusiveOrExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 470;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,25,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new LogicalAndExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_logicalAndExpression);
                this.state = 465;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 466;
                this.match(CParser.AndAnd);
                this.state = 467;
                this.inclusiveOrExpression(0); 
            }
            this.state = 472;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,25,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function LogicalOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_logicalOrExpression;
    return this;
}

LogicalOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LogicalOrExpressionContext.prototype.constructor = LogicalOrExpressionContext;

LogicalOrExpressionContext.prototype.logicalAndExpression = function() {
    return this.getTypedRuleContext(LogicalAndExpressionContext,0);
};

LogicalOrExpressionContext.prototype.logicalOrExpression = function() {
    return this.getTypedRuleContext(LogicalOrExpressionContext,0);
};

LogicalOrExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitLogicalOrExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.logicalOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new LogicalOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 36;
    this.enterRecursionRule(localctx, 36, CParser.RULE_logicalOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 474;
        this.logicalAndExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 481;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,26,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new LogicalOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_logicalOrExpression);
                this.state = 476;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 477;
                this.match(CParser.OrOr);
                this.state = 478;
                this.logicalAndExpression(0); 
            }
            this.state = 483;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,26,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ConditionalExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_conditionalExpression;
    return this;
}

ConditionalExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConditionalExpressionContext.prototype.constructor = ConditionalExpressionContext;

ConditionalExpressionContext.prototype.logicalOrExpression = function() {
    return this.getTypedRuleContext(LogicalOrExpressionContext,0);
};

ConditionalExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ConditionalExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

ConditionalExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitConditionalExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ConditionalExpressionContext = ConditionalExpressionContext;

CParser.prototype.conditionalExpression = function() {

    var localctx = new ConditionalExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, CParser.RULE_conditionalExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 484;
        this.logicalOrExpression(0);
        this.state = 490;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,27,this._ctx);
        if(la_===1) {
            this.state = 485;
            this.match(CParser.Question);
            this.state = 486;
            this.expression(0);
            this.state = 487;
            this.match(CParser.Colon);
            this.state = 488;
            this.conditionalExpression();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AssignmentExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_assignmentExpression;
    return this;
}

AssignmentExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AssignmentExpressionContext.prototype.constructor = AssignmentExpressionContext;

AssignmentExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

AssignmentExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

AssignmentExpressionContext.prototype.assignmentOperator = function() {
    return this.getTypedRuleContext(AssignmentOperatorContext,0);
};

AssignmentExpressionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

AssignmentExpressionContext.prototype.DigitSequence = function() {
    return this.getToken(CParser.DigitSequence, 0);
};

AssignmentExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAssignmentExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.AssignmentExpressionContext = AssignmentExpressionContext;

CParser.prototype.assignmentExpression = function() {

    var localctx = new AssignmentExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, CParser.RULE_assignmentExpression);
    try {
        this.state = 498;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,28,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 492;
            this.conditionalExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 493;
            this.unaryExpression();
            this.state = 494;
            this.assignmentOperator();
            this.state = 495;
            this.assignmentExpression();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 497;
            this.match(CParser.DigitSequence);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AssignmentOperatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_assignmentOperator;
    return this;
}

AssignmentOperatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AssignmentOperatorContext.prototype.constructor = AssignmentOperatorContext;


AssignmentOperatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAssignmentOperator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.AssignmentOperatorContext = AssignmentOperatorContext;

CParser.prototype.assignmentOperator = function() {

    var localctx = new AssignmentOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, CParser.RULE_assignmentOperator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 500;
        _la = this._input.LA(1);
        if(!(((((_la - 89)) & ~0x1f) == 0 && ((1 << (_la - 89)) & ((1 << (CParser.Assign - 89)) | (1 << (CParser.StarAssign - 89)) | (1 << (CParser.DivAssign - 89)) | (1 << (CParser.ModAssign - 89)) | (1 << (CParser.PlusAssign - 89)) | (1 << (CParser.MinusAssign - 89)) | (1 << (CParser.LeftShiftAssign - 89)) | (1 << (CParser.RightShiftAssign - 89)) | (1 << (CParser.AndAssign - 89)) | (1 << (CParser.XorAssign - 89)) | (1 << (CParser.OrAssign - 89)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;

ExpressionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

ExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.expression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 44;
    this.enterRecursionRule(localctx, 44, CParser.RULE_expression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 503;
        this.assignmentExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 510;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,29,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_expression);
                this.state = 505;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 506;
                this.match(CParser.Comma);
                this.state = 507;
                this.assignmentExpression(); 
            }
            this.state = 512;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,29,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ConstantExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_constantExpression;
    return this;
}

ConstantExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantExpressionContext.prototype.constructor = ConstantExpressionContext;

ConstantExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

ConstantExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitConstantExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ConstantExpressionContext = ConstantExpressionContext;

CParser.prototype.constantExpression = function() {

    var localctx = new ConstantExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, CParser.RULE_constantExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 513;
        this.conditionalExpression();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declaration;
    return this;
}

DeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationContext.prototype.constructor = DeclarationContext;

DeclarationContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

DeclarationContext.prototype.initDeclaratorList = function() {
    return this.getTypedRuleContext(InitDeclaratorListContext,0);
};

DeclarationContext.prototype.staticAssertDeclaration = function() {
    return this.getTypedRuleContext(StaticAssertDeclarationContext,0);
};

DeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DeclarationContext = DeclarationContext;

CParser.prototype.declaration = function() {

    var localctx = new DeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, CParser.RULE_declaration);
    try {
        this.state = 523;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,30,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 515;
            this.declarationSpecifiers();
            this.state = 516;
            this.initDeclaratorList(0);
            this.state = 517;
            this.match(CParser.Semi);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 519;
            this.declarationSpecifiers();
            this.state = 520;
            this.match(CParser.Semi);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 522;
            this.staticAssertDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifiersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifiers;
    return this;
}

DeclarationSpecifiersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifiersContext.prototype.constructor = DeclarationSpecifiersContext;

DeclarationSpecifiersContext.prototype.declarationSpecifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationSpecifierContext);
    } else {
        return this.getTypedRuleContext(DeclarationSpecifierContext,i);
    }
};

DeclarationSpecifiersContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclarationSpecifiers(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DeclarationSpecifiersContext = DeclarationSpecifiersContext;

CParser.prototype.declarationSpecifiers = function() {

    var localctx = new DeclarationSpecifiersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, CParser.RULE_declarationSpecifiers);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 526; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 525;
        		this.declarationSpecifier();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 528; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,31, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifiers2Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifiers2;
    return this;
}

DeclarationSpecifiers2Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifiers2Context.prototype.constructor = DeclarationSpecifiers2Context;

DeclarationSpecifiers2Context.prototype.declarationSpecifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationSpecifierContext);
    } else {
        return this.getTypedRuleContext(DeclarationSpecifierContext,i);
    }
};

DeclarationSpecifiers2Context.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclarationSpecifiers2(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DeclarationSpecifiers2Context = DeclarationSpecifiers2Context;

CParser.prototype.declarationSpecifiers2 = function() {

    var localctx = new DeclarationSpecifiers2Context(this, this._ctx, this.state);
    this.enterRule(localctx, 52, CParser.RULE_declarationSpecifiers2);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 531; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 530;
        		this.declarationSpecifier();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 533; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,32, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifier;
    return this;
}

DeclarationSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifierContext.prototype.constructor = DeclarationSpecifierContext;

DeclarationSpecifierContext.prototype.storageClassSpecifier = function() {
    return this.getTypedRuleContext(StorageClassSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.typeSpecifier = function() {
    return this.getTypedRuleContext(TypeSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

DeclarationSpecifierContext.prototype.functionSpecifier = function() {
    return this.getTypedRuleContext(FunctionSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.alignmentSpecifier = function() {
    return this.getTypedRuleContext(AlignmentSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclarationSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DeclarationSpecifierContext = DeclarationSpecifierContext;

CParser.prototype.declarationSpecifier = function() {

    var localctx = new DeclarationSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, CParser.RULE_declarationSpecifier);
    try {
        this.state = 540;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,33,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 535;
            this.storageClassSpecifier();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 536;
            this.typeSpecifier();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 537;
            this.typeQualifier();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 538;
            this.functionSpecifier();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 539;
            this.alignmentSpecifier();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitDeclaratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initDeclaratorList;
    return this;
}

InitDeclaratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitDeclaratorListContext.prototype.constructor = InitDeclaratorListContext;

InitDeclaratorListContext.prototype.initDeclarator = function() {
    return this.getTypedRuleContext(InitDeclaratorContext,0);
};

InitDeclaratorListContext.prototype.initDeclaratorList = function() {
    return this.getTypedRuleContext(InitDeclaratorListContext,0);
};

InitDeclaratorListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitInitDeclaratorList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.initDeclaratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InitDeclaratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 56;
    this.enterRecursionRule(localctx, 56, CParser.RULE_initDeclaratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 543;
        this.initDeclarator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 550;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,34,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InitDeclaratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_initDeclaratorList);
                this.state = 545;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 546;
                this.match(CParser.Comma);
                this.state = 547;
                this.initDeclarator(); 
            }
            this.state = 552;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,34,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function InitDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initDeclarator;
    return this;
}

InitDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitDeclaratorContext.prototype.constructor = InitDeclaratorContext;

InitDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

InitDeclaratorContext.prototype.initializer = function() {
    return this.getTypedRuleContext(InitializerContext,0);
};

InitDeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitInitDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.InitDeclaratorContext = InitDeclaratorContext;

CParser.prototype.initDeclarator = function() {

    var localctx = new InitDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, CParser.RULE_initDeclarator);
    try {
        this.state = 558;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,35,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 553;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 554;
            this.declarator();
            this.state = 555;
            this.match(CParser.Assign);
            this.state = 556;
            this.initializer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StorageClassSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_storageClassSpecifier;
    return this;
}

StorageClassSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StorageClassSpecifierContext.prototype.constructor = StorageClassSpecifierContext;


StorageClassSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStorageClassSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StorageClassSpecifierContext = StorageClassSpecifierContext;

CParser.prototype.storageClassSpecifier = function() {

    var localctx = new StorageClassSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, CParser.RULE_storageClassSpecifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 560;
        _la = this._input.LA(1);
        if(!(_la===CParser.Auto || _la===CParser.Extern || ((((_la - 34)) & ~0x1f) == 0 && ((1 << (_la - 34)) & ((1 << (CParser.Register - 34)) | (1 << (CParser.Static - 34)) | (1 << (CParser.Typedef - 34)) | (1 << (CParser.ThreadLocal - 34)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeSpecifier;
    return this;
}

TypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeSpecifierContext.prototype.constructor = TypeSpecifierContext;

TypeSpecifierContext.prototype.atomicTypeSpecifier = function() {
    return this.getTypedRuleContext(AtomicTypeSpecifierContext,0);
};

TypeSpecifierContext.prototype.structOrUnionSpecifier = function() {
    return this.getTypedRuleContext(StructOrUnionSpecifierContext,0);
};

TypeSpecifierContext.prototype.enumSpecifier = function() {
    return this.getTypedRuleContext(EnumSpecifierContext,0);
};

TypeSpecifierContext.prototype.typedefName = function() {
    return this.getTypedRuleContext(TypedefNameContext,0);
};

TypeSpecifierContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

TypeSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTypeSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.TypeSpecifierContext = TypeSpecifierContext;

CParser.prototype.typeSpecifier = function() {

    var localctx = new TypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, CParser.RULE_typeSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 576;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.Char:
        case CParser.Double:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Bool:
        case CParser.Complex:
            this.enterOuterAlt(localctx, 1);
            this.state = 562;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.Char) | (1 << CParser.Double) | (1 << CParser.Float))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            break;
        case CParser.T__0:
            this.enterOuterAlt(localctx, 2);
            this.state = 563;
            this.match(CParser.T__0);
            this.state = 564;
            this.match(CParser.LeftParen);
            this.state = 565;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 566;
            this.match(CParser.RightParen);
            break;
        case CParser.Atomic:
            this.enterOuterAlt(localctx, 3);
            this.state = 567;
            this.atomicTypeSpecifier();
            break;
        case CParser.Struct:
        case CParser.Union:
            this.enterOuterAlt(localctx, 4);
            this.state = 568;
            this.structOrUnionSpecifier();
            break;
        case CParser.Enum:
            this.enterOuterAlt(localctx, 5);
            this.state = 569;
            this.enumSpecifier();
            break;
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 6);
            this.state = 570;
            this.typedefName();
            break;
        case CParser.T__6:
            this.enterOuterAlt(localctx, 7);
            this.state = 571;
            this.match(CParser.T__6);
            this.state = 572;
            this.match(CParser.LeftParen);
            this.state = 573;
            this.constantExpression();
            this.state = 574;
            this.match(CParser.RightParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructOrUnionSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structOrUnionSpecifier;
    return this;
}

StructOrUnionSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructOrUnionSpecifierContext.prototype.constructor = StructOrUnionSpecifierContext;

StructOrUnionSpecifierContext.prototype.structOrUnion = function() {
    return this.getTypedRuleContext(StructOrUnionContext,0);
};

StructOrUnionSpecifierContext.prototype.structDeclarationList = function() {
    return this.getTypedRuleContext(StructDeclarationListContext,0);
};

StructOrUnionSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

StructOrUnionSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructOrUnionSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StructOrUnionSpecifierContext = StructOrUnionSpecifierContext;

CParser.prototype.structOrUnionSpecifier = function() {

    var localctx = new StructOrUnionSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, CParser.RULE_structOrUnionSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 589;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,38,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 578;
            this.structOrUnion();
            this.state = 580;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 579;
                this.match(CParser.Identifier);
            }

            this.state = 582;
            this.match(CParser.LeftBrace);
            this.state = 583;
            this.structDeclarationList(0);
            this.state = 584;
            this.match(CParser.RightBrace);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 586;
            this.structOrUnion();
            this.state = 587;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructOrUnionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structOrUnion;
    return this;
}

StructOrUnionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructOrUnionContext.prototype.constructor = StructOrUnionContext;


StructOrUnionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructOrUnion(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StructOrUnionContext = StructOrUnionContext;

CParser.prototype.structOrUnion = function() {

    var localctx = new StructOrUnionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, CParser.RULE_structOrUnion);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 591;
        _la = this._input.LA(1);
        if(!(_la===CParser.Struct || _la===CParser.Union)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructDeclarationListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclarationList;
    return this;
}

StructDeclarationListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclarationListContext.prototype.constructor = StructDeclarationListContext;

StructDeclarationListContext.prototype.structDeclaration = function() {
    return this.getTypedRuleContext(StructDeclarationContext,0);
};

StructDeclarationListContext.prototype.structDeclarationList = function() {
    return this.getTypedRuleContext(StructDeclarationListContext,0);
};

StructDeclarationListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructDeclarationList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.structDeclarationList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new StructDeclarationListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 68;
    this.enterRecursionRule(localctx, 68, CParser.RULE_structDeclarationList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 594;
        this.structDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 600;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,39,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new StructDeclarationListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_structDeclarationList);
                this.state = 596;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 597;
                this.structDeclaration(); 
            }
            this.state = 602;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,39,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function StructDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclaration;
    return this;
}

StructDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclarationContext.prototype.constructor = StructDeclarationContext;

StructDeclarationContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

StructDeclarationContext.prototype.structDeclaratorList = function() {
    return this.getTypedRuleContext(StructDeclaratorListContext,0);
};

StructDeclarationContext.prototype.staticAssertDeclaration = function() {
    return this.getTypedRuleContext(StaticAssertDeclarationContext,0);
};

StructDeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StructDeclarationContext = StructDeclarationContext;

CParser.prototype.structDeclaration = function() {

    var localctx = new StructDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, CParser.RULE_structDeclaration);
    var _la = 0; // Token type
    try {
        this.state = 610;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.Char:
        case CParser.Const:
        case CParser.Double:
        case CParser.Enum:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Restrict:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Struct:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 603;
            this.specifierQualifierList();
            this.state = 605;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)) | (1 << (CParser.Colon - 59)))) !== 0) || _la===CParser.Identifier) {
                this.state = 604;
                this.structDeclaratorList(0);
            }

            this.state = 607;
            this.match(CParser.Semi);
            break;
        case CParser.StaticAssert:
            this.enterOuterAlt(localctx, 2);
            this.state = 609;
            this.staticAssertDeclaration();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SpecifierQualifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_specifierQualifierList;
    return this;
}

SpecifierQualifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SpecifierQualifierListContext.prototype.constructor = SpecifierQualifierListContext;

SpecifierQualifierListContext.prototype.typeSpecifier = function() {
    return this.getTypedRuleContext(TypeSpecifierContext,0);
};

SpecifierQualifierListContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

SpecifierQualifierListContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

SpecifierQualifierListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitSpecifierQualifierList(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.SpecifierQualifierListContext = SpecifierQualifierListContext;

CParser.prototype.specifierQualifierList = function() {

    var localctx = new SpecifierQualifierListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, CParser.RULE_specifierQualifierList);
    try {
        this.state = 620;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,44,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 612;
            this.typeSpecifier();
            this.state = 614;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,42,this._ctx);
            if(la_===1) {
                this.state = 613;
                this.specifierQualifierList();

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 616;
            this.typeQualifier();
            this.state = 618;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,43,this._ctx);
            if(la_===1) {
                this.state = 617;
                this.specifierQualifierList();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructDeclaratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclaratorList;
    return this;
}

StructDeclaratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclaratorListContext.prototype.constructor = StructDeclaratorListContext;

StructDeclaratorListContext.prototype.structDeclarator = function() {
    return this.getTypedRuleContext(StructDeclaratorContext,0);
};

StructDeclaratorListContext.prototype.structDeclaratorList = function() {
    return this.getTypedRuleContext(StructDeclaratorListContext,0);
};

StructDeclaratorListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructDeclaratorList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.structDeclaratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new StructDeclaratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 74;
    this.enterRecursionRule(localctx, 74, CParser.RULE_structDeclaratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 623;
        this.structDeclarator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 630;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,45,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new StructDeclaratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_structDeclaratorList);
                this.state = 625;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 626;
                this.match(CParser.Comma);
                this.state = 627;
                this.structDeclarator(); 
            }
            this.state = 632;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,45,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function StructDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclarator;
    return this;
}

StructDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclaratorContext.prototype.constructor = StructDeclaratorContext;

StructDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

StructDeclaratorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

StructDeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStructDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StructDeclaratorContext = StructDeclaratorContext;

CParser.prototype.structDeclarator = function() {

    var localctx = new StructDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, CParser.RULE_structDeclarator);
    var _la = 0; // Token type
    try {
        this.state = 639;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,47,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 633;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 635;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)))) !== 0) || _la===CParser.Identifier) {
                this.state = 634;
                this.declarator();
            }

            this.state = 637;
            this.match(CParser.Colon);
            this.state = 638;
            this.constantExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumSpecifier;
    return this;
}

EnumSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumSpecifierContext.prototype.constructor = EnumSpecifierContext;

EnumSpecifierContext.prototype.enumeratorList = function() {
    return this.getTypedRuleContext(EnumeratorListContext,0);
};

EnumSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

EnumSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitEnumSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.EnumSpecifierContext = EnumSpecifierContext;

CParser.prototype.enumSpecifier = function() {

    var localctx = new EnumSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, CParser.RULE_enumSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 660;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,50,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 641;
            this.match(CParser.Enum);
            this.state = 643;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 642;
                this.match(CParser.Identifier);
            }

            this.state = 645;
            this.match(CParser.LeftBrace);
            this.state = 646;
            this.enumeratorList(0);
            this.state = 647;
            this.match(CParser.RightBrace);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 649;
            this.match(CParser.Enum);
            this.state = 651;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 650;
                this.match(CParser.Identifier);
            }

            this.state = 653;
            this.match(CParser.LeftBrace);
            this.state = 654;
            this.enumeratorList(0);
            this.state = 655;
            this.match(CParser.Comma);
            this.state = 656;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 658;
            this.match(CParser.Enum);
            this.state = 659;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumeratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumeratorList;
    return this;
}

EnumeratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorListContext.prototype.constructor = EnumeratorListContext;

EnumeratorListContext.prototype.enumerator = function() {
    return this.getTypedRuleContext(EnumeratorContext,0);
};

EnumeratorListContext.prototype.enumeratorList = function() {
    return this.getTypedRuleContext(EnumeratorListContext,0);
};

EnumeratorListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitEnumeratorList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.enumeratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new EnumeratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 80;
    this.enterRecursionRule(localctx, 80, CParser.RULE_enumeratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 663;
        this.enumerator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 670;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,51,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new EnumeratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_enumeratorList);
                this.state = 665;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 666;
                this.match(CParser.Comma);
                this.state = 667;
                this.enumerator(); 
            }
            this.state = 672;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,51,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function EnumeratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumerator;
    return this;
}

EnumeratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorContext.prototype.constructor = EnumeratorContext;

EnumeratorContext.prototype.enumerationConstant = function() {
    return this.getTypedRuleContext(EnumerationConstantContext,0);
};

EnumeratorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

EnumeratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitEnumerator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.EnumeratorContext = EnumeratorContext;

CParser.prototype.enumerator = function() {

    var localctx = new EnumeratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, CParser.RULE_enumerator);
    try {
        this.state = 678;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,52,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 673;
            this.enumerationConstant();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 674;
            this.enumerationConstant();
            this.state = 675;
            this.match(CParser.Assign);
            this.state = 676;
            this.constantExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumerationConstantContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumerationConstant;
    return this;
}

EnumerationConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumerationConstantContext.prototype.constructor = EnumerationConstantContext;

EnumerationConstantContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

EnumerationConstantContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitEnumerationConstant(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.EnumerationConstantContext = EnumerationConstantContext;

CParser.prototype.enumerationConstant = function() {

    var localctx = new EnumerationConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, CParser.RULE_enumerationConstant);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 680;
        this.match(CParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AtomicTypeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_atomicTypeSpecifier;
    return this;
}

AtomicTypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AtomicTypeSpecifierContext.prototype.constructor = AtomicTypeSpecifierContext;

AtomicTypeSpecifierContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

AtomicTypeSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAtomicTypeSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.AtomicTypeSpecifierContext = AtomicTypeSpecifierContext;

CParser.prototype.atomicTypeSpecifier = function() {

    var localctx = new AtomicTypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, CParser.RULE_atomicTypeSpecifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 682;
        this.match(CParser.Atomic);
        this.state = 683;
        this.match(CParser.LeftParen);
        this.state = 684;
        this.typeName();
        this.state = 685;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeQualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeQualifier;
    return this;
}

TypeQualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeQualifierContext.prototype.constructor = TypeQualifierContext;


TypeQualifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTypeQualifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.TypeQualifierContext = TypeQualifierContext;

CParser.prototype.typeQualifier = function() {

    var localctx = new TypeQualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, CParser.RULE_typeQualifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 687;
        _la = this._input.LA(1);
        if(!(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_functionSpecifier;
    return this;
}

FunctionSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionSpecifierContext.prototype.constructor = FunctionSpecifierContext;

FunctionSpecifierContext.prototype.gccAttributeSpecifier = function() {
    return this.getTypedRuleContext(GccAttributeSpecifierContext,0);
};

FunctionSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

FunctionSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitFunctionSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.FunctionSpecifierContext = FunctionSpecifierContext;

CParser.prototype.functionSpecifier = function() {

    var localctx = new FunctionSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, CParser.RULE_functionSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 695;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__7:
        case CParser.T__8:
        case CParser.Inline:
        case CParser.Noreturn:
            this.enterOuterAlt(localctx, 1);
            this.state = 689;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.Inline))) !== 0) || _la===CParser.Noreturn)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            break;
        case CParser.T__11:
            this.enterOuterAlt(localctx, 2);
            this.state = 690;
            this.gccAttributeSpecifier();
            break;
        case CParser.T__9:
            this.enterOuterAlt(localctx, 3);
            this.state = 691;
            this.match(CParser.T__9);
            this.state = 692;
            this.match(CParser.LeftParen);
            this.state = 693;
            this.match(CParser.Identifier);
            this.state = 694;
            this.match(CParser.RightParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AlignmentSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_alignmentSpecifier;
    return this;
}

AlignmentSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AlignmentSpecifierContext.prototype.constructor = AlignmentSpecifierContext;

AlignmentSpecifierContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

AlignmentSpecifierContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

AlignmentSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAlignmentSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.AlignmentSpecifierContext = AlignmentSpecifierContext;

CParser.prototype.alignmentSpecifier = function() {

    var localctx = new AlignmentSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, CParser.RULE_alignmentSpecifier);
    try {
        this.state = 707;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,54,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 697;
            this.match(CParser.Alignas);
            this.state = 698;
            this.match(CParser.LeftParen);
            this.state = 699;
            this.typeName();
            this.state = 700;
            this.match(CParser.RightParen);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 702;
            this.match(CParser.Alignas);
            this.state = 703;
            this.match(CParser.LeftParen);
            this.state = 704;
            this.constantExpression();
            this.state = 705;
            this.match(CParser.RightParen);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarator;
    return this;
}

DeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclaratorContext.prototype.constructor = DeclaratorContext;

DeclaratorContext.prototype.directDeclarator = function() {
    return this.getTypedRuleContext(DirectDeclaratorContext,0);
};

DeclaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

DeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

DeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DeclaratorContext = DeclaratorContext;

CParser.prototype.declarator = function() {

    var localctx = new DeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, CParser.RULE_declarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 710;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===CParser.Star || _la===CParser.Caret) {
            this.state = 709;
            this.pointer();
        }

        this.state = 712;
        this.directDeclarator(0);
        this.state = 716;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,56,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 713;
                this.gccDeclaratorExtension(); 
            }
            this.state = 718;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,56,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DirectDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_directDeclarator;
    return this;
}

DirectDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DirectDeclaratorContext.prototype.constructor = DirectDeclaratorContext;

DirectDeclaratorContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

DirectDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

DirectDeclaratorContext.prototype.DigitSequence = function() {
    return this.getToken(CParser.DigitSequence, 0);
};

DirectDeclaratorContext.prototype.directDeclarator = function() {
    return this.getTypedRuleContext(DirectDeclaratorContext,0);
};

DirectDeclaratorContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

DirectDeclaratorContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

DirectDeclaratorContext.prototype.parameterTypeList = function() {
    return this.getTypedRuleContext(ParameterTypeListContext,0);
};

DirectDeclaratorContext.prototype.identifierList = function() {
    return this.getTypedRuleContext(IdentifierListContext,0);
};

DirectDeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDirectDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.directDeclarator = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DirectDeclaratorContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 96;
    this.enterRecursionRule(localctx, 96, CParser.RULE_directDeclarator, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 728;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,57,this._ctx);
        switch(la_) {
        case 1:
            this.state = 720;
            this.match(CParser.Identifier);
            break;

        case 2:
            this.state = 721;
            this.match(CParser.LeftParen);
            this.state = 722;
            this.declarator();
            this.state = 723;
            this.match(CParser.RightParen);
            break;

        case 3:
            this.state = 725;
            this.match(CParser.Identifier);
            this.state = 726;
            this.match(CParser.Colon);
            this.state = 727;
            this.match(CParser.DigitSequence);
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 775;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,64,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 773;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,63,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 730;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 731;
                    this.match(CParser.LeftBracket);
                    this.state = 733;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 732;
                        this.typeQualifierList(0);
                    }

                    this.state = 736;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 735;
                        this.assignmentExpression();
                    }

                    this.state = 738;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 739;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 740;
                    this.match(CParser.LeftBracket);
                    this.state = 741;
                    this.match(CParser.Static);
                    this.state = 743;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 742;
                        this.typeQualifierList(0);
                    }

                    this.state = 745;
                    this.assignmentExpression();
                    this.state = 746;
                    this.match(CParser.RightBracket);
                    break;

                case 3:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 748;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 749;
                    this.match(CParser.LeftBracket);
                    this.state = 750;
                    this.typeQualifierList(0);
                    this.state = 751;
                    this.match(CParser.Static);
                    this.state = 752;
                    this.assignmentExpression();
                    this.state = 753;
                    this.match(CParser.RightBracket);
                    break;

                case 4:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 755;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 756;
                    this.match(CParser.LeftBracket);
                    this.state = 758;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 757;
                        this.typeQualifierList(0);
                    }

                    this.state = 760;
                    this.match(CParser.Star);
                    this.state = 761;
                    this.match(CParser.RightBracket);
                    break;

                case 5:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 762;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 763;
                    this.match(CParser.LeftParen);
                    this.state = 764;
                    this.parameterTypeList();
                    this.state = 765;
                    this.match(CParser.RightParen);
                    break;

                case 6:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 767;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 768;
                    this.match(CParser.LeftParen);
                    this.state = 770;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Identifier) {
                        this.state = 769;
                        this.identifierList(0);
                    }

                    this.state = 772;
                    this.match(CParser.RightParen);
                    break;

                } 
            }
            this.state = 777;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,64,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function GccDeclaratorExtensionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccDeclaratorExtension;
    return this;
}

GccDeclaratorExtensionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccDeclaratorExtensionContext.prototype.constructor = GccDeclaratorExtensionContext;

GccDeclaratorExtensionContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


GccDeclaratorExtensionContext.prototype.gccAttributeSpecifier = function() {
    return this.getTypedRuleContext(GccAttributeSpecifierContext,0);
};

GccDeclaratorExtensionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGccDeclaratorExtension(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GccDeclaratorExtensionContext = GccDeclaratorExtensionContext;

CParser.prototype.gccDeclaratorExtension = function() {

    var localctx = new GccDeclaratorExtensionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, CParser.RULE_gccDeclaratorExtension);
    var _la = 0; // Token type
    try {
        this.state = 787;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__10:
            this.enterOuterAlt(localctx, 1);
            this.state = 778;
            this.match(CParser.T__10);
            this.state = 779;
            this.match(CParser.LeftParen);
            this.state = 781; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 780;
                this.match(CParser.StringLiteral);
                this.state = 783; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===CParser.StringLiteral);
            this.state = 785;
            this.match(CParser.RightParen);
            break;
        case CParser.T__11:
            this.enterOuterAlt(localctx, 2);
            this.state = 786;
            this.gccAttributeSpecifier();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttributeSpecifier;
    return this;
}

GccAttributeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeSpecifierContext.prototype.constructor = GccAttributeSpecifierContext;

GccAttributeSpecifierContext.prototype.gccAttributeList = function() {
    return this.getTypedRuleContext(GccAttributeListContext,0);
};

GccAttributeSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGccAttributeSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GccAttributeSpecifierContext = GccAttributeSpecifierContext;

CParser.prototype.gccAttributeSpecifier = function() {

    var localctx = new GccAttributeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, CParser.RULE_gccAttributeSpecifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 789;
        this.match(CParser.T__11);
        this.state = 790;
        this.match(CParser.LeftParen);
        this.state = 791;
        this.match(CParser.LeftParen);
        this.state = 792;
        this.gccAttributeList();
        this.state = 793;
        this.match(CParser.RightParen);
        this.state = 794;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttributeList;
    return this;
}

GccAttributeListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeListContext.prototype.constructor = GccAttributeListContext;

GccAttributeListContext.prototype.gccAttribute = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccAttributeContext);
    } else {
        return this.getTypedRuleContext(GccAttributeContext,i);
    }
};

GccAttributeListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGccAttributeList(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GccAttributeListContext = GccAttributeListContext;

CParser.prototype.gccAttributeList = function() {

    var localctx = new GccAttributeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, CParser.RULE_gccAttributeList);
    var _la = 0; // Token type
    try {
        this.state = 805;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,68,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 796;
            this.gccAttribute();
            this.state = 801;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===CParser.Comma) {
                this.state = 797;
                this.match(CParser.Comma);
                this.state = 798;
                this.gccAttribute();
                this.state = 803;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttribute;
    return this;
}

GccAttributeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeContext.prototype.constructor = GccAttributeContext;

GccAttributeContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

GccAttributeContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitGccAttribute(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.GccAttributeContext = GccAttributeContext;

CParser.prototype.gccAttribute = function() {

    var localctx = new GccAttributeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, CParser.RULE_gccAttribute);
    var _la = 0; // Token type
    try {
        this.state = 816;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__1:
        case CParser.T__2:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.T__7:
        case CParser.T__8:
        case CParser.T__9:
        case CParser.T__10:
        case CParser.T__11:
        case CParser.T__12:
        case CParser.T__13:
        case CParser.Auto:
        case CParser.Break:
        case CParser.Case:
        case CParser.Char:
        case CParser.Const:
        case CParser.Continue:
        case CParser.Default:
        case CParser.Do:
        case CParser.Double:
        case CParser.Else:
        case CParser.Enum:
        case CParser.Extern:
        case CParser.Float:
        case CParser.For:
        case CParser.Goto:
        case CParser.If:
        case CParser.Inline:
        case CParser.Int:
        case CParser.Long:
        case CParser.Register:
        case CParser.Restrict:
        case CParser.Return:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Sizeof:
        case CParser.Static:
        case CParser.Struct:
        case CParser.Switch:
        case CParser.Typedef:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.While:
        case CParser.Alignas:
        case CParser.Alignof:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Generic:
        case CParser.Imaginary:
        case CParser.Noreturn:
        case CParser.StaticAssert:
        case CParser.ThreadLocal:
        case CParser.LeftBracket:
        case CParser.RightBracket:
        case CParser.LeftBrace:
        case CParser.RightBrace:
        case CParser.Less:
        case CParser.LessEqual:
        case CParser.Greater:
        case CParser.GreaterEqual:
        case CParser.LeftShift:
        case CParser.RightShift:
        case CParser.Plus:
        case CParser.PlusPlus:
        case CParser.Minus:
        case CParser.MinusMinus:
        case CParser.Star:
        case CParser.Div:
        case CParser.Mod:
        case CParser.And:
        case CParser.Or:
        case CParser.AndAnd:
        case CParser.OrOr:
        case CParser.Caret:
        case CParser.Not:
        case CParser.Tilde:
        case CParser.Question:
        case CParser.Colon:
        case CParser.Semi:
        case CParser.Assign:
        case CParser.StarAssign:
        case CParser.DivAssign:
        case CParser.ModAssign:
        case CParser.PlusAssign:
        case CParser.MinusAssign:
        case CParser.LeftShiftAssign:
        case CParser.RightShiftAssign:
        case CParser.AndAssign:
        case CParser.XorAssign:
        case CParser.OrAssign:
        case CParser.Equal:
        case CParser.NotEqual:
        case CParser.Arrow:
        case CParser.Dot:
        case CParser.Ellipsis:
        case CParser.Identifier:
        case CParser.Constant:
        case CParser.DigitSequence:
        case CParser.StringLiteral:
        case CParser.ComplexDefine:
        case CParser.AsmBlock:
        case CParser.LineAfterPreprocessing:
        case CParser.LineDirective:
        case CParser.PragmaDirective:
        case CParser.Whitespace:
        case CParser.Newline:
        case CParser.BlockComment:
        case CParser.LineComment:
            this.enterOuterAlt(localctx, 1);
            this.state = 807;
            _la = this._input.LA(1);
            if(_la<=0 || ((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.RightParen - 59)) | (1 << (CParser.Comma - 59)))) !== 0)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 813;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.LeftParen) {
                this.state = 808;
                this.match(CParser.LeftParen);
                this.state = 810;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                    this.state = 809;
                    this.argumentExpressionList(0);
                }

                this.state = 812;
                this.match(CParser.RightParen);
            }

            break;
        case CParser.RightParen:
        case CParser.Comma:
            this.enterOuterAlt(localctx, 2);

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NestedParenthesesBlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_nestedParenthesesBlock;
    return this;
}

NestedParenthesesBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NestedParenthesesBlockContext.prototype.constructor = NestedParenthesesBlockContext;

NestedParenthesesBlockContext.prototype.nestedParenthesesBlock = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(NestedParenthesesBlockContext);
    } else {
        return this.getTypedRuleContext(NestedParenthesesBlockContext,i);
    }
};

NestedParenthesesBlockContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitNestedParenthesesBlock(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.NestedParenthesesBlockContext = NestedParenthesesBlockContext;

CParser.prototype.nestedParenthesesBlock = function() {

    var localctx = new NestedParenthesesBlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, CParser.RULE_nestedParenthesesBlock);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 825;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.Auto) | (1 << CParser.Break) | (1 << CParser.Case) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Continue) | (1 << CParser.Default) | (1 << CParser.Do) | (1 << CParser.Double) | (1 << CParser.Else) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.For) | (1 << CParser.Goto) | (1 << CParser.If) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Return - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Sizeof - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Switch - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.While - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Alignof - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Generic - 32)) | (1 << (CParser.Imaginary - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)) | (1 << (CParser.LeftBracket - 32)) | (1 << (CParser.RightBracket - 32)) | (1 << (CParser.LeftBrace - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (CParser.RightBrace - 64)) | (1 << (CParser.Less - 64)) | (1 << (CParser.LessEqual - 64)) | (1 << (CParser.Greater - 64)) | (1 << (CParser.GreaterEqual - 64)) | (1 << (CParser.LeftShift - 64)) | (1 << (CParser.RightShift - 64)) | (1 << (CParser.Plus - 64)) | (1 << (CParser.PlusPlus - 64)) | (1 << (CParser.Minus - 64)) | (1 << (CParser.MinusMinus - 64)) | (1 << (CParser.Star - 64)) | (1 << (CParser.Div - 64)) | (1 << (CParser.Mod - 64)) | (1 << (CParser.And - 64)) | (1 << (CParser.Or - 64)) | (1 << (CParser.AndAnd - 64)) | (1 << (CParser.OrOr - 64)) | (1 << (CParser.Caret - 64)) | (1 << (CParser.Not - 64)) | (1 << (CParser.Tilde - 64)) | (1 << (CParser.Question - 64)) | (1 << (CParser.Colon - 64)) | (1 << (CParser.Semi - 64)) | (1 << (CParser.Comma - 64)) | (1 << (CParser.Assign - 64)) | (1 << (CParser.StarAssign - 64)) | (1 << (CParser.DivAssign - 64)) | (1 << (CParser.ModAssign - 64)) | (1 << (CParser.PlusAssign - 64)) | (1 << (CParser.MinusAssign - 64)) | (1 << (CParser.LeftShiftAssign - 64)))) !== 0) || ((((_la - 96)) & ~0x1f) == 0 && ((1 << (_la - 96)) & ((1 << (CParser.RightShiftAssign - 96)) | (1 << (CParser.AndAssign - 96)) | (1 << (CParser.XorAssign - 96)) | (1 << (CParser.OrAssign - 96)) | (1 << (CParser.Equal - 96)) | (1 << (CParser.NotEqual - 96)) | (1 << (CParser.Arrow - 96)) | (1 << (CParser.Dot - 96)) | (1 << (CParser.Ellipsis - 96)) | (1 << (CParser.Identifier - 96)) | (1 << (CParser.Constant - 96)) | (1 << (CParser.DigitSequence - 96)) | (1 << (CParser.StringLiteral - 96)) | (1 << (CParser.ComplexDefine - 96)) | (1 << (CParser.AsmBlock - 96)) | (1 << (CParser.LineAfterPreprocessing - 96)) | (1 << (CParser.LineDirective - 96)) | (1 << (CParser.PragmaDirective - 96)) | (1 << (CParser.Whitespace - 96)) | (1 << (CParser.Newline - 96)) | (1 << (CParser.BlockComment - 96)) | (1 << (CParser.LineComment - 96)))) !== 0)) {
            this.state = 823;
            this._errHandler.sync(this);
            switch(this._input.LA(1)) {
            case CParser.T__0:
            case CParser.T__1:
            case CParser.T__2:
            case CParser.T__3:
            case CParser.T__4:
            case CParser.T__5:
            case CParser.T__6:
            case CParser.T__7:
            case CParser.T__8:
            case CParser.T__9:
            case CParser.T__10:
            case CParser.T__11:
            case CParser.T__12:
            case CParser.T__13:
            case CParser.Auto:
            case CParser.Break:
            case CParser.Case:
            case CParser.Char:
            case CParser.Const:
            case CParser.Continue:
            case CParser.Default:
            case CParser.Do:
            case CParser.Double:
            case CParser.Else:
            case CParser.Enum:
            case CParser.Extern:
            case CParser.Float:
            case CParser.For:
            case CParser.Goto:
            case CParser.If:
            case CParser.Inline:
            case CParser.Int:
            case CParser.Long:
            case CParser.Register:
            case CParser.Restrict:
            case CParser.Return:
            case CParser.Short:
            case CParser.Signed:
            case CParser.Sizeof:
            case CParser.Static:
            case CParser.Struct:
            case CParser.Switch:
            case CParser.Typedef:
            case CParser.Union:
            case CParser.Unsigned:
            case CParser.Void:
            case CParser.Volatile:
            case CParser.While:
            case CParser.Alignas:
            case CParser.Alignof:
            case CParser.Atomic:
            case CParser.Bool:
            case CParser.Complex:
            case CParser.Generic:
            case CParser.Imaginary:
            case CParser.Noreturn:
            case CParser.StaticAssert:
            case CParser.ThreadLocal:
            case CParser.LeftBracket:
            case CParser.RightBracket:
            case CParser.LeftBrace:
            case CParser.RightBrace:
            case CParser.Less:
            case CParser.LessEqual:
            case CParser.Greater:
            case CParser.GreaterEqual:
            case CParser.LeftShift:
            case CParser.RightShift:
            case CParser.Plus:
            case CParser.PlusPlus:
            case CParser.Minus:
            case CParser.MinusMinus:
            case CParser.Star:
            case CParser.Div:
            case CParser.Mod:
            case CParser.And:
            case CParser.Or:
            case CParser.AndAnd:
            case CParser.OrOr:
            case CParser.Caret:
            case CParser.Not:
            case CParser.Tilde:
            case CParser.Question:
            case CParser.Colon:
            case CParser.Semi:
            case CParser.Comma:
            case CParser.Assign:
            case CParser.StarAssign:
            case CParser.DivAssign:
            case CParser.ModAssign:
            case CParser.PlusAssign:
            case CParser.MinusAssign:
            case CParser.LeftShiftAssign:
            case CParser.RightShiftAssign:
            case CParser.AndAssign:
            case CParser.XorAssign:
            case CParser.OrAssign:
            case CParser.Equal:
            case CParser.NotEqual:
            case CParser.Arrow:
            case CParser.Dot:
            case CParser.Ellipsis:
            case CParser.Identifier:
            case CParser.Constant:
            case CParser.DigitSequence:
            case CParser.StringLiteral:
            case CParser.ComplexDefine:
            case CParser.AsmBlock:
            case CParser.LineAfterPreprocessing:
            case CParser.LineDirective:
            case CParser.PragmaDirective:
            case CParser.Whitespace:
            case CParser.Newline:
            case CParser.BlockComment:
            case CParser.LineComment:
                this.state = 818;
                _la = this._input.LA(1);
                if(_la<=0 || _la===CParser.LeftParen || _la===CParser.RightParen) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
                break;
            case CParser.LeftParen:
                this.state = 819;
                this.match(CParser.LeftParen);
                this.state = 820;
                this.nestedParenthesesBlock();
                this.state = 821;
                this.match(CParser.RightParen);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 827;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PointerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_pointer;
    return this;
}

PointerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PointerContext.prototype.constructor = PointerContext;

PointerContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

PointerContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

PointerContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitPointer(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.PointerContext = PointerContext;

CParser.prototype.pointer = function() {

    var localctx = new PointerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, CParser.RULE_pointer);
    var _la = 0; // Token type
    try {
        this.state = 846;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,78,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 828;
            this.match(CParser.Star);
            this.state = 830;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,74,this._ctx);
            if(la_===1) {
                this.state = 829;
                this.typeQualifierList(0);

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 832;
            this.match(CParser.Star);
            this.state = 834;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 833;
                this.typeQualifierList(0);
            }

            this.state = 836;
            this.pointer();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 837;
            this.match(CParser.Caret);
            this.state = 839;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,76,this._ctx);
            if(la_===1) {
                this.state = 838;
                this.typeQualifierList(0);

            }
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 841;
            this.match(CParser.Caret);
            this.state = 843;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 842;
                this.typeQualifierList(0);
            }

            this.state = 845;
            this.pointer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeQualifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeQualifierList;
    return this;
}

TypeQualifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeQualifierListContext.prototype.constructor = TypeQualifierListContext;

TypeQualifierListContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

TypeQualifierListContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

TypeQualifierListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTypeQualifierList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.typeQualifierList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new TypeQualifierListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 110;
    this.enterRecursionRule(localctx, 110, CParser.RULE_typeQualifierList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 849;
        this.typeQualifier();
        this._ctx.stop = this._input.LT(-1);
        this.state = 855;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,79,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new TypeQualifierListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_typeQualifierList);
                this.state = 851;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 852;
                this.typeQualifier(); 
            }
            this.state = 857;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,79,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ParameterTypeListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterTypeList;
    return this;
}

ParameterTypeListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterTypeListContext.prototype.constructor = ParameterTypeListContext;

ParameterTypeListContext.prototype.parameterList = function() {
    return this.getTypedRuleContext(ParameterListContext,0);
};

ParameterTypeListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitParameterTypeList(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ParameterTypeListContext = ParameterTypeListContext;

CParser.prototype.parameterTypeList = function() {

    var localctx = new ParameterTypeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, CParser.RULE_parameterTypeList);
    try {
        this.state = 863;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,80,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 858;
            this.parameterList(0);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 859;
            this.parameterList(0);
            this.state = 860;
            this.match(CParser.Comma);
            this.state = 861;
            this.match(CParser.Ellipsis);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParameterListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterList;
    return this;
}

ParameterListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterListContext.prototype.constructor = ParameterListContext;

ParameterListContext.prototype.parameterDeclaration = function() {
    return this.getTypedRuleContext(ParameterDeclarationContext,0);
};

ParameterListContext.prototype.parameterList = function() {
    return this.getTypedRuleContext(ParameterListContext,0);
};

ParameterListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitParameterList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.parameterList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ParameterListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 114;
    this.enterRecursionRule(localctx, 114, CParser.RULE_parameterList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 866;
        this.parameterDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 873;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,81,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ParameterListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_parameterList);
                this.state = 868;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 869;
                this.match(CParser.Comma);
                this.state = 870;
                this.parameterDeclaration(); 
            }
            this.state = 875;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,81,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ParameterDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterDeclaration;
    return this;
}

ParameterDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterDeclarationContext.prototype.constructor = ParameterDeclarationContext;

ParameterDeclarationContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

ParameterDeclarationContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

ParameterDeclarationContext.prototype.declarationSpecifiers2 = function() {
    return this.getTypedRuleContext(DeclarationSpecifiers2Context,0);
};

ParameterDeclarationContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

ParameterDeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitParameterDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ParameterDeclarationContext = ParameterDeclarationContext;

CParser.prototype.parameterDeclaration = function() {

    var localctx = new ParameterDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, CParser.RULE_parameterDeclaration);
    try {
        this.state = 883;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,83,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 876;
            this.declarationSpecifiers();
            this.state = 877;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 879;
            this.declarationSpecifiers2();
            this.state = 881;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,82,this._ctx);
            if(la_===1) {
                this.state = 880;
                this.abstractDeclarator();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IdentifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_identifierList;
    return this;
}

IdentifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IdentifierListContext.prototype.constructor = IdentifierListContext;

IdentifierListContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

IdentifierListContext.prototype.identifierList = function() {
    return this.getTypedRuleContext(IdentifierListContext,0);
};

IdentifierListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitIdentifierList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.identifierList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new IdentifierListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 118;
    this.enterRecursionRule(localctx, 118, CParser.RULE_identifierList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 886;
        this.match(CParser.Identifier);
        this._ctx.stop = this._input.LT(-1);
        this.state = 893;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,84,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new IdentifierListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_identifierList);
                this.state = 888;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 889;
                this.match(CParser.Comma);
                this.state = 890;
                this.match(CParser.Identifier); 
            }
            this.state = 895;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,84,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function TypeNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeName;
    return this;
}

TypeNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeNameContext.prototype.constructor = TypeNameContext;

TypeNameContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

TypeNameContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

TypeNameContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTypeName(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.TypeNameContext = TypeNameContext;

CParser.prototype.typeName = function() {

    var localctx = new TypeNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, CParser.RULE_typeName);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 896;
        this.specifierQualifierList();
        this.state = 898;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.LeftBracket - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)))) !== 0)) {
            this.state = 897;
            this.abstractDeclarator();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AbstractDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_abstractDeclarator;
    return this;
}

AbstractDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AbstractDeclaratorContext.prototype.constructor = AbstractDeclaratorContext;

AbstractDeclaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

AbstractDeclaratorContext.prototype.directAbstractDeclarator = function() {
    return this.getTypedRuleContext(DirectAbstractDeclaratorContext,0);
};

AbstractDeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

AbstractDeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitAbstractDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.AbstractDeclaratorContext = AbstractDeclaratorContext;

CParser.prototype.abstractDeclarator = function() {

    var localctx = new AbstractDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, CParser.RULE_abstractDeclarator);
    var _la = 0; // Token type
    try {
        this.state = 911;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,88,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 900;
            this.pointer();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 902;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Star || _la===CParser.Caret) {
                this.state = 901;
                this.pointer();
            }

            this.state = 904;
            this.directAbstractDeclarator(0);
            this.state = 908;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,87,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 905;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 910;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,87,this._ctx);
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DirectAbstractDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_directAbstractDeclarator;
    return this;
}

DirectAbstractDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DirectAbstractDeclaratorContext.prototype.constructor = DirectAbstractDeclaratorContext;

DirectAbstractDeclaratorContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

DirectAbstractDeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

DirectAbstractDeclaratorContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

DirectAbstractDeclaratorContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

DirectAbstractDeclaratorContext.prototype.parameterTypeList = function() {
    return this.getTypedRuleContext(ParameterTypeListContext,0);
};

DirectAbstractDeclaratorContext.prototype.directAbstractDeclarator = function() {
    return this.getTypedRuleContext(DirectAbstractDeclaratorContext,0);
};

DirectAbstractDeclaratorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDirectAbstractDeclarator(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.directAbstractDeclarator = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DirectAbstractDeclaratorContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 124;
    this.enterRecursionRule(localctx, 124, CParser.RULE_directAbstractDeclarator, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 959;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,95,this._ctx);
        switch(la_) {
        case 1:
            this.state = 914;
            this.match(CParser.LeftParen);
            this.state = 915;
            this.abstractDeclarator();
            this.state = 916;
            this.match(CParser.RightParen);
            this.state = 920;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,89,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 917;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 922;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,89,this._ctx);
            }

            break;

        case 2:
            this.state = 923;
            this.match(CParser.LeftBracket);
            this.state = 925;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 924;
                this.typeQualifierList(0);
            }

            this.state = 928;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 927;
                this.assignmentExpression();
            }

            this.state = 930;
            this.match(CParser.RightBracket);
            break;

        case 3:
            this.state = 931;
            this.match(CParser.LeftBracket);
            this.state = 932;
            this.match(CParser.Static);
            this.state = 934;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 933;
                this.typeQualifierList(0);
            }

            this.state = 936;
            this.assignmentExpression();
            this.state = 937;
            this.match(CParser.RightBracket);
            break;

        case 4:
            this.state = 939;
            this.match(CParser.LeftBracket);
            this.state = 940;
            this.typeQualifierList(0);
            this.state = 941;
            this.match(CParser.Static);
            this.state = 942;
            this.assignmentExpression();
            this.state = 943;
            this.match(CParser.RightBracket);
            break;

        case 5:
            this.state = 945;
            this.match(CParser.LeftBracket);
            this.state = 946;
            this.match(CParser.Star);
            this.state = 947;
            this.match(CParser.RightBracket);
            break;

        case 6:
            this.state = 948;
            this.match(CParser.LeftParen);
            this.state = 950;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
                this.state = 949;
                this.parameterTypeList();
            }

            this.state = 952;
            this.match(CParser.RightParen);
            this.state = 956;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,94,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 953;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 958;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,94,this._ctx);
            }

            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 1004;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,102,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 1002;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,101,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 961;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 962;
                    this.match(CParser.LeftBracket);
                    this.state = 964;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 963;
                        this.typeQualifierList(0);
                    }

                    this.state = 967;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 966;
                        this.assignmentExpression();
                    }

                    this.state = 969;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 970;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 971;
                    this.match(CParser.LeftBracket);
                    this.state = 972;
                    this.match(CParser.Static);
                    this.state = 974;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 973;
                        this.typeQualifierList(0);
                    }

                    this.state = 976;
                    this.assignmentExpression();
                    this.state = 977;
                    this.match(CParser.RightBracket);
                    break;

                case 3:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 979;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 980;
                    this.match(CParser.LeftBracket);
                    this.state = 981;
                    this.typeQualifierList(0);
                    this.state = 982;
                    this.match(CParser.Static);
                    this.state = 983;
                    this.assignmentExpression();
                    this.state = 984;
                    this.match(CParser.RightBracket);
                    break;

                case 4:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 986;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 987;
                    this.match(CParser.LeftBracket);
                    this.state = 988;
                    this.match(CParser.Star);
                    this.state = 989;
                    this.match(CParser.RightBracket);
                    break;

                case 5:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 990;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 991;
                    this.match(CParser.LeftParen);
                    this.state = 993;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
                        this.state = 992;
                        this.parameterTypeList();
                    }

                    this.state = 995;
                    this.match(CParser.RightParen);
                    this.state = 999;
                    this._errHandler.sync(this);
                    var _alt = this._interp.adaptivePredict(this._input,100,this._ctx)
                    while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                        if(_alt===1) {
                            this.state = 996;
                            this.gccDeclaratorExtension(); 
                        }
                        this.state = 1001;
                        this._errHandler.sync(this);
                        _alt = this._interp.adaptivePredict(this._input,100,this._ctx);
                    }

                    break;

                } 
            }
            this.state = 1006;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,102,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function TypedefNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typedefName;
    return this;
}

TypedefNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypedefNameContext.prototype.constructor = TypedefNameContext;

TypedefNameContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

TypedefNameContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTypedefName(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.TypedefNameContext = TypedefNameContext;

CParser.prototype.typedefName = function() {

    var localctx = new TypedefNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, CParser.RULE_typedefName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1007;
        this.match(CParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initializer;
    return this;
}

InitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitializerContext.prototype.constructor = InitializerContext;

InitializerContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

InitializerContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

InitializerContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitInitializer(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.InitializerContext = InitializerContext;

CParser.prototype.initializer = function() {

    var localctx = new InitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, CParser.RULE_initializer);
    try {
        this.state = 1019;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,103,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1009;
            this.assignmentExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1010;
            this.match(CParser.LeftBrace);
            this.state = 1011;
            this.initializerList(0);
            this.state = 1012;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1014;
            this.match(CParser.LeftBrace);
            this.state = 1015;
            this.initializerList(0);
            this.state = 1016;
            this.match(CParser.Comma);
            this.state = 1017;
            this.match(CParser.RightBrace);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitializerListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initializerList;
    return this;
}

InitializerListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitializerListContext.prototype.constructor = InitializerListContext;

InitializerListContext.prototype.initializer = function() {
    return this.getTypedRuleContext(InitializerContext,0);
};

InitializerListContext.prototype.designation = function() {
    return this.getTypedRuleContext(DesignationContext,0);
};

InitializerListContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

InitializerListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitInitializerList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.initializerList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InitializerListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 130;
    this.enterRecursionRule(localctx, 130, CParser.RULE_initializerList, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1023;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===CParser.LeftBracket || _la===CParser.Dot) {
            this.state = 1022;
            this.designation();
        }

        this.state = 1025;
        this.initializer();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1035;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,106,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InitializerListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_initializerList);
                this.state = 1027;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1028;
                this.match(CParser.Comma);
                this.state = 1030;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===CParser.LeftBracket || _la===CParser.Dot) {
                    this.state = 1029;
                    this.designation();
                }

                this.state = 1032;
                this.initializer(); 
            }
            this.state = 1037;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,106,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function DesignationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designation;
    return this;
}

DesignationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignationContext.prototype.constructor = DesignationContext;

DesignationContext.prototype.designatorList = function() {
    return this.getTypedRuleContext(DesignatorListContext,0);
};

DesignationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDesignation(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DesignationContext = DesignationContext;

CParser.prototype.designation = function() {

    var localctx = new DesignationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, CParser.RULE_designation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1038;
        this.designatorList(0);
        this.state = 1039;
        this.match(CParser.Assign);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DesignatorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designatorList;
    return this;
}

DesignatorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignatorListContext.prototype.constructor = DesignatorListContext;

DesignatorListContext.prototype.designator = function() {
    return this.getTypedRuleContext(DesignatorContext,0);
};

DesignatorListContext.prototype.designatorList = function() {
    return this.getTypedRuleContext(DesignatorListContext,0);
};

DesignatorListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDesignatorList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.designatorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DesignatorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 134;
    this.enterRecursionRule(localctx, 134, CParser.RULE_designatorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1042;
        this.designator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1048;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,107,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new DesignatorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_designatorList);
                this.state = 1044;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1045;
                this.designator(); 
            }
            this.state = 1050;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,107,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function DesignatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designator;
    return this;
}

DesignatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignatorContext.prototype.constructor = DesignatorContext;

DesignatorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

DesignatorContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

DesignatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDesignator(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.DesignatorContext = DesignatorContext;

CParser.prototype.designator = function() {

    var localctx = new DesignatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, CParser.RULE_designator);
    try {
        this.state = 1057;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.LeftBracket:
            this.enterOuterAlt(localctx, 1);
            this.state = 1051;
            this.match(CParser.LeftBracket);
            this.state = 1052;
            this.constantExpression();
            this.state = 1053;
            this.match(CParser.RightBracket);
            break;
        case CParser.Dot:
            this.enterOuterAlt(localctx, 2);
            this.state = 1055;
            this.match(CParser.Dot);
            this.state = 1056;
            this.match(CParser.Identifier);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StaticAssertDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_staticAssertDeclaration;
    return this;
}

StaticAssertDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StaticAssertDeclarationContext.prototype.constructor = StaticAssertDeclarationContext;

StaticAssertDeclarationContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

StaticAssertDeclarationContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


StaticAssertDeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStaticAssertDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StaticAssertDeclarationContext = StaticAssertDeclarationContext;

CParser.prototype.staticAssertDeclaration = function() {

    var localctx = new StaticAssertDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, CParser.RULE_staticAssertDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1059;
        this.match(CParser.StaticAssert);
        this.state = 1060;
        this.match(CParser.LeftParen);
        this.state = 1061;
        this.constantExpression();
        this.state = 1062;
        this.match(CParser.Comma);
        this.state = 1064; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 1063;
            this.match(CParser.StringLiteral);
            this.state = 1066; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===CParser.StringLiteral);
        this.state = 1068;
        this.match(CParser.RightParen);
        this.state = 1069;
        this.match(CParser.Semi);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;

StatementContext.prototype.labeledStatement = function() {
    return this.getTypedRuleContext(LabeledStatementContext,0);
};

StatementContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

StatementContext.prototype.expressionStatement = function() {
    return this.getTypedRuleContext(ExpressionStatementContext,0);
};

StatementContext.prototype.selectionStatement = function() {
    return this.getTypedRuleContext(SelectionStatementContext,0);
};

StatementContext.prototype.iterationStatement = function() {
    return this.getTypedRuleContext(IterationStatementContext,0);
};

StatementContext.prototype.jumpStatement = function() {
    return this.getTypedRuleContext(JumpStatementContext,0);
};

StatementContext.prototype.logicalOrExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LogicalOrExpressionContext);
    } else {
        return this.getTypedRuleContext(LogicalOrExpressionContext,i);
    }
};

StatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.StatementContext = StatementContext;

CParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, CParser.RULE_statement);
    var _la = 0; // Token type
    try {
        this.state = 1108;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,115,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1071;
            this.labeledStatement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1072;
            this.compoundStatement();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1073;
            this.expressionStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1074;
            this.selectionStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1075;
            this.iterationStatement();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 1076;
            this.jumpStatement();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 1077;
            _la = this._input.LA(1);
            if(!(_la===CParser.T__10 || _la===CParser.T__12)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1078;
            _la = this._input.LA(1);
            if(!(_la===CParser.T__13 || _la===CParser.Volatile)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1079;
            this.match(CParser.LeftParen);
            this.state = 1088;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1080;
                this.logicalOrExpression(0);
                this.state = 1085;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===CParser.Comma) {
                    this.state = 1081;
                    this.match(CParser.Comma);
                    this.state = 1082;
                    this.logicalOrExpression(0);
                    this.state = 1087;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 1103;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===CParser.Colon) {
                this.state = 1090;
                this.match(CParser.Colon);
                this.state = 1099;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                    this.state = 1091;
                    this.logicalOrExpression(0);
                    this.state = 1096;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    while(_la===CParser.Comma) {
                        this.state = 1092;
                        this.match(CParser.Comma);
                        this.state = 1093;
                        this.logicalOrExpression(0);
                        this.state = 1098;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                    }
                }

                this.state = 1105;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1106;
            this.match(CParser.RightParen);
            this.state = 1107;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LabeledStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_labeledStatement;
    return this;
}

LabeledStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LabeledStatementContext.prototype.constructor = LabeledStatementContext;

LabeledStatementContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

LabeledStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

LabeledStatementContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

LabeledStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitLabeledStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.LabeledStatementContext = LabeledStatementContext;

CParser.prototype.labeledStatement = function() {

    var localctx = new LabeledStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, CParser.RULE_labeledStatement);
    try {
        this.state = 1121;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 1110;
            this.match(CParser.Identifier);
            this.state = 1111;
            this.match(CParser.Colon);
            this.state = 1112;
            this.statement();
            break;
        case CParser.Case:
            this.enterOuterAlt(localctx, 2);
            this.state = 1113;
            this.match(CParser.Case);
            this.state = 1114;
            this.constantExpression();
            this.state = 1115;
            this.match(CParser.Colon);
            this.state = 1116;
            this.statement();
            break;
        case CParser.Default:
            this.enterOuterAlt(localctx, 3);
            this.state = 1118;
            this.match(CParser.Default);
            this.state = 1119;
            this.match(CParser.Colon);
            this.state = 1120;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompoundStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_compoundStatement;
    return this;
}

CompoundStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompoundStatementContext.prototype.constructor = CompoundStatementContext;

CompoundStatementContext.prototype.blockItemList = function() {
    return this.getTypedRuleContext(BlockItemListContext,0);
};

CompoundStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitCompoundStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.CompoundStatementContext = CompoundStatementContext;

CParser.prototype.compoundStatement = function() {

    var localctx = new CompoundStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, CParser.RULE_compoundStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1123;
        this.match(CParser.LeftBrace);
        this.state = 1125;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.Auto) | (1 << CParser.Break) | (1 << CParser.Case) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Continue) | (1 << CParser.Default) | (1 << CParser.Do) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.For) | (1 << CParser.Goto) | (1 << CParser.If) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Return - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Sizeof - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Switch - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.While - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Alignof - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Generic - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)) | (1 << (CParser.LeftBrace - 32)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)) | (1 << (CParser.Semi - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
            this.state = 1124;
            this.blockItemList(0);
        }

        this.state = 1127;
        this.match(CParser.RightBrace);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockItemListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_blockItemList;
    return this;
}

BlockItemListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockItemListContext.prototype.constructor = BlockItemListContext;

BlockItemListContext.prototype.blockItem = function() {
    return this.getTypedRuleContext(BlockItemContext,0);
};

BlockItemListContext.prototype.blockItemList = function() {
    return this.getTypedRuleContext(BlockItemListContext,0);
};

BlockItemListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitBlockItemList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.blockItemList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new BlockItemListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 146;
    this.enterRecursionRule(localctx, 146, CParser.RULE_blockItemList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1130;
        this.blockItem();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1136;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,118,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new BlockItemListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_blockItemList);
                this.state = 1132;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1133;
                this.blockItem(); 
            }
            this.state = 1138;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,118,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function BlockItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_blockItem;
    return this;
}

BlockItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockItemContext.prototype.constructor = BlockItemContext;

BlockItemContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

BlockItemContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

BlockItemContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitBlockItem(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.BlockItemContext = BlockItemContext;

CParser.prototype.blockItem = function() {

    var localctx = new BlockItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, CParser.RULE_blockItem);
    try {
        this.state = 1141;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,119,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1139;
            this.declaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1140;
            this.statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_expressionStatement;
    return this;
}

ExpressionStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionStatementContext.prototype.constructor = ExpressionStatementContext;

ExpressionStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ExpressionStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitExpressionStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ExpressionStatementContext = ExpressionStatementContext;

CParser.prototype.expressionStatement = function() {

    var localctx = new ExpressionStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, CParser.RULE_expressionStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1144;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
            this.state = 1143;
            this.expression(0);
        }

        this.state = 1146;
        this.match(CParser.Semi);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SelectionStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_selectionStatement;
    return this;
}

SelectionStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SelectionStatementContext.prototype.constructor = SelectionStatementContext;

SelectionStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

SelectionStatementContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

SelectionStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitSelectionStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.SelectionStatementContext = SelectionStatementContext;

CParser.prototype.selectionStatement = function() {

    var localctx = new SelectionStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, CParser.RULE_selectionStatement);
    try {
        this.state = 1163;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.If:
            this.enterOuterAlt(localctx, 1);
            this.state = 1148;
            this.match(CParser.If);
            this.state = 1149;
            this.match(CParser.LeftParen);
            this.state = 1150;
            this.expression(0);
            this.state = 1151;
            this.match(CParser.RightParen);
            this.state = 1152;
            this.statement();
            this.state = 1155;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,121,this._ctx);
            if(la_===1) {
                this.state = 1153;
                this.match(CParser.Else);
                this.state = 1154;
                this.statement();

            }
            break;
        case CParser.Switch:
            this.enterOuterAlt(localctx, 2);
            this.state = 1157;
            this.match(CParser.Switch);
            this.state = 1158;
            this.match(CParser.LeftParen);
            this.state = 1159;
            this.expression(0);
            this.state = 1160;
            this.match(CParser.RightParen);
            this.state = 1161;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IterationStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_iterationStatement;
    return this;
}

IterationStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IterationStatementContext.prototype.constructor = IterationStatementContext;

IterationStatementContext.prototype.While = function() {
    return this.getToken(CParser.While, 0);
};

IterationStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

IterationStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

IterationStatementContext.prototype.Do = function() {
    return this.getToken(CParser.Do, 0);
};

IterationStatementContext.prototype.For = function() {
    return this.getToken(CParser.For, 0);
};

IterationStatementContext.prototype.forCondition = function() {
    return this.getTypedRuleContext(ForConditionContext,0);
};

IterationStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitIterationStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.IterationStatementContext = IterationStatementContext;

CParser.prototype.iterationStatement = function() {

    var localctx = new IterationStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, CParser.RULE_iterationStatement);
    try {
        this.state = 1185;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case CParser.While:
            this.enterOuterAlt(localctx, 1);
            this.state = 1165;
            this.match(CParser.While);
            this.state = 1166;
            this.match(CParser.LeftParen);
            this.state = 1167;
            this.expression(0);
            this.state = 1168;
            this.match(CParser.RightParen);
            this.state = 1169;
            this.statement();
            break;
        case CParser.Do:
            this.enterOuterAlt(localctx, 2);
            this.state = 1171;
            this.match(CParser.Do);
            this.state = 1172;
            this.statement();
            this.state = 1173;
            this.match(CParser.While);
            this.state = 1174;
            this.match(CParser.LeftParen);
            this.state = 1175;
            this.expression(0);
            this.state = 1176;
            this.match(CParser.RightParen);
            this.state = 1177;
            this.match(CParser.Semi);
            break;
        case CParser.For:
            this.enterOuterAlt(localctx, 3);
            this.state = 1179;
            this.match(CParser.For);
            this.state = 1180;
            this.match(CParser.LeftParen);
            this.state = 1181;
            this.forCondition();
            this.state = 1182;
            this.match(CParser.RightParen);
            this.state = 1183;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForConditionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_forCondition;
    return this;
}

ForConditionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForConditionContext.prototype.constructor = ForConditionContext;

ForConditionContext.prototype.forDeclaration = function() {
    return this.getTypedRuleContext(ForDeclarationContext,0);
};

ForConditionContext.prototype.forExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ForExpressionContext);
    } else {
        return this.getTypedRuleContext(ForExpressionContext,i);
    }
};

ForConditionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ForConditionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitForCondition(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ForConditionContext = ForConditionContext;

CParser.prototype.forCondition = function() {

    var localctx = new ForConditionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, CParser.RULE_forCondition);
    var _la = 0; // Token type
    try {
        this.state = 1207;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,129,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1187;
            this.forDeclaration();
            this.state = 1188;
            this.match(CParser.Semi);
            this.state = 1190;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1189;
                this.forExpression(0);
            }

            this.state = 1192;
            this.match(CParser.Semi);
            this.state = 1194;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1193;
                this.forExpression(0);
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1197;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1196;
                this.expression(0);
            }

            this.state = 1199;
            this.match(CParser.Semi);
            this.state = 1201;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1200;
                this.forExpression(0);
            }

            this.state = 1203;
            this.match(CParser.Semi);
            this.state = 1205;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1204;
                this.forExpression(0);
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_forDeclaration;
    return this;
}

ForDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForDeclarationContext.prototype.constructor = ForDeclarationContext;

ForDeclarationContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

ForDeclarationContext.prototype.initDeclaratorList = function() {
    return this.getTypedRuleContext(InitDeclaratorListContext,0);
};

ForDeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitForDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ForDeclarationContext = ForDeclarationContext;

CParser.prototype.forDeclaration = function() {

    var localctx = new ForDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, CParser.RULE_forDeclaration);
    try {
        this.state = 1213;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,130,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1209;
            this.declarationSpecifiers();
            this.state = 1210;
            this.initDeclaratorList(0);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1212;
            this.declarationSpecifiers();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_forExpression;
    return this;
}

ForExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForExpressionContext.prototype.constructor = ForExpressionContext;

ForExpressionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

ForExpressionContext.prototype.forExpression = function() {
    return this.getTypedRuleContext(ForExpressionContext,0);
};

ForExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitForExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.forExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ForExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 160;
    this.enterRecursionRule(localctx, 160, CParser.RULE_forExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1216;
        this.assignmentExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1223;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,131,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ForExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_forExpression);
                this.state = 1218;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1219;
                this.match(CParser.Comma);
                this.state = 1220;
                this.assignmentExpression(); 
            }
            this.state = 1225;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,131,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function JumpStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_jumpStatement;
    return this;
}

JumpStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JumpStatementContext.prototype.constructor = JumpStatementContext;

JumpStatementContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

JumpStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

JumpStatementContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

JumpStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitJumpStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.JumpStatementContext = JumpStatementContext;

CParser.prototype.jumpStatement = function() {

    var localctx = new JumpStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, CParser.RULE_jumpStatement);
    var _la = 0; // Token type
    try {
        this.state = 1242;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,133,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1226;
            this.match(CParser.Goto);
            this.state = 1227;
            this.match(CParser.Identifier);
            this.state = 1228;
            this.match(CParser.Semi);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1229;
            this.match(CParser.Continue);
            this.state = 1230;
            this.match(CParser.Semi);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1231;
            this.match(CParser.Break);
            this.state = 1232;
            this.match(CParser.Semi);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1233;
            this.match(CParser.Return);
            this.state = 1235;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.DigitSequence - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1234;
                this.expression(0);
            }

            this.state = 1237;
            this.match(CParser.Semi);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1238;
            this.match(CParser.Goto);
            this.state = 1239;
            this.unaryExpression();
            this.state = 1240;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompilationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_compilationUnit;
    return this;
}

CompilationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompilationUnitContext.prototype.constructor = CompilationUnitContext;

CompilationUnitContext.prototype.EOF = function() {
    return this.getToken(CParser.EOF, 0);
};

CompilationUnitContext.prototype.translationUnit = function() {
    return this.getTypedRuleContext(TranslationUnitContext,0);
};

CompilationUnitContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitCompilationUnit(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.CompilationUnitContext = CompilationUnitContext;

CParser.prototype.compilationUnit = function() {

    var localctx = new CompilationUnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, CParser.RULE_compilationUnit);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1245;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)))) !== 0) || ((((_la - 75)) & ~0x1f) == 0 && ((1 << (_la - 75)) & ((1 << (CParser.Star - 75)) | (1 << (CParser.Caret - 75)) | (1 << (CParser.Semi - 75)) | (1 << (CParser.Identifier - 75)))) !== 0)) {
            this.state = 1244;
            this.translationUnit(0);
        }

        this.state = 1247;
        this.match(CParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TranslationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_translationUnit;
    return this;
}

TranslationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TranslationUnitContext.prototype.constructor = TranslationUnitContext;

TranslationUnitContext.prototype.externalDeclaration = function() {
    return this.getTypedRuleContext(ExternalDeclarationContext,0);
};

TranslationUnitContext.prototype.translationUnit = function() {
    return this.getTypedRuleContext(TranslationUnitContext,0);
};

TranslationUnitContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitTranslationUnit(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.translationUnit = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new TranslationUnitContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 166;
    this.enterRecursionRule(localctx, 166, CParser.RULE_translationUnit, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1250;
        this.externalDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1256;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,135,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new TranslationUnitContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_translationUnit);
                this.state = 1252;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1253;
                this.externalDeclaration(); 
            }
            this.state = 1258;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,135,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ExternalDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_externalDeclaration;
    return this;
}

ExternalDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExternalDeclarationContext.prototype.constructor = ExternalDeclarationContext;

ExternalDeclarationContext.prototype.functionDefinition = function() {
    return this.getTypedRuleContext(FunctionDefinitionContext,0);
};

ExternalDeclarationContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

ExternalDeclarationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitExternalDeclaration(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.ExternalDeclarationContext = ExternalDeclarationContext;

CParser.prototype.externalDeclaration = function() {

    var localctx = new ExternalDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, CParser.RULE_externalDeclaration);
    try {
        this.state = 1262;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,136,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1259;
            this.functionDefinition();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1260;
            this.declaration();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1261;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionDefinitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_functionDefinition;
    return this;
}

FunctionDefinitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionDefinitionContext.prototype.constructor = FunctionDefinitionContext;

FunctionDefinitionContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

FunctionDefinitionContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

FunctionDefinitionContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

FunctionDefinitionContext.prototype.declarationList = function() {
    return this.getTypedRuleContext(DeclarationListContext,0);
};

FunctionDefinitionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitFunctionDefinition(this);
    } else {
        return visitor.visitChildren(this);
    }
};




CParser.FunctionDefinitionContext = FunctionDefinitionContext;

CParser.prototype.functionDefinition = function() {

    var localctx = new FunctionDefinitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, CParser.RULE_functionDefinition);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1265;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,137,this._ctx);
        if(la_===1) {
            this.state = 1264;
            this.declarationSpecifiers();

        }
        this.state = 1267;
        this.declarator();
        this.state = 1269;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
            this.state = 1268;
            this.declarationList(0);
        }

        this.state = 1271;
        this.compoundStatement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationList;
    return this;
}

DeclarationListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationListContext.prototype.constructor = DeclarationListContext;

DeclarationListContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

DeclarationListContext.prototype.declarationList = function() {
    return this.getTypedRuleContext(DeclarationListContext,0);
};

DeclarationListContext.prototype.accept = function(visitor) {
    if ( visitor instanceof CVisitor ) {
        return visitor.visitDeclarationList(this);
    } else {
        return visitor.visitChildren(this);
    }
};



CParser.prototype.declarationList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DeclarationListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 172;
    this.enterRecursionRule(localctx, 172, CParser.RULE_declarationList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1274;
        this.declaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1280;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,139,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new DeclarationListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_declarationList);
                this.state = 1276;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1277;
                this.declaration(); 
            }
            this.state = 1282;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,139,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


CParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 2:
			return this.genericAssocList_sempred(localctx, predIndex);
	case 4:
			return this.postfixExpression_sempred(localctx, predIndex);
	case 5:
			return this.argumentExpressionList_sempred(localctx, predIndex);
	case 9:
			return this.multiplicativeExpression_sempred(localctx, predIndex);
	case 10:
			return this.additiveExpression_sempred(localctx, predIndex);
	case 11:
			return this.shiftExpression_sempred(localctx, predIndex);
	case 12:
			return this.relationalExpression_sempred(localctx, predIndex);
	case 13:
			return this.equalityExpression_sempred(localctx, predIndex);
	case 14:
			return this.andExpression_sempred(localctx, predIndex);
	case 15:
			return this.exclusiveOrExpression_sempred(localctx, predIndex);
	case 16:
			return this.inclusiveOrExpression_sempred(localctx, predIndex);
	case 17:
			return this.logicalAndExpression_sempred(localctx, predIndex);
	case 18:
			return this.logicalOrExpression_sempred(localctx, predIndex);
	case 22:
			return this.expression_sempred(localctx, predIndex);
	case 28:
			return this.initDeclaratorList_sempred(localctx, predIndex);
	case 34:
			return this.structDeclarationList_sempred(localctx, predIndex);
	case 37:
			return this.structDeclaratorList_sempred(localctx, predIndex);
	case 40:
			return this.enumeratorList_sempred(localctx, predIndex);
	case 48:
			return this.directDeclarator_sempred(localctx, predIndex);
	case 55:
			return this.typeQualifierList_sempred(localctx, predIndex);
	case 57:
			return this.parameterList_sempred(localctx, predIndex);
	case 59:
			return this.identifierList_sempred(localctx, predIndex);
	case 62:
			return this.directAbstractDeclarator_sempred(localctx, predIndex);
	case 65:
			return this.initializerList_sempred(localctx, predIndex);
	case 67:
			return this.designatorList_sempred(localctx, predIndex);
	case 73:
			return this.blockItemList_sempred(localctx, predIndex);
	case 80:
			return this.forExpression_sempred(localctx, predIndex);
	case 83:
			return this.translationUnit_sempred(localctx, predIndex);
	case 86:
			return this.declarationList_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

CParser.prototype.genericAssocList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.postfixExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 1:
			return this.precpred(this._ctx, 10);
		case 2:
			return this.precpred(this._ctx, 9);
		case 3:
			return this.precpred(this._ctx, 8);
		case 4:
			return this.precpred(this._ctx, 7);
		case 5:
			return this.precpred(this._ctx, 6);
		case 6:
			return this.precpred(this._ctx, 5);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.argumentExpressionList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 7:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.multiplicativeExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 8:
			return this.precpred(this._ctx, 3);
		case 9:
			return this.precpred(this._ctx, 2);
		case 10:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.additiveExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 11:
			return this.precpred(this._ctx, 2);
		case 12:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.shiftExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 13:
			return this.precpred(this._ctx, 2);
		case 14:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.relationalExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 15:
			return this.precpred(this._ctx, 4);
		case 16:
			return this.precpred(this._ctx, 3);
		case 17:
			return this.precpred(this._ctx, 2);
		case 18:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.equalityExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 19:
			return this.precpred(this._ctx, 2);
		case 20:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.andExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 21:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.exclusiveOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 22:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.inclusiveOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 23:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.logicalAndExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 24:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.logicalOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 25:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.expression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 26:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.initDeclaratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 27:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.structDeclarationList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 28:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.structDeclaratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 29:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.enumeratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 30:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.directDeclarator_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 31:
			return this.precpred(this._ctx, 7);
		case 32:
			return this.precpred(this._ctx, 6);
		case 33:
			return this.precpred(this._ctx, 5);
		case 34:
			return this.precpred(this._ctx, 4);
		case 35:
			return this.precpred(this._ctx, 3);
		case 36:
			return this.precpred(this._ctx, 2);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.typeQualifierList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 37:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.parameterList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 38:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.identifierList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 39:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.directAbstractDeclarator_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 40:
			return this.precpred(this._ctx, 5);
		case 41:
			return this.precpred(this._ctx, 4);
		case 42:
			return this.precpred(this._ctx, 3);
		case 43:
			return this.precpred(this._ctx, 2);
		case 44:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.initializerList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 45:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.designatorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 46:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.blockItemList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 47:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.forExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 48:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.translationUnit_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 49:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.declarationList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 50:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.CParser = CParser;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2svYm9vdHN0cmFwIGJhMTY0ZTQyNmU5MTQyMDM3YzRhIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxVdGlscy5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcVG9rZW4uanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXEludGVydmFsU2V0LmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFx0cmVlXFxUcmVlLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxhdG5cXEFUTlN0YXRlLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxlcnJvclxcRXJyb3JzLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxQcmVkaWN0aW9uQ29udGV4dC5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE4uanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGF0blxcVHJhbnNpdGlvbi5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE5Db25maWdTZXQuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGF0blxcU2VtYW50aWNDb250ZXh0LmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxkZmFcXERGQVN0YXRlLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxpbmRleC5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE5Db25maWcuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXFJ1bGVDb250ZXh0LmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxMZXhlci5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcZXJyb3JcXEVycm9yTGlzdGVuZXIuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGRmYVxcREZBU2VyaWFsaXplci5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcUGFyc2VyUnVsZUNvbnRleHQuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXElucHV0U3RyZWFtLmpzIiwiZXh0ZXJuYWwgXCJmc1wiIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFx0cmVlXFxUcmVlcy5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE5EZXNlcmlhbGl6ZXIuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGF0blxcQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxMZXhlckFjdGlvbi5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcUmVjb2duaXplci5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE5TaW11bGF0b3IuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGF0blxcUHJlZGljdGlvbk1vZGUuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXHBvbHlmaWxsc1xcY29kZXBvaW50YXQuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXHBvbHlmaWxsc1xcZnJvbWNvZGVwb2ludC5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcZXJyb3JcXEVycm9yU3RyYXRlZ3kuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcc3JjXFxtYXBwZXJcXENWaXNpdG9yLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXHNyY1xcbWFwcGVyXFxDTWFwcGVyLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxhdG5cXGluZGV4LmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxMTDFBbmFseXplci5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxBVE5UeXBlLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxhdG5cXExleGVyQVROU2ltdWxhdG9yLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxDb21tb25Ub2tlbkZhY3RvcnkuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGF0blxcTGV4ZXJBY3Rpb25FeGVjdXRvci5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcYXRuXFxQYXJzZXJBVE5TaW11bGF0b3IuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGRmYVxcaW5kZXguanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXGRmYVxcREZBLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFx0cmVlXFxpbmRleC5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcZXJyb3JcXGluZGV4LmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxlcnJvclxcRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcbm9kZV9tb2R1bGVzXFxhbnRscjRcXENoYXJTdHJlYW1zLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxGaWxlU3RyZWFtLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXG5vZGVfbW9kdWxlc1xcYW50bHI0XFxDb21tb25Ub2tlblN0cmVhbS5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcQnVmZmVyZWRUb2tlblN0cmVhbS5qcyIsIkM6XFxkZXZlbG9wXFx1bmljb2VuLnRzXFxub2RlX21vZHVsZXNcXGFudGxyNFxcUGFyc2VyLmpzIiwiQzpcXGRldmVsb3BcXHVuaWNvZW4udHNcXHNyY1xcbWFwcGVyXFxDTGV4ZXIuanMiLCJDOlxcZGV2ZWxvcFxcdW5pY29lbi50c1xcc3JjXFxtYXBwZXJcXENQYXJzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLEtBQUs7QUFDTCwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDO0FBQ3ZELEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLG1CQUFtQixhQUFhO0FBQ2hDLGtCQUFrQixhQUFhO0FBQy9CLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsVUFBVTtBQUN6RCxJQUFJLFdBQVcsUUFBUSxnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCLElBQUksZUFBZTtBQUNuQjs7QUFFQSxxQkFBcUIsa0JBQWtCLHVCQUF1QixZQUFZO0FBQzFFO0FBQ0E7QUFDQSxPQUFPLGVBQWUsWUFBWSxrQkFBa0I7QUFDcEQsb0RBQW9ELGFBQWE7QUFDakUsUUFBUSxXQUFXLFlBQVksZUFBZSxjQUFjLGFBQWE7QUFDekUsc0NBQXNDLGdCQUFnQixPQUFPO0FBQzdELDJDQUEyQyw0QkFBNEI7QUFDdkUsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTLE1BQU0sYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxhQUFhLGlCQUFpQjtBQUM5QixxQ0FBcUM7QUFDckMsMENBQTBDLHdCQUF3QjtBQUNsRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDclVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsUUFBUSxnQ0FBZ0M7QUFDeEMsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0Msb0RBQW9EO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQXdEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwRkFBMEY7QUFDNUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7O0FBRUEsZUFBZSxRQUFRLHlDQUF5QztBQUNoRSwyQkFBMkIsb0JBQW9CO0FBQy9DLElBQUksUUFBUSxJQUFJLDJCQUEyQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQW1ELEVBQUU7QUFDcEUsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCLE9BQU8sRUFBRSxnQkFBZ0I7QUFDM0MsV0FBVywyQ0FBMkMsUUFBUTtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEVBQUUsZ0JBQWdCO0FBQzNDLFdBQVcsMkNBQTJDLFFBQVE7QUFDOUQsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxXQUFXLDJDQUEyQyxZQUFZO0FBQ2xFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0YsZUFBZTtBQUNmLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGNBQWMsMEJBQTBCLGNBQWM7QUFDaEU7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRixlQUFlO0FBQ2YsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0JBQWtCLFlBQVksd0JBQXdCO0FBQ3BFLFdBQVcsY0FBYyxLQUFLLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRLEtBQUssUUFBUTtBQUMzRCxJQUFJLGNBQWMseUNBQXlDLFFBQVE7QUFDbkUsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxPQUFPLGNBQWMsMEJBQTBCLFNBQVMsY0FBYztBQUN0RTtBQUNBO0FBQ0EsT0FBTyxjQUFjLGtCQUFrQixjQUFjO0FBQ3JELElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esa0NBQWtDO0FBQ2xDLEdBQUcsMENBQTBDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1YsR0FBRyxrREFBa0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxlQUFlLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzF0QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLHFCQUFxQixXQUFXO0FBQzVFO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxRUFBcUUsUUFBUTtBQUM3RSxRQUFRLFVBQVU7QUFDbEIsMEJBQTBCLFFBQVE7QUFDbEMsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStELFFBQVE7QUFDdkUsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGtCQUFrQix3QkFBd0IsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLFVBQVUsY0FBYyxLQUFLLFdBQVc7QUFDeEMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCOzs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRTs7Ozs7Ozs7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVyxTQUFTLGlCQUFpQixRQUFRO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFvQixTQUFTLFFBQVE7QUFDekMsSUFBSSx1QkFBdUIsR0FBRyxRQUFRLFNBQVMscUJBQXFCO0FBQ3BFLElBQUksU0FBUyxTQUFTLGlDQUFpQztBQUN2RCxJQUFJLGVBQWU7QUFDbkI7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELElBQUksMkJBQTJCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsd0JBQXdCLGFBQWE7QUFDckU7QUFDQSwwQkFBMEIsVUFBVSxHQUFHLFNBQVMsT0FBTyxnQkFBZ0I7QUFDdkUsS0FBSyxzQkFBc0I7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWEsa0NBQWtDLFdBQVc7QUFDbEU7QUFDQSxRQUFRLFdBQVcsa0NBQWtDLFlBQVk7QUFDakU7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQSxjQUFjLFdBQVcsRUFBRSxzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDLDJCQUEyQixPQUFPLEtBQUssRUFBRTtBQUN6QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4QztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLGlCQUFpQixVQUFVLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QixPQUFPO0FBQ3pELGtCQUFrQixhQUFhO0FBQy9CLEtBQUssNEJBQTRCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQ0FBa0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRCQUE0QixLQUFLLFlBQVk7QUFDbEQ7QUFDQSwyQ0FBMkMsbUJBQW1CO0FBQzlELEtBQUssOEJBQThCO0FBQ25DO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsc0NBQXNDLCtCQUErQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDOzs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELHlCQUF5QjtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0QsY0FBYyxXQUFXLEdBQUcseUJBQXlCLE9BQU8sVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGtFQUFrRSxFQUFFO0FBQ3hHOztBQUVBO0FBQ0Esb0NBQW9DLHNGQUFzRixFQUFFO0FBQzVIOztBQUVBO0FBQ0EsaUNBQWlDLGlHQUFpRyxFQUFFO0FBQ3BJOztBQUVBO0FBQ0EsaUNBQWlDLHlGQUF5RixFQUFFO0FBQzVIOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEM7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0SUEsK0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCOzs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBLFlBQVksV0FBVyxTQUFTLGlCQUFpQjtBQUNqRCx5REFBeUQsY0FBYztBQUN2RSxjQUFjLGFBQWEsWUFBWTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxRQUFRLCtDQUErQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRSw4Q0FBOEMsNkJBQTZCO0FBQzNFLCtDQUErQyxtQ0FBbUM7QUFDbEYsb0RBQW9ELGtDQUFrQztBQUN0RixvREFBb0Qsa0NBQWtDO0FBQ3RGLCtDQUErQywrQkFBK0I7QUFDOUUsNkNBQTZDLDRCQUE0QjtBQUN6RSw2Q0FBNkMsNEJBQTRCO0FBQ3pFLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsbURBQW1ELGlDQUFpQztBQUNwRixrREFBa0QsZ0NBQWdDO0FBQ2xGLDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNDQUFzQztBQUNwRyw2REFBNkQsNENBQTRDO0FBQ3pHLDJEQUEyRCxtQ0FBbUM7QUFDOUYsMkRBQTJELGlDQUFpQztBQUM1RiwrREFBK0Qsb0NBQW9DO0FBQ25HLGdFQUFnRSx1Q0FBdUM7QUFDdkcsMkRBQTJELGlDQUFpQztBQUM1RiwyREFBMkQsbUNBQW1DO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0EsMEM7Ozs7OztBQ3JxQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0IseUJBQXlCO0FBQzNFLDJCQUEyQix1QkFBdUIsd0JBQXdCO0FBQzFFLHlCQUF5Qix5QkFBeUIsc0JBQXNCO0FBQ3hFLHlCQUF5Qix5QkFBeUIsc0JBQXNCO0FBQ3hFLDZCQUE2QixxQkFBcUIseUJBQXlCO0FBQzNFLDhCQUE4QixvQkFBb0IsMEJBQTBCO0FBQzVFLHlCQUF5Qix5QkFBeUIsc0JBQXNCO0FBQ3hFLHlCQUF5Qix5QkFBeUIsc0JBQXNCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EsbUJBQW1CLFdBQVcsMEJBQTBCLGtCQUFrQjtBQUMxRTtBQUNBLFdBQVcsV0FBVztBQUN0QixtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQyxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLHNCQUFzQjtBQUNuRSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQixjQUFjLDBCQUEwQixxQkFBcUI7QUFDaEY7QUFDQSxXQUFXLGNBQWM7QUFDekIsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVywwQkFBMEIsa0JBQWtCO0FBQzFFO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQixXQUFXLDBCQUEwQixrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0EsT0FBTyx5QkFBeUI7QUFDaEM7QUFDQSx3RUFBd0UsSUFBSTtBQUM1RTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0EsUUFBUSx5QkFBeUI7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQyxJQUFJLHdCQUF3QjtBQUM1QixxQkFBcUIsY0FBYztBQUNuQyxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pELElBQUksZ0RBQWdEOztBQUVwRDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLHVDQUF1QyxVQUFVLFdBQVc7QUFDaEU7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLGdCQUFnQixtQkFBbUI7QUFDNUQsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQSxJQUFJLGlEQUFpRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7Ozs7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksV0FBVztBQUNmLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPLEtBQUssTUFBTSxPQUFPLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0RBQXNELElBQUk7QUFDakU7QUFDQSx3REFBd0QsUUFBUSxFQUFFO0FBQ2xFLCtCQUErQixpQ0FBaUM7QUFDaEUsSUFBSSxjQUFjLE1BQU0sY0FBYztBQUN0QztBQUNBLFFBQVEsZUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlEQUFpRDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrQkFBa0IsZUFBZSxFQUFFLEVBQUU7QUFDNUM7QUFDQTtBQUNBLElBQUksUUFBUSxNQUFNLFNBQVM7QUFDM0IseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0EsT0FBTyxrQkFBa0IsZUFBZSxFQUFFLGlCQUFpQixFQUFFO0FBQzdEO0FBQ0E7QUFDQSxJQUFJLHVDQUF1QztBQUMzQztBQUNBLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGNBQWM7QUFDakQsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsMEJBQTBCLGNBQWM7QUFDL0QsSUFBSSxvQkFBb0IsYUFBYTtBQUNyQztBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxjQUFjO0FBQ2xELElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLDJCQUEyQixjQUFjO0FBQ2hFLElBQUksb0JBQW9CLGFBQWE7QUFDckM7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0EsY0FBYyx1QkFBdUIsTUFBTSx5QkFBeUI7QUFDcEUsa0JBQWtCLHFCQUFxQixjQUFjO0FBQ3JELFFBQVEscUJBQXFCLE1BQU0sV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUJBQWlCLG9CQUFvQjtBQUM1QyxJQUFJLFFBQVEsVUFBVSxRQUFRLE1BQU0sVUFBVTtBQUM5QztBQUNBLGlEQUFpRCxRQUFRLEtBQUssUUFBUTtBQUN0RTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxpQkFBaUIsY0FBYztBQUM5RDtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLElBQUksUUFBUSxNQUFNLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0IsTUFBTSxpQkFBaUI7QUFDakUsU0FBUyxXQUFXLE1BQU0sV0FBVztBQUNyQyxJQUFJLGdCQUFnQjtBQUNwQixTQUFTLFFBQVEsdUNBQXVDLFFBQVE7QUFDaEUsSUFBSSxRQUFRO0FBQ1osd0RBQXdELFFBQVE7QUFDaEUsSUFBSSxTQUFTO0FBQ2IsNkRBQTZELFFBQVE7QUFDckUsSUFBSSxTQUFTLFVBQVUsUUFBUSxxQ0FBcUM7QUFDcEUsMEJBQTBCLFFBQVE7QUFDbEMsc0JBQXNCLGFBQWEsdUJBQXVCLFFBQVE7QUFDbEUsb0JBQW9CLFVBQVU7QUFDOUIsSUFBSSxRQUFRLHNDQUFzQyxRQUFRO0FBQzFEO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRSxJQUFJLFNBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxTQUFTLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQjtBQUMvRCxJQUFJLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN6QyxJQUFJLE9BQU8sR0FBRyxxQkFBcUIsV0FBVyxJQUFJLEVBQUUsSUFBSSxXQUFXLElBQUksRUFBRTtBQUN6RSxJQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQjtBQUMvRCxJQUFJLGlCQUFpQixHQUFHLGtCQUFrQjtBQUMxQyxJQUFJLE9BQU8sR0FBRyxxQkFBcUIsV0FBVyxJQUFJLEVBQUUsSUFBSSxXQUFXLElBQUksRUFBRTtBQUN6RSxJQUFJLE9BQU8sR0FBRyxNQUFNO0FBQ3BCO0FBQ0EsUUFBUSxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUI7QUFDL0QsSUFBSSxpQkFBaUIsbUNBQW1DLE9BQU8sR0FBRztBQUNsRSxJQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sR0FBRyxNQUFNO0FBQ2xDLGNBQWMsT0FBTyxLQUFLO0FBQzFCO0FBQ0EsUUFBUSxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUI7QUFDL0QsSUFBSSxpQkFBaUIsbUNBQW1DLE9BQU8sR0FBRztBQUNsRSxJQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3BDO0FBQ0EsUUFBUSxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUI7QUFDL0QsSUFBSSxpQkFBaUIsbUNBQW1DLE9BQU8sR0FBRztBQUNsRSxJQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSwyQ0FBMkMsVUFBVTtBQUNyRCxJQUFJLFVBQVUsSUFBSSxHQUFHLE1BQU07QUFDM0IsZ0NBQWdDLE9BQU8sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJLFVBQVUsTUFBTSxLQUFLLFFBQVEsSUFBSSxFQUFFLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsV0FBVyxhQUFhLEtBQUssY0FBYztBQUNsRSxJQUFJLHNDQUFzQyxLQUFLLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVyxLQUFLLGNBQWMsYUFBYSxhQUFhO0FBQ3BFLElBQUksc0NBQXNDLGVBQWU7QUFDekQ7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLEtBQUssY0FBYyxhQUFhLGFBQWE7QUFDcEUsSUFBSSxzQ0FBc0MsS0FBSyxlQUFlO0FBQzlEO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSxZQUFZLFdBQVcscUJBQXFCLGNBQWM7QUFDMUQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGNBQWM7QUFDbEIsSUFBSSw4QkFBOEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9ELE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjLEVBQUU7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsS0FBSyxjQUFjO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywrQ0FBK0M7QUFDOUYsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRLEtBQUssY0FBYztBQUM3QztBQUNBO0FBQ0EsVUFBVSw2QkFBNkIsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5aUJBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLLE9BQU8sc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUEsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MsMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQTJCO0FBQ25DLElBQUksa0NBQWtDO0FBQ3RDLFFBQVEsNkJBQTZCO0FBQ3JDLElBQUksNEJBQTRCO0FBQ2hDLFFBQVEsK0JBQStCO0FBQ3ZDLElBQUksOEJBQThCO0FBQ2xDLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhLEdBQUcsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUMsSUFBSSwyQkFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVkscUNBQXFDLFlBQVk7QUFDcEUsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQSxnREFBZ0Q7QUFDaEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLHVCQUF1QixZQUFZO0FBQ25DLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWSx5QkFBeUIsVUFBVTtBQUN6RSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0NBQWtDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLHlCQUF5QixRQUFRLEVBQUU7QUFDdEUsU0FBUyxzQkFBc0IsNEJBQTRCLGVBQWU7QUFDMUUsZ0RBQWdELFVBQVU7QUFDMUQsWUFBWSxXQUFXLHFDQUFxQyxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBLG1CQUFtQixXQUFXLEdBQUcsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLDJCQUEyQixZQUFZO0FBQ3ZDLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2Qix5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLHNCQUFzQjtBQUMxQixxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQSxJQUFJLGlDQUFpQztBQUNyQyxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUF5RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pELFNBQVMsaUNBQWlDO0FBQzFDLCtCQUErQiw0QkFBNEI7QUFDM0QsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNudkJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSw0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsVUFBVSxVQUFVLEtBQUssV0FBVztBQUNwQyxJQUFJLFFBQVEsY0FBYyxxQkFBcUI7QUFDL0MsT0FBTyxVQUFVLFNBQVMsV0FBVztBQUNyQyxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QiwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELGNBQWMsVUFBVTtBQUN4QjtBQUNBLFVBQVUsVUFBVSxLQUFLLFdBQVcsTUFBTSxnQkFBZ0I7QUFDMUQsb0JBQW9CLFFBQVEsY0FBYyxxQkFBcUI7QUFDL0QsdUJBQXVCLFVBQVUsU0FBUyxXQUFXLE1BQU0sYUFBYTtBQUN4RSxJQUFJLFdBQVcsTUFBTSxnQkFBZ0I7QUFDckMsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEIscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkIsd0JBQXdCLFdBQVc7QUFDbkMsZUFBZSxXQUFXLG9DQUFvQztBQUM5RCxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QyxrRUFBa0U7QUFDbEUsT0FBTyxXQUFXO0FBQ2xCO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFFBQVEsTUFBTSxXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFFBQVEsTUFBTSxRQUFRO0FBQzFCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVEsYUFBYSxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQXNEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBLHNDQUFzQyw4Q0FBOEM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DLHFEQUFxRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxHQUFHLFFBQVEsR0FBRzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOERBQThEO0FBQzNGLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQSxFQUFFO0FBQ0YsNEJBQTRCLG9CQUFvQjtBQUNoRCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCLEtBQUssV0FBVztBQUM1QyxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGdCQUFnQjtBQUNwQixnQ0FBZ0MscUJBQXFCLEdBQUcscUJBQXFCO0FBQzdFLFFBQVEsdUJBQXVCO0FBQy9CLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVywwQkFBMEIsWUFBWTtBQUN4RTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3RELElBQUksa0JBQWtCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEsb0NBQW9DO0FBQzVDLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsaUNBQWlDLCtCQUErQjtBQUNoRSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBLGNBQWMsMEJBQTBCO0FBQ3hDLGNBQWMsMEJBQTBCO0FBQ3hDLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCLGNBQWMsV0FBVztBQUNsRDtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDLE9BQU8sMEJBQTBCLE1BQU0sa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUksdUNBQXVDLFVBQVUsV0FBVztBQUNoRSxJQUFJLHNCQUFzQixlQUFlLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DLElBQUksWUFBWSxFQUFFLGlCQUFpQjtBQUNuQyxJQUFJLDJCQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVCQUF1QjtBQUNuRSxJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBLElBQUksc0JBQXNCLGFBQWEsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQixJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QixlQUFlLHNCQUFzQjtBQUN0RSw0Q0FBNEM7QUFDNUM7QUFDQSxJQUFJLHNCQUFzQixTQUFTLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0EsSUFBSSxnQkFBZ0IsK0JBQStCLGVBQWU7QUFDbEUsSUFBSSxXQUFXO0FBQ2YsSUFBSSxrQkFBa0Isc0JBQXNCLHNCQUFzQjtBQUNsRSxnREFBZ0Qsc0JBQXNCO0FBQ3RFLElBQUksV0FBVyxhQUFhLFdBQVcsTUFBTSxtQkFBbUI7QUFDaEUsSUFBSSxtQkFBbUI7QUFDdkIsSUFBSSxtQkFBbUI7QUFDdkIsOENBQThDLEtBQUssV0FBVztBQUM5RCxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsV0FBVyxnREFBZ0QsRUFBRSw2Q0FBNkMsU0FBUywyQkFBMkI7QUFDOUksV0FBVyw4Q0FBOEMsTUFBTSx3QkFBd0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU8sU0FBUztBQUM1RSx5REFBeUQsT0FBTyxNQUFNO0FBQ3RFO0FBQ0Esa0JBQWtCLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTTtBQUNqRDtBQUNBLDBCQUEwQixPQUFPLEdBQUcsS0FBSyxPQUFPLEdBQUc7QUFDbkQsNEJBQTRCLE9BQU8sR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxRQUFRLE1BQU0sV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxRQUFRLE1BQU0sUUFBUTtBQUMxQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixLQUFLLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRyxLQUFLOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksY0FBYyxpQkFBaUIsb0JBQW9CO0FBQ3ZELHNCQUFzQixjQUFjO0FBQ3BDLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsSUFBSSxzQkFBc0IsNEJBQTRCLGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0EsWUFBWSxjQUFjLDJCQUEyQixjQUFjO0FBQ25FO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EsK0JBQStCLGdEQUFnRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLEtBQUssY0FBYztBQUMzQztBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0EseUJBQXlCLFdBQVcsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkJBQTJCO0FBQy9CLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSwyQkFBMkI7QUFDL0IsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0QsSUFBSSw4QkFBOEI7QUFDbEMsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixVQUFVO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLDJDQUEyQztBQUMxRTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixVQUFVO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLDJDQUEyQztBQUMxRTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQixnQkFBZ0IsU0FBUztBQUNqRCxZQUFZLFdBQVcsS0FBSyxXQUFXLFNBQVMsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsS0FBSyxXQUFXLHVCQUF1QixXQUFXO0FBQ3JFLHVDQUF1QyxlQUFlO0FBQ3RELElBQUksb0JBQW9CLFVBQVUsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVMsS0FBSyxXQUFXLHVCQUF1QjtBQUMvRCx3REFBd0Q7QUFDeEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLG9FQUFvRTtBQUNwRTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsVUFBVSxRQUFRLEtBQUssY0FBYyx1QkFBdUIsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLDRCQUE0QixRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0Q7Ozs7OztBQy9yREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUMsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLLFdBQVcsMENBQTBDO0FBQzFELEtBQUssWUFBWSxpQ0FBaUMsd0JBQXdCO0FBQzFFLEtBQUsseUJBQXlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsV0FBVyxvQkFBb0IsS0FBSyxZQUFZO0FBQ2hELElBQUksV0FBVyxZQUFZLFlBQVk7QUFDdkMsSUFBSSxlQUFlLHlCQUF5QixzQkFBc0I7QUFDbEU7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0EseUJBQXlCLFdBQVcsNkJBQTZCO0FBQ2pFLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsZUFBZSxXQUFXO0FBQ2pFLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDOztBQUVBLDBEOzs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQywrQ0FBK0MsV0FBVyxHQUFHLFdBQVc7QUFDeEUsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEMsSUFBSSx3QkFBd0I7QUFDNUIsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEM7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixrQkFBa0I7QUFDN0MsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QjtBQUNuRTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSx3QkFBd0I7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCOztBQUVBO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRSxRQUFRLFdBQVc7QUFDbkI7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkMsS0FBSyxnQkFBZ0IsSUFBSSxnQkFBZ0IsU0FBUyxXQUFXLFFBQVE7QUFDckU7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSyx1QkFBdUI7QUFDNUI7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QyxLQUFLLG9CQUFvQixlQUFlLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0IsMEJBQTBCLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0EsS0FBSyxtQkFBbUIsTUFBTSxVQUFVLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1QsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0EsS0FBSyxlQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsWUFBWSxXQUFXLGlDQUFpQyxRQUFRO0FBQ2hFLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdFhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0EsVUFBVSxrQkFBa0IsYUFBYTtBQUN6QyxLQUFLLG9CQUFvQjtBQUN6QixtQkFBbUIsa0JBQWtCLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsWUFBWTtBQUNuRCxhQUFhLHNDQUFzQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QyxxQ0FBcUMsMEJBQTBCO0FBQy9ELElBQUksV0FBVztBQUNmLElBQUksd0NBQXdDO0FBQzVDLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QyxxQ0FBcUMsMEJBQTBCO0FBQy9ELElBQUksV0FBVztBQUNmLElBQUksd0NBQXdDO0FBQzVDLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLFVBQVUsZUFBZSxLQUFLLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsNENBQTRDO0FBQ3ZFO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQsd0RBQXdELFFBQVE7QUFDaEUsSUFBSSxRQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFLElBQUksdUNBQXVDO0FBQzNDO0FBQ0E7QUFDQSxJQUFJLDZDQUE2QztBQUNqRCxJQUFJLHdDQUF3QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGFBQWE7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0JBQWtCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLEtBQUssYUFBYTtBQUN6Qyx1QkFBdUIsWUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGlCQUFpQixNQUFNLG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLGlDQUFpQyxnREFBZ0QsRUFBRTtBQUNuRiwrQkFBK0Isd0NBQXdDLEVBQUU7QUFDekUsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qjs7Ozs7O0FDanFCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxHQUFHLGlCQUFpQixHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU87QUFDckUsTUFBTSxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFLG9CQUFvQixPQUFPLE9BQU8sT0FBTyxPQUFPLFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyREFBMkQsT0FBTyxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxrREFBa0Q7QUFDbEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQkFBK0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsbUVBQW1FLHNDQUFzQyxFQUFFOztBQUUzRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7Ozs7Ozs7O0FDMWxDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxPQUFPO0FBQ3ZFLE1BQU0sT0FBTyxPQUFPLE9BQU8sT0FBTyxTQUFTLEdBQUcsT0FBTyxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtRUFBbUUsc0NBQXNDLEVBQUU7O0FBRTNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBIiwiZmlsZSI6Im1hcHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwOSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYmExNjRlNDI2ZTkxNDIwMzdjNGEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICAgIHJldHVybiBcIltcIiArIGEuam9pbihcIiwgXCIpICsgXCJdXCI7XG59XG5cblN0cmluZy5wcm90b3R5cGUuc2VlZCA9IFN0cmluZy5wcm90b3R5cGUuc2VlZCB8fCBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikpO1xuXG5TdHJpbmcucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW1haW5kZXIsIGJ5dGVzLCBoMSwgaDFiLCBjMSwgYzFiLCBjMiwgYzJiLCBrMSwgaSxcbiAgICAgICAga2V5ID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7IC8vIGtleS5sZW5ndGggJSA0XG4gICAgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICAgIGgxID0gU3RyaW5nLnByb3RvdHlwZS5zZWVkO1xuICAgIGMxID0gMHhjYzllMmQ1MTtcbiAgICBjMiA9IDB4MWI4NzM1OTM7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGJ5dGVzKSB7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKSkgfFxuICAgICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgOCkgfFxuICAgICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDI0KTtcbiAgICAgICAgKytpO1xuXG4gICAgICAgIGsxID0gKCgoKGsxICYgMHhmZmZmKSAqIGMxKSArICgoKChrMSA+Pj4gMTYpICogYzEpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgICAgICBrMSA9ICgoKChrMSAmIDB4ZmZmZikgKiBjMikgKyAoKCgoazEgPj4+IDE2KSAqIGMyKSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuXG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IChoMSA8PCAxMykgfCAoaDEgPj4+IDE5KTtcbiAgICAgICAgaDFiID0gKCgoKGgxICYgMHhmZmZmKSAqIDUpICsgKCgoKGgxID4+PiAxNikgKiA1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICBoMSA9ICgoKGgxYiAmIDB4ZmZmZikgKyAweDZiNjQpICsgKCgoKGgxYiA+Pj4gMTYpICsgMHhlNjU0KSAmIDB4ZmZmZikgPDwgMTYpKTtcbiAgICB9XG5cbiAgICBrMSA9IDA7XG5cbiAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKTtcblxuICAgICAgICAgICAgazEgPSAoKChrMSAmIDB4ZmZmZikgKiBjMSkgKyAoKCgoazEgPj4+IDE2KSAqIGMxKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICAgICAgICAgIGsxID0gKCgoazEgJiAweGZmZmYpICogYzIpICsgKCgoKGsxID4+PiAxNikgKiBjMikgJiAweGZmZmYpIDw8IDE2KSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgfVxuXG4gICAgaDEgXj0ga2V5Lmxlbmd0aDtcblxuICAgIGgxIF49IGgxID4+PiAxNjtcbiAgICBoMSA9ICgoKGgxICYgMHhmZmZmKSAqIDB4ODVlYmNhNmIpICsgKCgoKGgxID4+PiAxNikgKiAweDg1ZWJjYTZiKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgXj0gaDEgPj4+IDEzO1xuICAgIGgxID0gKCgoKGgxICYgMHhmZmZmKSAqIDB4YzJiMmFlMzUpICsgKCgoKGgxID4+PiAxNikgKiAweGMyYjJhZTM1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGgxIF49IGgxID4+PiAxNjtcblxuICAgIHJldHVybiBoMSA+Pj4gMDtcbn07XG5cbmZ1bmN0aW9uIHN0YW5kYXJkRXF1YWxzRnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmVxdWFscyhiKTtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRIYXNoQ29kZUZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYS5oYXNoQ29kZSgpO1xufVxuXG5mdW5jdGlvbiBTZXQoaGFzaEZ1bmN0aW9uLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uIHx8IHN0YW5kYXJkSGFzaENvZGVGdW5jdGlvbjtcbiAgICB0aGlzLmVxdWFsc0Z1bmN0aW9uID0gZXF1YWxzRnVuY3Rpb24gfHwgc3RhbmRhcmRFcXVhbHNGdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJoYXNoX1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGwgPSBsICsgdGhpcy5kYXRhW2tleV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbn0pO1xuXG5TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoRnVuY3Rpb24odmFsdWUpO1xuICAgIHZhciBrZXkgPSBcImhhc2hfXCIgKyBoYXNoO1xuICAgIGlmIChrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKHZhbHVlLCB2YWx1ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IFt2YWx1ZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuXG5TZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHZhbHVlKSAhPSBudWxsO1xufTtcblxuU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaEZ1bmN0aW9uKHZhbHVlKTtcbiAgICB2YXIga2V5ID0gXCJoYXNoX1wiICsgaGFzaDtcbiAgICBpZiAoa2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGdW5jdGlvbih2YWx1ZSwgdmFsdWVzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5TZXQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiaGFzaF9cIikgPT09IDApIHtcbiAgICAgICAgICAgIGwgPSBsLmNvbmNhdCh0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGw7XG59O1xuXG5TZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHRoaXMudmFsdWVzKCkpO1xufTtcblxuZnVuY3Rpb24gQml0U2V0KCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5CaXRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVt2YWx1ZV0gPSB0cnVlO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYml0cyA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoc2V0LmRhdGEpLm1hcChmdW5jdGlvbiAoYWx0KSB7XG4gICAgICAgIGJpdHMuYWRkKGFsdCk7XG4gICAgfSk7XG59O1xuXG5CaXRTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRhdGFbdmFsdWVdO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdmFsdWVdID09PSB0cnVlO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG59O1xuXG5CaXRTZXQucHJvdG90eXBlLm1pblZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLnZhbHVlcygpKTtcbn07XG5cbkJpdFNldC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgIGhhc2gudXBkYXRlKHRoaXMudmFsdWVzKCkpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEJpdFNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXNoQ29kZSgpID09PSBvdGhlci5oYXNoQ29kZSgpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdFNldC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCkubGVuZ3RoO1xuICAgIH1cbn0pO1xuXG5CaXRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIntcIiArIHRoaXMudmFsdWVzKCkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG59O1xuXG5mdW5jdGlvbiBNYXAoaGFzaEZ1bmN0aW9uLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uIHx8IHN0YW5kYXJkSGFzaENvZGVGdW5jdGlvbjtcbiAgICB0aGlzLmVxdWFsc0Z1bmN0aW9uID0gZXF1YWxzRnVuY3Rpb24gfHwgc3RhbmRhcmRFcXVhbHNGdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBoYXNoS2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKGhhc2hLZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IGwgKyB0aGlzLmRhdGFbaGFzaEtleV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbn0pO1xuXG5NYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGhhc2hLZXkgPSBcImhhc2hfXCIgKyB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGlmIChoYXNoS2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZGF0YVtoYXNoS2V5XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRnVuY3Rpb24oa2V5LCBlbnRyeS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW50cmllcy5wdXNoKHtrZXk6a2V5LCB2YWx1ZTp2YWx1ZX0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW2hhc2hLZXldID0gW3trZXk6a2V5LCB2YWx1ZTp2YWx1ZX1dO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcblxuTWFwLnByb3RvdHlwZS5jb250YWluc0tleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaGFzaEtleSA9IFwiaGFzaF9cIiArIHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgaWYoaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmRhdGFbaGFzaEtleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKGtleSwgZW50cnkua2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaGFzaEtleSA9IFwiaGFzaF9cIiArIHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgaWYoaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmRhdGFbaGFzaEtleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKGtleSwgZW50cnkua2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5NYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGwgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgICBsID0gbC5jb25jYXQodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsO1xufTtcblxuXG5NYXAucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLmtleTtcbiAgICB9KTtcbn07XG5cblxuTWFwLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICB9KTtcbn07XG5cblxuTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3MgPSB0aGlzLmVudHJpZXMoKS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICd7JyArIGVudHJ5LmtleSArICc6JyArIGVudHJ5LnZhbHVlICsgJ30nO1xuICAgIH0pO1xuICAgIHJldHVybiAnWycgKyBzcy5qb2luKFwiLCBcIikgKyAnXSc7XG59O1xuXG5cbmZ1bmN0aW9uIEFsdERpY3QoKSB7XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblxuQWx0RGljdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSA9IFwiay1cIiArIGtleTtcbiAgICBpZiAoa2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuQWx0RGljdC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBcImstXCIgKyBrZXk7XG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbn07XG5cbkFsdERpY3QucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIERvdWJsZURpY3QoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIEhhc2goKSB7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gICAgdGhpcy5oYXNoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmFwcGx5KHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgayA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBrID0gdmFsdWUuaGFzaENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudXBkYXRlSGFzaENvZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IGsgKiAweENDOUUyRDUxO1xuICAgICAgICAgICAgayA9IChrIDw8IDE1KSB8IChrID4+PiAoMzIgLSAxNSkpO1xuICAgICAgICAgICAgayA9IGsgKiAweDFCODczNTkzO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IHRoaXMuY291bnQgKyAxO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLmhhc2ggXiBrO1xuICAgICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDEzKSB8IChoYXNoID4+PiAoMzIgLSAxMykpO1xuICAgICAgICAgICAgaGFzaCA9IGhhc2ggKiA1ICsgMHhFNjU0NkI2NDtcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkhhc2gucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCBeICh0aGlzLmNvdW50ICogNCk7XG4gICAgaGFzaCA9IGhhc2ggXiAoaGFzaCA+Pj4gMTYpO1xuICAgIGhhc2ggPSBoYXNoICogMHg4NUVCQ0E2QjtcbiAgICBoYXNoID0gaGFzaCBeIChoYXNoID4+PiAxMyk7XG4gICAgaGFzaCA9IGhhc2ggKiAweEMyQjJBRTM1O1xuICAgIGhhc2ggPSBoYXNoIF4gKGhhc2ggPj4+IDE2KTtcbiAgICByZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gaGFzaFN0dWZmKCkge1xuICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcbiAgICBoYXNoLnVwZGF0ZS5hcHBseShhcmd1bWVudHMpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufVxuXG5Eb3VibGVEaWN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBkID0gdGhpc1thXSB8fCBudWxsO1xuICAgIHJldHVybiBkID09PSBudWxsID8gbnVsbCA6IChkW2JdIHx8IG51bGwpO1xufTtcblxuRG91YmxlRGljdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGEsIGIsIG8pIHtcbiAgICB2YXIgZCA9IHRoaXNbYV0gfHwgbnVsbDtcbiAgICBpZiAoZCA9PT0gbnVsbCkge1xuICAgICAgICBkID0ge307XG4gICAgICAgIHRoaXNbYV0gPSBkO1xuICAgIH1cbiAgICBkW2JdID0gbztcbn07XG5cblxuZnVuY3Rpb24gZXNjYXBlV2hpdGVzcGFjZShzLCBlc2NhcGVTcGFjZXMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XG4gICAgaWYgKGVzY2FwZVNwYWNlcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKC8gL2csIFwiXFx1MDBCN1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcd1xcUyovZywgZnVuY3Rpb24gKHR4dCkge1xuICAgICAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGEsIGIpXG57XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID09IGJbaV0pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFhW2ldLmVxdWFscyhiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuZXhwb3J0cy5TZXQgPSBTZXQ7XG5leHBvcnRzLk1hcCA9IE1hcDtcbmV4cG9ydHMuQml0U2V0ID0gQml0U2V0O1xuZXhwb3J0cy5BbHREaWN0ID0gQWx0RGljdDtcbmV4cG9ydHMuRG91YmxlRGljdCA9IERvdWJsZURpY3Q7XG5leHBvcnRzLmhhc2hTdHVmZiA9IGhhc2hTdHVmZjtcbmV4cG9ydHMuZXNjYXBlV2hpdGVzcGFjZSA9IGVzY2FwZVdoaXRlc3BhY2U7XG5leHBvcnRzLmFycmF5VG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuZXhwb3J0cy50aXRsZUNhc2UgPSB0aXRsZUNhc2U7XG5leHBvcnRzLmVxdWFsQXJyYXlzID0gZXF1YWxBcnJheXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG4vLyBBIHRva2VuIGhhcyBwcm9wZXJ0aWVzOiB0ZXh0LCB0eXBlLCBsaW5lLCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gdGhlIGxpbmVcbi8vIChzbyB3ZSBjYW4gaWdub3JlIHRhYnMpLCB0b2tlbiBjaGFubmVsLCBpbmRleCwgYW5kIHNvdXJjZSBmcm9tIHdoaWNoXG4vLyB3ZSBvYnRhaW5lZCB0aGlzIHRva2VuLlxuXG5mdW5jdGlvbiBUb2tlbigpIHtcblx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHR0aGlzLnR5cGUgPSBudWxsOyAvLyB0b2tlbiB0eXBlIG9mIHRoZSB0b2tlblxuXHR0aGlzLmNoYW5uZWwgPSBudWxsOyAvLyBUaGUgcGFyc2VyIGlnbm9yZXMgZXZlcnl0aGluZyBub3Qgb24gREVGQVVMVF9DSEFOTkVMXG5cdHRoaXMuc3RhcnQgPSBudWxsOyAvLyBvcHRpb25hbDsgcmV0dXJuIC0xIGlmIG5vdCBpbXBsZW1lbnRlZC5cblx0dGhpcy5zdG9wID0gbnVsbDsgLy8gb3B0aW9uYWw7IHJldHVybiAtMSBpZiBub3QgaW1wbGVtZW50ZWQuXG5cdHRoaXMudG9rZW5JbmRleCA9IG51bGw7IC8vIGZyb20gMC4ubi0xIG9mIHRoZSB0b2tlbiBvYmplY3QgaW4gdGhlIGlucHV0IHN0cmVhbVxuXHR0aGlzLmxpbmUgPSBudWxsOyAvLyBsaW5lPTEuLm4gb2YgdGhlIDFzdCBjaGFyYWN0ZXJcblx0dGhpcy5jb2x1bW4gPSBudWxsOyAvLyBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXQgd2hpY2ggaXQgb2NjdXJzLCAwLi5uLTFcblx0dGhpcy5fdGV4dCA9IG51bGw7IC8vIHRleHQgb2YgdGhlIHRva2VuLlxuXHRyZXR1cm4gdGhpcztcbn1cblxuVG9rZW4uSU5WQUxJRF9UWVBFID0gMDtcblxuLy8gRHVyaW5nIGxvb2thaGVhZCBvcGVyYXRpb25zLCB0aGlzIFwidG9rZW5cIiBzaWduaWZpZXMgd2UgaGl0IHJ1bGUgZW5kIEFUTiBzdGF0ZVxuLy8gYW5kIGRpZCBub3QgZm9sbG93IGl0IGRlc3BpdGUgbmVlZGluZyB0by5cblRva2VuLkVQU0lMT04gPSAtMjtcblxuVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSA9IDE7XG5cblRva2VuLkVPRiA9IC0xO1xuXG4vLyBBbGwgdG9rZW5zIGdvIHRvIHRoZSBwYXJzZXIgKHVubGVzcyBza2lwKCkgaXMgY2FsbGVkIGluIHRoYXQgcnVsZSlcbi8vIG9uIGEgcGFydGljdWxhciBcImNoYW5uZWxcIi4gVGhlIHBhcnNlciB0dW5lcyB0byBhIHBhcnRpY3VsYXIgY2hhbm5lbFxuLy8gc28gdGhhdCB3aGl0ZXNwYWNlIGV0Yy4uLiBjYW4gZ28gdG8gdGhlIHBhcnNlciBvbiBhIFwiaGlkZGVuXCIgY2hhbm5lbC5cblxuVG9rZW4uREVGQVVMVF9DSEFOTkVMID0gMDtcblxuLy8gQW55dGhpbmcgb24gZGlmZmVyZW50IGNoYW5uZWwgdGhhbiBERUZBVUxUX0NIQU5ORUwgaXMgbm90IHBhcnNlZFxuLy8gYnkgcGFyc2VyLlxuXG5Ub2tlbi5ISURERU5fQ0hBTk5FTCA9IDE7XG5cbi8vIEV4cGxpY2l0bHkgc2V0IHRoZSB0ZXh0IGZvciB0aGlzIHRva2VuLiBJZiB7Y29kZSB0ZXh0fSBpcyBub3Rcbi8vIHtAY29kZSBudWxsfSwgdGhlbiB7QGxpbmsgLy9nZXRUZXh0fSB3aWxsIHJldHVybiB0aGlzIHZhbHVlIHJhdGhlciB0aGFuXG4vLyBleHRyYWN0aW5nIHRoZSB0ZXh0IGZyb20gdGhlIGlucHV0LlxuLy9cbi8vIEBwYXJhbSB0ZXh0IFRoZSBleHBsaWNpdCB0ZXh0IG9mIHRoZSB0b2tlbiwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSB0ZXh0XG4vLyBzaG91bGQgYmUgb2J0YWluZWQgZnJvbSB0aGUgaW5wdXQgYWxvbmcgd2l0aCB0aGUgc3RhcnQgYW5kIHN0b3AgaW5kZXhlc1xuLy8gb2YgdGhlIHRva2VuLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW4ucHJvdG90eXBlLCBcInRleHRcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcblx0fSxcblx0c2V0IDogZnVuY3Rpb24odGV4dCkge1xuXHRcdHRoaXMuX3RleHQgPSB0ZXh0O1xuXHR9XG59KTtcblxuVG9rZW4ucHJvdG90eXBlLmdldFRva2VuU291cmNlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNvdXJjZVswXTtcbn07XG5cblRva2VuLnByb3RvdHlwZS5nZXRJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zb3VyY2VbMV07XG59O1xuXG5mdW5jdGlvbiBDb21tb25Ub2tlbihzb3VyY2UsIHR5cGUsIGNoYW5uZWwsIHN0YXJ0LCBzdG9wKSB7XG5cdFRva2VuLmNhbGwodGhpcyk7XG5cdHRoaXMuc291cmNlID0gc291cmNlICE9PSB1bmRlZmluZWQgPyBzb3VyY2UgOiBDb21tb25Ub2tlbi5FTVBUWV9TT1VSQ0U7XG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBudWxsO1xuXHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsICE9PSB1bmRlZmluZWQgPyBjaGFubmVsIDogVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuXHR0aGlzLnN0YXJ0ID0gc3RhcnQgIT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogLTE7XG5cdHRoaXMuc3RvcCA9IHN0b3AgIT09IHVuZGVmaW5lZCA/IHN0b3AgOiAtMTtcblx0dGhpcy50b2tlbkluZGV4ID0gLTE7XG5cdGlmICh0aGlzLnNvdXJjZVswXSAhPT0gbnVsbCkge1xuXHRcdHRoaXMubGluZSA9IHNvdXJjZVswXS5saW5lO1xuXHRcdHRoaXMuY29sdW1uID0gc291cmNlWzBdLmNvbHVtbjtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmNvbHVtbiA9IC0xO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufVxuXG5Db21tb25Ub2tlbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRva2VuLnByb3RvdHlwZSk7XG5Db21tb25Ub2tlbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21tb25Ub2tlbjtcblxuLy8gQW4gZW1wdHkge0BsaW5rIFBhaXJ9IHdoaWNoIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQgdmFsdWUgb2Zcbi8vIHtAbGluayAvL3NvdXJjZX0gZm9yIHRva2VucyB0aGF0IGRvIG5vdCBoYXZlIGEgc291cmNlLlxuQ29tbW9uVG9rZW4uRU1QVFlfU09VUkNFID0gWyBudWxsLCBudWxsIF07XG5cbi8vIENvbnN0cnVjdHMgYSBuZXcge0BsaW5rIENvbW1vblRva2VufSBhcyBhIGNvcHkgb2YgYW5vdGhlciB7QGxpbmsgVG9rZW59LlxuLy9cbi8vIDxwPlxuLy8gSWYge0Bjb2RlIG9sZFRva2VufSBpcyBhbHNvIGEge0BsaW5rIENvbW1vblRva2VufSBpbnN0YW5jZSwgdGhlIG5ld2x5XG4vLyBjb25zdHJ1Y3RlZCB0b2tlbiB3aWxsIHNoYXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgLy90ZXh0fSBmaWVsZCBhbmRcbi8vIHRoZSB7QGxpbmsgUGFpcn0gc3RvcmVkIGluIHtAbGluayAvL3NvdXJjZX0uIE90aGVyd2lzZSwge0BsaW5rIC8vdGV4dH0gd2lsbFxuLy8gYmUgYXNzaWduZWQgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHtAbGluayAvL2dldFRleHR9LCBhbmQge0BsaW5rIC8vc291cmNlfVxuLy8gd2lsbCBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSByZXN1bHQgb2Yge0BsaW5rIFRva2VuLy9nZXRUb2tlblNvdXJjZX0gYW5kXG4vLyB7QGxpbmsgVG9rZW4vL2dldElucHV0U3RyZWFtfS48L3A+XG4vL1xuLy8gQHBhcmFtIG9sZFRva2VuIFRoZSB0b2tlbiB0byBjb3B5LlxuLy9cbkNvbW1vblRva2VuLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdCA9IG5ldyBDb21tb25Ub2tlbih0aGlzLnNvdXJjZSwgdGhpcy50eXBlLCB0aGlzLmNoYW5uZWwsIHRoaXMuc3RhcnQsXG5cdFx0XHR0aGlzLnN0b3ApO1xuXHR0LnRva2VuSW5kZXggPSB0aGlzLnRva2VuSW5kZXg7XG5cdHQubGluZSA9IHRoaXMubGluZTtcblx0dC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcblx0dC50ZXh0ID0gdGhpcy50ZXh0O1xuXHRyZXR1cm4gdDtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwidGV4dFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl90ZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcblx0XHR9XG5cdFx0dmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dFN0cmVhbSgpO1xuXHRcdGlmIChpbnB1dCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHZhciBuID0gaW5wdXQuc2l6ZTtcblx0XHRpZiAodGhpcy5zdGFydCA8IG4gJiYgdGhpcy5zdG9wIDwgbikge1xuXHRcdFx0cmV0dXJuIGlucHV0LmdldFRleHQodGhpcy5zdGFydCwgdGhpcy5zdG9wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiPEVPRj5cIjtcblx0XHR9XG5cdH0sXG5cdHNldCA6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR0aGlzLl90ZXh0ID0gdGV4dDtcblx0fVxufSk7XG5cbkNvbW1vblRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHh0ID0gdGhpcy50ZXh0O1xuXHRpZiAodHh0ICE9PSBudWxsKSB7XG5cdFx0dHh0ID0gdHh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpO1xuXHR9IGVsc2Uge1xuXHRcdHR4dCA9IFwiPG5vIHRleHQ+XCI7XG5cdH1cblx0cmV0dXJuIFwiW0BcIiArIHRoaXMudG9rZW5JbmRleCArIFwiLFwiICsgdGhpcy5zdGFydCArIFwiOlwiICsgdGhpcy5zdG9wICsgXCI9J1wiICtcblx0XHRcdHR4dCArIFwiJyw8XCIgKyB0aGlzLnR5cGUgKyBcIj5cIiArXG5cdFx0XHQodGhpcy5jaGFubmVsID4gMCA/IFwiLGNoYW5uZWw9XCIgKyB0aGlzLmNoYW5uZWwgOiBcIlwiKSArIFwiLFwiICtcblx0XHRcdHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2x1bW4gKyBcIl1cIjtcbn07XG5cbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbmV4cG9ydHMuQ29tbW9uVG9rZW4gPSBDb21tb25Ub2tlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9Ub2tlbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLypqc2xpbnQgc21hcnR0YWJzOnRydWUgKi9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xuXG4vKiBzdG9wIGlzIG5vdCBpbmNsdWRlZCEgKi9cbmZ1bmN0aW9uIEludGVydmFsKHN0YXJ0LCBzdG9wKSB7XG5cdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0dGhpcy5zdG9wID0gc3RvcDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkludGVydmFsLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0cmV0dXJuIGl0ZW0gPj0gdGhpcy5zdGFydCAmJiBpdGVtIDwgdGhpcy5zdG9wO1xufTtcblxuSW50ZXJ2YWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdGlmKHRoaXMuc3RhcnQ9PT10aGlzLnN0b3AtMSkge1xuXHRcdHJldHVybiB0aGlzLnN0YXJ0LnRvU3RyaW5nKCk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQudG9TdHJpbmcoKSArIFwiLi5cIiArICh0aGlzLnN0b3AtMSkudG9TdHJpbmcoKTtcblx0fVxufTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJ2YWwucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnN0b3AgLSB0aGlzLnN0YXJ0O1xuXHR9XG59KTtcblxuZnVuY3Rpb24gSW50ZXJ2YWxTZXQoKSB7XG5cdHRoaXMuaW50ZXJ2YWxzID0gbnVsbDtcblx0dGhpcy5yZWFkT25seSA9IGZhbHNlO1xufVxuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbih2KSB7XG5cdGlmICh0aGlzLmludGVydmFscyA9PT0gbnVsbCB8fCB0aGlzLmludGVydmFscy5sZW5ndGg9PT0wKSB7XG5cdFx0cmV0dXJuIFRva2VuLklOVkFMSURfVFlQRTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnZhbHNbMF0uc3RhcnQ7XG5cdH1cbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5hZGRPbmUgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMuYWRkSW50ZXJ2YWwobmV3IEludGVydmFsKHYsIHYgKyAxKSk7XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuYWRkUmFuZ2UgPSBmdW5jdGlvbihsLCBoKSB7XG5cdHRoaXMuYWRkSW50ZXJ2YWwobmV3IEludGVydmFsKGwsIGggKyAxKSk7XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuYWRkSW50ZXJ2YWwgPSBmdW5jdGlvbih2KSB7XG5cdGlmICh0aGlzLmludGVydmFscyA9PT0gbnVsbCkge1xuXHRcdHRoaXMuaW50ZXJ2YWxzID0gW107XG5cdFx0dGhpcy5pbnRlcnZhbHMucHVzaCh2KTtcblx0fSBlbHNlIHtcblx0XHQvLyBmaW5kIGluc2VydCBwb3Ncblx0XHRmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuaW50ZXJ2YWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHR2YXIgaSA9IHRoaXMuaW50ZXJ2YWxzW2tdO1xuXHRcdFx0Ly8gZGlzdGluY3QgcmFuZ2UgLT4gaW5zZXJ0XG5cdFx0XHRpZiAodi5zdG9wIDwgaS5zdGFydCkge1xuXHRcdFx0XHR0aGlzLmludGVydmFscy5zcGxpY2UoaywgMCwgdik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRpZ3VvdXMgcmFuZ2UgLT4gYWRqdXN0XG5cdFx0XHRlbHNlIGlmICh2LnN0b3AgPT09IGkuc3RhcnQpIHtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbHNba10uc3RhcnQgPSB2LnN0YXJ0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBvdmVybGFwcGluZyByYW5nZSAtPiBhZGp1c3QgYW5kIHJlZHVjZVxuXHRcdFx0ZWxzZSBpZiAodi5zdGFydCA8PSBpLnN0b3ApIHtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwoTWF0aC5taW4oaS5zdGFydCwgdi5zdGFydCksIE1hdGgubWF4KGkuc3RvcCwgdi5zdG9wKSk7XG5cdFx0XHRcdHRoaXMucmVkdWNlKGspO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGdyZWF0ZXIgdGhhbiBhbnkgZXhpc3Rpbmdcblx0XHR0aGlzLmludGVydmFscy5wdXNoKHYpO1xuXHR9XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuYWRkU2V0ID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0aWYgKG90aGVyLmludGVydmFscyAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgb3RoZXIuaW50ZXJ2YWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHR2YXIgaSA9IG90aGVyLmludGVydmFsc1trXTtcblx0XHRcdHRoaXMuYWRkSW50ZXJ2YWwobmV3IEludGVydmFsKGkuc3RhcnQsIGkuc3RvcCkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihrKSB7XG5cdC8vIG9ubHkgbmVlZCB0byByZWR1Y2UgaWYgayBpcyBub3QgdGhlIGxhc3Rcblx0aWYgKGsgPCB0aGlzLmludGVydmFsc2xlbmd0aCAtIDEpIHtcblx0XHR2YXIgbCA9IHRoaXMuaW50ZXJ2YWxzW2tdO1xuXHRcdHZhciByID0gdGhpcy5pbnRlcnZhbHNbayArIDFdO1xuXHRcdC8vIGlmIHIgY29udGFpbmVkIGluIGxcblx0XHRpZiAobC5zdG9wID49IHIuc3RvcCkge1xuXHRcdFx0dGhpcy5pbnRlcnZhbHMucG9wKGsgKyAxKTtcblx0XHRcdHRoaXMucmVkdWNlKGspO1xuXHRcdH0gZWxzZSBpZiAobC5zdG9wID49IHIuc3RhcnQpIHtcblx0XHRcdHRoaXMuaW50ZXJ2YWxzW2tdID0gbmV3IEludGVydmFsKGwuc3RhcnQsIHIuc3RvcCk7XG5cdFx0XHR0aGlzLmludGVydmFscy5wb3AoayArIDEpO1xuXHRcdH1cblx0fVxufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLmNvbXBsZW1lbnQgPSBmdW5jdGlvbihzdGFydCwgc3RvcCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICByZXN1bHQuYWRkSW50ZXJ2YWwobmV3IEludGVydmFsKHN0YXJ0LHN0b3ArMSkpO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5yZW1vdmVSYW5nZSh0aGlzLmludGVydmFsc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihpdGVtKSB7XG5cdGlmICh0aGlzLmludGVydmFscyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuaW50ZXJ2YWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRpZih0aGlzLmludGVydmFsc1trXS5jb250YWlucyhpdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJ2YWxTZXQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW4gPSAwO1xuXHRcdHRoaXMuaW50ZXJ2YWxzLm1hcChmdW5jdGlvbihpKSB7bGVuICs9IGkubGVuZ3RoO30pO1xuXHRcdHJldHVybiBsZW47XG5cdH1cbn0pO1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYodi5zdGFydD09PXYuc3RvcC0xKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT25lKHYuc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnZhbHMhPT1udWxsKSB7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgZm9yKHZhciBuPTA7IG48dGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5pbnRlcnZhbHNba107XG4gICAgICAgICAgICAvLyBpbnRlcnZhbHMgYXJlIG9yZGVyZWRcbiAgICAgICAgICAgIGlmICh2LnN0b3A8PWkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW5jbHVkaW5nIHJhbmdlLCBzcGxpdCBpdFxuICAgICAgICAgICAgZWxzZSBpZih2LnN0YXJ0Pmkuc3RhcnQgJiYgdi5zdG9wPGkuc3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW2tdID0gbmV3IEludGVydmFsKGkuc3RhcnQsIHYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbmV3IEludGVydmFsKHYuc3RvcCwgaS5zdG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFscy5zcGxpY2UoaywgMCwgeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGluY2x1ZGVkIHJhbmdlLCByZW1vdmUgaXRcbiAgICAgICAgICAgIGVsc2UgaWYodi5zdGFydDw9aS5zdGFydCAmJiB2LnN0b3A+PWkuc3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICBrID0gayAtIDE7IC8vIG5lZWQgYW5vdGhlciBwYXNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgbG93ZXIgYm91bmRhcnlcbiAgICAgICAgICAgIGVsc2UgaWYodi5zdGFydDxpLnN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsc1trXSA9IG5ldyBJbnRlcnZhbChpLnN0YXJ0LCB2LnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB1cHBlciBib3VuZGFyeVxuICAgICAgICAgICAgZWxzZSBpZih2LnN0b3A8aS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwodi5zdG9wLCBpLnN0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLnJlbW92ZU9uZSA9IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHRoaXMuaW50ZXJ2YWxzICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGsrKykge1xuXHRcdFx0dmFyIGkgPSB0aGlzLmludGVydmFsc1trXTtcblx0XHRcdC8vIGludGVydmFscyBpcyBvcmRlcmVkXG5cdFx0XHRpZiAodiA8IGkuc3RhcnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hlY2sgZm9yIHNpbmdsZSB2YWx1ZSByYW5nZVxuXHRcdFx0ZWxzZSBpZiAodiA9PT0gaS5zdGFydCAmJiB2ID09PSBpLnN0b3AgLSAxKSB7XG5cdFx0XHRcdHRoaXMuaW50ZXJ2YWxzLnNwbGljZShrLCAxKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hlY2sgZm9yIGxvd2VyIGJvdW5kYXJ5XG5cdFx0XHRlbHNlIGlmICh2ID09PSBpLnN0YXJ0KSB7XG5cdFx0XHRcdHRoaXMuaW50ZXJ2YWxzW2tdID0gbmV3IEludGVydmFsKGkuc3RhcnQgKyAxLCBpLnN0b3ApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjaGVjayBmb3IgdXBwZXIgYm91bmRhcnlcblx0XHRcdGVsc2UgaWYgKHYgPT09IGkuc3RvcCAtIDEpIHtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwoaS5zdGFydCwgaS5zdG9wIC0gMSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIHNwbGl0IGV4aXN0aW5nIHJhbmdlXG5cdFx0XHRlbHNlIGlmICh2IDwgaS5zdG9wIC0gMSkge1xuXHRcdFx0XHR2YXIgeCA9IG5ldyBJbnRlcnZhbChpLnN0YXJ0LCB2KTtcblx0XHRcdFx0aS5zdGFydCA9IHYgKyAxO1xuXHRcdFx0XHR0aGlzLmludGVydmFscy5zcGxpY2UoaywgMCwgeCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcywgZWxlbXNBcmVDaGFyKSB7XG5cdGxpdGVyYWxOYW1lcyA9IGxpdGVyYWxOYW1lcyB8fCBudWxsO1xuXHRzeW1ib2xpY05hbWVzID0gc3ltYm9saWNOYW1lcyB8fCBudWxsO1xuXHRlbGVtc0FyZUNoYXIgPSBlbGVtc0FyZUNoYXIgfHwgZmFsc2U7XG5cdGlmICh0aGlzLmludGVydmFscyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBcInt9XCI7XG5cdH0gZWxzZSBpZihsaXRlcmFsTmFtZXMhPT1udWxsIHx8IHN5bWJvbGljTmFtZXMhPT1udWxsKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9Ub2tlblN0cmluZyhsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpO1xuXHR9IGVsc2UgaWYoZWxlbXNBcmVDaGFyKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9DaGFyU3RyaW5nKCk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMudG9JbmRleFN0cmluZygpO1xuXHR9XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUudG9DaGFyU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBuYW1lcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHYgPSB0aGlzLmludGVydmFsc1tpXTtcblx0XHRpZih2LnN0b3A9PT12LnN0YXJ0KzEpIHtcblx0XHRcdGlmICggdi5zdGFydD09PVRva2VuLkVPRiApIHtcblx0XHRcdFx0bmFtZXMucHVzaChcIjxFT0Y+XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmFtZXMucHVzaChcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodi5zdGFydCkgKyBcIidcIik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5hbWVzLnB1c2goXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHYuc3RhcnQpICsgXCInLi4nXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHYuc3RvcC0xKSArIFwiJ1wiKTtcblx0XHR9XG5cdH1cblx0aWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcblx0XHRyZXR1cm4gXCJ7XCIgKyBuYW1lcy5qb2luKFwiLCBcIikgKyBcIn1cIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmFtZXNbMF07XG5cdH1cbn07XG5cblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLnRvSW5kZXhTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIG5hbWVzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdiA9IHRoaXMuaW50ZXJ2YWxzW2ldO1xuXHRcdGlmKHYuc3RvcD09PXYuc3RhcnQrMSkge1xuXHRcdFx0aWYgKCB2LnN0YXJ0PT09VG9rZW4uRU9GICkge1xuXHRcdFx0XHRuYW1lcy5wdXNoKFwiPEVPRj5cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYW1lcy5wdXNoKHYuc3RhcnQudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5hbWVzLnB1c2godi5zdGFydC50b1N0cmluZygpICsgXCIuLlwiICsgKHYuc3RvcC0xKS50b1N0cmluZygpKTtcblx0XHR9XG5cdH1cblx0aWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcblx0XHRyZXR1cm4gXCJ7XCIgKyBuYW1lcy5qb2luKFwiLCBcIikgKyBcIn1cIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmFtZXNbMF07XG5cdH1cbn07XG5cblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLnRvVG9rZW5TdHJpbmcgPSBmdW5jdGlvbihsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpIHtcblx0dmFyIG5hbWVzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdiA9IHRoaXMuaW50ZXJ2YWxzW2ldO1xuXHRcdGZvciAodmFyIGogPSB2LnN0YXJ0OyBqIDwgdi5zdG9wOyBqKyspIHtcblx0XHRcdG5hbWVzLnB1c2godGhpcy5lbGVtZW50TmFtZShsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMsIGopKTtcblx0XHR9XG5cdH1cblx0aWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcblx0XHRyZXR1cm4gXCJ7XCIgKyBuYW1lcy5qb2luKFwiLCBcIikgKyBcIn1cIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmFtZXNbMF07XG5cdH1cbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5lbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcywgYSkge1xuXHRpZiAoYSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0cmV0dXJuIFwiPEVPRj5cIjtcblx0fSBlbHNlIGlmIChhID09PSBUb2tlbi5FUFNJTE9OKSB7XG5cdFx0cmV0dXJuIFwiPEVQU0lMT04+XCI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGxpdGVyYWxOYW1lc1thXSB8fCBzeW1ib2xpY05hbWVzW2FdO1xuXHR9XG59O1xuXG5leHBvcnRzLkludGVydmFsID0gSW50ZXJ2YWw7XG5leHBvcnRzLkludGVydmFsU2V0ID0gSW50ZXJ2YWxTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvSW50ZXJ2YWxTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gVGhlIGJhc2ljIG5vdGlvbiBvZiBhIHRyZWUgaGFzIGEgcGFyZW50LCBhIHBheWxvYWQsIGFuZCBhIGxpc3Qgb2YgY2hpbGRyZW4uXG4vLyAgSXQgaXMgdGhlIG1vc3QgYWJzdHJhY3QgaW50ZXJmYWNlIGZvciBhbGwgdGhlIHRyZWVzIHVzZWQgYnkgQU5UTFIuXG4vLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIElOVkFMSURfSU5URVJWQUwgPSBuZXcgSW50ZXJ2YWwoLTEsIC0yKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL1V0aWxzLmpzJyk7XG5cblxuZnVuY3Rpb24gVHJlZSgpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIFN5bnRheFRyZWUoKSB7XG5cdFRyZWUuY2FsbCh0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cblN5bnRheFRyZWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmVlLnByb3RvdHlwZSk7XG5TeW50YXhUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bnRheFRyZWU7XG5cbmZ1bmN0aW9uIFBhcnNlVHJlZSgpIHtcblx0U3ludGF4VHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VUcmVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3ludGF4VHJlZS5wcm90b3R5cGUpO1xuUGFyc2VUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNlVHJlZTtcblxuZnVuY3Rpb24gUnVsZU5vZGUoKSB7XG5cdFBhcnNlVHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUnVsZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJzZVRyZWUucHJvdG90eXBlKTtcblJ1bGVOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJ1bGVOb2RlO1xuXG5mdW5jdGlvbiBUZXJtaW5hbE5vZGUoKSB7XG5cdFBhcnNlVHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuVGVybWluYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyc2VUcmVlLnByb3RvdHlwZSk7XG5UZXJtaW5hbE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVybWluYWxOb2RlO1xuXG5mdW5jdGlvbiBFcnJvck5vZGUoKSB7XG5cdFRlcm1pbmFsTm9kZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuRXJyb3JOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGVybWluYWxOb2RlLnByb3RvdHlwZSk7XG5FcnJvck5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXJyb3JOb2RlO1xuXG5mdW5jdGlvbiBQYXJzZVRyZWVWaXNpdG9yKCkge1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VUcmVlVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihjdHgpIHtcbiBcdGlmIChBcnJheS5pc0FycmF5KGN0eCkpIHtcblx0XHRyZXR1cm4gY3R4Lm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGN0eC5hY2NlcHQodGhpcyk7XG5cdH1cbn07XG5cblBhcnNlVHJlZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgcmV0dXJuIHRoaXMudmlzaXQoY3R4LmNoaWxkcmVuKTtcbn1cblxuUGFyc2VUcmVlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXJtaW5hbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbn07XG5cblBhcnNlVHJlZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXJyb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuXG5mdW5jdGlvbiBQYXJzZVRyZWVMaXN0ZW5lcigpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cblBhcnNlVHJlZUxpc3RlbmVyLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLnZpc2l0RXJyb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLmVudGVyRXZlcnlSdWxlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLmV4aXRFdmVyeVJ1bGUgPSBmdW5jdGlvbihub2RlKSB7XG59O1xuXG5mdW5jdGlvbiBUZXJtaW5hbE5vZGVJbXBsKHN5bWJvbCkge1xuXHRUZXJtaW5hbE5vZGUuY2FsbCh0aGlzKTtcblx0dGhpcy5wYXJlbnRDdHggPSBudWxsO1xuXHR0aGlzLnN5bWJvbCA9IHN5bWJvbDtcblx0cmV0dXJuIHRoaXM7XG59XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXJtaW5hbE5vZGUucHJvdG90eXBlKTtcblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVybWluYWxOb2RlSW1wbDtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbihpKSB7XG5cdHJldHVybiBudWxsO1xufTtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUuZ2V0U3ltYm9sID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbDtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wYXJlbnRDdHg7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5nZXRQYXlsb2FkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbDtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldFNvdXJjZUludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnN5bWJvbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBJTlZBTElEX0lOVEVSVkFMO1xuXHR9XG5cdHZhciB0b2tlbkluZGV4ID0gdGhpcy5zeW1ib2wudG9rZW5JbmRleDtcblx0cmV0dXJuIG5ldyBJbnRlcnZhbCh0b2tlbkluZGV4LCB0b2tlbkluZGV4KTtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIDA7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XG5cdHJldHVybiB2aXNpdG9yLnZpc2l0VGVybWluYWwodGhpcyk7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbC50ZXh0O1xufTtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuc3ltYm9sLnR5cGUgPT09IFRva2VuLkVPRikge1xuXHRcdHJldHVybiBcIjxFT0Y+XCI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuc3ltYm9sLnRleHQ7XG5cdH1cbn07XG5cbi8vIFJlcHJlc2VudHMgYSB0b2tlbiB0aGF0IHdhcyBjb25zdW1lZCBkdXJpbmcgcmVzeW5jaHJvbml6YXRpb25cbi8vIHJhdGhlciB0aGFuIGR1cmluZyBhIHZhbGlkIG1hdGNoIG9wZXJhdGlvbi4gRm9yIGV4YW1wbGUsXG4vLyB3ZSB3aWxsIGNyZWF0ZSB0aGlzIGtpbmQgb2YgYSBub2RlIGR1cmluZyBzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uXG4vLyBhbmQgZGVsZXRpb24gYXMgd2VsbCBhcyBkdXJpbmcgXCJjb25zdW1lIHVudGlsIGVycm9yIHJlY292ZXJ5IHNldFwiXG4vLyB1cG9uIG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBleGNlcHRpb25zLlxuXG5mdW5jdGlvbiBFcnJvck5vZGVJbXBsKHRva2VuKSB7XG5cdFRlcm1pbmFsTm9kZUltcGwuY2FsbCh0aGlzLCB0b2tlbik7XG5cdHJldHVybiB0aGlzO1xufVxuXG5FcnJvck5vZGVJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUpO1xuRXJyb3JOb2RlSW1wbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcnJvck5vZGVJbXBsO1xuXG5FcnJvck5vZGVJbXBsLnByb3RvdHlwZS5pc0Vycm9yTm9kZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkVycm9yTm9kZUltcGwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcblx0cmV0dXJuIHZpc2l0b3IudmlzaXRFcnJvck5vZGUodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBQYXJzZVRyZWVXYWxrZXIoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5QYXJzZVRyZWVXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbihsaXN0ZW5lciwgdCkge1xuXHR2YXIgZXJyb3JOb2RlID0gdCBpbnN0YW5jZW9mIEVycm9yTm9kZSB8fFxuXHRcdFx0KHQuaXNFcnJvck5vZGUgIT09IHVuZGVmaW5lZCAmJiB0LmlzRXJyb3JOb2RlKCkpO1xuXHRpZiAoZXJyb3JOb2RlKSB7XG5cdFx0bGlzdGVuZXIudmlzaXRFcnJvck5vZGUodCk7XG5cdH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuXHRcdGxpc3RlbmVyLnZpc2l0VGVybWluYWwodCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5lbnRlclJ1bGUobGlzdGVuZXIsIHQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdC5nZXRDaGlsZENvdW50KCk7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gdC5nZXRDaGlsZChpKTtcblx0XHRcdHRoaXMud2FsayhsaXN0ZW5lciwgY2hpbGQpO1xuXHRcdH1cblx0XHR0aGlzLmV4aXRSdWxlKGxpc3RlbmVyLCB0KTtcblx0fVxufTtcbi8vXG4vLyBUaGUgZGlzY292ZXJ5IG9mIGEgcnVsZSBub2RlLCBpbnZvbHZlcyBzZW5kaW5nIHR3byBldmVudHM6IHRoZSBnZW5lcmljXG4vLyB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIvL2VudGVyRXZlcnlSdWxlfSBhbmQgYVxuLy8ge0BsaW5rIFJ1bGVDb250ZXh0fS1zcGVjaWZpYyBldmVudC4gRmlyc3Qgd2UgdHJpZ2dlciB0aGUgZ2VuZXJpYyBhbmQgdGhlblxuLy8gdGhlIHJ1bGUgc3BlY2lmaWMuIFdlIHRvIHRoZW0gaW4gcmV2ZXJzZSBvcmRlciB1cG9uIGZpbmlzaGluZyB0aGUgbm9kZS5cbi8vXG5QYXJzZVRyZWVXYWxrZXIucHJvdG90eXBlLmVudGVyUnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyLCByKSB7XG5cdHZhciBjdHggPSByLmdldFJ1bGVDb250ZXh0KCk7XG5cdGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKGN0eCk7XG5cdGN0eC5lbnRlclJ1bGUobGlzdGVuZXIpO1xufTtcblxuUGFyc2VUcmVlV2Fsa2VyLnByb3RvdHlwZS5leGl0UnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyLCByKSB7XG5cdHZhciBjdHggPSByLmdldFJ1bGVDb250ZXh0KCk7XG5cdGN0eC5leGl0UnVsZShsaXN0ZW5lcik7XG5cdGxpc3RlbmVyLmV4aXRFdmVyeVJ1bGUoY3R4KTtcbn07XG5cblBhcnNlVHJlZVdhbGtlci5ERUZBVUxUID0gbmV3IFBhcnNlVHJlZVdhbGtlcigpO1xuXG5leHBvcnRzLlJ1bGVOb2RlID0gUnVsZU5vZGU7XG5leHBvcnRzLkVycm9yTm9kZSA9IEVycm9yTm9kZTtcbmV4cG9ydHMuVGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlO1xuZXhwb3J0cy5FcnJvck5vZGVJbXBsID0gRXJyb3JOb2RlSW1wbDtcbmV4cG9ydHMuVGVybWluYWxOb2RlSW1wbCA9IFRlcm1pbmFsTm9kZUltcGw7XG5leHBvcnRzLlBhcnNlVHJlZUxpc3RlbmVyID0gUGFyc2VUcmVlTGlzdGVuZXI7XG5leHBvcnRzLlBhcnNlVHJlZVZpc2l0b3IgPSBQYXJzZVRyZWVWaXNpdG9yO1xuZXhwb3J0cy5QYXJzZVRyZWVXYWxrZXIgPSBQYXJzZVRyZWVXYWxrZXI7XG5leHBvcnRzLklOVkFMSURfSU5URVJWQUwgPSBJTlZBTElEX0lOVEVSVkFMO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L3RyZWUvVHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG4vLyBUaGUgZm9sbG93aW5nIGltYWdlcyBzaG93IHRoZSByZWxhdGlvbiBvZiBzdGF0ZXMgYW5kXG4vLyB7QGxpbmsgQVROU3RhdGUvL3RyYW5zaXRpb25zfSBmb3IgdmFyaW91cyBncmFtbWFyIGNvbnN0cnVjdHMuXG4vL1xuLy8gPHVsPlxuLy9cbi8vIDxsaT5Tb2xpZCBlZGdlcyBtYXJrZWQgd2l0aCBhbiAmLy8wOTQ5OyBpbmRpY2F0ZSBhIHJlcXVpcmVkXG4vLyB7QGxpbmsgRXBzaWxvblRyYW5zaXRpb259LjwvbGk+XG4vL1xuLy8gPGxpPkRhc2hlZCBlZGdlcyBpbmRpY2F0ZSBsb2NhdGlvbnMgd2hlcmUgYW55IHRyYW5zaXRpb24gZGVyaXZlZCBmcm9tXG4vLyB7QGxpbmsgVHJhbnNpdGlvbn0gbWlnaHQgYXBwZWFyLjwvbGk+XG4vL1xuLy8gPGxpPkRhc2hlZCBub2RlcyBhcmUgcGxhY2UgaG9sZGVycyBmb3IgZWl0aGVyIGEgc2VxdWVuY2Ugb2YgbGlua2VkXG4vLyB7QGxpbmsgQmFzaWNTdGF0ZX0gc3RhdGVzIG9yIHRoZSBpbmNsdXNpb24gb2YgYSBibG9jayByZXByZXNlbnRpbmcgYSBuZXN0ZWRcbi8vIGNvbnN0cnVjdCBpbiBvbmUgb2YgdGhlIGZvcm1zIGJlbG93LjwvbGk+XG4vL1xuLy8gPGxpPk5vZGVzIHNob3dpbmcgbXVsdGlwbGUgb3V0Z29pbmcgYWx0ZXJuYXRpdmVzIHdpdGggYSB7QGNvZGUgLi4ufSBzdXBwb3J0XG4vLyBhbnkgbnVtYmVyIG9mIGFsdGVybmF0aXZlcyAob25lIG9yIG1vcmUpLiBOb2RlcyB3aXRob3V0IHRoZSB7QGNvZGUgLi4ufSBvbmx5XG4vLyBzdXBwb3J0IHRoZSBleGFjdCBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIHNob3duIGluIHRoZSBkaWFncmFtLjwvbGk+XG4vL1xuLy8gPC91bD5cbi8vXG4vLyA8aDI+QmFzaWMgQmxvY2tzPC9oMj5cbi8vXG4vLyA8aDM+UnVsZTwvaDM+XG4vL1xuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9SdWxlLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMz5CbG9jayBvZiAxIG9yIG1vcmUgYWx0ZXJuYXRpdmVzPC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0Jsb2NrLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMj5HcmVlZHkgTG9vcHM8L2gyPlxuLy9cbi8vIDxoMz5HcmVlZHkgQ2xvc3VyZToge0Bjb2RlICguLi4pKn08L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQ2xvc3VyZUdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cbi8vXG4vLyA8aDM+R3JlZWR5IFBvc2l0aXZlIENsb3N1cmU6IHtAY29kZSAoLi4uKSt9PC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1Bvc2l0aXZlQ2xvc3VyZUdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cbi8vXG4vLyA8aDM+R3JlZWR5IE9wdGlvbmFsOiB7QGNvZGUgKC4uLik/fTwvaDM+XG4vL1xuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9PcHRpb25hbEdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cbi8vXG4vLyA8aDI+Tm9uLUdyZWVkeSBMb29wczwvaDI+XG4vL1xuLy8gPGgzPk5vbi1HcmVlZHkgQ2xvc3VyZToge0Bjb2RlICguLi4pKj99PC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0Nsb3N1cmVOb25HcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XG4vL1xuLy8gPGgzPk5vbi1HcmVlZHkgUG9zaXRpdmUgQ2xvc3VyZToge0Bjb2RlICguLi4pKz99PC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1Bvc2l0aXZlQ2xvc3VyZU5vbkdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cbi8vXG4vLyA8aDM+Tm9uLUdyZWVkeSBPcHRpb25hbDoge0Bjb2RlICguLi4pPz99PC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL09wdGlvbmFsTm9uR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cblxudmFyIElOSVRJQUxfTlVNX1RSQU5TSVRJT05TID0gNDtcblxuZnVuY3Rpb24gQVROU3RhdGUoKSB7XG4gICAgLy8gV2hpY2ggQVROIGFyZSB3ZSBpbj9cbiAgICB0aGlzLmF0biA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZU51bWJlciA9IEFUTlN0YXRlLklOVkFMSURfU1RBVEVfTlVNQkVSO1xuICAgIHRoaXMuc3RhdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IDA7IC8vIGF0IHJ1bnRpbWUsIHdlIGRvbid0IGhhdmUgUnVsZSBvYmplY3RzXG4gICAgdGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgLy8gVHJhY2sgdGhlIHRyYW5zaXRpb25zIGVtYW5hdGluZyBmcm9tIHRoaXMgQVROIHN0YXRlLlxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBbXTtcbiAgICAvLyBVc2VkIHRvIGNhY2hlIGxvb2thaGVhZCBkdXJpbmcgcGFyc2luZywgbm90IHVzZWQgZHVyaW5nIGNvbnN0cnVjdGlvblxuICAgIHRoaXMubmV4dFRva2VuV2l0aGluUnVsZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIGNvbnN0YW50cyBmb3Igc2VyaWFsaXphdGlvblxuQVROU3RhdGUuSU5WQUxJRF9UWVBFID0gMDtcbkFUTlN0YXRlLkJBU0lDID0gMTtcbkFUTlN0YXRlLlJVTEVfU1RBUlQgPSAyO1xuQVROU3RhdGUuQkxPQ0tfU1RBUlQgPSAzO1xuQVROU3RhdGUuUExVU19CTE9DS19TVEFSVCA9IDQ7XG5BVE5TdGF0ZS5TVEFSX0JMT0NLX1NUQVJUID0gNTtcbkFUTlN0YXRlLlRPS0VOX1NUQVJUID0gNjtcbkFUTlN0YXRlLlJVTEVfU1RPUCA9IDc7XG5BVE5TdGF0ZS5CTE9DS19FTkQgPSA4O1xuQVROU3RhdGUuU1RBUl9MT09QX0JBQ0sgPSA5O1xuQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZID0gMTA7XG5BVE5TdGF0ZS5QTFVTX0xPT1BfQkFDSyA9IDExO1xuQVROU3RhdGUuTE9PUF9FTkQgPSAxMjtcblxuQVROU3RhdGUuc2VyaWFsaXphdGlvbk5hbWVzID0gW1xuICAgICAgICAgICAgXCJJTlZBTElEXCIsXG4gICAgICAgICAgICBcIkJBU0lDXCIsXG4gICAgICAgICAgICBcIlJVTEVfU1RBUlRcIixcbiAgICAgICAgICAgIFwiQkxPQ0tfU1RBUlRcIixcbiAgICAgICAgICAgIFwiUExVU19CTE9DS19TVEFSVFwiLFxuICAgICAgICAgICAgXCJTVEFSX0JMT0NLX1NUQVJUXCIsXG4gICAgICAgICAgICBcIlRPS0VOX1NUQVJUXCIsXG4gICAgICAgICAgICBcIlJVTEVfU1RPUFwiLFxuICAgICAgICAgICAgXCJCTE9DS19FTkRcIixcbiAgICAgICAgICAgIFwiU1RBUl9MT09QX0JBQ0tcIixcbiAgICAgICAgICAgIFwiU1RBUl9MT09QX0VOVFJZXCIsXG4gICAgICAgICAgICBcIlBMVVNfTE9PUF9CQUNLXCIsXG4gICAgICAgICAgICBcIkxPT1BfRU5EXCIgXTtcblxuQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVIgPSAtMTtcblxuQVROU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN0YXRlTnVtYmVyO1xufTtcblxuQVROU3RhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQVROU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1iZXI9PT1vdGhlci5zdGF0ZU51bWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuQVROU3RhdGUucHJvdG90eXBlLmlzTm9uR3JlZWR5RXhpdFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5BVE5TdGF0ZS5wcm90b3R5cGUuYWRkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zLCBpbmRleCkge1xuXHRpZihpbmRleD09PXVuZGVmaW5lZCkge1xuXHRcdGluZGV4ID0gLTE7XG5cdH1cbiAgICBpZiAodGhpcy50cmFuc2l0aW9ucy5sZW5ndGg9PT0wKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IHRyYW5zLmlzRXBzaWxvbjtcbiAgICB9IGVsc2UgaWYodGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zICE9PSB0cmFucy5pc0Vwc2lsb24pIHtcbiAgICAgICAgdGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleD09PS0xKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMucHVzaCh0cmFucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucy5zcGxpY2UoaW5kZXgsIDEsIHRyYW5zKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBCYXNpY1N0YXRlKCkge1xuXHRBVE5TdGF0ZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuQkFTSUM7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkJhc2ljU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TdGF0ZS5wcm90b3R5cGUpO1xuQmFzaWNTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNpY1N0YXRlO1xuXG5cbmZ1bmN0aW9uIERlY2lzaW9uU3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kZWNpc2lvbiA9IC0xO1xuICAgIHRoaXMubm9uR3JlZWR5ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkRlY2lzaW9uU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TdGF0ZS5wcm90b3R5cGUpO1xuRGVjaXNpb25TdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWNpc2lvblN0YXRlO1xuXG5cbi8vICBUaGUgc3RhcnQgb2YgYSByZWd1bGFyIHtAY29kZSAoLi4uKX0gYmxvY2suXG5mdW5jdGlvbiBCbG9ja1N0YXJ0U3RhdGUoKSB7XG5cdERlY2lzaW9uU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5lbmRTdGF0ZSA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufVxuXG5CbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWNpc2lvblN0YXRlLnByb3RvdHlwZSk7XG5CbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvY2tTdGFydFN0YXRlO1xuXG5cbmZ1bmN0aW9uIEJhc2ljQmxvY2tTdGFydFN0YXRlKCkge1xuXHRCbG9ja1N0YXJ0U3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5CTE9DS19TVEFSVDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkJhc2ljQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSk7XG5CYXNpY0Jsb2NrU3RhcnRTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNpY0Jsb2NrU3RhcnRTdGF0ZTtcblxuXG4vLyBUZXJtaW5hbCBub2RlIG9mIGEgc2ltcGxlIHtAY29kZSAoYXxifGMpfSBibG9jay5cbmZ1bmN0aW9uIEJsb2NrRW5kU3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuQkxPQ0tfRU5EO1xuICAgIHRoaXMuc3RhcnRTdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkJsb2NrRW5kU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TdGF0ZS5wcm90b3R5cGUpO1xuQmxvY2tFbmRTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9ja0VuZFN0YXRlO1xuXG5cbi8vIFRoZSBsYXN0IG5vZGUgaW4gdGhlIEFUTiBmb3IgYSBydWxlLCB1bmxlc3MgdGhhdCBydWxlIGlzIHRoZSBzdGFydCBzeW1ib2wuXG4vLyAgSW4gdGhhdCBjYXNlLCB0aGVyZSBpcyBvbmUgdHJhbnNpdGlvbiB0byBFT0YuIExhdGVyLCB3ZSBtaWdodCBlbmNvZGVcbi8vICByZWZlcmVuY2VzIHRvIGFsbCBjYWxscyB0byB0aGlzIHJ1bGUgdG8gY29tcHV0ZSBGT0xMT1cgc2V0cyBmb3Jcbi8vICBlcnJvciBoYW5kbGluZy5cbi8vXG5mdW5jdGlvbiBSdWxlU3RvcFN0YXRlKCkge1xuXHRBVE5TdGF0ZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUlVMRV9TVE9QO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5SdWxlU3RvcFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROU3RhdGUucHJvdG90eXBlKTtcblJ1bGVTdG9wU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVsZVN0b3BTdGF0ZTtcblxuZnVuY3Rpb24gUnVsZVN0YXJ0U3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUlVMRV9TVEFSVDtcblx0dGhpcy5zdG9wU3RhdGUgPSBudWxsO1xuXHR0aGlzLmlzUHJlY2VkZW5jZVJ1bGUgPSBmYWxzZTtcblx0cmV0dXJuIHRoaXM7XG59XG5cblJ1bGVTdGFydFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROU3RhdGUucHJvdG90eXBlKTtcblJ1bGVTdGFydFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJ1bGVTdGFydFN0YXRlO1xuXG4vLyBEZWNpc2lvbiBzdGF0ZSBmb3Ige0Bjb2RlIEErfSBhbmQge0Bjb2RlIChBfEIpK30uICBJdCBoYXMgdHdvIHRyYW5zaXRpb25zOlxuLy8gIG9uZSB0byB0aGUgbG9vcCBiYWNrIHRvIHN0YXJ0IG9mIHRoZSBibG9jayBhbmQgb25lIHRvIGV4aXQuXG4vL1xuZnVuY3Rpb24gUGx1c0xvb3BiYWNrU3RhdGUoKSB7XG5cdERlY2lzaW9uU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5QTFVTX0xPT1BfQkFDSztcblx0cmV0dXJuIHRoaXM7XG59XG5cblBsdXNMb29wYmFja1N0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVjaXNpb25TdGF0ZS5wcm90b3R5cGUpO1xuUGx1c0xvb3BiYWNrU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGx1c0xvb3BiYWNrU3RhdGU7XG5cblxuLy8gU3RhcnQgb2Yge0Bjb2RlIChBfEJ8Li4uKSt9IGxvb3AuIFRlY2huaWNhbGx5IGEgZGVjaXNpb24gc3RhdGUsIGJ1dFxuLy8gIHdlIGRvbid0IHVzZSBmb3IgY29kZSBnZW5lcmF0aW9uOyBzb21lYm9keSBtaWdodCBuZWVkIGl0LCBzbyBJJ20gZGVmaW5pbmdcbi8vICBpdCBmb3IgY29tcGxldGVuZXNzLiBJbiByZWFsaXR5LCB0aGUge0BsaW5rIFBsdXNMb29wYmFja1N0YXRlfSBub2RlIGlzIHRoZVxuLy8gIHJlYWwgZGVjaXNpb24tbWFraW5nIG5vdGUgZm9yIHtAY29kZSBBK30uXG4vL1xuZnVuY3Rpb24gUGx1c0Jsb2NrU3RhcnRTdGF0ZSgpIHtcblx0QmxvY2tTdGFydFN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUExVU19CTE9DS19TVEFSVDtcbiAgICB0aGlzLmxvb3BCYWNrU3RhdGUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5QbHVzQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSk7XG5QbHVzQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdXNCbG9ja1N0YXJ0U3RhdGU7XG5cbi8vIFRoZSBibG9jayB0aGF0IGJlZ2lucyBhIGNsb3N1cmUgbG9vcC5cbmZ1bmN0aW9uIFN0YXJCbG9ja1N0YXJ0U3RhdGUoKSB7XG5cdEJsb2NrU3RhcnRTdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLlNUQVJfQkxPQ0tfU1RBUlQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5TdGFyQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZSk7XG5TdGFyQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXJCbG9ja1N0YXJ0U3RhdGU7XG5cblxuZnVuY3Rpb24gU3Rhckxvb3BiYWNrU3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuU1RBUl9MT09QX0JBQ0s7XG5cdHJldHVybiB0aGlzO1xufVxuXG5TdGFyTG9vcGJhY2tTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlN0YXRlLnByb3RvdHlwZSk7XG5TdGFyTG9vcGJhY2tTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFyTG9vcGJhY2tTdGF0ZTtcblxuXG5mdW5jdGlvbiBTdGFyTG9vcEVudHJ5U3RhdGUoKSB7XG5cdERlY2lzaW9uU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5TVEFSX0xPT1BfRU5UUlk7XG4gICAgdGhpcy5sb29wQmFja1N0YXRlID0gbnVsbDtcbiAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBiZW5lZml0IGZyb20gYSBwcmVjZWRlbmNlIERGQSBkdXJpbmcgU0xMIGRlY2lzaW9uIG1ha2luZy5cbiAgICB0aGlzLmlzUHJlY2VkZW5jZURlY2lzaW9uID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuU3Rhckxvb3BFbnRyeVN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVjaXNpb25TdGF0ZS5wcm90b3R5cGUpO1xuU3Rhckxvb3BFbnRyeVN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXJMb29wRW50cnlTdGF0ZTtcblxuXG4vLyBNYXJrIHRoZSBlbmQgb2YgYSAqIG9yICsgbG9vcC5cbmZ1bmN0aW9uIExvb3BFbmRTdGF0ZSgpIHtcblx0QVROU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5MT09QX0VORDtcblx0dGhpcy5sb29wQmFja1N0YXRlID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkxvb3BFbmRTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlN0YXRlLnByb3RvdHlwZSk7XG5Mb29wRW5kU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9vcEVuZFN0YXRlO1xuXG5cbi8vIFRoZSBUb2tlbnMgcnVsZSBzdGFydCBzdGF0ZSBsaW5raW5nIHRvIGVhY2ggbGV4ZXIgcnVsZSBzdGFydCBzdGF0ZSAqL1xuZnVuY3Rpb24gVG9rZW5zU3RhcnRTdGF0ZSgpIHtcblx0RGVjaXNpb25TdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLlRPS0VOX1NUQVJUO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuVG9rZW5zU3RhcnRTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlY2lzaW9uU3RhdGUucHJvdG90eXBlKTtcblRva2Vuc1N0YXJ0U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9rZW5zU3RhcnRTdGF0ZTtcblxuZXhwb3J0cy5BVE5TdGF0ZSA9IEFUTlN0YXRlO1xuZXhwb3J0cy5CYXNpY1N0YXRlID0gQmFzaWNTdGF0ZTtcbmV4cG9ydHMuRGVjaXNpb25TdGF0ZSA9IERlY2lzaW9uU3RhdGU7XG5leHBvcnRzLkJsb2NrU3RhcnRTdGF0ZSA9IEJsb2NrU3RhcnRTdGF0ZTtcbmV4cG9ydHMuQmxvY2tFbmRTdGF0ZSA9IEJsb2NrRW5kU3RhdGU7XG5leHBvcnRzLkxvb3BFbmRTdGF0ZSA9IExvb3BFbmRTdGF0ZTtcbmV4cG9ydHMuUnVsZVN0YXJ0U3RhdGUgPSBSdWxlU3RhcnRTdGF0ZTtcbmV4cG9ydHMuUnVsZVN0b3BTdGF0ZSA9IFJ1bGVTdG9wU3RhdGU7XG5leHBvcnRzLlRva2Vuc1N0YXJ0U3RhdGUgPSBUb2tlbnNTdGFydFN0YXRlO1xuZXhwb3J0cy5QbHVzTG9vcGJhY2tTdGF0ZSA9IFBsdXNMb29wYmFja1N0YXRlO1xuZXhwb3J0cy5TdGFyTG9vcGJhY2tTdGF0ZSA9IFN0YXJMb29wYmFja1N0YXRlO1xuZXhwb3J0cy5TdGFyTG9vcEVudHJ5U3RhdGUgPSBTdGFyTG9vcEVudHJ5U3RhdGU7XG5leHBvcnRzLlBsdXNCbG9ja1N0YXJ0U3RhdGUgPSBQbHVzQmxvY2tTdGFydFN0YXRlO1xuZXhwb3J0cy5TdGFyQmxvY2tTdGFydFN0YXRlID0gU3RhckJsb2NrU3RhcnRTdGF0ZTtcbmV4cG9ydHMuQmFzaWNCbG9ja1N0YXJ0U3RhdGUgPSBCYXNpY0Jsb2NrU3RhcnRTdGF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vQVROU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbi8vIFRoZSByb290IG9mIHRoZSBBTlRMUiBleGNlcHRpb24gaGllcmFyY2h5LiBJbiBnZW5lcmFsLCBBTlRMUiB0cmFja3MganVzdFxuLy8gIDMga2luZHMgb2YgZXJyb3JzOiBwcmVkaWN0aW9uIGVycm9ycywgZmFpbGVkIHByZWRpY2F0ZSBlcnJvcnMsIGFuZFxuLy8gIG1pc21hdGNoZWQgaW5wdXQgZXJyb3JzLiBJbiBlYWNoIGNhc2UsIHRoZSBwYXJzZXIga25vd3Mgd2hlcmUgaXQgaXNcbi8vICBpbiB0aGUgaW5wdXQsIHdoZXJlIGl0IGlzIGluIHRoZSBBVE4sIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2ssXG4vLyAgYW5kIHdoYXQga2luZCBvZiBwcm9ibGVtIG9jY3VycmVkLlxuXG52YXIgUHJlZGljYXRlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vLi4vYXRuL1RyYW5zaXRpb24nKS5QcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG5mdW5jdGlvbiBSZWNvZ25pdGlvbkV4Y2VwdGlvbihwYXJhbXMpIHtcblx0RXJyb3IuY2FsbCh0aGlzKTtcblx0aWYgKCEhRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVjb2duaXRpb25FeGNlcHRpb24pO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuXHR9XG5cdHRoaXMubWVzc2FnZSA9IHBhcmFtcy5tZXNzYWdlO1xuICAgIHRoaXMucmVjb2duaXplciA9IHBhcmFtcy5yZWNvZ25pemVyO1xuICAgIHRoaXMuaW5wdXQgPSBwYXJhbXMuaW5wdXQ7XG4gICAgdGhpcy5jdHggPSBwYXJhbXMuY3R4O1xuICAgIC8vIFRoZSBjdXJyZW50IHtAbGluayBUb2tlbn0gd2hlbiBhbiBlcnJvciBvY2N1cnJlZC4gU2luY2Ugbm90IGFsbCBzdHJlYW1zXG4gICAgLy8gc3VwcG9ydCBhY2Nlc3Npbmcgc3ltYm9scyBieSBpbmRleCwgd2UgaGF2ZSB0byB0cmFjayB0aGUge0BsaW5rIFRva2VufVxuICAgIC8vIGluc3RhbmNlIGl0c2VsZi5cbiAgICB0aGlzLm9mZmVuZGluZ1Rva2VuID0gbnVsbDtcbiAgICAvLyBHZXQgdGhlIEFUTiBzdGF0ZSBudW1iZXIgdGhlIHBhcnNlciB3YXMgaW4gYXQgdGhlIHRpbWUgdGhlIGVycm9yXG4gICAgLy8gb2NjdXJyZWQuIEZvciB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259IGFuZFxuICAgIC8vIHtAbGluayBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9ufSBleGNlcHRpb25zLCB0aGlzIGlzIHRoZVxuICAgIC8vIHtAbGluayBEZWNpc2lvblN0YXRlfSBudW1iZXIuIEZvciBvdGhlcnMsIGl0IGlzIHRoZSBzdGF0ZSB3aG9zZSBvdXRnb2luZ1xuICAgIC8vIGVkZ2Ugd2UgY291bGRuJ3QgbWF0Y2guXG4gICAgdGhpcy5vZmZlbmRpbmdTdGF0ZSA9IC0xO1xuICAgIGlmICh0aGlzLnJlY29nbml6ZXIhPT1udWxsKSB7XG4gICAgICAgIHRoaXMub2ZmZW5kaW5nU3RhdGUgPSB0aGlzLnJlY29nbml6ZXIuc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5SZWNvZ25pdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5SZWNvZ25pdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWNvZ25pdGlvbkV4Y2VwdGlvbjtcblxuLy8gPHA+SWYgdGhlIHN0YXRlIG51bWJlciBpcyBub3Qga25vd24sIHRoaXMgbWV0aG9kIHJldHVybnMgLTEuPC9wPlxuXG4vL1xuLy8gR2V0cyB0aGUgc2V0IG9mIGlucHV0IHN5bWJvbHMgd2hpY2ggY291bGQgcG90ZW50aWFsbHkgZm9sbG93IHRoZVxuLy8gcHJldmlvdXNseSBtYXRjaGVkIHN5bWJvbCBhdCB0aGUgdGltZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuLy9cbi8vIDxwPklmIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zIGlzIG5vdCBrbm93biBhbmQgY291bGQgbm90IGJlIGNvbXB1dGVkLFxuLy8gdGhpcyBtZXRob2QgcmV0dXJucyB7QGNvZGUgbnVsbH0uPC9wPlxuLy9cbi8vIEByZXR1cm4gVGhlIHNldCBvZiB0b2tlbiB0eXBlcyB0aGF0IGNvdWxkIHBvdGVudGlhbGx5IGZvbGxvdyB0aGUgY3VycmVudFxuLy8gc3RhdGUgaW4gdGhlIEFUTiwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxuLy8gL1xuUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlLmdldEV4cGVjdGVkVG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVjb2duaXplciE9PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb2duaXplci5hdG4uZ2V0RXhwZWN0ZWRUb2tlbnModGhpcy5vZmZlbmRpbmdTdGF0ZSwgdGhpcy5jdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cblJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuXG5mdW5jdGlvbiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKGxleGVyLCBpbnB1dCwgc3RhcnRJbmRleCwgZGVhZEVuZENvbmZpZ3MpIHtcblx0UmVjb2duaXRpb25FeGNlcHRpb24uY2FsbCh0aGlzLCB7bWVzc2FnZTpcIlwiLCByZWNvZ25pemVyOmxleGVyLCBpbnB1dDppbnB1dCwgY3R4Om51bGx9KTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuZGVhZEVuZENvbmZpZ3MgPSBkZWFkRW5kQ29uZmlncztcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZSk7XG5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb247XG5cbkxleGVyTm9WaWFibGVBbHRFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN5bWJvbCA9IFwiXCI7XG4gICAgaWYgKHRoaXMuc3RhcnRJbmRleCA+PSAwICYmIHRoaXMuc3RhcnRJbmRleCA8IHRoaXMuaW5wdXQuc2l6ZSkge1xuICAgICAgICBzeW1ib2wgPSB0aGlzLmlucHV0LmdldFRleHQoKHRoaXMuc3RhcnRJbmRleCx0aGlzLnN0YXJ0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiICsgc3ltYm9sO1xufTtcblxuLy8gSW5kaWNhdGVzIHRoYXQgdGhlIHBhcnNlciBjb3VsZCBub3QgZGVjaWRlIHdoaWNoIG9mIHR3byBvciBtb3JlIHBhdGhzXG4vLyB0byB0YWtlIGJhc2VkIHVwb24gdGhlIHJlbWFpbmluZyBpbnB1dC4gSXQgdHJhY2tzIHRoZSBzdGFydGluZyB0b2tlblxuLy8gb2YgdGhlIG9mZmVuZGluZyBpbnB1dCBhbmQgYWxzbyBrbm93cyB3aGVyZSB0aGUgcGFyc2VyIHdhc1xuLy8gaW4gdGhlIHZhcmlvdXMgcGF0aHMgd2hlbiB0aGUgZXJyb3IuIFJlcG9ydGVkIGJ5IHJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUoKVxuLy9cbmZ1bmN0aW9uIE5vVmlhYmxlQWx0RXhjZXB0aW9uKHJlY29nbml6ZXIsIGlucHV0LCBzdGFydFRva2VuLCBvZmZlbmRpbmdUb2tlbiwgZGVhZEVuZENvbmZpZ3MsIGN0eCkge1xuXHRjdHggPSBjdHggfHwgcmVjb2duaXplci5fY3R4O1xuXHRvZmZlbmRpbmdUb2tlbiA9IG9mZmVuZGluZ1Rva2VuIHx8IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG5cdHN0YXJ0VG9rZW4gPSBzdGFydFRva2VuIHx8IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG5cdGlucHV0ID0gaW5wdXQgfHwgcmVjb2duaXplci5nZXRJbnB1dFN0cmVhbSgpO1xuXHRSZWNvZ25pdGlvbkV4Y2VwdGlvbi5jYWxsKHRoaXMsIHttZXNzYWdlOlwiXCIsIHJlY29nbml6ZXI6cmVjb2duaXplciwgaW5wdXQ6aW5wdXQsIGN0eDpjdHh9KTtcbiAgICAvLyBXaGljaCBjb25maWd1cmF0aW9ucyBkaWQgd2UgdHJ5IGF0IGlucHV0LmluZGV4KCkgdGhhdCBjb3VsZG4ndCBtYXRjaFxuXHQvLyBpbnB1dC5MVCgxKT8vL1xuICAgIHRoaXMuZGVhZEVuZENvbmZpZ3MgPSBkZWFkRW5kQ29uZmlncztcbiAgICAvLyBUaGUgdG9rZW4gb2JqZWN0IGF0IHRoZSBzdGFydCBpbmRleDsgdGhlIGlucHV0IHN0cmVhbSBtaWdodFxuICAgIC8vIG5vdCBiZSBidWZmZXJpbmcgdG9rZW5zIHNvIGdldCBhIHJlZmVyZW5jZSB0byBpdC4gKEF0IHRoZVxuICAgIC8vIHRpbWUgdGhlIGVycm9yIG9jY3VycmVkLCBvZiBjb3Vyc2UgdGhlIHN0cmVhbSBuZWVkcyB0byBrZWVwIGFcbiAgICAvLyBidWZmZXIgYWxsIG9mIHRoZSB0b2tlbnMgYnV0IGxhdGVyIHdlIG1pZ2h0IG5vdCBoYXZlIGFjY2VzcyB0byB0aG9zZS4pXG4gICAgdGhpcy5zdGFydFRva2VuID0gc3RhcnRUb2tlbjtcbiAgICB0aGlzLm9mZmVuZGluZ1Rva2VuID0gb2ZmZW5kaW5nVG9rZW47XG59XG5cbk5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlKTtcbk5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vVmlhYmxlQWx0RXhjZXB0aW9uO1xuXG4vLyBUaGlzIHNpZ25pZmllcyBhbnkga2luZCBvZiBtaXNtYXRjaGVkIGlucHV0IGV4Y2VwdGlvbnMgc3VjaCBhc1xuLy8gd2hlbiB0aGUgY3VycmVudCBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdG9rZW4uXG4vL1xuZnVuY3Rpb24gSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKSB7XG5cdFJlY29nbml0aW9uRXhjZXB0aW9uLmNhbGwodGhpcywge21lc3NhZ2U6XCJcIiwgcmVjb2duaXplcjpyZWNvZ25pemVyLCBpbnB1dDpyZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCksIGN0eDpyZWNvZ25pemVyLl9jdHh9KTtcbiAgICB0aGlzLm9mZmVuZGluZ1Rva2VuID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbn1cblxuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZSk7XG5JbnB1dE1pc21hdGNoRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElucHV0TWlzbWF0Y2hFeGNlcHRpb247XG5cbi8vIEEgc2VtYW50aWMgcHJlZGljYXRlIGZhaWxlZCBkdXJpbmcgdmFsaWRhdGlvbi4gVmFsaWRhdGlvbiBvZiBwcmVkaWNhdGVzXG4vLyBvY2N1cnMgd2hlbiBub3JtYWxseSBwYXJzaW5nIHRoZSBhbHRlcm5hdGl2ZSBqdXN0IGxpa2UgbWF0Y2hpbmcgYSB0b2tlbi5cbi8vIERpc2FtYmlndWF0aW5nIHByZWRpY2F0ZSBldmFsdWF0aW9uIG9jY3VycyB3aGVuIHdlIHRlc3QgYSBwcmVkaWNhdGUgZHVyaW5nXG4vLyBwcmVkaWN0aW9uLlxuXG5mdW5jdGlvbiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24ocmVjb2duaXplciwgcHJlZGljYXRlLCBtZXNzYWdlKSB7XG5cdFJlY29nbml0aW9uRXhjZXB0aW9uLmNhbGwodGhpcywge21lc3NhZ2U6dGhpcy5mb3JtYXRNZXNzYWdlKHByZWRpY2F0ZSxtZXNzYWdlIHx8IG51bGwpLCByZWNvZ25pemVyOnJlY29nbml6ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6cmVjb2duaXplci5nZXRJbnB1dFN0cmVhbSgpLCBjdHg6cmVjb2duaXplci5fY3R4fSk7XG4gICAgdmFyIHMgPSByZWNvZ25pemVyLl9pbnRlcnAuYXRuLnN0YXRlc1tyZWNvZ25pemVyLnN0YXRlXTtcbiAgICB2YXIgdHJhbnMgPSBzLnRyYW5zaXRpb25zWzBdO1xuICAgIGlmICh0cmFucyBpbnN0YW5jZW9mIFByZWRpY2F0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSB0cmFucy5ydWxlSW5kZXg7XG4gICAgICAgIHRoaXMucHJlZGljYXRlSW5kZXggPSB0cmFucy5wcmVkSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZUluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgdGhpcy5vZmZlbmRpbmdUb2tlbiA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZSk7XG5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uO1xuXG5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24ucHJvdG90eXBlLmZvcm1hdE1lc3NhZ2UgPSBmdW5jdGlvbihwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSAhPT1udWxsKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcImZhaWxlZCBwcmVkaWNhdGU6IHtcIiArIHByZWRpY2F0ZSArIFwifT9cIjtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbigpIHtcblx0RXJyb3IuY2FsbCh0aGlzKTtcblx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24pO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb247XG5cbmV4cG9ydHMuUmVjb2duaXRpb25FeGNlcHRpb24gPSBSZWNvZ25pdGlvbkV4Y2VwdGlvbjtcbmV4cG9ydHMuTm9WaWFibGVBbHRFeGNlcHRpb24gPSBOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb247XG5leHBvcnRzLklucHV0TWlzbWF0Y2hFeGNlcHRpb24gPSBJbnB1dE1pc21hdGNoRXhjZXB0aW9uO1xuZXhwb3J0cy5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24gPSBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb247XG5leHBvcnRzLlBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uID0gUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvZXJyb3IvRXJyb3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG52YXIgUnVsZUNvbnRleHQgPSByZXF1aXJlKCcuL1J1bGVDb250ZXh0JykuUnVsZUNvbnRleHQ7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vVXRpbHMnKS5IYXNoO1xuXG5mdW5jdGlvbiBQcmVkaWN0aW9uQ29udGV4dChjYWNoZWRIYXNoQ29kZSkge1xuXHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gY2FjaGVkSGFzaENvZGU7XG59XG5cbi8vIFJlcHJlc2VudHMge0Bjb2RlICR9IGluIGxvY2FsIGNvbnRleHQgcHJlZGljdGlvbiwgd2hpY2ggbWVhbnMgd2lsZGNhcmQuXG4vLyB7QGNvZGUvLyt4ID0vL30uXG4vLyAvXG5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWSA9IG51bGw7XG5cbi8vIFJlcHJlc2VudHMge0Bjb2RlICR9IGluIGFuIGFycmF5IGluIGZ1bGwgY29udGV4dCBtb2RlLCB3aGVuIHtAY29kZSAkfVxuLy8gZG9lc24ndCBtZWFuIHdpbGRjYXJkOiB7QGNvZGUgJCArIHggPSBbJCx4XX0uIEhlcmUsXG4vLyB7QGNvZGUgJH0gPSB7QGxpbmsgLy9FTVBUWV9SRVRVUk5fU1RBVEV9LlxuLy8gL1xuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFID0gMHg3RkZGRkZGRjtcblxuUHJlZGljdGlvbkNvbnRleHQuZ2xvYmFsTm9kZUNvdW50ID0gMTtcblByZWRpY3Rpb25Db250ZXh0LmlkID0gUHJlZGljdGlvbkNvbnRleHQuZ2xvYmFsTm9kZUNvdW50O1xuXG4vLyBTdG9yZXMgdGhlIGNvbXB1dGVkIGhhc2ggY29kZSBvZiB0aGlzIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dH0uIFRoZSBoYXNoXG4vLyBjb2RlIGlzIGNvbXB1dGVkIGluIHBhcnRzIHRvIG1hdGNoIHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlIGFsZ29yaXRobS5cbi8vXG4vLyA8cHJlPlxuLy8gcHJpdmF0ZSBpbnQgcmVmZXJlbmNlSGFzaENvZGUoKSB7XG4vLyBpbnQgaGFzaCA9IHtAbGluayBNdXJtdXJIYXNoLy9pbml0aWFsaXplIE11cm11ckhhc2guaW5pdGlhbGl6ZX0oe0BsaW5rXG4vLyAvL0lOSVRJQUxfSEFTSH0pO1xuLy9cbi8vIGZvciAoaW50IGkgPSAwOyBpICZsdDsge0BsaW5rIC8vc2l6ZSgpfTsgaSsrKSB7XG4vLyBoYXNoID0ge0BsaW5rIE11cm11ckhhc2gvL3VwZGF0ZSBNdXJtdXJIYXNoLnVwZGF0ZX0oaGFzaCwge0BsaW5rIC8vZ2V0UGFyZW50XG4vLyBnZXRQYXJlbnR9KGkpKTtcbi8vIH1cbi8vXG4vLyBmb3IgKGludCBpID0gMDsgaSAmbHQ7IHtAbGluayAvL3NpemUoKX07IGkrKykge1xuLy8gaGFzaCA9IHtAbGluayBNdXJtdXJIYXNoLy91cGRhdGUgTXVybXVySGFzaC51cGRhdGV9KGhhc2gsIHtAbGlua1xuLy8gLy9nZXRSZXR1cm5TdGF0ZSBnZXRSZXR1cm5TdGF0ZX0oaSkpO1xuLy8gfVxuLy9cbi8vIGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaC8vZmluaXNoIE11cm11ckhhc2guZmluaXNofShoYXNoLCAyLy8ge0BsaW5rXG4vLyAvL3NpemUoKX0pO1xuLy8gcmV0dXJuIGhhc2g7XG4vLyB9XG4vLyA8L3ByZT5cbi8vIC9cblxuLy8gVGhpcyBtZWFucyBvbmx5IHRoZSB7QGxpbmsgLy9FTVBUWX0gY29udGV4dCBpcyBpbiBzZXQuXG5QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcyA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG59O1xuXG5QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuaGFzRW1wdHlQYXRoID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmdldFJldHVyblN0YXRlKHRoaXMubGVuZ3RoIC0gMSkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURTtcbn07XG5cblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZTtcbn07XG5cblxuUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuY2FjaGVkSGFzaENvZGUpO1xufTtcbi8qXG5mdW5jdGlvbiBjYWxjdWxhdGVIYXNoU3RyaW5nKHBhcmVudCwgcmV0dXJuU3RhdGUpIHtcblx0cmV0dXJuIFwiXCIgKyBwYXJlbnQgKyByZXR1cm5TdGF0ZTtcbn1cbiovXG5cbi8vIFVzZWQgdG8gY2FjaGUge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RzLiBJdHMgdXNlZCBmb3IgdGhlIHNoYXJlZFxuLy8gY29udGV4dCBjYXNoIGFzc29jaWF0ZWQgd2l0aCBjb250ZXh0cyBpbiBERkEgc3RhdGVzLiBUaGlzIGNhY2hlXG4vLyBjYW4gYmUgdXNlZCBmb3IgYm90aCBsZXhlcnMgYW5kIHBhcnNlcnMuXG5cbmZ1bmN0aW9uIFByZWRpY3Rpb25Db250ZXh0Q2FjaGUoKSB7XG5cdHRoaXMuY2FjaGUgPSB7fTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBhIGNvbnRleHQgdG8gdGhlIGNhY2hlIGFuZCByZXR1cm4gaXQuIElmIHRoZSBjb250ZXh0IGFscmVhZHkgZXhpc3RzLFxuLy8gcmV0dXJuIHRoYXQgb25lIGluc3RlYWQgYW5kIGRvIG5vdCBhZGQgYSBuZXcgY29udGV4dCB0byB0aGUgY2FjaGUuXG4vLyBQcm90ZWN0IHNoYXJlZCBjYWNoZSBmcm9tIHVuc2FmZSB0aHJlYWQgYWNjZXNzLlxuLy9cblByZWRpY3Rpb25Db250ZXh0Q2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRpZiAoY3R4ID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcblx0fVxuXHR2YXIgZXhpc3RpbmcgPSB0aGlzLmNhY2hlW2N0eF0gfHwgbnVsbDtcblx0aWYgKGV4aXN0aW5nICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIGV4aXN0aW5nO1xuXHR9XG5cdHRoaXMuY2FjaGVbY3R4XSA9IGN0eDtcblx0cmV0dXJuIGN0eDtcbn07XG5cblByZWRpY3Rpb25Db250ZXh0Q2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRyZXR1cm4gdGhpcy5jYWNoZVtjdHhdIHx8IG51bGw7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJlZGljdGlvbkNvbnRleHRDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuXHR2YXIgaGFzaENvZGUgPSAwO1xuXHRpZihwYXJlbnQgIT09IG51bGwpIHtcblx0XHR2YXIgaGFzaCA9IG5ldyBIYXNoKCk7XG5cdFx0aGFzaC51cGRhdGUocGFyZW50LCByZXR1cm5TdGF0ZSk7XG4gICAgICAgIGhhc2hDb2RlID0gaGFzaC5maW5pc2goKTtcblx0fVxuXHRQcmVkaWN0aW9uQ29udGV4dC5jYWxsKHRoaXMsIGhhc2hDb2RlKTtcblx0dGhpcy5wYXJlbnRDdHggPSBwYXJlbnQ7XG5cdHRoaXMucmV0dXJuU3RhdGUgPSByZXR1cm5TdGF0ZTtcbn1cblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUpO1xuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnRydWN0b3IgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlID0gZnVuY3Rpb24ocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuXHRpZiAocmV0dXJuU3RhdGUgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSAmJiBwYXJlbnQgPT09IG51bGwpIHtcblx0XHQvLyBzb21lb25lIGNhbiBwYXNzIGluIHRoZSBiaXRzIG9mIGFuIGFycmF5IGN0eCB0aGF0IG1lYW4gJFxuXHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHBhcmVudCwgcmV0dXJuU3RhdGUpO1xuXHR9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG59KTtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnBhcmVudEN0eDtcbn07XG5cblNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5nZXRSZXR1cm5TdGF0ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnJldHVyblN0YXRlO1xufTtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSBpZiAodGhpcy5oYXNoQ29kZSgpICE9PSBvdGhlci5oYXNoQ29kZSgpKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBjYW4ndCBiZSBzYW1lIGlmIGhhc2ggaXMgZGlmZmVyZW50XG5cdH0gZWxzZSB7XG5cdFx0aWYodGhpcy5yZXR1cm5TdGF0ZSAhPT0gb3RoZXIucmV0dXJuU3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYodGhpcy5wYXJlbnRDdHg9PW51bGwpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIucGFyZW50Q3R4PT1udWxsXG5cdFx0ZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Q3R4LmVxdWFscyhvdGhlci5wYXJlbnRDdHgpO1xuXHR9XG59O1xuXG5TaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHVwID0gdGhpcy5wYXJlbnRDdHggPT09IG51bGwgPyBcIlwiIDogdGhpcy5wYXJlbnRDdHgudG9TdHJpbmcoKTtcblx0aWYgKHVwLmxlbmd0aCA9PT0gMCkge1xuXHRcdGlmICh0aGlzLnJldHVyblN0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUpIHtcblx0XHRcdHJldHVybiBcIiRcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiXCIgKyB0aGlzLnJldHVyblN0YXRlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCJcIiArIHRoaXMucmV0dXJuU3RhdGUgKyBcIiBcIiArIHVwO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBFbXB0eVByZWRpY3Rpb25Db250ZXh0KCkge1xuXHRTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jYWxsKHRoaXMsIG51bGwsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5FbXB0eVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlKTtcbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1wdHlQcmVkaWN0aW9uQ29udGV4dDtcblxuRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiBudWxsO1xufTtcblxuRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2V0UmV0dXJuU3RhdGUgPSBmdW5jdGlvbihpbmRleCkge1xuXHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZTtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdHJldHVybiB0aGlzID09PSBvdGhlcjtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIiRcIjtcbn07XG5cblByZWRpY3Rpb25Db250ZXh0LkVNUFRZID0gbmV3IEVtcHR5UHJlZGljdGlvbkNvbnRleHQoKTtcblxuZnVuY3Rpb24gQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCByZXR1cm5TdGF0ZXMpIHtcblx0Ly8gUGFyZW50IGNhbiBiZSBudWxsIG9ubHkgaWYgZnVsbCBjdHggbW9kZSBhbmQgd2UgbWFrZSBhbiBhcnJheVxuXHQvLyBmcm9tIHtAbGluayAvL0VNUFRZfSBhbmQgbm9uLWVtcHR5LiBXZSBtZXJnZSB7QGxpbmsgLy9FTVBUWX0gYnkgdXNpbmdcblx0Ly8gbnVsbCBwYXJlbnQgYW5kXG5cdC8vIHJldHVyblN0YXRlID09IHtAbGluayAvL0VNUFRZX1JFVFVSTl9TVEFURX0uXG5cdHZhciBoID0gbmV3IEhhc2goKTtcblx0aC51cGRhdGUocGFyZW50cywgcmV0dXJuU3RhdGVzKTtcblx0dmFyIGhhc2hDb2RlID0gaC5maW5pc2goKTtcblx0UHJlZGljdGlvbkNvbnRleHQuY2FsbCh0aGlzLCBoYXNoQ29kZSk7XG5cdHRoaXMucGFyZW50cyA9IHBhcmVudHM7XG5cdHRoaXMucmV0dXJuU3RhdGVzID0gcmV0dXJuU3RhdGVzO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSk7XG5BcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5UHJlZGljdGlvbkNvbnRleHQ7XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0Ly8gc2luY2UgRU1QVFlfUkVUVVJOX1NUQVRFIGNhbiBvbmx5IGFwcGVhciBpbiB0aGUgbGFzdCBwb3NpdGlvbiwgd2Vcblx0Ly8gZG9uJ3QgbmVlZCB0byB2ZXJpZnkgdGhhdCBzaXplPT0xXG5cdHJldHVybiB0aGlzLnJldHVyblN0YXRlc1swXSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlcy5sZW5ndGg7XG5cdH1cbn0pO1xuXG5BcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRyZXR1cm4gdGhpcy5wYXJlbnRzW2luZGV4XTtcbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFJldHVyblN0YXRlID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0cmV0dXJuIHRoaXMucmV0dXJuU3RhdGVzW2luZGV4XTtcbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBcnJheVByZWRpY3Rpb25Db250ZXh0KSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG90aGVyLmhhc2hDb2RlKCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIGNhbid0IGJlIHNhbWUgaWYgaGFzaCBpcyBkaWZmZXJlbnRcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXMgPT09IG90aGVyLnJldHVyblN0YXRlcyAmJlxuXHRcdFx0XHR0aGlzLnBhcmVudHMgPT09IG90aGVyLnBhcmVudHM7XG5cdH1cbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmlzRW1wdHkoKSkge1xuXHRcdHJldHVybiBcIltdXCI7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHMgPSBcIltcIjtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmV0dXJuU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0cyA9IHMgKyBcIiwgXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5yZXR1cm5TdGF0ZXNbaV0gPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuXHRcdFx0XHRzID0gcyArIFwiJFwiO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHMgPSBzICsgdGhpcy5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHRpZiAodGhpcy5wYXJlbnRzW2ldICE9PSBudWxsKSB7XG5cdFx0XHRcdHMgPSBzICsgXCIgXCIgKyB0aGlzLnBhcmVudHNbaV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcyArIFwibnVsbFwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcyArIFwiXVwiO1xuXHR9XG59O1xuXG4vLyBDb252ZXJ0IGEge0BsaW5rIFJ1bGVDb250ZXh0fSB0cmVlIHRvIGEge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBncmFwaC5cbi8vIFJldHVybiB7QGxpbmsgLy9FTVBUWX0gaWYge0Bjb2RlIG91dGVyQ29udGV4dH0gaXMgZW1wdHkgb3IgbnVsbC5cbi8vIC9cbmZ1bmN0aW9uIHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0KGF0biwgb3V0ZXJDb250ZXh0KSB7XG5cdGlmIChvdXRlckNvbnRleHQgPT09IHVuZGVmaW5lZCB8fCBvdXRlckNvbnRleHQgPT09IG51bGwpIHtcblx0XHRvdXRlckNvbnRleHQgPSBSdWxlQ29udGV4dC5FTVBUWTtcblx0fVxuXHQvLyBpZiB3ZSBhcmUgaW4gUnVsZUNvbnRleHQgb2Ygc3RhcnQgcnVsZSwgcywgdGhlbiBQcmVkaWN0aW9uQ29udGV4dFxuXHQvLyBpcyBFTVBUWS4gTm9ib2R5IGNhbGxlZCB1cy4gKGlmIHdlIGFyZSBlbXB0eSwgcmV0dXJuIGVtcHR5KVxuXHRpZiAob3V0ZXJDb250ZXh0LnBhcmVudEN0eCA9PT0gbnVsbCB8fCBvdXRlckNvbnRleHQgPT09IFJ1bGVDb250ZXh0LkVNUFRZKSB7XG5cdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuXHR9XG5cdC8vIElmIHdlIGhhdmUgYSBwYXJlbnQsIGNvbnZlcnQgaXQgdG8gYSBQcmVkaWN0aW9uQ29udGV4dCBncmFwaFxuXHR2YXIgcGFyZW50ID0gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQoYXRuLCBvdXRlckNvbnRleHQucGFyZW50Q3R4KTtcblx0dmFyIHN0YXRlID0gYXRuLnN0YXRlc1tvdXRlckNvbnRleHQuaW52b2tpbmdTdGF0ZV07XG5cdHZhciB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbnNbMF07XG5cdHJldHVybiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUocGFyZW50LCB0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbn1cbi8qXG5mdW5jdGlvbiBjYWxjdWxhdGVMaXN0c0hhc2hTdHJpbmcocGFyZW50cywgcmV0dXJuU3RhdGVzKSB7XG5cdHZhciBzID0gXCJcIjtcblx0cGFyZW50cy5tYXAoZnVuY3Rpb24ocCkge1xuXHRcdHMgPSBzICsgcDtcblx0fSk7XG5cdHJldHVyblN0YXRlcy5tYXAoZnVuY3Rpb24ocikge1xuXHRcdHMgPSBzICsgcjtcblx0fSk7XG5cdHJldHVybiBzO1xufVxuKi9cbmZ1bmN0aW9uIG1lcmdlKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdC8vIHNoYXJlIHNhbWUgZ3JhcGggaWYgYm90aCBzYW1lXG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblx0aWYgKGEgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCAmJiBiIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRyZXR1cm4gbWVyZ2VTaW5nbGV0b25zKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0fVxuXHQvLyBBdCBsZWFzdCBvbmUgb2YgYSBvciBiIGlzIGFycmF5XG5cdC8vIElmIG9uZSBpcyAkIGFuZCByb290SXNXaWxkY2FyZCwgcmV0dXJuICQgYXMvLyB3aWxkY2FyZFxuXHRpZiAocm9vdElzV2lsZGNhcmQpIHtcblx0XHRpZiAoYSBpbnN0YW5jZW9mIEVtcHR5UHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRcdHJldHVybiBhO1xuXHRcdH1cblx0XHRpZiAoYiBpbnN0YW5jZW9mIEVtcHR5UHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRcdHJldHVybiBiO1xuXHRcdH1cblx0fVxuXHQvLyBjb252ZXJ0IHNpbmdsZXRvbiBzbyBib3RoIGFyZSBhcnJheXMgdG8gbm9ybWFsaXplXG5cdGlmIChhIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRhID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQoW2EuZ2V0UGFyZW50KCldLCBbYS5yZXR1cm5TdGF0ZV0pO1xuXHR9XG5cdGlmIChiIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRiID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQoW2IuZ2V0UGFyZW50KCldLCBbYi5yZXR1cm5TdGF0ZV0pO1xuXHR9XG5cdHJldHVybiBtZXJnZUFycmF5cyhhLCBiLCByb290SXNXaWxkY2FyZCwgbWVyZ2VDYWNoZSk7XG59XG5cbi8vXG4vLyBNZXJnZSB0d28ge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fSBpbnN0YW5jZXMuXG4vL1xuLy8gPHA+U3RhY2sgdG9wcyBlcXVhbCwgcGFyZW50cyBtZXJnZSBpcyBzYW1lOyByZXR1cm4gbGVmdCBncmFwaC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1NpbmdsZXRvbk1lcmdlX1NhbWVSb290U2FtZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNhbWUgc3RhY2sgdG9wLCBwYXJlbnRzIGRpZmZlcjsgbWVyZ2UgcGFyZW50cyBnaXZpbmcgYXJyYXkgbm9kZSwgdGhlblxuLy8gcmVtYWluZGVycyBvZiB0aG9zZSBncmFwaHMuIEEgbmV3IHJvb3Qgbm9kZSBpcyBjcmVhdGVkIHRvIHBvaW50IHRvIHRoZVxuLy8gbWVyZ2VkIHBhcmVudHMuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9TaW5nbGV0b25NZXJnZV9TYW1lUm9vdERpZmZQYXIuc3ZnXCJcbi8vIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8cD5EaWZmZXJlbnQgc3RhY2sgdG9wcyBwb2ludGluZyB0byBzYW1lIHBhcmVudC4gTWFrZSBhcnJheSBub2RlIGZvciB0aGVcbi8vIHJvb3Qgd2hlcmUgYm90aCBlbGVtZW50IGluIHRoZSByb290IHBvaW50IHRvIHRoZSBzYW1lIChvcmlnaW5hbClcbi8vIHBhcmVudC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1NpbmdsZXRvbk1lcmdlX0RpZmZSb290U2FtZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPkRpZmZlcmVudCBzdGFjayB0b3BzIHBvaW50aW5nIHRvIGRpZmZlcmVudCBwYXJlbnRzLiBNYWtlIGFycmF5IG5vZGUgZm9yXG4vLyB0aGUgcm9vdCB3aGVyZSBlYWNoIGVsZW1lbnQgcG9pbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIG9yaWdpbmFsXG4vLyBwYXJlbnQuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9TaW5nbGV0b25NZXJnZV9EaWZmUm9vdERpZmZQYXIuc3ZnXCJcbi8vIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyBAcGFyYW0gYSB0aGUgZmlyc3Qge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fVxuLy8gQHBhcmFtIGIgdGhlIHNlY29uZCB7QGxpbmsgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHR9XG4vLyBAcGFyYW0gcm9vdElzV2lsZGNhcmQge0Bjb2RlIHRydWV9IGlmIHRoaXMgaXMgYSBsb2NhbC1jb250ZXh0IG1lcmdlLFxuLy8gb3RoZXJ3aXNlIGZhbHNlIHRvIGluZGljYXRlIGEgZnVsbC1jb250ZXh0IG1lcmdlXG4vLyBAcGFyYW0gbWVyZ2VDYWNoZVxuLy8gL1xuZnVuY3Rpb24gbWVyZ2VTaW5nbGV0b25zKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYSwgYik7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHRcdHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYiwgYSk7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHJvb3RNZXJnZSA9IG1lcmdlUm9vdChhLCBiLCByb290SXNXaWxkY2FyZCk7XG5cdGlmIChyb290TWVyZ2UgIT09IG51bGwpIHtcblx0XHRpZiAobWVyZ2VDYWNoZSAhPT0gbnVsbCkge1xuXHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgcm9vdE1lcmdlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvb3RNZXJnZTtcblx0fVxuXHRpZiAoYS5yZXR1cm5TdGF0ZSA9PT0gYi5yZXR1cm5TdGF0ZSkge1xuXHRcdHZhciBwYXJlbnQgPSBtZXJnZShhLnBhcmVudEN0eCwgYi5wYXJlbnRDdHgsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0XHQvLyBpZiBwYXJlbnQgaXMgc2FtZSBhcyBleGlzdGluZyBhIG9yIGIgcGFyZW50IG9yIHJlZHVjZWQgdG8gYSBwYXJlbnQsXG5cdFx0Ly8gcmV0dXJuIGl0XG5cdFx0aWYgKHBhcmVudCA9PT0gYS5wYXJlbnRDdHgpIHtcblx0XHRcdHJldHVybiBhOyAvLyBheCArIGJ4ID0gYXgsIGlmIGE9YlxuXHRcdH1cblx0XHRpZiAocGFyZW50ID09PSBiLnBhcmVudEN0eCkge1xuXHRcdFx0cmV0dXJuIGI7IC8vIGF4ICsgYnggPSBieCwgaWYgYT1iXG5cdFx0fVxuXHRcdC8vIGVsc2U6IGF4ICsgYXkgPSBhJ1t4LHldXG5cdFx0Ly8gbWVyZ2UgcGFyZW50cyB4IGFuZCB5LCBnaXZpbmcgYXJyYXkgbm9kZSB3aXRoIHgseSB0aGVuIHJlbWFpbmRlcnNcblx0XHQvLyBvZiB0aG9zZSBncmFwaHMuIGR1cCBhLCBhJyBwb2ludHMgYXQgbWVyZ2VkIGFycmF5XG5cdFx0Ly8gbmV3IGpvaW5lZCBwYXJlbnQgc28gY3JlYXRlIG5ldyBzaW5nbGV0b24gcG9pbnRpbmcgdG8gaXQsIGEnXG5cdFx0dmFyIHNwYyA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShwYXJlbnQsIGEucmV0dXJuU3RhdGUpO1xuXHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBzcGMpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3BjO1xuXHR9IGVsc2UgeyAvLyBhICE9IGIgcGF5bG9hZHMgZGlmZmVyXG5cdFx0Ly8gc2VlIGlmIHdlIGNhbiBjb2xsYXBzZSBwYXJlbnRzIGR1ZSB0byAkK3ggcGFyZW50cyBpZiBsb2NhbCBjdHhcblx0XHR2YXIgc2luZ2xlUGFyZW50ID0gbnVsbDtcblx0XHRpZiAoYSA9PT0gYiB8fCAoYS5wYXJlbnRDdHggIT09IG51bGwgJiYgYS5wYXJlbnRDdHggPT09IGIucGFyZW50Q3R4KSkgeyAvLyBheCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYnggPVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFthLGJdeFxuXHRcdFx0c2luZ2xlUGFyZW50ID0gYS5wYXJlbnRDdHg7XG5cdFx0fVxuXHRcdGlmIChzaW5nbGVQYXJlbnQgIT09IG51bGwpIHsgLy8gcGFyZW50cyBhcmUgc2FtZVxuXHRcdFx0Ly8gc29ydCBwYXlsb2FkcyBhbmQgdXNlIHNhbWUgcGFyZW50XG5cdFx0XHR2YXIgcGF5bG9hZHMgPSBbIGEucmV0dXJuU3RhdGUsIGIucmV0dXJuU3RhdGUgXTtcblx0XHRcdGlmIChhLnJldHVyblN0YXRlID4gYi5yZXR1cm5TdGF0ZSkge1xuXHRcdFx0XHRwYXlsb2Fkc1swXSA9IGIucmV0dXJuU3RhdGU7XG5cdFx0XHRcdHBheWxvYWRzWzFdID0gYS5yZXR1cm5TdGF0ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJlbnRzID0gWyBzaW5nbGVQYXJlbnQsIHNpbmdsZVBhcmVudCBdO1xuXHRcdFx0dmFyIGFwYyA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHBheWxvYWRzKTtcblx0XHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRcdG1lcmdlQ2FjaGUuc2V0KGEsIGIsIGFwYyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXBjO1xuXHRcdH1cblx0XHQvLyBwYXJlbnRzIGRpZmZlciBhbmQgY2FuJ3QgbWVyZ2UgdGhlbS4gSnVzdCBwYWNrIHRvZ2V0aGVyXG5cdFx0Ly8gaW50byBhcnJheTsgY2FuJ3QgbWVyZ2UuXG5cdFx0Ly8gYXggKyBieSA9IFtheCxieV1cblx0XHR2YXIgcGF5bG9hZHMgPSBbIGEucmV0dXJuU3RhdGUsIGIucmV0dXJuU3RhdGUgXTtcblx0XHR2YXIgcGFyZW50cyA9IFsgYS5wYXJlbnRDdHgsIGIucGFyZW50Q3R4IF07XG5cdFx0aWYgKGEucmV0dXJuU3RhdGUgPiBiLnJldHVyblN0YXRlKSB7IC8vIHNvcnQgYnkgcGF5bG9hZFxuXHRcdFx0cGF5bG9hZHNbMF0gPSBiLnJldHVyblN0YXRlO1xuXHRcdFx0cGF5bG9hZHNbMV0gPSBhLnJldHVyblN0YXRlO1xuXHRcdFx0cGFyZW50cyA9IFsgYi5wYXJlbnRDdHgsIGEucGFyZW50Q3R4IF07XG5cdFx0fVxuXHRcdHZhciBhXyA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHBheWxvYWRzKTtcblx0XHRpZiAobWVyZ2VDYWNoZSAhPT0gbnVsbCkge1xuXHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuXHRcdH1cblx0XHRyZXR1cm4gYV87XG5cdH1cbn1cblxuLy9cbi8vIEhhbmRsZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB7QGNvZGUgYX0gb3Ige0Bjb2RlIGJ9IGlzXG4vLyB7QGxpbmsgLy9FTVBUWX0uIEluIHRoZSBmb2xsb3dpbmcgZGlhZ3JhbXMsIHRoZSBzeW1ib2wge0Bjb2RlICR9IGlzIHVzZWRcbi8vIHRvIHJlcHJlc2VudCB7QGxpbmsgLy9FTVBUWX0uXG4vL1xuLy8gPGgyPkxvY2FsLUNvbnRleHQgTWVyZ2VzPC9oMj5cbi8vXG4vLyA8cD5UaGVzZSBsb2NhbC1jb250ZXh0IG1lcmdlIG9wZXJhdGlvbnMgYXJlIHVzZWQgd2hlbiB7QGNvZGUgcm9vdElzV2lsZGNhcmR9XG4vLyBpcyB0cnVlLjwvcD5cbi8vXG4vLyA8cD57QGxpbmsgLy9FTVBUWX0gaXMgc3VwZXJzZXQgb2YgYW55IGdyYXBoOyByZXR1cm4ge0BsaW5rIC8vRU1QVFl9Ljxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvTG9jYWxNZXJnZV9FbXB0eVJvb3Quc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPntAbGluayAvL0VNUFRZfSBhbmQgYW55dGhpbmcgaXMge0Bjb2RlIC8vRU1QVFl9LCBzbyBtZXJnZWQgcGFyZW50IGlzXG4vLyB7QGNvZGUgLy9FTVBUWX07IHJldHVybiBsZWZ0IGdyYXBoLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvTG9jYWxNZXJnZV9FbXB0eVBhcmVudC5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+U3BlY2lhbCBjYXNlIG9mIGxhc3QgbWVyZ2UgaWYgbG9jYWwgY29udGV4dC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0xvY2FsTWVyZ2VfRGlmZlJvb3RzLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8aDI+RnVsbC1Db250ZXh0IE1lcmdlczwvaDI+XG4vL1xuLy8gPHA+VGhlc2UgZnVsbC1jb250ZXh0IG1lcmdlIG9wZXJhdGlvbnMgYXJlIHVzZWQgd2hlbiB7QGNvZGUgcm9vdElzV2lsZGNhcmR9XG4vLyBpcyBmYWxzZS48L3A+XG4vL1xuLy8gPHA+PGVtYmVkIHNyYz1cImltYWdlcy9GdWxsTWVyZ2VfRW1wdHlSb290cy5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+TXVzdCBrZWVwIGFsbCBjb250ZXh0czsge0BsaW5rIC8vRU1QVFl9IGluIGFycmF5IGlzIGEgc3BlY2lhbCB2YWx1ZSAoYW5kXG4vLyBudWxsIHBhcmVudCkuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9GdWxsTWVyZ2VfRW1wdHlSb290LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8cD48ZW1iZWQgc3JjPVwiaW1hZ2VzL0Z1bGxNZXJnZV9TYW1lUm9vdC5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gQHBhcmFtIGEgdGhlIGZpcnN0IHtAbGluayBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dH1cbi8vIEBwYXJhbSBiIHRoZSBzZWNvbmQge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fVxuLy8gQHBhcmFtIHJvb3RJc1dpbGRjYXJkIHtAY29kZSB0cnVlfSBpZiB0aGlzIGlzIGEgbG9jYWwtY29udGV4dCBtZXJnZSxcbi8vIG90aGVyd2lzZSBmYWxzZSB0byBpbmRpY2F0ZSBhIGZ1bGwtY29udGV4dCBtZXJnZVxuLy8gL1xuZnVuY3Rpb24gbWVyZ2VSb290KGEsIGIsIHJvb3RJc1dpbGRjYXJkKSB7XG5cdGlmIChyb290SXNXaWxkY2FyZCkge1xuXHRcdGlmIChhID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZOyAvLyAvLyArIGIgPS8vXG5cdFx0fVxuXHRcdGlmIChiID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZOyAvLyBhICsvLyA9Ly9cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGEgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZICYmIGIgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZKSB7XG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7IC8vICQgKyAkID0gJFxuXHRcdH0gZWxzZSBpZiAoYSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHsgLy8gJCArIHggPSBbJCx4XVxuXHRcdFx0dmFyIHBheWxvYWRzID0gWyBiLnJldHVyblN0YXRlLFxuXHRcdFx0XHRcdFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSBdO1xuXHRcdFx0dmFyIHBhcmVudHMgPSBbIGIucGFyZW50Q3R4LCBudWxsIF07XG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcGF5bG9hZHMpO1xuXHRcdH0gZWxzZSBpZiAoYiA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHsgLy8geCArICQgPSBbJCx4XSAoJCBpcyBhbHdheXMgZmlyc3QgaWYgcHJlc2VudClcblx0XHRcdHZhciBwYXlsb2FkcyA9IFsgYS5yZXR1cm5TdGF0ZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFIF07XG5cdFx0XHR2YXIgcGFyZW50cyA9IFsgYS5wYXJlbnRDdHgsIG51bGwgXTtcblx0XHRcdHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCBwYXlsb2Fkcyk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG4vL1xuLy8gTWVyZ2UgdHdvIHtAbGluayBBcnJheVByZWRpY3Rpb25Db250ZXh0fSBpbnN0YW5jZXMuXG4vL1xuLy8gPHA+RGlmZmVyZW50IHRvcHMsIGRpZmZlcmVudCBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9EaWZmVG9wRGlmZlBhci5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+U2hhcmVkIHRvcCwgc2FtZSBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9TaGFyZVRvcFNhbWVQYXIuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNoYXJlZCB0b3AsIGRpZmZlcmVudCBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9TaGFyZVRvcERpZmZQYXIuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNoYXJlZCB0b3AsIGFsbCBzaGFyZWQgcGFyZW50cy48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0FycmF5TWVyZ2VfU2hhcmVUb3BTaGFyZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPkVxdWFsIHRvcHMsIG1lcmdlIHBhcmVudHMgYW5kIHJlZHVjZSB0b3AgdG9cbi8vIHtAbGluayBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dH0uPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9BcnJheU1lcmdlX0VxdWFsVG9wLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vIC9cbmZ1bmN0aW9uIG1lcmdlQXJyYXlzKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYSwgYik7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHRcdHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYiwgYSk7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHR9XG5cdC8vIG1lcmdlIHNvcnRlZCBwYXlsb2FkcyBhICsgYiA9PiBNXG5cdHZhciBpID0gMDsgLy8gd2Fsa3MgYVxuXHR2YXIgaiA9IDA7IC8vIHdhbGtzIGJcblx0dmFyIGsgPSAwOyAvLyB3YWxrcyB0YXJnZXQgTSBhcnJheVxuXG5cdHZhciBtZXJnZWRSZXR1cm5TdGF0ZXMgPSBbXTtcblx0dmFyIG1lcmdlZFBhcmVudHMgPSBbXTtcblx0Ly8gd2FsayBhbmQgbWVyZ2UgdG8geWllbGQgbWVyZ2VkUGFyZW50cywgbWVyZ2VkUmV0dXJuU3RhdGVzXG5cdHdoaWxlIChpIDwgYS5yZXR1cm5TdGF0ZXMubGVuZ3RoICYmIGogPCBiLnJldHVyblN0YXRlcy5sZW5ndGgpIHtcblx0XHR2YXIgYV9wYXJlbnQgPSBhLnBhcmVudHNbaV07XG5cdFx0dmFyIGJfcGFyZW50ID0gYi5wYXJlbnRzW2pdO1xuXHRcdGlmIChhLnJldHVyblN0YXRlc1tpXSA9PT0gYi5yZXR1cm5TdGF0ZXNbal0pIHtcblx0XHRcdC8vIHNhbWUgcGF5bG9hZCAoc3RhY2sgdG9wcyBhcmUgZXF1YWwpLCBtdXN0IHlpZWxkIG1lcmdlZCBzaW5nbGV0b25cblx0XHRcdHZhciBwYXlsb2FkID0gYS5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHQvLyAkKyQgPSAkXG5cdFx0XHR2YXIgYm90aERvbGxhcnMgPSBwYXlsb2FkID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUgJiZcblx0XHRcdFx0XHRhX3BhcmVudCA9PT0gbnVsbCAmJiBiX3BhcmVudCA9PT0gbnVsbDtcblx0XHRcdHZhciBheF9heCA9IChhX3BhcmVudCAhPT0gbnVsbCAmJiBiX3BhcmVudCAhPT0gbnVsbCAmJiBhX3BhcmVudCA9PT0gYl9wYXJlbnQpOyAvLyBheCtheFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYXhcblx0XHRcdGlmIChib3RoRG9sbGFycyB8fCBheF9heCkge1xuXHRcdFx0XHRtZXJnZWRQYXJlbnRzW2tdID0gYV9wYXJlbnQ7IC8vIGNob29zZSBsZWZ0XG5cdFx0XHRcdG1lcmdlZFJldHVyblN0YXRlc1trXSA9IHBheWxvYWQ7XG5cdFx0XHR9IGVsc2UgeyAvLyBheCtheSAtPiBhJ1t4LHldXG5cdFx0XHRcdHZhciBtZXJnZWRQYXJlbnQgPSBtZXJnZShhX3BhcmVudCwgYl9wYXJlbnQsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0XHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IG1lcmdlZFBhcmVudDtcblx0XHRcdFx0bWVyZ2VkUmV0dXJuU3RhdGVzW2tdID0gcGF5bG9hZDtcblx0XHRcdH1cblx0XHRcdGkgKz0gMTsgLy8gaG9wIG92ZXIgbGVmdCBvbmUgYXMgdXN1YWxcblx0XHRcdGogKz0gMTsgLy8gYnV0IGFsc28gc2tpcCBvbmUgaW4gcmlnaHQgc2lkZSBzaW5jZSB3ZSBtZXJnZVxuXHRcdH0gZWxzZSBpZiAoYS5yZXR1cm5TdGF0ZXNbaV0gPCBiLnJldHVyblN0YXRlc1tqXSkgeyAvLyBjb3B5IGFbaV0gdG8gTVxuXHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IGFfcGFyZW50O1xuXHRcdFx0bWVyZ2VkUmV0dXJuU3RhdGVzW2tdID0gYS5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHRpICs9IDE7XG5cdFx0fSBlbHNlIHsgLy8gYiA+IGEsIGNvcHkgYltqXSB0byBNXG5cdFx0XHRtZXJnZWRQYXJlbnRzW2tdID0gYl9wYXJlbnQ7XG5cdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBiLnJldHVyblN0YXRlc1tqXTtcblx0XHRcdGogKz0gMTtcblx0XHR9XG5cdFx0ayArPSAxO1xuXHR9XG5cdC8vIGNvcHkgb3ZlciBhbnkgcGF5bG9hZHMgcmVtYWluaW5nIGluIGVpdGhlciBhcnJheVxuXHRpZiAoaSA8IGEucmV0dXJuU3RhdGVzLmxlbmd0aCkge1xuXHRcdGZvciAodmFyIHAgPSBpOyBwIDwgYS5yZXR1cm5TdGF0ZXMubGVuZ3RoOyBwKyspIHtcblx0XHRcdG1lcmdlZFBhcmVudHNba10gPSBhLnBhcmVudHNbcF07XG5cdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBhLnJldHVyblN0YXRlc1twXTtcblx0XHRcdGsgKz0gMTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgcCA9IGo7IHAgPCBiLnJldHVyblN0YXRlcy5sZW5ndGg7IHArKykge1xuXHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IGIucGFyZW50c1twXTtcblx0XHRcdG1lcmdlZFJldHVyblN0YXRlc1trXSA9IGIucmV0dXJuU3RhdGVzW3BdO1xuXHRcdFx0ayArPSAxO1xuXHRcdH1cblx0fVxuXHQvLyB0cmltIG1lcmdlZCBpZiB3ZSBjb21iaW5lZCBhIGZldyB0aGF0IGhhZCBzYW1lIHN0YWNrIHRvcHNcblx0aWYgKGsgPCBtZXJnZWRQYXJlbnRzLmxlbmd0aCkgeyAvLyB3cml0ZSBpbmRleCA8IGxhc3QgcG9zaXRpb247IHRyaW1cblx0XHRpZiAoayA9PT0gMSkgeyAvLyBmb3IganVzdCBvbmUgbWVyZ2VkIGVsZW1lbnQsIHJldHVybiBzaW5nbGV0b24gdG9wXG5cdFx0XHR2YXIgYV8gPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUobWVyZ2VkUGFyZW50c1swXSxcblx0XHRcdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNbMF0pO1xuXHRcdFx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFfO1xuXHRcdH1cblx0XHRtZXJnZWRQYXJlbnRzID0gbWVyZ2VkUGFyZW50cy5zbGljZSgwLCBrKTtcblx0XHRtZXJnZWRSZXR1cm5TdGF0ZXMgPSBtZXJnZWRSZXR1cm5TdGF0ZXMuc2xpY2UoMCwgayk7XG5cdH1cblxuXHR2YXIgTSA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KG1lcmdlZFBhcmVudHMsIG1lcmdlZFJldHVyblN0YXRlcyk7XG5cblx0Ly8gaWYgd2UgY3JlYXRlZCBzYW1lIGFycmF5IGFzIGEgb3IgYiwgcmV0dXJuIHRoYXQgaW5zdGVhZFxuXHQvLyBUT0RPOiB0cmFjayB3aGV0aGVyIHRoaXMgaXMgcG9zc2libGUgYWJvdmUgZHVyaW5nIG1lcmdlIHNvcnQgZm9yIHNwZWVkXG5cdGlmIChNID09PSBhKSB7XG5cdFx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRcdG1lcmdlQ2FjaGUuc2V0KGEsIGIsIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fVxuXHRpZiAoTSA9PT0gYikge1xuXHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBiKTtcblx0XHR9XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0Y29tYmluZUNvbW1vblBhcmVudHMobWVyZ2VkUGFyZW50cyk7XG5cblx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBNKTtcblx0fVxuXHRyZXR1cm4gTTtcbn1cblxuLy9cbi8vIE1ha2UgcGFzcyBvdmVyIGFsbCA8ZW0+TTwvZW0+IHtAY29kZSBwYXJlbnRzfTsgbWVyZ2UgYW55IHtAY29kZSBlcXVhbHMoKX1cbi8vIG9uZXMuXG4vLyAvXG5mdW5jdGlvbiBjb21iaW5lQ29tbW9uUGFyZW50cyhwYXJlbnRzKSB7XG5cdHZhciB1bmlxdWVQYXJlbnRzID0ge307XG5cblx0Zm9yICh2YXIgcCA9IDA7IHAgPCBwYXJlbnRzLmxlbmd0aDsgcCsrKSB7XG5cdFx0dmFyIHBhcmVudCA9IHBhcmVudHNbcF07XG5cdFx0aWYgKCEocGFyZW50IGluIHVuaXF1ZVBhcmVudHMpKSB7XG5cdFx0XHR1bmlxdWVQYXJlbnRzW3BhcmVudF0gPSBwYXJlbnQ7XG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIHEgPSAwOyBxIDwgcGFyZW50cy5sZW5ndGg7IHErKykge1xuXHRcdHBhcmVudHNbcV0gPSB1bmlxdWVQYXJlbnRzW3BhcmVudHNbcV1dO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQsIGNvbnRleHRDYWNoZSwgdmlzaXRlZCkge1xuXHRpZiAoY29udGV4dC5pc0VtcHR5KCkpIHtcblx0XHRyZXR1cm4gY29udGV4dDtcblx0fVxuXHR2YXIgZXhpc3RpbmcgPSB2aXNpdGVkW2NvbnRleHRdIHx8IG51bGw7XG5cdGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBleGlzdGluZztcblx0fVxuXHRleGlzdGluZyA9IGNvbnRleHRDYWNoZS5nZXQoY29udGV4dCk7XG5cdGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xuXHRcdHZpc2l0ZWRbY29udGV4dF0gPSBleGlzdGluZztcblx0XHRyZXR1cm4gZXhpc3Rpbmc7XG5cdH1cblx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0dmFyIHBhcmVudHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHBhcmVudCA9IGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQuZ2V0UGFyZW50KGkpLCBjb250ZXh0Q2FjaGUsIHZpc2l0ZWQpO1xuXHRcdGlmIChjaGFuZ2VkIHx8IHBhcmVudCAhPT0gY29udGV4dC5nZXRQYXJlbnQoaSkpIHtcblx0XHRcdGlmICghY2hhbmdlZCkge1xuXHRcdFx0XHRwYXJlbnRzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgY29udGV4dC5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHBhcmVudHNbal0gPSBjb250ZXh0LmdldFBhcmVudChqKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHBhcmVudHNbaV0gPSBwYXJlbnQ7XG5cdFx0fVxuXHR9XG5cdGlmICghY2hhbmdlZCkge1xuXHRcdGNvbnRleHRDYWNoZS5hZGQoY29udGV4dCk7XG5cdFx0dmlzaXRlZFtjb250ZXh0XSA9IGNvbnRleHQ7XG5cdFx0cmV0dXJuIGNvbnRleHQ7XG5cdH1cblx0dmFyIHVwZGF0ZWQgPSBudWxsO1xuXHRpZiAocGFyZW50cy5sZW5ndGggPT09IDApIHtcblx0XHR1cGRhdGVkID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG5cdH0gZWxzZSBpZiAocGFyZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHR1cGRhdGVkID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKHBhcmVudHNbMF0sIGNvbnRleHRcblx0XHRcdFx0LmdldFJldHVyblN0YXRlKDApKTtcblx0fSBlbHNlIHtcblx0XHR1cGRhdGVkID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgY29udGV4dC5yZXR1cm5TdGF0ZXMpO1xuXHR9XG5cdGNvbnRleHRDYWNoZS5hZGQodXBkYXRlZCk7XG5cdHZpc2l0ZWRbdXBkYXRlZF0gPSB1cGRhdGVkO1xuXHR2aXNpdGVkW2NvbnRleHRdID0gdXBkYXRlZDtcblxuXHRyZXR1cm4gdXBkYXRlZDtcbn1cblxuLy8gdGVyJ3MgcmVjdXJzaXZlIHZlcnNpb24gb2YgU2FtJ3MgZ2V0QWxsTm9kZXMoKVxuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dE5vZGVzKGNvbnRleHQsIG5vZGVzLCB2aXNpdGVkKSB7XG5cdGlmIChub2RlcyA9PT0gbnVsbCkge1xuXHRcdG5vZGVzID0gW107XG5cdFx0cmV0dXJuIGdldEFsbENvbnRleHROb2Rlcyhjb250ZXh0LCBub2RlcywgdmlzaXRlZCk7XG5cdH0gZWxzZSBpZiAodmlzaXRlZCA9PT0gbnVsbCkge1xuXHRcdHZpc2l0ZWQgPSB7fTtcblx0XHRyZXR1cm4gZ2V0QWxsQ29udGV4dE5vZGVzKGNvbnRleHQsIG5vZGVzLCB2aXNpdGVkKTtcblx0fSBlbHNlIHtcblx0XHRpZiAoY29udGV4dCA9PT0gbnVsbCB8fCB2aXNpdGVkW2NvbnRleHRdICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fVxuXHRcdHZpc2l0ZWRbY29udGV4dF0gPSBjb250ZXh0O1xuXHRcdG5vZGVzLnB1c2goY29udGV4dCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRnZXRBbGxDb250ZXh0Tm9kZXMoY29udGV4dC5nZXRQYXJlbnQoaSksIG5vZGVzLCB2aXNpdGVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9XG59XG5cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMuUHJlZGljdGlvbkNvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dDtcbmV4cG9ydHMuUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IFByZWRpY3Rpb25Db250ZXh0Q2FjaGU7XG5leHBvcnRzLlNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQ7XG5leHBvcnRzLnByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0ID0gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQ7XG5leHBvcnRzLmdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0ID0gZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvUHJlZGljdGlvbkNvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBMTDFBbmFseXplciA9IHJlcXVpcmUoJy4vLi4vTEwxQW5hbHl6ZXInKS5MTDFBbmFseXplcjtcbnZhciBJbnRlcnZhbFNldCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbFNldDtcblxuZnVuY3Rpb24gQVROKGdyYW1tYXJUeXBlICwgbWF4VG9rZW5UeXBlKSB7XG5cbiAgICAvLyBVc2VkIGZvciBydW50aW1lIGRlc2VyaWFsaXphdGlvbiBvZiBBVE5zIGZyb20gc3RyaW5ncy8vL1xuICAgIC8vIFRoZSB0eXBlIG9mIHRoZSBBVE4uXG4gICAgdGhpcy5ncmFtbWFyVHlwZSA9IGdyYW1tYXJUeXBlO1xuICAgIC8vIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbnkgc3ltYm9sIHJlY29nbml6ZWQgYnkgYSB0cmFuc2l0aW9uIGluIHRoZSBBVE4uXG4gICAgdGhpcy5tYXhUb2tlblR5cGUgPSBtYXhUb2tlblR5cGU7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAvLyBFYWNoIHN1YnJ1bGUvcnVsZSBpcyBhIGRlY2lzaW9uIHBvaW50IGFuZCB3ZSBtdXN0IHRyYWNrIHRoZW0gc28gd2VcbiAgICAvLyAgY2FuIGdvIGJhY2sgbGF0ZXIgYW5kIGJ1aWxkIERGQSBwcmVkaWN0b3JzIGZvciB0aGVtLiAgVGhpcyBpbmNsdWRlc1xuICAgIC8vICBhbGwgdGhlIHJ1bGVzLCBzdWJydWxlcywgb3B0aW9uYWwgYmxvY2tzLCAoKSssICgpKiBldGMuLi5cbiAgICB0aGlzLmRlY2lzaW9uVG9TdGF0ZSA9IFtdO1xuICAgIC8vIE1hcHMgZnJvbSBydWxlIGluZGV4IHRvIHN0YXJ0aW5nIHN0YXRlIG51bWJlci5cbiAgICB0aGlzLnJ1bGVUb1N0YXJ0U3RhdGUgPSBbXTtcbiAgICAvLyBNYXBzIGZyb20gcnVsZSBpbmRleCB0byBzdG9wIHN0YXRlIG51bWJlci5cbiAgICB0aGlzLnJ1bGVUb1N0b3BTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5tb2RlTmFtZVRvU3RhcnRTdGF0ZSA9IHt9O1xuICAgIC8vIEZvciBsZXhlciBBVE5zLCB0aGlzIG1hcHMgdGhlIHJ1bGUgaW5kZXggdG8gdGhlIHJlc3VsdGluZyB0b2tlbiB0eXBlLlxuICAgIC8vIEZvciBwYXJzZXIgQVROcywgdGhpcyBtYXBzIHRoZSBydWxlIGluZGV4IHRvIHRoZSBnZW5lcmF0ZWQgYnlwYXNzIHRva2VuXG4gICAgLy8gdHlwZSBpZiB0aGVcbiAgICAvLyB7QGxpbmsgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy8vaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uc31cbiAgICAvLyBkZXNlcmlhbGl6YXRpb24gb3B0aW9uIHdhcyBzcGVjaWZpZWQ7IG90aGVyd2lzZSwgdGhpcyBpcyB7QGNvZGUgbnVsbH0uXG4gICAgdGhpcy5ydWxlVG9Ub2tlblR5cGUgPSBudWxsO1xuICAgIC8vIEZvciBsZXhlciBBVE5zLCB0aGlzIGlzIGFuIGFycmF5IG9mIHtAbGluayBMZXhlckFjdGlvbn0gb2JqZWN0cyB3aGljaCBtYXlcbiAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGFjdGlvbiB0cmFuc2l0aW9ucyBpbiB0aGUgQVROLlxuICAgIHRoaXMubGV4ZXJBY3Rpb25zID0gbnVsbDtcbiAgICB0aGlzLm1vZGVUb1N0YXJ0U3RhdGUgPSBbXTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBDb21wdXRlIHRoZSBzZXQgb2YgdmFsaWQgdG9rZW5zIHRoYXQgY2FuIG9jY3VyIHN0YXJ0aW5nIGluIHN0YXRlIHtAY29kZSBzfS5cbi8vICBJZiB7QGNvZGUgY3R4fSBpcyBudWxsLCB0aGUgc2V0IG9mIHRva2VucyB3aWxsIG5vdCBpbmNsdWRlIHdoYXQgY2FuIGZvbGxvd1xuLy8gIHRoZSBydWxlIHN1cnJvdW5kaW5nIHtAY29kZSBzfS4gSW4gb3RoZXIgd29yZHMsIHRoZSBzZXQgd2lsbCBiZVxuLy8gIHJlc3RyaWN0ZWQgdG8gdG9rZW5zIHJlYWNoYWJsZSBzdGF5aW5nIHdpdGhpbiB7QGNvZGUgc30ncyBydWxlLlxuQVROLnByb3RvdHlwZS5uZXh0VG9rZW5zSW5Db250ZXh0ID0gZnVuY3Rpb24ocywgY3R4KSB7XG4gICAgdmFyIGFuYWwgPSBuZXcgTEwxQW5hbHl6ZXIodGhpcyk7XG4gICAgcmV0dXJuIGFuYWwuTE9PSyhzLCBudWxsLCBjdHgpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2V0IG9mIHZhbGlkIHRva2VucyB0aGF0IGNhbiBvY2N1ciBzdGFydGluZyBpbiB7QGNvZGUgc30gYW5kXG4vLyBzdGF5aW5nIGluIHNhbWUgcnVsZS4ge0BsaW5rIFRva2VuLy9FUFNJTE9OfSBpcyBpbiBzZXQgaWYgd2UgcmVhY2ggZW5kIG9mXG4vLyBydWxlLlxuQVROLnByb3RvdHlwZS5uZXh0VG9rZW5zTm9Db250ZXh0ID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChzLm5leHRUb2tlbldpdGhpblJ1bGUgIT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG4gICAgfVxuICAgIHMubmV4dFRva2VuV2l0aGluUnVsZSA9IHRoaXMubmV4dFRva2Vuc0luQ29udGV4dChzLCBudWxsKTtcbiAgICBzLm5leHRUb2tlbldpdGhpblJ1bGUucmVhZE9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG59O1xuXG5BVE4ucHJvdG90eXBlLm5leHRUb2tlbnMgPSBmdW5jdGlvbihzLCBjdHgpIHtcbiAgICBpZiAoIGN0eD09PXVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2Vuc05vQ29udGV4dChzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5zSW5Db250ZXh0KHMsIGN0eCk7XG4gICAgfVxufTtcblxuQVROLnByb3RvdHlwZS5hZGRTdGF0ZSA9IGZ1bmN0aW9uKCBzdGF0ZSkge1xuICAgIGlmICggc3RhdGUgIT09IG51bGwgKSB7XG4gICAgICAgIHN0YXRlLmF0biA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnN0YXRlTnVtYmVyID0gdGhpcy5zdGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbn07XG5cbkFUTi5wcm90b3R5cGUucmVtb3ZlU3RhdGUgPSBmdW5jdGlvbiggc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlc1tzdGF0ZS5zdGF0ZU51bWJlcl0gPSBudWxsOyAvLyBqdXN0IGZyZWUgbWVtLCBkb24ndCBzaGlmdCBzdGF0ZXMgaW4gbGlzdFxufTtcblxuQVROLnByb3RvdHlwZS5kZWZpbmVEZWNpc2lvblN0YXRlID0gZnVuY3Rpb24oIHMpIHtcbiAgICB0aGlzLmRlY2lzaW9uVG9TdGF0ZS5wdXNoKHMpO1xuICAgIHMuZGVjaXNpb24gPSB0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGgtMTtcbiAgICByZXR1cm4gcy5kZWNpc2lvbjtcbn07XG5cbkFUTi5wcm90b3R5cGUuZ2V0RGVjaXNpb25TdGF0ZSA9IGZ1bmN0aW9uKCBkZWNpc2lvbikge1xuICAgIGlmICh0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGg9PT0wKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uVG9TdGF0ZVtkZWNpc2lvbl07XG4gICAgfVxufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHNldCBvZiBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyBBVE4gc3RhdGUgbnVtYmVyXG4vLyB7QGNvZGUgc3RhdGVOdW1iZXJ9IGluIHRoZSBzcGVjaWZpZWQgZnVsbCB7QGNvZGUgY29udGV4dH0uIFRoaXMgbWV0aG9kXG4vLyBjb25zaWRlcnMgdGhlIGNvbXBsZXRlIHBhcnNlciBjb250ZXh0LCBidXQgZG9lcyBub3QgZXZhbHVhdGUgc2VtYW50aWNcbi8vIHByZWRpY2F0ZXMgKGkuZS4gYWxsIHByZWRpY2F0ZXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBjYWxjdWxhdGlvbiBhcmVcbi8vIGFzc3VtZWQgdHJ1ZSkuIElmIGEgcGF0aCBpbiB0aGUgQVROIGV4aXN0cyBmcm9tIHRoZSBzdGFydGluZyBzdGF0ZSB0byB0aGVcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfSBvZiB0aGUgb3V0ZXJtb3N0IGNvbnRleHQgd2l0aG91dCBtYXRjaGluZyBhbnlcbi8vIHN5bWJvbHMsIHtAbGluayBUb2tlbi8vRU9GfSBpcyBhZGRlZCB0byB0aGUgcmV0dXJuZWQgc2V0LlxuLy9cbi8vIDxwPklmIHtAY29kZSBjb250ZXh0fSBpcyB7QGNvZGUgbnVsbH0sIGl0IGlzIHRyZWF0ZWQgYXNcbi8vIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dC8vRU1QVFl9LjwvcD5cbi8vXG4vLyBAcGFyYW0gc3RhdGVOdW1iZXIgdGhlIEFUTiBzdGF0ZSBudW1iZXJcbi8vIEBwYXJhbSBjb250ZXh0IHRoZSBmdWxsIHBhcnNlIGNvbnRleHRcbi8vIEByZXR1cm4gVGhlIHNldCBvZiBwb3RlbnRpYWxseSB2YWxpZCBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyB0aGVcbi8vIHNwZWNpZmllZCBzdGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4vLyBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB0aGUgQVROIGRvZXMgbm90IGNvbnRhaW4gYSBzdGF0ZSB3aXRoXG4vLyBudW1iZXIge0Bjb2RlIHN0YXRlTnVtYmVyfVxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xuXG5BVE4ucHJvdG90eXBlLmdldEV4cGVjdGVkVG9rZW5zID0gZnVuY3Rpb24oIHN0YXRlTnVtYmVyLCBjdHggKSB7XG4gICAgaWYgKCBzdGF0ZU51bWJlciA8IDAgfHwgc3RhdGVOdW1iZXIgPj0gdGhpcy5zdGF0ZXMubGVuZ3RoICkge1xuICAgICAgICB0aHJvdyhcIkludmFsaWQgc3RhdGUgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdmFyIHMgPSB0aGlzLnN0YXRlc1tzdGF0ZU51bWJlcl07XG4gICAgdmFyIGZvbGxvd2luZyA9IHRoaXMubmV4dFRva2VucyhzKTtcbiAgICBpZiAoIWZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nO1xuICAgIH1cbiAgICB2YXIgZXhwZWN0ZWQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICBleHBlY3RlZC5hZGRTZXQoZm9sbG93aW5nKTtcbiAgICBleHBlY3RlZC5yZW1vdmVPbmUoVG9rZW4uRVBTSUxPTik7XG4gICAgd2hpbGUgKGN0eCAhPT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwICYmIGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICB2YXIgaW52b2tpbmdTdGF0ZSA9IHRoaXMuc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcbiAgICAgICAgdmFyIHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgZm9sbG93aW5nID0gdGhpcy5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcbiAgICAgICAgZXhwZWN0ZWQuYWRkU2V0KGZvbGxvd2luZyk7XG4gICAgICAgIGV4cGVjdGVkLnJlbW92ZU9uZShUb2tlbi5FUFNJTE9OKTtcbiAgICAgICAgY3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICB9XG4gICAgaWYgKGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICBleHBlY3RlZC5hZGRPbmUoVG9rZW4uRU9GKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdGVkO1xufTtcblxuQVROLklOVkFMSURfQUxUX05VTUJFUiA9IDA7XG5cbmV4cG9ydHMuQVROID0gQVROO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vQVROLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbi8vICBBbiBBVE4gdHJhbnNpdGlvbiBiZXR3ZWVuIGFueSB0d28gQVROIHN0YXRlcy4gIFN1YmNsYXNzZXMgZGVmaW5lXG4vLyAgYXRvbSwgc2V0LCBlcHNpbG9uLCBhY3Rpb24sIHByZWRpY2F0ZSwgcnVsZSB0cmFuc2l0aW9ucy5cbi8vXG4vLyAgPHA+VGhpcyBpcyBhIG9uZSB3YXkgbGluay4gIEl0IGVtYW5hdGVzIGZyb20gYSBzdGF0ZSAodXN1YWxseSB2aWEgYSBsaXN0IG9mXG4vLyAgdHJhbnNpdGlvbnMpIGFuZCBoYXMgYSB0YXJnZXQgc3RhdGUuPC9wPlxuLy9cbi8vICA8cD5TaW5jZSB3ZSBuZXZlciBoYXZlIHRvIGNoYW5nZSB0aGUgQVROIHRyYW5zaXRpb25zIG9uY2Ugd2UgY29uc3RydWN0IGl0LFxuLy8gIHdlIGNhbiBmaXggdGhlc2UgdHJhbnNpdGlvbnMgYXMgc3BlY2lmaWMgY2xhc3Nlcy4gVGhlIERGQSB0cmFuc2l0aW9uc1xuLy8gIG9uIHRoZSBvdGhlciBoYW5kIG5lZWQgdG8gdXBkYXRlIHRoZSBsYWJlbHMgYXMgaXQgYWRkcyB0cmFuc2l0aW9ucyB0b1xuLy8gIHRoZSBzdGF0ZXMuIFdlJ2xsIHVzZSB0aGUgdGVybSBFZGdlIGZvciB0aGUgREZBIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbVxuLy8gIEFUTiB0cmFuc2l0aW9ucy48L3A+XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vLi4vVG9rZW4nKS5Ub2tlbjtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbnZhciBJbnRlcnZhbFNldCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbFNldDtcbnZhciBQcmVkaWNhdGUgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlByZWRpY2F0ZTtcbnZhciBQcmVjZWRlbmNlUHJlZGljYXRlID0gcmVxdWlyZSgnLi9TZW1hbnRpY0NvbnRleHQnKS5QcmVjZWRlbmNlUHJlZGljYXRlO1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBUaGUgdGFyZ2V0IG9mIHRoaXMgdHJhbnNpdGlvbi5cbiAgICBpZiAodGFyZ2V0PT09dW5kZWZpbmVkIHx8IHRhcmdldD09PW51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJ0YXJnZXQgY2Fubm90IGJlIG51bGwuXCI7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIC8vIEFyZSB3ZSBlcHNpbG9uLCBhY3Rpb24sIHNlbXByZWQ/XG4gICAgdGhpcy5pc0Vwc2lsb24gPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cbiAgICAvLyBjb25zdGFudHMgZm9yIHNlcmlhbGl6YXRpb25cblRyYW5zaXRpb24uRVBTSUxPTiA9IDE7XG5UcmFuc2l0aW9uLlJBTkdFID0gMjtcblRyYW5zaXRpb24uUlVMRSA9IDM7XG5UcmFuc2l0aW9uLlBSRURJQ0FURSA9IDQ7IC8vIGUuZy4sIHtpc1R5cGUoaW5wdXQuTFQoMSkpfT9cblRyYW5zaXRpb24uQVRPTSA9IDU7XG5UcmFuc2l0aW9uLkFDVElPTiA9IDY7XG5UcmFuc2l0aW9uLlNFVCA9IDc7IC8vIH4oQXxCKSBvciB+YXRvbSwgd2lsZGNhcmQsIHdoaWNoIGNvbnZlcnQgdG8gbmV4dCAyXG5UcmFuc2l0aW9uLk5PVF9TRVQgPSA4O1xuVHJhbnNpdGlvbi5XSUxEQ0FSRCA9IDk7XG5UcmFuc2l0aW9uLlBSRUNFREVOQ0UgPSAxMDtcblxuVHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uTmFtZXMgPSBbXG4gICAgICAgICAgICBcIklOVkFMSURcIixcbiAgICAgICAgICAgIFwiRVBTSUxPTlwiLFxuICAgICAgICAgICAgXCJSQU5HRVwiLFxuICAgICAgICAgICAgXCJSVUxFXCIsXG4gICAgICAgICAgICBcIlBSRURJQ0FURVwiLFxuICAgICAgICAgICAgXCJBVE9NXCIsXG4gICAgICAgICAgICBcIkFDVElPTlwiLFxuICAgICAgICAgICAgXCJTRVRcIixcbiAgICAgICAgICAgIFwiTk9UX1NFVFwiLFxuICAgICAgICAgICAgXCJXSUxEQ0FSRFwiLFxuICAgICAgICAgICAgXCJQUkVDRURFTkNFXCJcbiAgICAgICAgXTtcblxuVHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZXMgPSB7XG4gICAgICAgIEVwc2lsb25UcmFuc2l0aW9uOiBUcmFuc2l0aW9uLkVQU0lMT04sXG4gICAgICAgIFJhbmdlVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5SQU5HRSxcbiAgICAgICAgUnVsZVRyYW5zaXRpb246IFRyYW5zaXRpb24uUlVMRSxcbiAgICAgICAgUHJlZGljYXRlVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5QUkVESUNBVEUsXG4gICAgICAgIEF0b21UcmFuc2l0aW9uOiBUcmFuc2l0aW9uLkFUT00sXG4gICAgICAgIEFjdGlvblRyYW5zaXRpb246IFRyYW5zaXRpb24uQUNUSU9OLFxuICAgICAgICBTZXRUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLlNFVCxcbiAgICAgICAgTm90U2V0VHJhbnNpdGlvbjogVHJhbnNpdGlvbi5OT1RfU0VULFxuICAgICAgICBXaWxkY2FyZFRyYW5zaXRpb246IFRyYW5zaXRpb24uV0lMRENBUkQsXG4gICAgICAgIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLlBSRUNFREVOQ0VcbiAgICB9O1xuXG5cbi8vIFRPRE86IG1ha2UgYWxsIHRyYW5zaXRpb25zIHNldHM/IG5vLCBzaG91bGQgcmVtb3ZlIHNldCBlZGdlc1xuZnVuY3Rpb24gQXRvbVRyYW5zaXRpb24odGFyZ2V0LCBsYWJlbCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0dGhpcy5sYWJlbF8gPSBsYWJlbDsgLy8gVGhlIHRva2VuIHR5cGUgb3IgY2hhcmFjdGVyIHZhbHVlOyBvciwgc2lnbmlmaWVzIHNwZWNpYWwgbGFiZWwuXG4gICAgdGhpcy5sYWJlbCA9IHRoaXMubWFrZUxhYmVsKCk7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uQVRPTTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQXRvbVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5BdG9tVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBdG9tVHJhbnNpdGlvbjtcblxuQXRvbVRyYW5zaXRpb24ucHJvdG90eXBlLm1ha2VMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcyA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgIHMuYWRkT25lKHRoaXMubGFiZWxfKTtcbiAgICByZXR1cm4gcztcbn07XG5cbkF0b21UcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oIHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsXyA9PT0gc3ltYm9sO1xufTtcblxuQXRvbVRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxhYmVsXztcbn07XG5cbmZ1bmN0aW9uIFJ1bGVUcmFuc2l0aW9uKHJ1bGVTdGFydCwgcnVsZUluZGV4LCBwcmVjZWRlbmNlLCBmb2xsb3dTdGF0ZSkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgcnVsZVN0YXJ0KTtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDsgLy8gcHRyIHRvIHRoZSBydWxlIGRlZmluaXRpb24gb2JqZWN0IGZvciB0aGlzIHJ1bGUgcmVmXG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB0aGlzLmZvbGxvd1N0YXRlID0gZm9sbG93U3RhdGU7IC8vIHdoYXQgbm9kZSB0byBiZWdpbiBjb21wdXRhdGlvbnMgZm9sbG93aW5nIHJlZiB0byBydWxlXG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uUlVMRTtcbiAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblJ1bGVUcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuUnVsZVRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVsZVRyYW5zaXRpb247XG5cblJ1bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblxuZnVuY3Rpb24gRXBzaWxvblRyYW5zaXRpb24odGFyZ2V0LCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuKSB7XG5cdFRyYW5zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLkVQU0lMT047XG4gICAgdGhpcy5pc0Vwc2lsb24gPSB0cnVlO1xuICAgIHRoaXMub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkVwc2lsb25UcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXBzaWxvblRyYW5zaXRpb247XG5cbkVwc2lsb25UcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oIHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5FcHNpbG9uVHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiZXBzaWxvblwiO1xufTtcblxuZnVuY3Rpb24gUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgc3RhcnQsIHN0b3ApIHtcblx0VHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLlJBTkdFO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLnN0b3AgPSBzdG9wO1xuICAgIHRoaXMubGFiZWwgPSB0aGlzLm1ha2VMYWJlbCgpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5SYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5SYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2VUcmFuc2l0aW9uO1xuXG5SYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLm1ha2VMYWJlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgcy5hZGRSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLnN0b3ApO1xuICAgIHJldHVybiBzO1xufTtcblxuUmFuZ2VUcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBzeW1ib2wgPj0gdGhpcy5zdGFydCAmJiBzeW1ib2wgPD0gdGhpcy5zdG9wO1xufTtcblxuUmFuZ2VUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuc3RhcnQpICsgXCInLi4nXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuc3RvcCkgKyBcIidcIjtcbn07XG5cbmZ1bmN0aW9uIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbih0YXJnZXQpIHtcblx0VHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG5mdW5jdGlvbiBQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgcnVsZUluZGV4LCBwcmVkSW5kZXgsIGlzQ3R4RGVwZW5kZW50KSB7XG5cdEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uUFJFRElDQVRFO1xuICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgIHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xuICAgIHRoaXMuaXNDdHhEZXBlbmRlbnQgPSBpc0N0eERlcGVuZGVudDsgLy8gZS5nLiwgJGkgcmVmIGluIHByZWRcbiAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlKTtcblByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJlZGljYXRlVHJhbnNpdGlvbjtcblxuUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5QcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRQcmVkaWNhdGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG5ldyBQcmVkaWNhdGUodGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4LCB0aGlzLmlzQ3R4RGVwZW5kZW50KTtcbn07XG5cblByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcInByZWRfXCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5wcmVkSW5kZXg7XG59O1xuXG5mdW5jdGlvbiBBY3Rpb25UcmFuc2l0aW9uKHRhcmdldCwgcnVsZUluZGV4LCBhY3Rpb25JbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcblx0VHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uQUNUSU9OO1xuICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgIHRoaXMuYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleD09PXVuZGVmaW5lZCA/IC0xIDogYWN0aW9uSW5kZXg7XG4gICAgdGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50PT09dW5kZWZpbmVkID8gZmFsc2UgOiBpc0N0eERlcGVuZGVudDsgLy8gZS5nLiwgJGkgcmVmIGluIHByZWRcbiAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkFjdGlvblRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5BY3Rpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFjdGlvblRyYW5zaXRpb247XG5cblxuQWN0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5BY3Rpb25UcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJhY3Rpb25fXCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5hY3Rpb25JbmRleDtcbn07XG5cblxuLy8gQSB0cmFuc2l0aW9uIGNvbnRhaW5pbmcgYSBzZXQgb2YgdmFsdWVzLlxuZnVuY3Rpb24gU2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0dGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uU0VUO1xuICAgIGlmIChzZXQgIT09dW5kZWZpbmVkICYmIHNldCAhPT1udWxsKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgICB0aGlzLmxhYmVsLmFkZE9uZShUb2tlbi5JTlZBTElEX1RZUEUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zaXRpb24ucHJvdG90eXBlKTtcblNldFRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0VHJhbnNpdGlvbjtcblxuU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gdGhpcy5sYWJlbC5jb250YWlucyhzeW1ib2wpO1xufTtcblxuXG5TZXRUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sYWJlbC50b1N0cmluZygpO1xufTtcblxuZnVuY3Rpb24gTm90U2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldCkge1xuXHRTZXRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0LCBzZXQpO1xuXHR0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5OT1RfU0VUO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuTm90U2V0VHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNldFRyYW5zaXRpb24ucHJvdG90eXBlKTtcbk5vdFNldFRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm90U2V0VHJhbnNpdGlvbjtcblxuTm90U2V0VHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gc3ltYm9sID49IG1pblZvY2FiU3ltYm9sICYmIHN5bWJvbCA8PSBtYXhWb2NhYlN5bWJvbCAmJlxuXHRcdFx0IVNldFRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMuY2FsbCh0aGlzLCBzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCk7XG59O1xuXG5Ob3RTZXRUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gJ34nICsgU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIFdpbGRjYXJkVHJhbnNpdGlvbih0YXJnZXQpIHtcblx0VHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLldJTERDQVJEO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuV2lsZGNhcmRUcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuV2lsZGNhcmRUcmFuc2l0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdpbGRjYXJkVHJhbnNpdGlvbjtcblxuXG5XaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCAgbWF4Vm9jYWJTeW1ib2wpIHtcblx0cmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2w7XG59O1xuXG5XaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIi5cIjtcbn07XG5cbmZ1bmN0aW9uIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgcHJlY2VkZW5jZSkge1xuXHRBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLlBSRUNFREVOQ0U7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbjtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCAgbWF4Vm9jYWJTeW1ib2wpIHtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmdldFByZWRpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IFByZWNlZGVuY2VQcmVkaWNhdGUodGhpcy5wcmVjZWRlbmNlKTtcbn07XG5cblByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wcmVjZWRlbmNlICsgXCIgPj0gX3BcIjtcbn07XG5cbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5leHBvcnRzLkF0b21UcmFuc2l0aW9uID0gQXRvbVRyYW5zaXRpb247XG5leHBvcnRzLlNldFRyYW5zaXRpb24gPSBTZXRUcmFuc2l0aW9uO1xuZXhwb3J0cy5Ob3RTZXRUcmFuc2l0aW9uID0gTm90U2V0VHJhbnNpdGlvbjtcbmV4cG9ydHMuUnVsZVRyYW5zaXRpb24gPSBSdWxlVHJhbnNpdGlvbjtcbmV4cG9ydHMuQWN0aW9uVHJhbnNpdGlvbiA9IEFjdGlvblRyYW5zaXRpb247XG5leHBvcnRzLkVwc2lsb25UcmFuc2l0aW9uID0gRXBzaWxvblRyYW5zaXRpb247XG5leHBvcnRzLlJhbmdlVHJhbnNpdGlvbiA9IFJhbmdlVHJhbnNpdGlvbjtcbmV4cG9ydHMuV2lsZGNhcmRUcmFuc2l0aW9uID0gV2lsZGNhcmRUcmFuc2l0aW9uO1xuZXhwb3J0cy5QcmVkaWNhdGVUcmFuc2l0aW9uID0gUHJlZGljYXRlVHJhbnNpdGlvbjtcbmV4cG9ydHMuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gPSBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbjtcbmV4cG9ydHMuQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uID0gQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vVHJhbnNpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG4vL1xuLy8gU3BlY2lhbGl6ZWQge0BsaW5rIFNldH17QGNvZGUgPH17QGxpbmsgQVROQ29uZmlnfXtAY29kZSA+fSB0aGF0IGNhbiB0cmFja1xuLy8gaW5mbyBhYm91dCB0aGUgc2V0LCB3aXRoIHN1cHBvcnQgZm9yIGNvbWJpbmluZyBzaW1pbGFyIGNvbmZpZ3VyYXRpb25zIHVzaW5nIGFcbi8vIGdyYXBoLXN0cnVjdHVyZWQgc3RhY2suXG4vLy9cblxudmFyIEFUTiA9IHJlcXVpcmUoJy4vQVROJykuQVROO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi8uLi9VdGlscycpO1xudmFyIEhhc2ggPSBVdGlscy5IYXNoO1xudmFyIFNldCA9IFV0aWxzLlNldDtcbnZhciBTZW1hbnRpY0NvbnRleHQgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlNlbWFudGljQ29udGV4dDtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5tZXJnZTtcblxuZnVuY3Rpb24gaGFzaEFUTkNvbmZpZyhjKSB7XG5cdHJldHVybiBjLmhhc2hDb2RlRm9yQ29uZmlnU2V0KCk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsQVROQ29uZmlncyhhLCBiKSB7XG5cdGlmICggYT09PWIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSBpZiAoIGE9PT1udWxsIHx8IGI9PT1udWxsICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlXG4gICAgICAgcmV0dXJuIGEuZXF1YWxzRm9yQ29uZmlnU2V0KGIpO1xuIH1cblxuXG5mdW5jdGlvbiBBVE5Db25maWdTZXQoZnVsbEN0eCkge1xuXHQvL1xuXHQvLyBUaGUgcmVhc29uIHRoYXQgd2UgbmVlZCB0aGlzIGlzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0aGUgaGFzaCBtYXAgdG8gdXNlXG5cdC8vIHRoZSBzdGFuZGFyZCBoYXNoIGNvZGUgYW5kIGVxdWFscy4gV2UgbmVlZCBhbGwgY29uZmlndXJhdGlvbnMgd2l0aCB0aGVcblx0Ly8gc2FtZVxuXHQvLyB7QGNvZGUgKHMsaSxfLHNlbWN0eCl9IHRvIGJlIGVxdWFsLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGtleSBlZmZlY3RpdmVseVxuXHQvLyBkb3VibGVzXG5cdC8vIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggQVROQ29uZmlncy4gVGhlIG90aGVyIHNvbHV0aW9uIGlzXG5cdC8vIHRvXG5cdC8vIHVzZSBhIGhhc2ggdGFibGUgdGhhdCBsZXRzIHVzIHNwZWNpZnkgdGhlIGVxdWFscy9oYXNoY29kZSBvcGVyYXRpb24uXG5cdC8vIEFsbCBjb25maWdzIGJ1dCBoYXNoZWQgYnkgKHMsIGksIF8sIHBpKSBub3QgaW5jbHVkaW5nIGNvbnRleHQuIFdpcGVkIG91dFxuXHQvLyB3aGVuIHdlIGdvIHJlYWRvbmx5IGFzIHRoaXMgc2V0IGJlY29tZXMgYSBERkEgc3RhdGUuXG5cdHRoaXMuY29uZmlnTG9va3VwID0gbmV3IFNldChoYXNoQVROQ29uZmlnLCBlcXVhbEFUTkNvbmZpZ3MpO1xuXHQvLyBJbmRpY2F0ZXMgdGhhdCB0aGlzIGNvbmZpZ3VyYXRpb24gc2V0IGlzIHBhcnQgb2YgYSBmdWxsIGNvbnRleHRcblx0Ly8gTEwgcHJlZGljdGlvbi4gSXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gbWVyZ2UgJC4gV2l0aCBTTExcblx0Ly8gaXQncyBhIHdpbGRjYXJkIHdoZXJlYXMgaXQgaXMgbm90IGZvciBMTCBjb250ZXh0IG1lcmdlLlxuXHR0aGlzLmZ1bGxDdHggPSBmdWxsQ3R4ID09PSB1bmRlZmluZWQgPyB0cnVlIDogZnVsbEN0eDtcblx0Ly8gSW5kaWNhdGVzIHRoYXQgdGhlIHNldCBvZiBjb25maWd1cmF0aW9ucyBpcyByZWFkLW9ubHkuIERvIG5vdFxuXHQvLyBhbGxvdyBhbnkgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBzZXQ7IERGQSBzdGF0ZXMgd2lsbCBwb2ludCBhdFxuXHQvLyB0aGUgc2V0cyBhbmQgdGhleSBtdXN0IG5vdCBjaGFuZ2UuIFRoaXMgZG9lcyBub3QgcHJvdGVjdCB0aGUgb3RoZXJcblx0Ly8gZmllbGRzOyBpbiBwYXJ0aWN1bGFyLCBjb25mbGljdGluZ0FsdHMgaXMgc2V0IGFmdGVyXG5cdC8vIHdlJ3ZlIG1hZGUgdGhpcyByZWFkb25seS5cblx0dGhpcy5yZWFkT25seSA9IGZhbHNlO1xuXHQvLyBUcmFjayB0aGUgZWxlbWVudHMgYXMgdGhleSBhcmUgYWRkZWQgdG8gdGhlIHNldDsgc3VwcG9ydHMgZ2V0KGkpLy8vXG5cdHRoaXMuY29uZmlncyA9IFtdO1xuXG5cdC8vIFRPRE86IHRoZXNlIGZpZWxkcyBtYWtlIG1lIHByZXR0eSB1bmNvbWZvcnRhYmxlIGJ1dCBuaWNlIHRvIHBhY2sgdXAgaW5mb1xuXHQvLyB0b2dldGhlciwgc2F2ZXMgcmVjb21wdXRhdGlvblxuXHQvLyBUT0RPOiBjYW4gd2UgdHJhY2sgY29uZmxpY3RzIGFzIHRoZXkgYXJlIGFkZGVkIHRvIHNhdmUgc2Nhbm5pbmcgY29uZmlnc1xuXHQvLyBsYXRlcj9cblx0dGhpcy51bmlxdWVBbHQgPSAwO1xuXHR0aGlzLmNvbmZsaWN0aW5nQWx0cyA9IG51bGw7XG5cblx0Ly8gVXNlZCBpbiBwYXJzZXIgYW5kIGxleGVyLiBJbiBsZXhlciwgaXQgaW5kaWNhdGVzIHdlIGhpdCBhIHByZWRcblx0Ly8gd2hpbGUgY29tcHV0aW5nIGEgY2xvc3VyZSBvcGVyYXRpb24uIERvbid0IG1ha2UgYSBERkEgc3RhdGUgZnJvbSB0aGlzLlxuXHR0aGlzLmhhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xuXHR0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID0gZmFsc2U7XG5cblx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IC0xO1xuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGRpbmcgYSBuZXcgY29uZmlnIG1lYW5zIG1lcmdpbmcgY29udGV4dHMgd2l0aCBleGlzdGluZyBjb25maWdzIGZvclxuLy8ge0Bjb2RlIChzLCBpLCBwaSwgXyl9LCB3aGVyZSB7QGNvZGUgc30gaXMgdGhlXG4vLyB7QGxpbmsgQVROQ29uZmlnLy9zdGF0ZX0sIHtAY29kZSBpfSBpcyB0aGUge0BsaW5rIEFUTkNvbmZpZy8vYWx0fSwgYW5kXG4vLyB7QGNvZGUgcGl9IGlzIHRoZSB7QGxpbmsgQVROQ29uZmlnLy9zZW1hbnRpY0NvbnRleHR9LiBXZSB1c2Vcbi8vIHtAY29kZSAocyxpLHBpKX0gYXMga2V5LlxuLy9cbi8vIDxwPlRoaXMgbWV0aG9kIHVwZGF0ZXMge0BsaW5rIC8vZGlwc0ludG9PdXRlckNvbnRleHR9IGFuZFxuLy8ge0BsaW5rIC8vaGFzU2VtYW50aWNDb250ZXh0fSB3aGVuIG5lY2Vzc2FyeS48L3A+XG4vLyAvXG5BVE5Db25maWdTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbmZpZywgbWVyZ2VDYWNoZSkge1xuXHRpZiAobWVyZ2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bWVyZ2VDYWNoZSA9IG51bGw7XG5cdH1cblx0aWYgKHRoaXMucmVhZE9ubHkpIHtcblx0XHR0aHJvdyBcIlRoaXMgc2V0IGlzIHJlYWRvbmx5XCI7XG5cdH1cblx0aWYgKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG5cdFx0dGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgPSB0cnVlO1xuXHR9XG5cdGlmIChjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPiAwKSB7XG5cdFx0dGhpcy5kaXBzSW50b091dGVyQ29udGV4dCA9IHRydWU7XG5cdH1cblx0dmFyIGV4aXN0aW5nID0gdGhpcy5jb25maWdMb29rdXAuYWRkKGNvbmZpZyk7XG5cdGlmIChleGlzdGluZyA9PT0gY29uZmlnKSB7XG5cdFx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IC0xO1xuXHRcdHRoaXMuY29uZmlncy5wdXNoKGNvbmZpZyk7IC8vIHRyYWNrIG9yZGVyIGhlcmVcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHQvLyBhIHByZXZpb3VzIChzLGkscGksXyksIG1lcmdlIHdpdGggaXQgYW5kIHNhdmUgcmVzdWx0XG5cdHZhciByb290SXNXaWxkY2FyZCA9ICF0aGlzLmZ1bGxDdHg7XG5cdHZhciBtZXJnZWQgPSBtZXJnZShleGlzdGluZy5jb250ZXh0LCBjb25maWcuY29udGV4dCwgcm9vdElzV2lsZGNhcmQsIG1lcmdlQ2FjaGUpO1xuXHQvLyBubyBuZWVkIHRvIGNoZWNrIGZvciBleGlzdGluZy5jb250ZXh0LCBjb25maWcuY29udGV4dCBpbiBjYWNoZVxuXHQvLyBzaW5jZSBvbmx5IHdheSB0byBjcmVhdGUgbmV3IGdyYXBocyBpcyBcImNhbGwgcnVsZVwiIGFuZCBoZXJlLiBXZVxuXHQvLyBjYWNoZSBhdCBib3RoIHBsYWNlcy5cblx0ZXhpc3RpbmcucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPSBNYXRoLm1heCggZXhpc3RpbmcucmVhY2hlc0ludG9PdXRlckNvbnRleHQsIGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCk7XG5cdC8vIG1ha2Ugc3VyZSB0byBwcmVzZXJ2ZSB0aGUgcHJlY2VkZW5jZSBmaWx0ZXIgc3VwcHJlc3Npb24gZHVyaW5nIHRoZSBtZXJnZVxuXHRpZiAoY29uZmlnLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XG5cdFx0ZXhpc3RpbmcucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xuXHR9XG5cdGV4aXN0aW5nLmNvbnRleHQgPSBtZXJnZWQ7IC8vIHJlcGxhY2UgY29udGV4dDsgbm8gbmVlZCB0byBhbHQgbWFwcGluZ1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuZ2V0U3RhdGVzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzdGF0ZXMgPSBuZXcgU2V0KCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c3RhdGVzLmFkZCh0aGlzLmNvbmZpZ3NbaV0uc3RhdGUpO1xuXHR9XG5cdHJldHVybiBzdGF0ZXM7XG59O1xuXG5BVE5Db25maWdTZXQucHJvdG90eXBlLmdldFByZWRpY2F0ZXMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHByZWRzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGMgPSB0aGlzLmNvbmZpZ3NbaV0uc2VtYW50aWNDb250ZXh0O1xuXHRcdGlmIChjICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuXHRcdFx0cHJlZHMucHVzaChjLnNlbWFudGljQ29udGV4dCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBwcmVkcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBVE5Db25maWdTZXQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlncztcblx0fVxufSk7XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUub3B0aW1pemVDb25maWdzID0gZnVuY3Rpb24oaW50ZXJwcmV0ZXIpIHtcblx0aWYgKHRoaXMucmVhZE9ubHkpIHtcblx0XHR0aHJvdyBcIlRoaXMgc2V0IGlzIHJlYWRvbmx5XCI7XG5cdH1cblx0aWYgKHRoaXMuY29uZmlnTG9va3VwLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uZmlncy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjb25maWcgPSB0aGlzLmNvbmZpZ3NbaV07XG5cdFx0Y29uZmlnLmNvbnRleHQgPSBpbnRlcnByZXRlci5nZXRDYWNoZWRDb250ZXh0KGNvbmZpZy5jb250ZXh0KTtcblx0fVxufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbihjb2xsKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29sbC5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuYWRkKGNvbGxbaV0pO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0cmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG5cdFx0KG90aGVyIGluc3RhbmNlb2YgQVROQ29uZmlnU2V0ICYmXG5cdFx0VXRpbHMuZXF1YWxBcnJheXModGhpcy5jb25maWdzLCBvdGhlci5jb25maWdzKSAmJlxuXHRcdHRoaXMuZnVsbEN0eCA9PT0gb3RoZXIuZnVsbEN0eCAmJlxuXHRcdHRoaXMudW5pcXVlQWx0ID09PSBvdGhlci51bmlxdWVBbHQgJiZcblx0XHR0aGlzLmNvbmZsaWN0aW5nQWx0cyA9PT0gb3RoZXIuY29uZmxpY3RpbmdBbHRzICYmXG5cdFx0dGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgPT09IG90aGVyLmhhc1NlbWFudGljQ29udGV4dCAmJlxuXHRcdHRoaXMuZGlwc0ludG9PdXRlckNvbnRleHQgPT09IG90aGVyLmRpcHNJbnRvT3V0ZXJDb250ZXh0KTtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBIYXNoKCk7XG4gICAgdGhpcy51cGRhdGVIYXNoQ29kZShoYXNoKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn07XG5cblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcblx0aWYgKHRoaXMucmVhZE9ubHkpIHtcblx0XHRpZiAodGhpcy5jYWNoZWRIYXNoQ29kZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcbiAgICAgICAgICAgIGhhc2gudXBkYXRlKHRoaXMuY29uZmlncyk7XG5cdFx0XHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gaGFzaC5maW5pc2goKTtcblx0XHR9XG4gICAgICAgIGhhc2gudXBkYXRlKHRoaXMuY2FjaGVkSGFzaENvZGUpO1xuXHR9IGVsc2Uge1xuICAgICAgICBoYXNoLnVwZGF0ZSh0aGlzLmNvbmZpZ3MpO1xuXHR9XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoO1xuXHR9XG59KTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoID09PSAwO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0aWYgKHRoaXMuY29uZmlnTG9va3VwID09PSBudWxsKSB7XG5cdFx0dGhyb3cgXCJUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHJlYWRvbmx5IHNldHMuXCI7XG5cdH1cblx0cmV0dXJuIHRoaXMuY29uZmlnTG9va3VwLmNvbnRhaW5zKGl0ZW0pO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5jb250YWluc0Zhc3QgPSBmdW5jdGlvbihpdGVtKSB7XG5cdGlmICh0aGlzLmNvbmZpZ0xvb2t1cCA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwiVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGZvciByZWFkb25seSBzZXRzLlwiO1xuXHR9XG5cdHJldHVybiB0aGlzLmNvbmZpZ0xvb2t1cC5jb250YWluc0Zhc3QoaXRlbSk7XG59O1xuXG5BVE5Db25maWdTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnJlYWRPbmx5KSB7XG5cdFx0dGhyb3cgXCJUaGlzIHNldCBpcyByZWFkb25seVwiO1xuXHR9XG5cdHRoaXMuY29uZmlncyA9IFtdO1xuXHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG5cdHRoaXMuY29uZmlnTG9va3VwID0gbmV3IFNldCgpO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5zZXRSZWFkb25seSA9IGZ1bmN0aW9uKHJlYWRPbmx5KSB7XG5cdHRoaXMucmVhZE9ubHkgPSByZWFkT25seTtcblx0aWYgKHJlYWRPbmx5KSB7XG5cdFx0dGhpcy5jb25maWdMb29rdXAgPSBudWxsOyAvLyBjYW4ndCBtb2QsIG5vIG5lZWQgZm9yIGxvb2t1cCBjYWNoZVxuXHR9XG59O1xuXG5BVE5Db25maWdTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBVdGlscy5hcnJheVRvU3RyaW5nKHRoaXMuY29uZmlncykgK1xuXHRcdCh0aGlzLmhhc1NlbWFudGljQ29udGV4dCA/IFwiLGhhc1NlbWFudGljQ29udGV4dD1cIiArIHRoaXMuaGFzU2VtYW50aWNDb250ZXh0IDogXCJcIikgK1xuXHRcdCh0aGlzLnVuaXF1ZUFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUiA/IFwiLHVuaXF1ZUFsdD1cIiArIHRoaXMudW5pcXVlQWx0IDogXCJcIikgK1xuXHRcdCh0aGlzLmNvbmZsaWN0aW5nQWx0cyAhPT0gbnVsbCA/IFwiLGNvbmZsaWN0aW5nQWx0cz1cIiArIHRoaXMuY29uZmxpY3RpbmdBbHRzIDogXCJcIikgK1xuXHRcdCh0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID8gXCIsZGlwc0ludG9PdXRlckNvbnRleHRcIiA6IFwiXCIpO1xufTtcblxuZnVuY3Rpb24gT3JkZXJlZEFUTkNvbmZpZ1NldCgpIHtcblx0QVROQ29uZmlnU2V0LmNhbGwodGhpcyk7XG5cdHRoaXMuY29uZmlnTG9va3VwID0gbmV3IFNldCgpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuT3JkZXJlZEFUTkNvbmZpZ1NldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTkNvbmZpZ1NldC5wcm90b3R5cGUpO1xuT3JkZXJlZEFUTkNvbmZpZ1NldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkQVROQ29uZmlnU2V0O1xuXG5leHBvcnRzLkFUTkNvbmZpZ1NldCA9IEFUTkNvbmZpZ1NldDtcbmV4cG9ydHMuT3JkZXJlZEFUTkNvbmZpZ1NldCA9IE9yZGVyZWRBVE5Db25maWdTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTkNvbmZpZ1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy8gQSB0cmVlIHN0cnVjdHVyZSB1c2VkIHRvIHJlY29yZCB0aGUgc2VtYW50aWMgY29udGV4dCBpbiB3aGljaFxuLy8gIGFuIEFUTiBjb25maWd1cmF0aW9uIGlzIHZhbGlkLiAgSXQncyBlaXRoZXIgYSBzaW5nbGUgcHJlZGljYXRlLFxuLy8gIGEgY29uanVuY3Rpb24ge0Bjb2RlIHAxJiZwMn0sIG9yIGEgc3VtIG9mIHByb2R1Y3RzIHtAY29kZSBwMXx8cDJ9LlxuLy9cbi8vICA8cD5JIGhhdmUgc2NvcGVkIHRoZSB7QGxpbmsgQU5EfSwge0BsaW5rIE9SfSwgYW5kIHtAbGluayBQcmVkaWNhdGV9IHN1YmNsYXNzZXMgb2Zcbi8vICB7QGxpbmsgU2VtYW50aWNDb250ZXh0fSB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoaXMgb3V0ZXIgY2xhc3MuPC9wPlxuLy9cblxudmFyIFNldCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5TZXQ7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5IYXNoO1xuXG5mdW5jdGlvbiBTZW1hbnRpY0NvbnRleHQoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5TZW1hbnRpY0NvbnRleHQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgIHRoaXMudXBkYXRlSGFzaENvZGUoaGFzaCk7XG4gICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG59O1xuXG4vLyBGb3IgY29udGV4dCBpbmRlcGVuZGVudCBwcmVkaWNhdGVzLCB3ZSBldmFsdWF0ZSB0aGVtIHdpdGhvdXQgYSBsb2NhbFxuLy8gY29udGV4dCAoaS5lLiwgbnVsbCBjb250ZXh0KS4gVGhhdCB3YXksIHdlIGNhbiBldmFsdWF0ZSB0aGVtIHdpdGhvdXRcbi8vIGhhdmluZyB0byBjcmVhdGUgcHJvcGVyIHJ1bGUtc3BlY2lmaWMgY29udGV4dCBkdXJpbmcgcHJlZGljdGlvbiAoYXNcbi8vIG9wcG9zZWQgdG8gdGhlIHBhcnNlciwgd2hpY2ggY3JlYXRlcyB0aGVtIG5hdHVyYWxseSkuIEluIGEgcHJhY3RpY2FsXG4vLyBzZW5zZSwgdGhpcyBhdm9pZHMgYSBjYXN0IGV4Y2VwdGlvbiBmcm9tIFJ1bGVDb250ZXh0IHRvIG15cnVsZUNvbnRleHQuXG4vL1xuLy8gPHA+Rm9yIGNvbnRleHQgZGVwZW5kZW50IHByZWRpY2F0ZXMsIHdlIG11c3QgcGFzcyBpbiBhIGxvY2FsIGNvbnRleHQgc28gdGhhdFxuLy8gcmVmZXJlbmNlcyBzdWNoIGFzICRhcmcgZXZhbHVhdGUgcHJvcGVybHkgYXMgX2xvY2FsY3R4LmFyZy4gV2Ugb25seVxuLy8gY2FwdHVyZSBjb250ZXh0IGRlcGVuZGVudCBwcmVkaWNhdGVzIGluIHRoZSBjb250ZXh0IGluIHdoaWNoIHdlIGJlZ2luXG4vLyBwcmVkaWN0aW9uLCBzbyB3ZSBwYXNzZWQgaW4gdGhlIG91dGVyIGNvbnRleHQgaGVyZSBpbiBjYXNlIG9mIGNvbnRleHRcbi8vIGRlcGVuZGVudCBwcmVkaWNhdGUgZXZhbHVhdGlvbi48L3A+XG4vL1xuU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG59O1xuXG4vL1xuLy8gRXZhbHVhdGUgdGhlIHByZWNlZGVuY2UgcHJlZGljYXRlcyBmb3IgdGhlIGNvbnRleHQgYW5kIHJlZHVjZSB0aGUgcmVzdWx0LlxuLy9cbi8vIEBwYXJhbSBwYXJzZXIgVGhlIHBhcnNlciBpbnN0YW5jZS5cbi8vIEBwYXJhbSBvdXRlckNvbnRleHQgVGhlIGN1cnJlbnQgcGFyc2VyIGNvbnRleHQgb2JqZWN0LlxuLy8gQHJldHVybiBUaGUgc2ltcGxpZmllZCBzZW1hbnRpYyBjb250ZXh0IGFmdGVyIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmVcbi8vIGV2YWx1YXRlZCwgd2hpY2ggd2lsbCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXMuXG4vLyA8dWw+XG4vLyA8bGk+e0BsaW5rIC8vTk9ORX06IGlmIHRoZSBwcmVkaWNhdGUgc2ltcGxpZmllcyB0byB7QGNvZGUgdHJ1ZX0gYWZ0ZXJcbi8vIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmUgZXZhbHVhdGVkLjwvbGk+XG4vLyA8bGk+e0Bjb2RlIG51bGx9OiBpZiB0aGUgcHJlZGljYXRlIHNpbXBsaWZpZXMgdG8ge0Bjb2RlIGZhbHNlfSBhZnRlclxuLy8gcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuPC9saT5cbi8vIDxsaT57QGNvZGUgdGhpc306IGlmIHRoZSBzZW1hbnRpYyBjb250ZXh0IGlzIG5vdCBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mXG4vLyBwcmVjZWRlbmNlIHByZWRpY2F0ZSBldmFsdWF0aW9uLjwvbGk+XG4vLyA8bGk+QSBub24te0Bjb2RlIG51bGx9IHtAbGluayBTZW1hbnRpY0NvbnRleHR9OiB0aGUgbmV3IHNpbXBsaWZpZWRcbi8vIHNlbWFudGljIGNvbnRleHQgYWZ0ZXIgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuPC9saT5cbi8vIDwvdWw+XG4vL1xuU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHJldHVybiB0aGlzO1xufTtcblxuU2VtYW50aWNDb250ZXh0LmFuZENvbnRleHQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChhID09PSBudWxsIHx8IGEgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKGIgPT09IG51bGwgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRyZXR1cm4gYTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gbmV3IEFORChhLCBiKTtcblx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gcmVzdWx0Lm9wbmRzWzBdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cblNlbWFudGljQ29udGV4dC5vckNvbnRleHQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChhID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKGIgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRpZiAoYSA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XG5cdH1cblx0dmFyIHJlc3VsdCA9IG5ldyBPUihhLCBiKTtcblx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gcmVzdWx0Lm9wbmRzWzBdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIFByZWRpY2F0ZShydWxlSW5kZXgsIHByZWRJbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4ID09PSB1bmRlZmluZWQgPyAtMSA6IHJ1bGVJbmRleDtcblx0dGhpcy5wcmVkSW5kZXggPSBwcmVkSW5kZXggPT09IHVuZGVmaW5lZCA/IC0xIDogcHJlZEluZGV4O1xuXHR0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogaXNDdHhEZXBlbmRlbnQ7IC8vIGUuZy4sICRpIHJlZiBpbiBwcmVkXG5cdHJldHVybiB0aGlzO1xufVxuXG5QcmVkaWNhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTZW1hbnRpY0NvbnRleHQucHJvdG90eXBlKTtcblByZWRpY2F0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVkaWNhdGU7XG5cbi8vVGhlIGRlZmF1bHQge0BsaW5rIFNlbWFudGljQ29udGV4dH0sIHdoaWNoIGlzIHNlbWFudGljYWxseSBlcXVpdmFsZW50IHRvXG4vL2EgcHJlZGljYXRlIG9mIHRoZSBmb3JtIHtAY29kZSB7dHJ1ZX0/fS5cbi8vXG5TZW1hbnRpY0NvbnRleHQuTk9ORSA9IG5ldyBQcmVkaWNhdGUoKTtcblxuXG5QcmVkaWNhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24ocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcblx0dmFyIGxvY2FsY3R4ID0gdGhpcy5pc0N0eERlcGVuZGVudCA/IG91dGVyQ29udGV4dCA6IG51bGw7XG5cdHJldHVybiBwYXJzZXIuc2VtcHJlZChsb2NhbGN0eCwgdGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4KTtcbn07XG5cblByZWRpY2F0ZS5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG5cdGhhc2gudXBkYXRlKHRoaXMucnVsZUluZGV4LCB0aGlzLnByZWRJbmRleCwgdGhpcy5pc0N0eERlcGVuZGVudCk7XG59O1xuXG5QcmVkaWNhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQcmVkaWNhdGUpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLnJ1bGVJbmRleCA9PT0gb3RoZXIucnVsZUluZGV4ICYmXG5cdFx0XHRcdHRoaXMucHJlZEluZGV4ID09PSBvdGhlci5wcmVkSW5kZXggJiZcblx0XHRcdFx0dGhpcy5pc0N0eERlcGVuZGVudCA9PT0gb3RoZXIuaXNDdHhEZXBlbmRlbnQ7XG5cdH1cbn07XG5cblByZWRpY2F0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwie1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMucHJlZEluZGV4ICsgXCJ9P1wiO1xufTtcblxuZnVuY3Rpb24gUHJlY2VkZW5jZVByZWRpY2F0ZShwcmVjZWRlbmNlKSB7XG5cdFNlbWFudGljQ29udGV4dC5jYWxsKHRoaXMpO1xuXHR0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlID09PSB1bmRlZmluZWQgPyAwIDogcHJlY2VkZW5jZTtcbn1cblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNlbWFudGljQ29udGV4dC5wcm90b3R5cGUpO1xuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVjZWRlbmNlUHJlZGljYXRlO1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHJldHVybiBwYXJzZXIucHJlY3ByZWQob3V0ZXJDb250ZXh0LCB0aGlzLnByZWNlZGVuY2UpO1xufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuZXZhbFByZWNlZGVuY2UgPSBmdW5jdGlvbihwYXJzZXIsIG91dGVyQ29udGV4dCkge1xuXHRpZiAocGFyc2VyLnByZWNwcmVkKG91dGVyQ29udGV4dCwgdGhpcy5wcmVjZWRlbmNlKSkge1xuXHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSAtIG90aGVyLnByZWNlZGVuY2U7XG59O1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSgzMSk7XG59O1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHRpZiAodGhpcyA9PT0gb3RoZXIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJlY2VkZW5jZVByZWRpY2F0ZSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSA9PT0gb3RoZXIucHJlY2VkZW5jZTtcblx0fVxufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwie1wiK3RoaXMucHJlY2VkZW5jZStcIj49cHJlY30/XCI7XG59O1xuXG5cblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5maWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyA9IGZ1bmN0aW9uKHNldCkge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHNldC52YWx1ZXMoKS5tYXAoIGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRpZiAoY29udGV4dCBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpIHtcblx0XHRcdHJlc3VsdC5wdXNoKGNvbnRleHQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIEEgc2VtYW50aWMgY29udGV4dCB3aGljaCBpcyB0cnVlIHdoZW5ldmVyIG5vbmUgb2YgdGhlIGNvbnRhaW5lZCBjb250ZXh0c1xuLy8gaXMgZmFsc2UuXG4vL1xuZnVuY3Rpb24gQU5EKGEsIGIpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHZhciBvcGVyYW5kcyA9IG5ldyBTZXQoKTtcblx0aWYgKGEgaW5zdGFuY2VvZiBBTkQpIHtcblx0XHRhLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0XHRvcGVyYW5kcy5hZGQobyk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3BlcmFuZHMuYWRkKGEpO1xuXHR9XG5cdGlmIChiIGluc3RhbmNlb2YgQU5EKSB7XG5cdFx0Yi5vcG5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdFx0b3BlcmFuZHMuYWRkKG8pO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9wZXJhbmRzLmFkZChiKTtcblx0fVxuXHR2YXIgcHJlY2VkZW5jZVByZWRpY2F0ZXMgPSBQcmVjZWRlbmNlUHJlZGljYXRlLmZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKG9wZXJhbmRzKTtcblx0aWYgKHByZWNlZGVuY2VQcmVkaWNhdGVzLmxlbmd0aCA+IDApIHtcblx0XHQvLyBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIGxvd2VzdCBwcmVjZWRlbmNlXG5cdFx0dmFyIHJlZHVjZWQgPSBudWxsO1xuXHRcdHByZWNlZGVuY2VQcmVkaWNhdGVzLm1hcCggZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYocmVkdWNlZD09PW51bGwgfHwgcC5wcmVjZWRlbmNlPHJlZHVjZWQucHJlY2VkZW5jZSkge1xuXHRcdFx0XHRyZWR1Y2VkID0gcDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRvcGVyYW5kcy5hZGQocmVkdWNlZCk7XG5cdH1cblx0dGhpcy5vcG5kcyA9IG9wZXJhbmRzLnZhbHVlcygpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQU5ELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZSk7XG5BTkQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQU5EO1xuXG5BTkQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBTkQpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLm9wbmRzID09PSBvdGhlci5vcG5kcztcblx0fVxufTtcblxuQU5ELnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLm9wbmRzLCBcIkFORFwiKTtcbn07XG4vL1xuLy8ge0Bpbmhlcml0RG9jfVxuLy9cbi8vIDxwPlxuLy8gVGhlIGV2YWx1YXRpb24gb2YgcHJlZGljYXRlcyBieSB0aGlzIGNvbnRleHQgaXMgc2hvcnQtY2lyY3VpdGluZywgYnV0XG4vLyB1bm9yZGVyZWQuPC9wPlxuLy9cbkFORC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihwYXJzZXIsIG91dGVyQ29udGV4dCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIXRoaXMub3BuZHNbaV0uZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcblxuQU5ELnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHZhciBkaWZmZXJzID0gZmFsc2U7XG5cdHZhciBvcGVyYW5kcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXMub3BuZHNbaV07XG5cdFx0dmFyIGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpO1xuXHRcdGRpZmZlcnMgfD0gKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XG5cdFx0aWYgKGV2YWx1YXRlZCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gVGhlIEFORCBjb250ZXh0IGlzIGZhbHNlIGlmIGFueSBlbGVtZW50IGlzIGZhbHNlXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGV2YWx1YXRlZCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRcdC8vIFJlZHVjZSB0aGUgcmVzdWx0IGJ5IHNraXBwaW5nIHRydWUgZWxlbWVudHNcblx0XHRcdG9wZXJhbmRzLnB1c2goZXZhbHVhdGVkKTtcblx0XHR9XG5cdH1cblx0aWYgKCFkaWZmZXJzKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdC8vIGFsbCBlbGVtZW50cyB3ZXJlIHRydWUsIHNvIHRoZSBBTkQgY29udGV4dCBpcyB0cnVlXG5cdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xuXHR9XG5cdHZhciByZXN1bHQgPSBudWxsO1xuXHRvcGVyYW5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdHJlc3VsdCA9IHJlc3VsdCA9PT0gbnVsbCA/IG8gOiBTZW1hbnRpY0NvbnRleHQuYW5kQ29udGV4dChyZXN1bHQsIG8pO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbkFORC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHMgPSBcIlwiO1xuXHR0aGlzLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0cyArPSBcIiYmIFwiICsgby50b1N0cmluZygpO1xuXHR9KTtcblx0cmV0dXJuIHMubGVuZ3RoID4gMyA/IHMuc2xpY2UoMykgOiBzO1xufTtcblxuLy9cbi8vIEEgc2VtYW50aWMgY29udGV4dCB3aGljaCBpcyB0cnVlIHdoZW5ldmVyIGF0IGxlYXN0IG9uZSBvZiB0aGUgY29udGFpbmVkXG4vLyBjb250ZXh0cyBpcyB0cnVlLlxuLy9cbmZ1bmN0aW9uIE9SKGEsIGIpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHZhciBvcGVyYW5kcyA9IG5ldyBTZXQoKTtcblx0aWYgKGEgaW5zdGFuY2VvZiBPUikge1xuXHRcdGEub3BuZHMubWFwKGZ1bmN0aW9uKG8pIHtcblx0XHRcdG9wZXJhbmRzLmFkZChvKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvcGVyYW5kcy5hZGQoYSk7XG5cdH1cblx0aWYgKGIgaW5zdGFuY2VvZiBPUikge1xuXHRcdGIub3BuZHMubWFwKGZ1bmN0aW9uKG8pIHtcblx0XHRcdG9wZXJhbmRzLmFkZChvKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvcGVyYW5kcy5hZGQoYik7XG5cdH1cblxuXHR2YXIgcHJlY2VkZW5jZVByZWRpY2F0ZXMgPSBQcmVjZWRlbmNlUHJlZGljYXRlLmZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKG9wZXJhbmRzKTtcblx0aWYgKHByZWNlZGVuY2VQcmVkaWNhdGVzLmxlbmd0aCA+IDApIHtcblx0XHQvLyBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdHZhciBzID0gcHJlY2VkZW5jZVByZWRpY2F0ZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5jb21wYXJlVG8oYik7XG5cdFx0fSk7XG5cdFx0dmFyIHJlZHVjZWQgPSBzW3MubGVuZ3RoLTFdO1xuXHRcdG9wZXJhbmRzLmFkZChyZWR1Y2VkKTtcblx0fVxuXHR0aGlzLm9wbmRzID0gb3BlcmFuZHMudmFsdWVzKCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5PUi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNlbWFudGljQ29udGV4dC5wcm90b3R5cGUpO1xuT1IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT1I7XG5cbk9SLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBPUikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMub3BuZHMgPT09IG90aGVyLm9wbmRzO1xuXHR9XG59O1xuXG5PUi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5vcG5kcywgXCJPUlwiKTtcbn07XG5cbi8vIDxwPlxuLy8gVGhlIGV2YWx1YXRpb24gb2YgcHJlZGljYXRlcyBieSB0aGlzIGNvbnRleHQgaXMgc2hvcnQtY2lyY3VpdGluZywgYnV0XG4vLyB1bm9yZGVyZWQuPC9wPlxuLy9cbk9SLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcG5kcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLm9wbmRzW2ldLmV2YWx1YXRlKHBhcnNlciwgb3V0ZXJDb250ZXh0KSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbk9SLnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHZhciBkaWZmZXJzID0gZmFsc2U7XG5cdHZhciBvcGVyYW5kcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXMub3BuZHNbaV07XG5cdFx0dmFyIGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpO1xuXHRcdGRpZmZlcnMgfD0gKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XG5cdFx0aWYgKGV2YWx1YXRlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRcdC8vIFRoZSBPUiBjb250ZXh0IGlzIHRydWUgaWYgYW55IGVsZW1lbnQgaXMgdHJ1ZVxuXHRcdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xuXHRcdH0gZWxzZSBpZiAoZXZhbHVhdGVkICE9PSBudWxsKSB7XG5cdFx0XHQvLyBSZWR1Y2UgdGhlIHJlc3VsdCBieSBza2lwcGluZyBmYWxzZSBlbGVtZW50c1xuXHRcdFx0b3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xuXHRcdH1cblx0fVxuXHRpZiAoIWRpZmZlcnMpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG5cdFx0Ly8gYWxsIGVsZW1lbnRzIHdlcmUgZmFsc2UsIHNvIHRoZSBPUiBjb250ZXh0IGlzIGZhbHNlXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIHJlc3VsdCA9IG51bGw7XG5cdG9wZXJhbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG8gOiBTZW1hbnRpY0NvbnRleHQub3JDb250ZXh0KHJlc3VsdCwgbyk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuT1IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzID0gXCJcIjtcblx0dGhpcy5vcG5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdHMgKz0gXCJ8fCBcIiArIG8udG9TdHJpbmcoKTtcblx0fSk7XG5cdHJldHVybiBzLmxlbmd0aCA+IDMgPyBzLnNsaWNlKDMpIDogcztcbn07XG5cbmV4cG9ydHMuU2VtYW50aWNDb250ZXh0ID0gU2VtYW50aWNDb250ZXh0O1xuZXhwb3J0cy5QcmVjZWRlbmNlUHJlZGljYXRlID0gUHJlY2VkZW5jZVByZWRpY2F0ZTtcbmV4cG9ydHMuUHJlZGljYXRlID0gUHJlZGljYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9TZW1hbnRpY0NvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG52YXIgQVROQ29uZmlnU2V0ID0gcmVxdWlyZSgnLi8uLi9hdG4vQVROQ29uZmlnU2V0JykuQVROQ29uZmlnU2V0O1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi8uLi9VdGlscycpO1xudmFyIEhhc2ggPSBVdGlscy5IYXNoO1xudmFyIFNldCA9IFV0aWxzLlNldDtcblxuLy8gTWFwIGEgcHJlZGljYXRlIHRvIGEgcHJlZGljdGVkIGFsdGVybmF0aXZlLi8vL1xuXG5mdW5jdGlvbiBQcmVkUHJlZGljdGlvbihwcmVkLCBhbHQpIHtcblx0dGhpcy5hbHQgPSBhbHQ7XG5cdHRoaXMucHJlZCA9IHByZWQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5QcmVkUHJlZGljdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5wcmVkICsgXCIsIFwiICsgdGhpcy5hbHQgKyBcIilcIjtcbn07XG5cbi8vIEEgREZBIHN0YXRlIHJlcHJlc2VudHMgYSBzZXQgb2YgcG9zc2libGUgQVROIGNvbmZpZ3VyYXRpb25zLlxuLy8gQXMgQWhvLCBTZXRoaSwgVWxsbWFuIHAuIDExNyBzYXlzIFwiVGhlIERGQSB1c2VzIGl0cyBzdGF0ZVxuLy8gdG8ga2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgc3RhdGVzIHRoZSBBVE4gY2FuIGJlIGluIGFmdGVyXG4vLyByZWFkaW5nIGVhY2ggaW5wdXQgc3ltYm9sLiBUaGF0IGlzIHRvIHNheSwgYWZ0ZXIgcmVhZGluZ1xuLy8gaW5wdXQgYTFhMi4uYW4sIHRoZSBERkEgaXMgaW4gYSBzdGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4vLyBzdWJzZXQgVCBvZiB0aGUgc3RhdGVzIG9mIHRoZSBBVE4gdGhhdCBhcmUgcmVhY2hhYmxlIGZyb20gdGhlXG4vLyBBVE4ncyBzdGFydCBzdGF0ZSBhbG9uZyBzb21lIHBhdGggbGFiZWxlZCBhMWEyLi5hbi5cIlxuLy8gSW4gY29udmVudGlvbmFsIE5GQSZyYXJyO0RGQSBjb252ZXJzaW9uLCB0aGVyZWZvcmUsIHRoZSBzdWJzZXQgVFxuLy8gd291bGQgYmUgYSBiaXRzZXQgcmVwcmVzZW50aW5nIHRoZSBzZXQgb2Ygc3RhdGVzIHRoZVxuLy8gQVROIGNvdWxkIGJlIGluLiBXZSBuZWVkIHRvIHRyYWNrIHRoZSBhbHQgcHJlZGljdGVkIGJ5IGVhY2hcbi8vIHN0YXRlIGFzIHdlbGwsIGhvd2V2ZXIuIE1vcmUgaW1wb3J0YW50bHksIHdlIG5lZWQgdG8gbWFpbnRhaW5cbi8vIGEgc3RhY2sgb2Ygc3RhdGVzLCB0cmFja2luZyB0aGUgY2xvc3VyZSBvcGVyYXRpb25zIGFzIHRoZXlcbi8vIGp1bXAgZnJvbSBydWxlIHRvIHJ1bGUsIGVtdWxhdGluZyBydWxlIGludm9jYXRpb25zIChtZXRob2QgY2FsbHMpLlxuLy8gSSBoYXZlIHRvIGFkZCBhIHN0YWNrIHRvIHNpbXVsYXRlIHRoZSBwcm9wZXIgbG9va2FoZWFkIHNlcXVlbmNlcyBmb3Jcbi8vIHRoZSB1bmRlcmx5aW5nIExMIGdyYW1tYXIgZnJvbSB3aGljaCB0aGUgQVROIHdhcyBkZXJpdmVkLlxuLy9cbi8vIDxwPkkgdXNlIGEgc2V0IG9mIEFUTkNvbmZpZyBvYmplY3RzIG5vdCBzaW1wbGUgc3RhdGVzLiBBbiBBVE5Db25maWdcbi8vIGlzIGJvdGggYSBzdGF0ZSAoYWxhIG5vcm1hbCBjb252ZXJzaW9uKSBhbmQgYSBSdWxlQ29udGV4dCBkZXNjcmliaW5nXG4vLyB0aGUgY2hhaW4gb2YgcnVsZXMgKGlmIGFueSkgZm9sbG93ZWQgdG8gYXJyaXZlIGF0IHRoYXQgc3RhdGUuPC9wPlxuLy9cbi8vIDxwPkEgREZBIHN0YXRlIG1heSBoYXZlIG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gYSBwYXJ0aWN1bGFyIHN0YXRlLFxuLy8gYnV0IHdpdGggZGlmZmVyZW50IEFUTiBjb250ZXh0cyAod2l0aCBzYW1lIG9yIGRpZmZlcmVudCBhbHRzKVxuLy8gbWVhbmluZyB0aGF0IHN0YXRlIHdhcyByZWFjaGVkIHZpYSBhIGRpZmZlcmVudCBzZXQgb2YgcnVsZSBpbnZvY2F0aW9ucy48L3A+XG4vLyAvXG5cbmZ1bmN0aW9uIERGQVN0YXRlKHN0YXRlTnVtYmVyLCBjb25maWdzKSB7XG5cdGlmIChzdGF0ZU51bWJlciA9PT0gbnVsbCkge1xuXHRcdHN0YXRlTnVtYmVyID0gLTE7XG5cdH1cblx0aWYgKGNvbmZpZ3MgPT09IG51bGwpIHtcblx0XHRjb25maWdzID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xuXHR9XG5cdHRoaXMuc3RhdGVOdW1iZXIgPSBzdGF0ZU51bWJlcjtcblx0dGhpcy5jb25maWdzID0gY29uZmlncztcblx0Ly8ge0Bjb2RlIGVkZ2VzW3N5bWJvbF19IHBvaW50cyB0byB0YXJnZXQgb2Ygc3ltYm9sLiBTaGlmdCB1cCBieSAxIHNvICgtMSlcblx0Ly8ge0BsaW5rIFRva2VuLy9FT0Z9IG1hcHMgdG8ge0Bjb2RlIGVkZ2VzWzBdfS5cblx0dGhpcy5lZGdlcyA9IG51bGw7XG5cdHRoaXMuaXNBY2NlcHRTdGF0ZSA9IGZhbHNlO1xuXHQvLyBpZiBhY2NlcHQgc3RhdGUsIHdoYXQgdHR5cGUgZG8gd2UgbWF0Y2ggb3IgYWx0IGRvIHdlIHByZWRpY3Q/XG5cdC8vIFRoaXMgaXMgc2V0IHRvIHtAbGluayBBVE4vL0lOVkFMSURfQUxUX05VTUJFUn0gd2hlbiB7QGxpbmtcblx0Ly8gLy9wcmVkaWNhdGVzfXtAY29kZSAhPW51bGx9IG9yXG5cdC8vIHtAbGluayAvL3JlcXVpcmVzRnVsbENvbnRleHR9LlxuXHR0aGlzLnByZWRpY3Rpb24gPSAwO1xuXHR0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IgPSBudWxsO1xuXHQvLyBJbmRpY2F0ZXMgdGhhdCB0aGlzIHN0YXRlIHdhcyBjcmVhdGVkIGR1cmluZyBTTEwgcHJlZGljdGlvbiB0aGF0XG5cdC8vIGRpc2NvdmVyZWQgYSBjb25mbGljdCBiZXR3ZWVuIHRoZSBjb25maWd1cmF0aW9ucyBpbiB0aGUgc3RhdGUuIEZ1dHVyZVxuXHQvLyB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yLy9leGVjQVROfSBpbnZvY2F0aW9ucyBpbW1lZGlhdGVseSBqdW1wZWQgZG9pbmdcblx0Ly8gZnVsbCBjb250ZXh0IHByZWRpY3Rpb24gaWYgdGhpcyBmaWVsZCBpcyB0cnVlLlxuXHR0aGlzLnJlcXVpcmVzRnVsbENvbnRleHQgPSBmYWxzZTtcblx0Ly8gRHVyaW5nIFNMTCBwYXJzaW5nLCB0aGlzIGlzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGVcblx0Ly8gQVROIGNvbmZpZ3VyYXRpb25zIG9mIHRoZSBERkEgc3RhdGUuIFdoZW4gd2UgaGF2ZSBwcmVkaWNhdGVzLFxuXHQvLyB7QGxpbmsgLy9yZXF1aXJlc0Z1bGxDb250ZXh0fSBpcyB7QGNvZGUgZmFsc2V9IHNpbmNlIGZ1bGwgY29udGV4dFxuXHQvLyBwcmVkaWN0aW9uIGV2YWx1YXRlcyBwcmVkaWNhdGVzXG5cdC8vIG9uLXRoZS1mbHkuIElmIHRoaXMgaXMgbm90IG51bGwsIHRoZW4ge0BsaW5rIC8vcHJlZGljdGlvbn0gaXNcblx0Ly8ge0BsaW5rIEFUTi8vSU5WQUxJRF9BTFRfTlVNQkVSfS5cblx0Ly9cblx0Ly8gPHA+V2Ugb25seSB1c2UgdGhlc2UgZm9yIG5vbi17QGxpbmsgLy9yZXF1aXJlc0Z1bGxDb250ZXh0fSBidXRcblx0Ly8gY29uZmxpY3Rpbmcgc3RhdGVzLiBUaGF0XG5cdC8vIG1lYW5zIHdlIGtub3cgZnJvbSB0aGUgY29udGV4dCAoaXQncyAkIG9yIHdlIGRvbid0IGRpcCBpbnRvIG91dGVyXG5cdC8vIGNvbnRleHQpIHRoYXQgaXQncyBhbiBhbWJpZ3VpdHkgbm90IGEgY29uZmxpY3QuPC9wPlxuXHQvL1xuXHQvLyA8cD5UaGlzIGxpc3QgaXMgY29tcHV0ZWQgYnkge0BsaW5rXG5cdC8vIFBhcnNlckFUTlNpbXVsYXRvci8vcHJlZGljYXRlREZBU3RhdGV9LjwvcD5cblx0dGhpcy5wcmVkaWNhdGVzID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEdldCB0aGUgc2V0IG9mIGFsbCBhbHRzIG1lbnRpb25lZCBieSBhbGwgQVROIGNvbmZpZ3VyYXRpb25zIGluIHRoaXNcbi8vIERGQSBzdGF0ZS5cbkRGQVN0YXRlLnByb3RvdHlwZS5nZXRBbHRTZXQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGFsdHMgPSBuZXcgU2V0KCk7XG5cdGlmICh0aGlzLmNvbmZpZ3MgIT09IG51bGwpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uZmlncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLmNvbmZpZ3NbaV07XG5cdFx0XHRhbHRzLmFkZChjLmFsdCk7XG5cdFx0fVxuXHR9XG5cdGlmIChhbHRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBhbHRzO1xuXHR9XG59O1xuXG4vLyBUd28ge0BsaW5rIERGQVN0YXRlfSBpbnN0YW5jZXMgYXJlIGVxdWFsIGlmIHRoZWlyIEFUTiBjb25maWd1cmF0aW9uIHNldHNcbi8vIGFyZSB0aGUgc2FtZS4gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZWUgaWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cy5cbi8vXG4vLyA8cD5CZWNhdXNlIHRoZSBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIGFuZCBudW1iZXIgb2YgQVROIGNvbmZpZ3VyYXRpb25zIGFyZVxuLy8gZmluaXRlLCB0aGVyZSBpcyBhIGZpbml0ZSBudW1iZXIgb2YgREZBIHN0YXRlcyB0aGF0IGNhbiBiZSBwcm9jZXNzZWQuXG4vLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzaG93IHRoYXQgdGhlIGFsZ29yaXRobSB0ZXJtaW5hdGVzLjwvcD5cbi8vXG4vLyA8cD5DYW5ub3QgdGVzdCB0aGUgREZBIHN0YXRlIG51bWJlcnMgaGVyZSBiZWNhdXNlIGluXG4vLyB7QGxpbmsgUGFyc2VyQVROU2ltdWxhdG9yLy9hZGRERkFTdGF0ZX0gd2UgbmVlZCB0byBrbm93IGlmIGFueSBvdGhlciBzdGF0ZVxuLy8gZXhpc3RzIHRoYXQgaGFzIHRoaXMgZXhhY3Qgc2V0IG9mIEFUTiBjb25maWd1cmF0aW9ucy4gVGhlXG4vLyB7QGxpbmsgLy9zdGF0ZU51bWJlcn0gaXMgaXJyZWxldmFudC48L3A+XG5ERkFTdGF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0Ly8gY29tcGFyZSBzZXQgb2YgQVROIGNvbmZpZ3VyYXRpb25zIGluIHRoaXMgc2V0IHdpdGggb3RoZXJcblx0cmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG5cdFx0XHQob3RoZXIgaW5zdGFuY2VvZiBERkFTdGF0ZSAmJlxuXHRcdFx0XHR0aGlzLmNvbmZpZ3MuZXF1YWxzKG90aGVyLmNvbmZpZ3MpKTtcbn07XG5cbkRGQVN0YXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcyA9IFwiXCIgKyB0aGlzLnN0YXRlTnVtYmVyICsgXCI6XCIgKyB0aGlzLmNvbmZpZ3M7XG5cdGlmKHRoaXMuaXNBY2NlcHRTdGF0ZSkge1xuICAgICAgICBzID0gcyArIFwiPT5cIjtcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlcyAhPT0gbnVsbClcbiAgICAgICAgICAgIHMgPSBzICsgdGhpcy5wcmVkaWNhdGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzID0gcyArIHRoaXMucHJlZGljdGlvbjtcbiAgICB9XG5cdHJldHVybiBzO1xufTtcblxuREZBU3RhdGUucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBoYXNoID0gbmV3IEhhc2goKTtcblx0aGFzaC51cGRhdGUodGhpcy5jb25maWdzKTtcblx0aWYodGhpcy5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZXMgIT09IG51bGwpXG4gICAgICAgICAgICBoYXNoLnVwZGF0ZSh0aGlzLnByZWRpY2F0ZXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoYXNoLnVwZGF0ZSh0aGlzLnByZWRpY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn07XG5cbmV4cG9ydHMuREZBU3RhdGUgPSBERkFTdGF0ZTtcbmV4cG9ydHMuUHJlZFByZWRpY3Rpb24gPSBQcmVkUHJlZGljdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9kZmEvREZBU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuZXhwb3J0cy5hdG4gPSByZXF1aXJlKCcuL2F0bi9pbmRleCcpO1xuZXhwb3J0cy5jb2RlcG9pbnRhdCA9IHJlcXVpcmUoJy4vcG9seWZpbGxzL2NvZGVwb2ludGF0Jyk7XG5leHBvcnRzLmRmYSA9IHJlcXVpcmUoJy4vZGZhL2luZGV4Jyk7XG5leHBvcnRzLmZyb21jb2RlcG9pbnQgPSByZXF1aXJlKCcuL3BvbHlmaWxscy9mcm9tY29kZXBvaW50Jyk7XG5leHBvcnRzLnRyZWUgPSByZXF1aXJlKCcuL3RyZWUvaW5kZXgnKTtcbmV4cG9ydHMuZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5leHBvcnRzLlRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xuZXhwb3J0cy5DaGFyU3RyZWFtcyA9IHJlcXVpcmUoJy4vQ2hhclN0cmVhbXMnKS5DaGFyU3RyZWFtcztcbmV4cG9ydHMuQ29tbW9uVG9rZW4gPSByZXF1aXJlKCcuL1Rva2VuJykuQ29tbW9uVG9rZW47XG5leHBvcnRzLklucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpLklucHV0U3RyZWFtO1xuZXhwb3J0cy5GaWxlU3RyZWFtID0gcmVxdWlyZSgnLi9GaWxlU3RyZWFtJykuRmlsZVN0cmVhbTtcbmV4cG9ydHMuQ29tbW9uVG9rZW5TdHJlYW0gPSByZXF1aXJlKCcuL0NvbW1vblRva2VuU3RyZWFtJykuQ29tbW9uVG9rZW5TdHJlYW07XG5leHBvcnRzLkxleGVyID0gcmVxdWlyZSgnLi9MZXhlcicpLkxleGVyO1xuZXhwb3J0cy5QYXJzZXIgPSByZXF1aXJlKCcuL1BhcnNlcicpLlBhcnNlcjtcbnZhciBwYyA9IHJlcXVpcmUoJy4vUHJlZGljdGlvbkNvbnRleHQnKTtcbmV4cG9ydHMuUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IHBjLlByZWRpY3Rpb25Db250ZXh0Q2FjaGU7XG5leHBvcnRzLlBhcnNlclJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi9QYXJzZXJSdWxlQ29udGV4dCcpLlBhcnNlclJ1bGVDb250ZXh0O1xuZXhwb3J0cy5JbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbmV4cG9ydHMuVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG4vLyBBIHR1cGxlOiAoQVROIHN0YXRlLCBwcmVkaWN0ZWQgYWx0LCBzeW50YWN0aWMsIHNlbWFudGljIGNvbnRleHQpLlxuLy8gIFRoZSBzeW50YWN0aWMgY29udGV4dCBpcyBhIGdyYXBoLXN0cnVjdHVyZWQgc3RhY2sgbm9kZSB3aG9zZVxuLy8gIHBhdGgocykgdG8gdGhlIHJvb3QgaXMgdGhlIHJ1bGUgaW52b2NhdGlvbihzKVxuLy8gIGNoYWluIHVzZWQgdG8gYXJyaXZlIGF0IHRoZSBzdGF0ZS4gIFRoZSBzZW1hbnRpYyBjb250ZXh0IGlzXG4vLyAgdGhlIHRyZWUgb2Ygc2VtYW50aWMgcHJlZGljYXRlcyBlbmNvdW50ZXJlZCBiZWZvcmUgcmVhY2hpbmdcbi8vICBhbiBBVE4gc3RhdGUuXG4vLy9cblxudmFyIERlY2lzaW9uU3RhdGUgPSByZXF1aXJlKCcuL0FUTlN0YXRlJykuRGVjaXNpb25TdGF0ZTtcbnZhciBTZW1hbnRpY0NvbnRleHQgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlNlbWFudGljQ29udGV4dDtcbnZhciBIYXNoID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpLkhhc2g7XG5cblxuZnVuY3Rpb24gY2hlY2tQYXJhbXMocGFyYW1zLCBpc0NmZykge1xuXHRpZihwYXJhbXM9PT1udWxsKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHsgc3RhdGU6bnVsbCwgYWx0Om51bGwsIGNvbnRleHQ6bnVsbCwgc2VtYW50aWNDb250ZXh0Om51bGwgfTtcblx0XHRpZihpc0NmZykge1xuXHRcdFx0cmVzdWx0LnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBlbHNlIHtcblx0XHR2YXIgcHJvcHMgPSB7fTtcblx0XHRwcm9wcy5zdGF0ZSA9IHBhcmFtcy5zdGF0ZSB8fCBudWxsO1xuXHRcdHByb3BzLmFsdCA9IChwYXJhbXMuYWx0ID09PSB1bmRlZmluZWQpID8gbnVsbCA6IHBhcmFtcy5hbHQ7XG5cdFx0cHJvcHMuY29udGV4dCA9IHBhcmFtcy5jb250ZXh0IHx8IG51bGw7XG5cdFx0cHJvcHMuc2VtYW50aWNDb250ZXh0ID0gcGFyYW1zLnNlbWFudGljQ29udGV4dCB8fCBudWxsO1xuXHRcdGlmKGlzQ2ZnKSB7XG5cdFx0XHRwcm9wcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IHBhcmFtcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCB8fCAwO1xuXHRcdFx0cHJvcHMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSBwYXJhbXMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgfHwgZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9wcztcblx0fVxufVxuXG5mdW5jdGlvbiBBVE5Db25maWcocGFyYW1zLCBjb25maWcpIHtcblx0dGhpcy5jaGVja0NvbnRleHQocGFyYW1zLCBjb25maWcpO1xuXHRwYXJhbXMgPSBjaGVja1BhcmFtcyhwYXJhbXMpO1xuXHRjb25maWcgPSBjaGVja1BhcmFtcyhjb25maWcsIHRydWUpO1xuICAgIC8vIFRoZSBBVE4gc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29uZmlndXJhdGlvbi8vL1xuICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUhPT1udWxsID8gcGFyYW1zLnN0YXRlIDogY29uZmlnLnN0YXRlO1xuICAgIC8vIFdoYXQgYWx0IChvciBsZXhlciBydWxlKSBpcyBwcmVkaWN0ZWQgYnkgdGhpcyBjb25maWd1cmF0aW9uLy8vXG4gICAgdGhpcy5hbHQgPSBwYXJhbXMuYWx0IT09bnVsbCA/IHBhcmFtcy5hbHQgOiBjb25maWcuYWx0O1xuICAgIC8vIFRoZSBzdGFjayBvZiBpbnZva2luZyBzdGF0ZXMgbGVhZGluZyB0byB0aGUgcnVsZS9zdGF0ZXMgYXNzb2NpYXRlZFxuICAgIC8vICB3aXRoIHRoaXMgY29uZmlnLiAgV2UgdHJhY2sgb25seSB0aG9zZSBjb250ZXh0cyBwdXNoZWQgZHVyaW5nXG4gICAgLy8gIGV4ZWN1dGlvbiBvZiB0aGUgQVROIHNpbXVsYXRvci5cbiAgICB0aGlzLmNvbnRleHQgPSBwYXJhbXMuY29udGV4dCE9PW51bGwgPyBwYXJhbXMuY29udGV4dCA6IGNvbmZpZy5jb250ZXh0O1xuICAgIHRoaXMuc2VtYW50aWNDb250ZXh0ID0gcGFyYW1zLnNlbWFudGljQ29udGV4dCE9PW51bGwgPyBwYXJhbXMuc2VtYW50aWNDb250ZXh0IDpcbiAgICAgICAgKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQhPT1udWxsID8gY29uZmlnLnNlbWFudGljQ29udGV4dCA6IFNlbWFudGljQ29udGV4dC5OT05FKTtcbiAgICAvLyBXZSBjYW5ub3QgZXhlY3V0ZSBwcmVkaWNhdGVzIGRlcGVuZGVudCB1cG9uIGxvY2FsIGNvbnRleHQgdW5sZXNzXG4gICAgLy8gd2Uga25vdyBmb3Igc3VyZSB3ZSBhcmUgaW4gdGhlIGNvcnJlY3QgY29udGV4dC4gQmVjYXVzZSB0aGVyZSBpc1xuICAgIC8vIG5vIHdheSB0byBkbyB0aGlzIGVmZmljaWVudGx5LCB3ZSBzaW1wbHkgY2Fubm90IGV2YWx1YXRlXG4gICAgLy8gZGVwZW5kZW50IHByZWRpY2F0ZXMgdW5sZXNzIHdlIGFyZSBpbiB0aGUgcnVsZSB0aGF0IGluaXRpYWxseVxuICAgIC8vIGludm9rZXMgdGhlIEFUTiBzaW11bGF0b3IuXG4gICAgLy9cbiAgICAvLyBjbG9zdXJlKCkgdHJhY2tzIHRoZSBkZXB0aCBvZiBob3cgZmFyIHdlIGRpcCBpbnRvIHRoZVxuICAgIC8vIG91dGVyIGNvbnRleHQ6IGRlcHRoICZndDsgMC4gIE5vdGUgdGhhdCBpdCBtYXkgbm90IGJlIHRvdGFsbHlcbiAgICAvLyBhY2N1cmF0ZSBkZXB0aCBzaW5jZSBJIGRvbid0IGV2ZXIgZGVjcmVtZW50LiBUT0RPOiBtYWtlIGl0IGEgYm9vbGVhbiB0aGVuXG4gICAgdGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dDtcbiAgICB0aGlzLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gY29uZmlnLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5BVE5Db25maWcucHJvdG90eXBlLmNoZWNrQ29udGV4dCA9IGZ1bmN0aW9uKHBhcmFtcywgY29uZmlnKSB7XG5cdGlmKChwYXJhbXMuY29udGV4dD09PW51bGwgfHwgcGFyYW1zLmNvbnRleHQ9PT11bmRlZmluZWQpICYmXG5cdFx0XHQoY29uZmlnPT09bnVsbCB8fCBjb25maWcuY29udGV4dD09PW51bGwgfHwgY29uZmlnLmNvbnRleHQ9PT11bmRlZmluZWQpKSB7XG5cdFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcblx0fVxufTtcblxuXG5BVE5Db25maWcucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgIHRoaXMudXBkYXRlSGFzaENvZGUoaGFzaCk7XG4gICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG59O1xuXG5cbkFUTkNvbmZpZy5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5zdGF0ZS5zdGF0ZU51bWJlciwgdGhpcy5hbHQsIHRoaXMuY29udGV4dCwgdGhpcy5zZW1hbnRpY0NvbnRleHQpO1xufTtcblxuLy8gQW4gQVROIGNvbmZpZ3VyYXRpb24gaXMgZXF1YWwgdG8gYW5vdGhlciBpZiBib3RoIGhhdmVcbi8vICB0aGUgc2FtZSBzdGF0ZSwgdGhleSBwcmVkaWN0IHRoZSBzYW1lIGFsdGVybmF0aXZlLCBhbmRcbi8vICBzeW50YWN0aWMvc2VtYW50aWMgY29udGV4dHMgYXJlIHRoZSBzYW1lLlxuXG5BVE5Db25maWcucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBBVE5Db25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0ZU51bWJlcj09PW90aGVyLnN0YXRlLnN0YXRlTnVtYmVyICYmXG4gICAgICAgICAgICB0aGlzLmFsdD09PW90aGVyLmFsdCAmJlxuICAgICAgICAgICAgKHRoaXMuY29udGV4dD09PW51bGwgPyBvdGhlci5jb250ZXh0PT09bnVsbCA6IHRoaXMuY29udGV4dC5lcXVhbHMob3RoZXIuY29udGV4dCkpICYmXG4gICAgICAgICAgICB0aGlzLnNlbWFudGljQ29udGV4dC5lcXVhbHMob3RoZXIuc2VtYW50aWNDb250ZXh0KSAmJlxuICAgICAgICAgICAgdGhpcy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZD09PW90aGVyLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkO1xuICAgIH1cbn07XG5cblxuQVROQ29uZmlnLnByb3RvdHlwZS5oYXNoQ29kZUZvckNvbmZpZ1NldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLnN0YXRlLnN0YXRlTnVtYmVyLCB0aGlzLmFsdCwgdGhpcy5zZW1hbnRpY0NvbnRleHQpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufTtcblxuXG5BVE5Db25maWcucHJvdG90eXBlLmVxdWFsc0ZvckNvbmZpZ1NldCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBBVE5Db25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0ZU51bWJlcj09PW90aGVyLnN0YXRlLnN0YXRlTnVtYmVyICYmXG4gICAgICAgICAgICB0aGlzLmFsdD09PW90aGVyLmFsdCAmJlxuICAgICAgICAgICAgdGhpcy5zZW1hbnRpY0NvbnRleHQuZXF1YWxzKG90aGVyLnNlbWFudGljQ29udGV4dCk7XG4gICAgfVxufTtcblxuXG5BVE5Db25maWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgdGhpcy5zdGF0ZSArIFwiLFwiICsgdGhpcy5hbHQgK1xuICAgICAgICAodGhpcy5jb250ZXh0IT09bnVsbCA/IFwiLFtcIiArIHRoaXMuY29udGV4dC50b1N0cmluZygpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICh0aGlzLnNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgP1xuICAgICAgICAgICAgICAgIChcIixcIiArIHRoaXMuc2VtYW50aWNDb250ZXh0LnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgOiBcIlwiKSArXG4gICAgICAgICh0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0PjAgP1xuICAgICAgICAgICAgICAgIChcIix1cD1cIiArIHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiBcIlwiKSArIFwiKVwiO1xufTtcblxuXG5mdW5jdGlvbiBMZXhlckFUTkNvbmZpZyhwYXJhbXMsIGNvbmZpZykge1xuXHRBVE5Db25maWcuY2FsbCh0aGlzLCBwYXJhbXMsIGNvbmZpZyk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgLy9nZXRMZXhlckFjdGlvbkV4ZWN1dG9yfS5cblx0dmFyIGxleGVyQWN0aW9uRXhlY3V0b3IgPSBwYXJhbXMubGV4ZXJBY3Rpb25FeGVjdXRvciB8fCBudWxsO1xuICAgIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3IgfHwgKGNvbmZpZyE9PW51bGwgPyBjb25maWcubGV4ZXJBY3Rpb25FeGVjdXRvciA6IG51bGwpO1xuICAgIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID0gY29uZmlnIT09bnVsbCA/IHRoaXMuY2hlY2tOb25HcmVlZHlEZWNpc2lvbihjb25maWcsIHRoaXMuc3RhdGUpIDogZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROQ29uZmlnLnByb3RvdHlwZSk7XG5MZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlckFUTkNvbmZpZztcblxuTGV4ZXJBVE5Db25maWcucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuc3RhdGUuc3RhdGVOdW1iZXIsIHRoaXMuYWx0LCB0aGlzLmNvbnRleHQsIHRoaXMuc2VtYW50aWNDb250ZXh0LCB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiwgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcbn07XG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJBVE5Db25maWcgJiZcbiAgICAgICAgICAgIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID09IG90aGVyLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiAmJlxuICAgICAgICAgICAgKHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciA/IHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvci5lcXVhbHMob3RoZXIubGV4ZXJBY3Rpb25FeGVjdXRvcikgOiAhb3RoZXIubGV4ZXJBY3Rpb25FeGVjdXRvcikgJiZcbiAgICAgICAgICAgIEFUTkNvbmZpZy5wcm90b3R5cGUuZXF1YWxzLmNhbGwodGhpcywgb3RoZXIpKTtcbn07XG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZS5oYXNoQ29kZUZvckNvbmZpZ1NldCA9IExleGVyQVROQ29uZmlnLnByb3RvdHlwZS5oYXNoQ29kZTtcblxuTGV4ZXJBVE5Db25maWcucHJvdG90eXBlLmVxdWFsc0ZvckNvbmZpZ1NldCA9IExleGVyQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHM7XG5cblxuTGV4ZXJBVE5Db25maWcucHJvdG90eXBlLmNoZWNrTm9uR3JlZWR5RGVjaXNpb24gPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiBzb3VyY2UucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uIHx8XG4gICAgICAgICh0YXJnZXQgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlKSAmJiB0YXJnZXQubm9uR3JlZWR5O1xufTtcblxuZXhwb3J0cy5BVE5Db25maWcgPSBBVE5Db25maWc7XG5leHBvcnRzLkxleGVyQVROQ29uZmlnID0gTGV4ZXJBVE5Db25maWc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9BVE5Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbi8vICBBIHJ1bGUgY29udGV4dCBpcyBhIHJlY29yZCBvZiBhIHNpbmdsZSBydWxlIGludm9jYXRpb24uIEl0IGtub3dzXG4vLyAgd2hpY2ggY29udGV4dCBpbnZva2VkIGl0LCBpZiBhbnkuIElmIHRoZXJlIGlzIG5vIHBhcmVudCBjb250ZXh0LCB0aGVuXG4vLyAgbmF0dXJhbGx5IHRoZSBpbnZva2luZyBzdGF0ZSBpcyBub3QgdmFsaWQuICBUaGUgcGFyZW50IGxpbmtcbi8vICBwcm92aWRlcyBhIGNoYWluIHVwd2FyZHMgZnJvbSB0aGUgY3VycmVudCBydWxlIGludm9jYXRpb24gdG8gdGhlIHJvb3Rcbi8vICBvZiB0aGUgaW52b2NhdGlvbiB0cmVlLCBmb3JtaW5nIGEgc3RhY2suIFdlIGFjdHVhbGx5IGNhcnJ5IG5vXG4vLyAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udGV4dCAoZXhjZXB0XG4vLyAgd2hlbiBwYXJzaW5nKS4gV2Uga2VlcCBvbmx5IHRoZSBzdGF0ZSBudW1iZXIgb2YgdGhlIGludm9raW5nIHN0YXRlIGZyb21cbi8vICB0aGUgQVROIHN1Ym1hY2hpbmUgdGhhdCBpbnZva2VkIHRoaXMuIENvbnRyYXN0IHRoaXMgd2l0aCB0aGUgc1xuLy8gIHBvaW50ZXIgaW5zaWRlIFBhcnNlclJ1bGVDb250ZXh0IHRoYXQgdHJhY2tzIHRoZSBjdXJyZW50IHN0YXRlXG4vLyAgYmVpbmcgXCJleGVjdXRlZFwiIGZvciB0aGUgY3VycmVudCBydWxlLlxuLy9cbi8vICBUaGUgcGFyZW50IGNvbnRleHRzIGFyZSB1c2VmdWwgZm9yIGNvbXB1dGluZyBsb29rYWhlYWQgc2V0cyBhbmRcbi8vICBnZXR0aW5nIGVycm9yIGluZm9ybWF0aW9uLlxuLy9cbi8vICBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIGR1cmluZyBwYXJzaW5nIGFuZCBwcmVkaWN0aW9uLlxuLy8gIEZvciB0aGUgc3BlY2lhbCBjYXNlIG9mIHBhcnNlcnMsIHdlIHVzZSB0aGUgc3ViY2xhc3Ncbi8vICBQYXJzZXJSdWxlQ29udGV4dC5cbi8vXG4vLyAgQHNlZSBQYXJzZXJSdWxlQ29udGV4dFxuLy8vXG5cbnZhciBSdWxlTm9kZSA9IHJlcXVpcmUoJy4vdHJlZS9UcmVlJykuUnVsZU5vZGU7XG52YXIgSU5WQUxJRF9JTlRFUlZBTCA9IHJlcXVpcmUoJy4vdHJlZS9UcmVlJykuSU5WQUxJRF9JTlRFUlZBTDtcbnZhciBJTlZBTElEX0FMVF9OVU1CRVIgPSByZXF1aXJlKCcuL2F0bi9BVE4nKS5JTlZBTElEX0FMVF9OVU1CRVI7XG5cbmZ1bmN0aW9uIFJ1bGVDb250ZXh0KHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuXHRSdWxlTm9kZS5jYWxsKHRoaXMpO1xuXHQvLyBXaGF0IGNvbnRleHQgaW52b2tlZCB0aGlzIHJ1bGU/XG5cdHRoaXMucGFyZW50Q3R4ID0gcGFyZW50IHx8IG51bGw7XG5cdC8vIFdoYXQgc3RhdGUgaW52b2tlZCB0aGUgcnVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0P1xuXHQvLyBUaGUgXCJyZXR1cm4gYWRkcmVzc1wiIGlzIHRoZSBmb2xsb3dTdGF0ZSBvZiBpbnZva2luZ1N0YXRlXG5cdC8vIElmIHBhcmVudCBpcyBudWxsLCB0aGlzIHNob3VsZCBiZSAtMS5cblx0dGhpcy5pbnZva2luZ1N0YXRlID0gaW52b2tpbmdTdGF0ZSB8fCAtMTtcblx0cmV0dXJuIHRoaXM7XG59XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUnVsZU5vZGUucHJvdG90eXBlKTtcblJ1bGVDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJ1bGVDb250ZXh0O1xuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbigpIHtcblx0dmFyIG4gPSAwO1xuXHR2YXIgcCA9IHRoaXM7XG5cdHdoaWxlIChwICE9PSBudWxsKSB7XG5cdFx0cCA9IHAucGFyZW50Q3R4O1xuXHRcdG4gKz0gMTtcblx0fVxuXHRyZXR1cm4gbjtcbn07XG5cbi8vIEEgY29udGV4dCBpcyBlbXB0eSBpZiB0aGVyZSBpcyBubyBpbnZva2luZyBzdGF0ZTsgbWVhbmluZyBub2JvZHkgY2FsbFxuLy8gY3VycmVudCBjb250ZXh0LlxuUnVsZUNvbnRleHQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuaW52b2tpbmdTdGF0ZSA9PT0gLTE7XG59O1xuXG4vLyBzYXRpc2Z5IHRoZSBQYXJzZVRyZWUgLyBTeW50YXhUcmVlIGludGVyZmFjZVxuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0U291cmNlSW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIElOVkFMSURfSU5URVJWQUw7XG59O1xuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0UnVsZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0UGF5bG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8vIFJldHVybiB0aGUgY29tYmluZWQgdGV4dCBvZiBhbGwgY2hpbGQgbm9kZXMuIFRoaXMgbWV0aG9kIG9ubHkgY29uc2lkZXJzXG4vLyB0b2tlbnMgd2hpY2ggaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlLlxuLy8gPHA+XG4vLyBTaW5jZSB0b2tlbnMgb24gaGlkZGVuIGNoYW5uZWxzIChlLmcuIHdoaXRlc3BhY2Ugb3IgY29tbWVudHMpIGFyZSBub3Rcbi8vIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlcywgdGhleSB3aWxsIG5vdCBhcHBlYXIgaW4gdGhlIG91dHB1dCBvZiB0aGlzXG4vLyBtZXRob2QuXG4vLyAvXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5nZXRDaGlsZENvdW50KCkgPT09IDApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdHJldHVybiBjaGlsZC5nZXRUZXh0KCk7XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fVxufTtcblxuLy8gRm9yIHJ1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGFyc2UgdHJlZSBpbnRlcm5hbCBub2RlLCByZXR1cm5cbi8vIHRoZSBvdXRlciBhbHRlcm5hdGl2ZSBudW1iZXIgdXNlZCB0byBtYXRjaCB0aGUgaW5wdXQuIERlZmF1bHRcbi8vIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGNvbXB1dGUgbm9yIHN0b3JlIHRoaXMgYWx0IG51bS4gQ3JlYXRlXG4vLyBhIHN1YmNsYXNzIG9mIFBhcnNlclJ1bGVDb250ZXh0IHdpdGggYmFja2luZyBmaWVsZCBhbmQgc2V0XG4vLyBvcHRpb24gY29udGV4dFN1cGVyQ2xhc3MuXG4vLyB0byBzZXQgaXQuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0QWx0TnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBJTlZBTElEX0FMVF9OVU1CRVI7IH1cblxuLy8gU2V0IHRoZSBvdXRlciBhbHRlcm5hdGl2ZSBudW1iZXIgZm9yIHRoaXMgY29udGV4dCBub2RlLiBEZWZhdWx0XG4vLyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdGhpbmcgdG8gYXZvaWQgYmFja2luZyBmaWVsZCBvdmVyaGVhZCBmb3Jcbi8vIHRyZWVzIHRoYXQgZG9uJ3QgbmVlZCBpdC4gIENyZWF0ZVxuLy8gYSBzdWJjbGFzcyBvZiBQYXJzZXJSdWxlQ29udGV4dCB3aXRoIGJhY2tpbmcgZmllbGQgYW5kIHNldFxuLy8gb3B0aW9uIGNvbnRleHRTdXBlckNsYXNzLlxuUnVsZUNvbnRleHQucHJvdG90eXBlLnNldEFsdE51bWJlciA9IGZ1bmN0aW9uKGFsdE51bWJlcikgeyB9XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKGkpIHtcblx0cmV0dXJuIG51bGw7XG59O1xuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gMDtcbn07XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XG5cdHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG59O1xuXG4vL25lZWQgdG8gbWFuYWdlIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgc28gZXhwb3J0IG5vd1xuZXhwb3J0cy5SdWxlQ29udGV4dCA9IFJ1bGVDb250ZXh0O1xudmFyIFRyZWVzID0gcmVxdWlyZSgnLi90cmVlL1RyZWVzJykuVHJlZXM7XG5cblxuLy8gUHJpbnQgb3V0IGEgd2hvbGUgdHJlZSwgbm90IGp1c3QgYSBub2RlLCBpbiBMSVNQIGZvcm1hdFxuLy8gKHJvb3QgY2hpbGQxIC4uIGNoaWxkTikuIFByaW50IGp1c3QgYSBub2RlIGlmIHRoaXMgaXMgYSBsZWFmLlxuLy9cblxuUnVsZUNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nVHJlZSA9IGZ1bmN0aW9uKHJ1bGVOYW1lcywgcmVjb2cpIHtcblx0cmV0dXJuIFRyZWVzLnRvU3RyaW5nVHJlZSh0aGlzLCBydWxlTmFtZXMsIHJlY29nKTtcbn07XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHJ1bGVOYW1lcywgc3RvcCkge1xuXHRydWxlTmFtZXMgPSBydWxlTmFtZXMgfHwgbnVsbDtcblx0c3RvcCA9IHN0b3AgfHwgbnVsbDtcblx0dmFyIHAgPSB0aGlzO1xuXHR2YXIgcyA9IFwiW1wiO1xuXHR3aGlsZSAocCAhPT0gbnVsbCAmJiBwICE9PSBzdG9wKSB7XG5cdFx0aWYgKHJ1bGVOYW1lcyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKCFwLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRzICs9IHAuaW52b2tpbmdTdGF0ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJpID0gcC5ydWxlSW5kZXg7XG5cdFx0XHR2YXIgcnVsZU5hbWUgPSAocmkgPj0gMCAmJiByaSA8IHJ1bGVOYW1lcy5sZW5ndGgpID8gcnVsZU5hbWVzW3JpXVxuXHRcdFx0XHRcdDogXCJcIiArIHJpO1xuXHRcdFx0cyArPSBydWxlTmFtZTtcblx0XHR9XG5cdFx0aWYgKHAucGFyZW50Q3R4ICE9PSBudWxsICYmIChydWxlTmFtZXMgIT09IG51bGwgfHwgIXAucGFyZW50Q3R4LmlzRW1wdHkoKSkpIHtcblx0XHRcdHMgKz0gXCIgXCI7XG5cdFx0fVxuXHRcdHAgPSBwLnBhcmVudEN0eDtcblx0fVxuXHRzICs9IFwiXVwiO1xuXHRyZXR1cm4gcztcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9SdWxlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gQSBsZXhlciBpcyByZWNvZ25pemVyIHRoYXQgZHJhd3MgaW5wdXQgc3ltYm9scyBmcm9tIGEgY2hhcmFjdGVyIHN0cmVhbS5cbi8vICBsZXhlciBncmFtbWFycyByZXN1bHQgaW4gYSBzdWJjbGFzcyBvZiB0aGlzIG9iamVjdC4gQSBMZXhlciBvYmplY3Rcbi8vICB1c2VzIHNpbXBsaWZpZWQgbWF0Y2goKSBhbmQgZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtcyBpbiB0aGUgaW50ZXJlc3Qgb2Ygc3BlZWQuXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBSZWNvZ25pemVyID0gcmVxdWlyZSgnLi9SZWNvZ25pemVyJykuUmVjb2duaXplcjtcbnZhciBDb21tb25Ub2tlbkZhY3RvcnkgPSByZXF1aXJlKCcuL0NvbW1vblRva2VuRmFjdG9yeScpLkNvbW1vblRva2VuRmFjdG9yeTtcbnZhciBSZWNvZ25pdGlvbkV4Y2VwdGlvbiAgPSByZXF1aXJlKCcuL2Vycm9yL0Vycm9ycycpLlJlY29nbml0aW9uRXhjZXB0aW9uO1xudmFyIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gPSByZXF1aXJlKCcuL2Vycm9yL0Vycm9ycycpLkxleGVyTm9WaWFibGVBbHRFeGNlcHRpb247XG5cbmZ1bmN0aW9uIFRva2VuU291cmNlKCkge1xuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gTGV4ZXIoaW5wdXQpIHtcblx0UmVjb2duaXplci5jYWxsKHRoaXMpO1xuXHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHR0aGlzLl9mYWN0b3J5ID0gQ29tbW9uVG9rZW5GYWN0b3J5LkRFRkFVTFQ7XG5cdHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIgPSBbIHRoaXMsIGlucHV0IF07XG5cblx0dGhpcy5faW50ZXJwID0gbnVsbDsgLy8gY2hpbGQgY2xhc3NlcyBtdXN0IHBvcHVsYXRlIHRoaXNcblxuXHQvLyBUaGUgZ29hbCBvZiBhbGwgbGV4ZXIgcnVsZXMvbWV0aG9kcyBpcyB0byBjcmVhdGUgYSB0b2tlbiBvYmplY3QuXG5cdC8vIHRoaXMgaXMgYW4gaW5zdGFuY2UgdmFyaWFibGUgYXMgbXVsdGlwbGUgcnVsZXMgbWF5IGNvbGxhYm9yYXRlIHRvXG5cdC8vIGNyZWF0ZSBhIHNpbmdsZSB0b2tlbi4gbmV4dFRva2VuIHdpbGwgcmV0dXJuIHRoaXMgb2JqZWN0IGFmdGVyXG5cdC8vIG1hdGNoaW5nIGxleGVyIHJ1bGUocykuIElmIHlvdSBzdWJjbGFzcyB0byBhbGxvdyBtdWx0aXBsZSB0b2tlblxuXHQvLyBlbWlzc2lvbnMsIHRoZW4gc2V0IHRoaXMgdG8gdGhlIGxhc3QgdG9rZW4gdG8gYmUgbWF0Y2hlZCBvclxuXHQvLyBzb21ldGhpbmcgbm9ubnVsbCBzbyB0aGF0IHRoZSBhdXRvIHRva2VuIGVtaXQgbWVjaGFuaXNtIHdpbGwgbm90XG5cdC8vIGVtaXQgYW5vdGhlciB0b2tlbi5cblx0dGhpcy5fdG9rZW4gPSBudWxsO1xuXG5cdC8vIFdoYXQgY2hhcmFjdGVyIGluZGV4IGluIHRoZSBzdHJlYW0gZGlkIHRoZSBjdXJyZW50IHRva2VuIHN0YXJ0IGF0P1xuXHQvLyBOZWVkZWQsIGZvciBleGFtcGxlLCB0byBnZXQgdGhlIHRleHQgZm9yIGN1cnJlbnQgdG9rZW4uIFNldCBhdFxuXHQvLyB0aGUgc3RhcnQgb2YgbmV4dFRva2VuLlxuXHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4ID0gLTE7XG5cblx0Ly8gVGhlIGxpbmUgb24gd2hpY2ggdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdG9rZW4gcmVzaWRlcy8vL1xuXHR0aGlzLl90b2tlblN0YXJ0TGluZSA9IC0xO1xuXG5cdC8vIFRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gb2YgZmlyc3QgY2hhcmFjdGVyIHdpdGhpbiB0aGUgbGluZS8vL1xuXHR0aGlzLl90b2tlblN0YXJ0Q29sdW1uID0gLTE7XG5cblx0Ly8gT25jZSB3ZSBzZWUgRU9GIG9uIGNoYXIgc3RyZWFtLCBuZXh0IHRva2VuIHdpbGwgYmUgRU9GLlxuXHQvLyBJZiB5b3UgaGF2ZSBET05FIDogRU9GIDsgdGhlbiB5b3Ugc2VlIERPTkUgRU9GLlxuXHR0aGlzLl9oaXRFT0YgPSBmYWxzZTtcblxuXHQvLyBUaGUgY2hhbm5lbCBudW1iZXIgZm9yIHRoZSBjdXJyZW50IHRva2VuLy8vXG5cdHRoaXMuX2NoYW5uZWwgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XG5cblx0Ly8gVGhlIHRva2VuIHR5cGUgZm9yIHRoZSBjdXJyZW50IHRva2VuLy8vXG5cdHRoaXMuX3R5cGUgPSBUb2tlbi5JTlZBTElEX1RZUEU7XG5cblx0dGhpcy5fbW9kZVN0YWNrID0gW107XG5cdHRoaXMuX21vZGUgPSBMZXhlci5ERUZBVUxUX01PREU7XG5cblx0Ly8gWW91IGNhbiBzZXQgdGhlIHRleHQgZm9yIHRoZSBjdXJyZW50IHRva2VuIHRvIG92ZXJyaWRlIHdoYXQgaXMgaW5cblx0Ly8gdGhlIGlucHV0IGNoYXIgYnVmZmVyLiBVc2Ugc2V0VGV4dCgpIG9yIGNhbiBzZXQgdGhpcyBpbnN0YW5jZSB2YXIuXG5cdC8vIC9cblx0dGhpcy5fdGV4dCA9IG51bGw7XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbkxleGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXplci5wcm90b3R5cGUpO1xuTGV4ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXI7XG5cbkxleGVyLkRFRkFVTFRfTU9ERSA9IDA7XG5MZXhlci5NT1JFID0gLTI7XG5MZXhlci5TS0lQID0gLTM7XG5cbkxleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcbkxleGVyLkhJRERFTiA9IFRva2VuLkhJRERFTl9DSEFOTkVMO1xuTGV4ZXIuTUlOX0NIQVJfVkFMVUUgPSAweDAwMDA7XG5MZXhlci5NQVhfQ0hBUl9WQUxVRSA9IDB4MTBGRkZGO1xuXG5MZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0Ly8gd2FjayBMZXhlciBzdGF0ZSB2YXJpYWJsZXNcblx0aWYgKHRoaXMuX2lucHV0ICE9PSBudWxsKSB7XG5cdFx0dGhpcy5faW5wdXQuc2VlaygwKTsgLy8gcmV3aW5kIHRoZSBpbnB1dFxuXHR9XG5cdHRoaXMuX3Rva2VuID0gbnVsbDtcblx0dGhpcy5fdHlwZSA9IFRva2VuLklOVkFMSURfVFlQRTtcblx0dGhpcy5fY2hhbm5lbCA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcblx0dGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IC0xO1xuXHR0aGlzLl90b2tlblN0YXJ0Q29sdW1uID0gLTE7XG5cdHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gLTE7XG5cdHRoaXMuX3RleHQgPSBudWxsO1xuXG5cdHRoaXMuX2hpdEVPRiA9IGZhbHNlO1xuXHR0aGlzLl9tb2RlID0gTGV4ZXIuREVGQVVMVF9NT0RFO1xuXHR0aGlzLl9tb2RlU3RhY2sgPSBbXTtcblxuXHR0aGlzLl9pbnRlcnAucmVzZXQoKTtcbn07XG5cbi8vIFJldHVybiBhIHRva2VuIGZyb20gdGhpcyBzb3VyY2U7IGkuZS4sIG1hdGNoIGEgdG9rZW4gb24gdGhlIGNoYXIgc3RyZWFtLlxuTGV4ZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5faW5wdXQgPT09IG51bGwpIHtcblx0XHR0aHJvdyBcIm5leHRUb2tlbiByZXF1aXJlcyBhIG5vbi1udWxsIGlucHV0IHN0cmVhbS5cIjtcblx0fVxuXG5cdC8vIE1hcmsgc3RhcnQgbG9jYXRpb24gaW4gY2hhciBzdHJlYW0gc28gdW5idWZmZXJlZCBzdHJlYW1zIGFyZVxuXHQvLyBndWFyYW50ZWVkIGF0IGxlYXN0IGhhdmUgdGV4dCBvZiBjdXJyZW50IHRva2VuXG5cdHZhciB0b2tlblN0YXJ0TWFya2VyID0gdGhpcy5faW5wdXQubWFyaygpO1xuXHR0cnkge1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAodGhpcy5faGl0RU9GKSB7XG5cdFx0XHRcdHRoaXMuZW1pdEVPRigpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9rZW47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b2tlbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9jaGFubmVsID0gVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuXHRcdFx0dGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xuXHRcdFx0dGhpcy5fdG9rZW5TdGFydENvbHVtbiA9IHRoaXMuX2ludGVycC5jb2x1bW47XG5cdFx0XHR0aGlzLl90b2tlblN0YXJ0TGluZSA9IHRoaXMuX2ludGVycC5saW5lO1xuXHRcdFx0dGhpcy5fdGV4dCA9IG51bGw7XG5cdFx0XHR2YXIgY29udGludWVPdXRlciA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0dGhpcy5fdHlwZSA9IFRva2VuLklOVkFMSURfVFlQRTtcblx0XHRcdFx0dmFyIHR0eXBlID0gTGV4ZXIuU0tJUDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0dHlwZSA9IHRoaXMuX2ludGVycC5tYXRjaCh0aGlzLl9pbnB1dCwgdGhpcy5fbW9kZSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ICAgIGlmKGUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSk7IC8vIHJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyKGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdFx0XHR0aGlzLl9oaXRFT0YgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlID09PSBUb2tlbi5JTlZBTElEX1RZUEUpIHtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09IExleGVyLlNLSVApIHtcblx0XHRcdFx0XHRjb250aW51ZU91dGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gTGV4ZXIuTU9SRSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29udGludWVPdXRlcikge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90b2tlbiA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmVtaXQoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl90b2tlbjtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gbWFrZSBzdXJlIHdlIHJlbGVhc2UgbWFya2VyIGFmdGVyIG1hdGNoIG9yXG5cdFx0Ly8gdW5idWZmZXJlZCBjaGFyIHN0cmVhbSB3aWxsIGtlZXAgYnVmZmVyaW5nXG5cdFx0dGhpcy5faW5wdXQucmVsZWFzZSh0b2tlblN0YXJ0TWFya2VyKTtcblx0fVxufTtcblxuLy8gSW5zdHJ1Y3QgdGhlIGxleGVyIHRvIHNraXAgY3JlYXRpbmcgYSB0b2tlbiBmb3IgY3VycmVudCBsZXhlciBydWxlXG4vLyBhbmQgbG9vayBmb3IgYW5vdGhlciB0b2tlbi4gbmV4dFRva2VuKCkga25vd3MgdG8ga2VlcCBsb29raW5nIHdoZW5cbi8vIGEgbGV4ZXIgcnVsZSBmaW5pc2hlcyB3aXRoIHRva2VuIHNldCB0byBTS0lQX1RPS0VOLiBSZWNhbGwgdGhhdFxuLy8gaWYgdG9rZW49PW51bGwgYXQgZW5kIG9mIGFueSB0b2tlbiBydWxlLCBpdCBjcmVhdGVzIG9uZSBmb3IgeW91XG4vLyBhbmQgZW1pdHMgaXQuXG4vLyAvXG5MZXhlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl90eXBlID0gTGV4ZXIuU0tJUDtcbn07XG5cbkxleGVyLnByb3RvdHlwZS5tb3JlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3R5cGUgPSBMZXhlci5NT1JFO1xufTtcblxuTGV4ZXIucHJvdG90eXBlLm1vZGUgPSBmdW5jdGlvbihtKSB7XG5cdHRoaXMuX21vZGUgPSBtO1xufTtcblxuTGV4ZXIucHJvdG90eXBlLnB1c2hNb2RlID0gZnVuY3Rpb24obSkge1xuXHRpZiAodGhpcy5faW50ZXJwLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJwdXNoTW9kZSBcIiArIG0pO1xuXHR9XG5cdHRoaXMuX21vZGVTdGFjay5wdXNoKHRoaXMuX21vZGUpO1xuXHR0aGlzLm1vZGUobSk7XG59O1xuXG5MZXhlci5wcm90b3R5cGUucG9wTW9kZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fbW9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IFwiRW1wdHkgU3RhY2tcIjtcblx0fVxuXHRpZiAodGhpcy5faW50ZXJwLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJwb3BNb2RlIGJhY2sgdG8gXCIgKyB0aGlzLl9tb2RlU3RhY2suc2xpY2UoMCwgLTEpKTtcblx0fVxuXHR0aGlzLm1vZGUodGhpcy5fbW9kZVN0YWNrLnBvcCgpKTtcblx0cmV0dXJuIHRoaXMuX21vZGU7XG59O1xuXG4vLyBTZXQgdGhlIGNoYXIgc3RyZWFtIGFuZCByZXNldCB0aGUgbGV4ZXJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXhlci5wcm90b3R5cGUsIFwiaW5wdXRTdHJlYW1cIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQ7XG5cdH0sXG5cdHNldCA6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0dGhpcy5faW5wdXQgPSBudWxsO1xuXHRcdHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIgPSBbIHRoaXMsIHRoaXMuX2lucHV0IF07XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0dGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciA9IFsgdGhpcywgdGhpcy5faW5wdXQgXTtcblx0fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXhlci5wcm90b3R5cGUsIFwic291cmNlTmFtZVwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uIHNvdXJjZU5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0LnNvdXJjZU5hbWU7XG5cdH1cbn0pO1xuXG4vLyBCeSBkZWZhdWx0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgZW1pdHMgcGVyIG5leHRUb2tlbiBpbnZvY2F0aW9uXG4vLyBmb3IgZWZmaWNpZW5jeSByZWFzb25zLiBTdWJjbGFzcyBhbmQgb3ZlcnJpZGUgdGhpcyBtZXRob2QsIG5leHRUb2tlbixcbi8vIGFuZCBnZXRUb2tlbiAodG8gcHVzaCB0b2tlbnMgaW50byBhIGxpc3QgYW5kIHB1bGwgZnJvbSB0aGF0IGxpc3Rcbi8vIHJhdGhlciB0aGFuIGEgc2luZ2xlIHZhcmlhYmxlIGFzIHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcykuXG4vLyAvXG5MZXhlci5wcm90b3R5cGUuZW1pdFRva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcblx0dGhpcy5fdG9rZW4gPSB0b2tlbjtcbn07XG5cbi8vIFRoZSBzdGFuZGFyZCBtZXRob2QgY2FsbGVkIHRvIGF1dG9tYXRpY2FsbHkgZW1pdCBhIHRva2VuIGF0IHRoZVxuLy8gb3V0ZXJtb3N0IGxleGljYWwgcnVsZS4gVGhlIHRva2VuIG9iamVjdCBzaG91bGQgcG9pbnQgaW50byB0aGVcbi8vIGNoYXIgYnVmZmVyIHN0YXJ0Li5zdG9wLiBJZiB0aGVyZSBpcyBhIHRleHQgb3ZlcnJpZGUgaW4gJ3RleHQnLFxuLy8gdXNlIHRoYXQgdG8gc2V0IHRoZSB0b2tlbidzIHRleHQuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGVtaXRcbi8vIGN1c3RvbSBUb2tlbiBvYmplY3RzIG9yIHByb3ZpZGUgYSBuZXcgZmFjdG9yeS5cbi8vIC9cbkxleGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0ID0gdGhpcy5fZmFjdG9yeS5jcmVhdGUodGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciwgdGhpcy5fdHlwZSxcblx0XHRcdHRoaXMuX3RleHQsIHRoaXMuX2NoYW5uZWwsIHRoaXMuX3Rva2VuU3RhcnRDaGFySW5kZXgsIHRoaXNcblx0XHRcdFx0XHQuZ2V0Q2hhckluZGV4KCkgLSAxLCB0aGlzLl90b2tlblN0YXJ0TGluZSxcblx0XHRcdHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4pO1xuXHR0aGlzLmVtaXRUb2tlbih0KTtcblx0cmV0dXJuIHQ7XG59O1xuXG5MZXhlci5wcm90b3R5cGUuZW1pdEVPRiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY3BvcyA9IHRoaXMuY29sdW1uO1xuXHR2YXIgbHBvcyA9IHRoaXMubGluZTtcblx0dmFyIGVvZiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIsIFRva2VuLkVPRixcblx0XHRcdG51bGwsIFRva2VuLkRFRkFVTFRfQ0hBTk5FTCwgdGhpcy5faW5wdXQuaW5kZXgsXG5cdFx0XHR0aGlzLl9pbnB1dC5pbmRleCAtIDEsIGxwb3MsIGNwb3MpO1xuXHR0aGlzLmVtaXRUb2tlbihlb2YpO1xuXHRyZXR1cm4gZW9mO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZTtcblx0fSxcblx0c2V0IDogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJsaW5lXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludGVycC5saW5lO1xuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbihsaW5lKSB7XG5cdFx0dGhpcy5faW50ZXJwLmxpbmUgPSBsaW5lO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJjb2x1bW5cIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJwLmNvbHVtbjtcblx0fSxcblx0c2V0IDogZnVuY3Rpb24oY29sdW1uKSB7XG5cdFx0dGhpcy5faW50ZXJwLmNvbHVtbiA9IGNvbHVtbjtcblx0fVxufSk7XG5cblxuLy8gV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIG9mIGxvb2thaGVhZD8vLy9cbkxleGVyLnByb3RvdHlwZS5nZXRDaGFySW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2lucHV0LmluZGV4O1xufTtcblxuLy8gUmV0dXJuIHRoZSB0ZXh0IG1hdGNoZWQgc28gZmFyIGZvciB0aGUgY3VycmVudCB0b2tlbiBvciBhbnkgdGV4dCBvdmVycmlkZS5cbi8vU2V0IHRoZSBjb21wbGV0ZSB0ZXh0IG9mIHRoaXMgdG9rZW47IGl0IHdpcGVzIGFueSBwcmV2aW91cyBjaGFuZ2VzIHRvIHRoZSB0ZXh0LlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3RleHQgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl90ZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW50ZXJwLmdldFRleHQodGhpcy5faW5wdXQpO1xuXHRcdH1cblx0fSxcblx0c2V0IDogZnVuY3Rpb24odGV4dCkge1xuXHRcdHRoaXMuX3RleHQgPSB0ZXh0O1xuXHR9XG59KTtcbi8vIFJldHVybiBhIGxpc3Qgb2YgYWxsIFRva2VuIG9iamVjdHMgaW4gaW5wdXQgY2hhciBzdHJlYW0uXG4vLyBGb3JjZXMgbG9hZCBvZiBhbGwgdG9rZW5zLiBEb2VzIG5vdCBpbmNsdWRlIEVPRiB0b2tlbi5cbi8vIC9cbkxleGVyLnByb3RvdHlwZS5nZXRBbGxUb2tlbnMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRva2VucyA9IFtdO1xuXHR2YXIgdCA9IHRoaXMubmV4dFRva2VuKCk7XG5cdHdoaWxlICh0LnR5cGUgIT09IFRva2VuLkVPRikge1xuXHRcdHRva2Vucy5wdXNoKHQpO1xuXHRcdHQgPSB0aGlzLm5leHRUb2tlbigpO1xuXHR9XG5cdHJldHVybiB0b2tlbnM7XG59O1xuXG5MZXhlci5wcm90b3R5cGUubm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgc3RhcnQgPSB0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4O1xuXHR2YXIgc3RvcCA9IHRoaXMuX2lucHV0LmluZGV4O1xuXHR2YXIgdGV4dCA9IHRoaXMuX2lucHV0LmdldFRleHQoc3RhcnQsIHN0b3ApO1xuXHR2YXIgbXNnID0gXCJ0b2tlbiByZWNvZ25pdGlvbiBlcnJvciBhdDogJ1wiICsgdGhpcy5nZXRFcnJvckRpc3BsYXkodGV4dCkgKyBcIidcIjtcblx0dmFyIGxpc3RlbmVyID0gdGhpcy5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcblx0bGlzdGVuZXIuc3ludGF4RXJyb3IodGhpcywgbnVsbCwgdGhpcy5fdG9rZW5TdGFydExpbmUsXG5cdFx0XHR0aGlzLl90b2tlblN0YXJ0Q29sdW1uLCBtc2csIGUpO1xufTtcblxuTGV4ZXIucHJvdG90eXBlLmdldEVycm9yRGlzcGxheSA9IGZ1bmN0aW9uKHMpIHtcblx0dmFyIGQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZC5wdXNoKHNbaV0pO1xuXHR9XG5cdHJldHVybiBkLmpvaW4oJycpO1xufTtcblxuTGV4ZXIucHJvdG90eXBlLmdldEVycm9yRGlzcGxheUZvckNoYXIgPSBmdW5jdGlvbihjKSB7XG5cdGlmIChjLmNoYXJDb2RlQXQoMCkgPT09IFRva2VuLkVPRikge1xuXHRcdHJldHVybiBcIjxFT0Y+XCI7XG5cdH0gZWxzZSBpZiAoYyA9PT0gJ1xcbicpIHtcblx0XHRyZXR1cm4gXCJcXFxcblwiO1xuXHR9IGVsc2UgaWYgKGMgPT09ICdcXHQnKSB7XG5cdFx0cmV0dXJuIFwiXFxcXHRcIjtcblx0fSBlbHNlIGlmIChjID09PSAnXFxyJykge1xuXHRcdHJldHVybiBcIlxcXFxyXCI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGM7XG5cdH1cbn07XG5cbkxleGVyLnByb3RvdHlwZS5nZXRDaGFyRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24oYykge1xuXHRyZXR1cm4gXCInXCIgKyB0aGlzLmdldEVycm9yRGlzcGxheUZvckNoYXIoYykgKyBcIidcIjtcbn07XG5cbi8vIExleGVycyBjYW4gbm9ybWFsbHkgbWF0Y2ggYW55IGNoYXIgaW4gaXQncyB2b2NhYnVsYXJ5IGFmdGVyIG1hdGNoaW5nXG4vLyBhIHRva2VuLCBzbyBkbyB0aGUgZWFzeSB0aGluZyBhbmQganVzdCBraWxsIGEgY2hhcmFjdGVyIGFuZCBob3BlXG4vLyBpdCBhbGwgd29ya3Mgb3V0LiBZb3UgY2FuIGluc3RlYWQgdXNlIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2tcbi8vIHRvIGRvIHNvcGhpc3RpY2F0ZWQgZXJyb3IgcmVjb3ZlcnkgaWYgeW91IGFyZSBpbiBhIGZyYWdtZW50IHJ1bGUuXG4vLyAvXG5MZXhlci5wcm90b3R5cGUucmVjb3ZlciA9IGZ1bmN0aW9uKHJlKSB7XG5cdGlmICh0aGlzLl9pbnB1dC5MQSgxKSAhPT0gVG9rZW4uRU9GKSB7XG5cdFx0aWYgKHJlIGluc3RhbmNlb2YgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xuXHRcdFx0Ly8gc2tpcCBhIGNoYXIgYW5kIHRyeSBhZ2FpblxuXHRcdFx0dGhpcy5faW50ZXJwLmNvbnN1bWUodGhpcy5faW5wdXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUT0RPOiBEbyB3ZSBsb3NlIGNoYXJhY3RlciBvciBsaW5lIHBvc2l0aW9uIGluZm9ybWF0aW9uP1xuXHRcdFx0dGhpcy5faW5wdXQuY29uc3VtZSgpO1xuXHRcdH1cblx0fVxufTtcblxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0xleGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbi8vIFByb3ZpZGVzIGFuIGVtcHR5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFOVExSRXJyb3JMaXN0ZW5lcn0uIFRoZVxuLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZCBkb2VzIG5vdGhpbmcsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBhc1xuLy8gbmVjZXNzYXJ5LlxuXG5mdW5jdGlvbiBFcnJvckxpc3RlbmVyKCkge1xuXHRyZXR1cm4gdGhpcztcbn1cblxuRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUuc3ludGF4RXJyb3IgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBvZmZlbmRpbmdTeW1ib2wsIGxpbmUsIGNvbHVtbiwgbXNnLCBlKSB7XG59O1xuXG5FcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBbWJpZ3VpdHkgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncykge1xufTtcblxuRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0ID0gZnVuY3Rpb24ocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncykge1xufTtcblxuRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5ID0gZnVuY3Rpb24ocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpIHtcbn07XG5cbmZ1bmN0aW9uIENvbnNvbGVFcnJvckxpc3RlbmVyKCkge1xuXHRFcnJvckxpc3RlbmVyLmNhbGwodGhpcyk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5Db25zb2xlRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yTGlzdGVuZXIucHJvdG90eXBlKTtcbkNvbnNvbGVFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnNvbGVFcnJvckxpc3RlbmVyO1xuXG4vL1xuLy8gUHJvdmlkZXMgYSBkZWZhdWx0IGluc3RhbmNlIG9mIHtAbGluayBDb25zb2xlRXJyb3JMaXN0ZW5lcn0uXG4vL1xuQ29uc29sZUVycm9yTGlzdGVuZXIuSU5TVEFOQ0UgPSBuZXcgQ29uc29sZUVycm9yTGlzdGVuZXIoKTtcblxuLy9cbi8vIHtAaW5oZXJpdERvY31cbi8vXG4vLyA8cD5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gcHJpbnRzIG1lc3NhZ2VzIHRvIHtAbGluayBTeXN0ZW0vL2Vycn0gY29udGFpbmluZyB0aGVcbi8vIHZhbHVlcyBvZiB7QGNvZGUgbGluZX0sIHtAY29kZSBjaGFyUG9zaXRpb25JbkxpbmV9LCBhbmQge0Bjb2RlIG1zZ30gdXNpbmdcbi8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0LjwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gbGluZSA8ZW0+bGluZTwvZW0+OjxlbT5jaGFyUG9zaXRpb25JbkxpbmU8L2VtPiA8ZW0+bXNnPC9lbT5cbi8vIDwvcHJlPlxuLy9cbkNvbnNvbGVFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5zeW50YXhFcnJvciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY29sdW1uLCBtc2csIGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibGluZSBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbiArIFwiIFwiICsgbXNnKTtcbn07XG5cbmZ1bmN0aW9uIFByb3h5RXJyb3JMaXN0ZW5lcihkZWxlZ2F0ZXMpIHtcblx0RXJyb3JMaXN0ZW5lci5jYWxsKHRoaXMpO1xuICAgIGlmIChkZWxlZ2F0ZXM9PT1udWxsKSB7XG4gICAgICAgIHRocm93IFwiZGVsZWdhdGVzXCI7XG4gICAgfVxuICAgIHRoaXMuZGVsZWdhdGVzID0gZGVsZWdhdGVzO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUpO1xuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb3h5RXJyb3JMaXN0ZW5lcjtcblxuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5zeW50YXhFcnJvciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY29sdW1uLCBtc2csIGUpIHtcbiAgICB0aGlzLmRlbGVnYXRlcy5tYXAoZnVuY3Rpb24oZCkgeyBkLnN5bnRheEVycm9yKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY29sdW1uLCBtc2csIGUpOyB9KTtcbn07XG5cblByb3h5RXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0QW1iaWd1aXR5ID0gZnVuY3Rpb24ocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpIHtcbiAgICB0aGlzLmRlbGVnYXRlcy5tYXAoZnVuY3Rpb24oZCkgeyBkLnJlcG9ydEFtYmlndWl0eShyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7IH0pO1xufTtcblxuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKSB7XG5cdHRoaXMuZGVsZWdhdGVzLm1hcChmdW5jdGlvbihkKSB7IGQucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZpZ3MpOyB9KTtcbn07XG5cblByb3h5RXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5ID0gZnVuY3Rpb24ocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpIHtcblx0dGhpcy5kZWxlZ2F0ZXMubWFwKGZ1bmN0aW9uKGQpIHsgZC5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpOyB9KTtcbn07XG5cbmV4cG9ydHMuRXJyb3JMaXN0ZW5lciA9IEVycm9yTGlzdGVuZXI7XG5leHBvcnRzLkNvbnNvbGVFcnJvckxpc3RlbmVyID0gQ29uc29sZUVycm9yTGlzdGVuZXI7XG5leHBvcnRzLlByb3h5RXJyb3JMaXN0ZW5lciA9IFByb3h5RXJyb3JMaXN0ZW5lcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2Vycm9yL0Vycm9yTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG4vLyBBIERGQSB3YWxrZXIgdGhhdCBrbm93cyBob3cgdG8gZHVtcCB0aGVtIHRvIHNlcmlhbGl6ZWQgc3RyaW5ncy4jL1xuXG5cbmZ1bmN0aW9uIERGQVNlcmlhbGl6ZXIoZGZhLCBsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpIHtcblx0dGhpcy5kZmEgPSBkZmE7XG5cdHRoaXMubGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzIHx8IFtdO1xuXHR0aGlzLnN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzIHx8IFtdO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuREZBU2VyaWFsaXplci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgIGlmKHRoaXMuZGZhLnMwID09PSBudWxsKSB7XG4gICAgICAgcmV0dXJuIG51bGw7XG4gICB9XG4gICB2YXIgYnVmID0gXCJcIjtcbiAgIHZhciBzdGF0ZXMgPSB0aGlzLmRmYS5zb3J0ZWRTdGF0ZXMoKTtcbiAgIGZvcih2YXIgaT0wO2k8c3RhdGVzLmxlbmd0aDtpKyspIHtcbiAgICAgICB2YXIgcyA9IHN0YXRlc1tpXTtcbiAgICAgICBpZihzLmVkZ2VzIT09bnVsbCkge1xuICAgICAgICAgICAgdmFyIG4gPSBzLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgaj0wO2o8bjtqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHMuZWRnZXNbal0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBpZih0IT09bnVsbCAmJiB0LnN0YXRlTnVtYmVyICE9PSAweDdGRkZGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5jb25jYXQodGhpcy5nZXRTdGF0ZVN0cmluZyhzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5jb25jYXQoXCItXCIpO1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KHRoaXMuZ2V0RWRnZUxhYmVsKGopKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmLmNvbmNhdChcIi0+XCIpO1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KHRoaXMuZ2V0U3RhdGVTdHJpbmcodCkpO1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgfVxuICAgfVxuICAgcmV0dXJuIGJ1Zi5sZW5ndGg9PT0wID8gbnVsbCA6IGJ1Zjtcbn07XG5cbkRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldEVkZ2VMYWJlbCA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaT09PTApIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgfSBlbHNlIGlmKHRoaXMubGl0ZXJhbE5hbWVzICE9PW51bGwgfHwgdGhpcy5zeW1ib2xpY05hbWVzIT09bnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsTmFtZXNbaS0xXSB8fCB0aGlzLnN5bWJvbGljTmFtZXNbaS0xXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpLTEpO1xuICAgIH1cbn07XG5cbkRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldFN0YXRlU3RyaW5nID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBiYXNlU3RhdGVTdHIgPSAoIHMuaXNBY2NlcHRTdGF0ZSA/IFwiOlwiIDogXCJcIikgKyBcInNcIiArIHMuc3RhdGVOdW1iZXIgKyAoIHMucmVxdWlyZXNGdWxsQ29udGV4dCA/IFwiXlwiIDogXCJcIik7XG4gICAgaWYocy5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIGlmIChzLnByZWRpY2F0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlU3RhdGVTdHIgKyBcIj0+XCIgKyBzLnByZWRpY2F0ZXMudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlU3RhdGVTdHIgKyBcIj0+XCIgKyBzLnByZWRpY3Rpb24udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlU3RhdGVTdHI7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gTGV4ZXJERkFTZXJpYWxpemVyKGRmYSkge1xuXHRERkFTZXJpYWxpemVyLmNhbGwodGhpcywgZGZhLCBudWxsKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkxleGVyREZBU2VyaWFsaXplci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERGQVNlcmlhbGl6ZXIucHJvdG90eXBlKTtcbkxleGVyREZBU2VyaWFsaXplci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlckRGQVNlcmlhbGl6ZXI7XG5cbkxleGVyREZBU2VyaWFsaXplci5wcm90b3R5cGUuZ2V0RWRnZUxhYmVsID0gZnVuY3Rpb24oaSkge1xuXHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICsgXCInXCI7XG59O1xuXG5leHBvcnRzLkRGQVNlcmlhbGl6ZXIgPSBERkFTZXJpYWxpemVyO1xuZXhwb3J0cy5MZXhlckRGQVNlcmlhbGl6ZXIgPSBMZXhlckRGQVNlcmlhbGl6ZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9kZmEvREZBU2VyaWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbi8vKiBBIHJ1bGUgaW52b2NhdGlvbiByZWNvcmQgZm9yIHBhcnNpbmcuXG4vL1xuLy8gIENvbnRhaW5zIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcnVsZSBub3Qgc3RvcmVkIGluIHRoZVxuLy8gIFJ1bGVDb250ZXh0LiBJdCBoYW5kbGVzIHBhcnNlIHRyZWUgY2hpbGRyZW4gbGlzdCwgQW55IEFUTiBzdGF0ZVxuLy8gIHRyYWNpbmcsIGFuZCB0aGUgZGVmYXVsdCB2YWx1ZXMgYXZhaWxhYmxlIGZvciBydWxlIGluZGljYXRpb25zOlxuLy8gIHN0YXJ0LCBzdG9wLCBydWxlIGluZGV4LCBjdXJyZW50IGFsdCBudW1iZXIsIGN1cnJlbnRcbi8vICBBVE4gc3RhdGUuXG4vL1xuLy8gIFN1YmNsYXNzZXMgbWFkZSBmb3IgZWFjaCBydWxlIGFuZCBncmFtbWFyIHRyYWNrIHRoZSBwYXJhbWV0ZXJzLFxuLy8gIHJldHVybiB2YWx1ZXMsIGxvY2FscywgYW5kIGxhYmVscyBzcGVjaWZpYyB0byB0aGF0IHJ1bGUuIFRoZXNlXG4vLyAgYXJlIHRoZSBvYmplY3RzIHRoYXQgYXJlIHJldHVybmVkIGZyb20gcnVsZXMuXG4vL1xuLy8gIE5vdGUgdGV4dCBpcyBub3QgYW4gYWN0dWFsIGZpZWxkIG9mIGEgcnVsZSByZXR1cm4gdmFsdWU7IGl0IGlzIGNvbXB1dGVkXG4vLyAgZnJvbSBzdGFydCBhbmQgc3RvcCB1c2luZyB0aGUgaW5wdXQgc3RyZWFtJ3MgdG9TdHJpbmcoKSBtZXRob2QuICBJXG4vLyAgY291bGQgYWRkIGEgY3RvciB0byB0aGlzIHNvIHRoYXQgd2UgY2FuIHBhc3MgaW4gYW5kIHN0b3JlIHRoZSBpbnB1dFxuLy8gIHN0cmVhbSwgYnV0IEknbSBub3Qgc3VyZSB3ZSB3YW50IHRvIGRvIHRoYXQuICBJdCB3b3VsZCBzZWVtIHRvIGJlIHVuZGVmaW5lZFxuLy8gIHRvIGdldCB0aGUgLnRleHQgcHJvcGVydHkgYW55d2F5IGlmIHRoZSBydWxlIG1hdGNoZXMgdG9rZW5zIGZyb20gbXVsdGlwbGVcbi8vICBpbnB1dCBzdHJlYW1zLlxuLy9cbi8vICBJIGRvIG5vdCB1c2UgZ2V0dGVycyBmb3IgZmllbGRzIG9mIG9iamVjdHMgdGhhdCBhcmUgdXNlZCBzaW1wbHkgdG9cbi8vICBncm91cCB2YWx1ZXMgc3VjaCBhcyB0aGlzIGFnZ3JlZ2F0ZS4gIFRoZSBnZXR0ZXJzL3NldHRlcnMgYXJlIHRoZXJlIHRvXG4vLyAgc2F0aXNmeSB0aGUgc3VwZXJjbGFzcyBpbnRlcmZhY2UuXG5cbnZhciBSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vUnVsZUNvbnRleHQnKS5SdWxlQ29udGV4dDtcbnZhciBUcmVlID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKTtcbnZhciBJTlZBTElEX0lOVEVSVkFMID0gVHJlZS5JTlZBTElEX0lOVEVSVkFMO1xudmFyIFRlcm1pbmFsTm9kZSA9IFRyZWUuVGVybWluYWxOb2RlO1xudmFyIFRlcm1pbmFsTm9kZUltcGwgPSBUcmVlLlRlcm1pbmFsTm9kZUltcGw7XG52YXIgRXJyb3JOb2RlSW1wbCA9IFRyZWUuRXJyb3JOb2RlSW1wbDtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoXCIuL0ludGVydmFsU2V0XCIpLkludGVydmFsO1xuXG5mdW5jdGlvbiBQYXJzZXJSdWxlQ29udGV4dChwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpIHtcblx0cGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG5cdGludm9raW5nU3RhdGVOdW1iZXIgPSBpbnZva2luZ1N0YXRlTnVtYmVyIHx8IG51bGw7XG5cdFJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcblx0dGhpcy5ydWxlSW5kZXggPSAtMTtcbiAgICAvLyAqIElmIHdlIGFyZSBkZWJ1Z2dpbmcgb3IgYnVpbGRpbmcgYSBwYXJzZSB0cmVlIGZvciBhIHZpc2l0b3IsXG4gICAgLy8gd2UgbmVlZCB0byB0cmFjayBhbGwgb2YgdGhlIHRva2VucyBhbmQgcnVsZSBpbnZvY2F0aW9ucyBhc3NvY2lhdGVkXG4gICAgLy8gd2l0aCB0aGlzIHJ1bGUncyBjb250ZXh0LiBUaGlzIGlzIGVtcHR5IGZvciBwYXJzaW5nIHcvbyB0cmVlIGNvbnN0ci5cbiAgICAvLyBvcGVyYXRpb24gYmVjYXVzZSB3ZSBkb24ndCB0aGUgbmVlZCB0byB0cmFjayB0aGUgZGV0YWlscyBhYm91dFxuICAgIC8vIGhvdyB3ZSBwYXJzZSB0aGlzIHJ1bGUuXG4gICAgLy8gL1xuICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgIHRoaXMuc3RvcCA9IG51bGw7XG4gICAgLy8gVGhlIGV4Y2VwdGlvbiB0aGF0IGZvcmNlZCB0aGlzIHJ1bGUgdG8gcmV0dXJuLiBJZiB0aGUgcnVsZSBzdWNjZXNzZnVsbHlcbiAgICAvLyBjb21wbGV0ZWQsIHRoaXMgaXMge0Bjb2RlIG51bGx9LlxuICAgIHRoaXMuZXhjZXB0aW9uID0gbnVsbDtcbn1cblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2VyUnVsZUNvbnRleHQ7XG5cbi8vICogQ09QWSBhIGN0eCAoSSdtIGRlbGliZXJhdGVseSBub3QgdXNpbmcgY29weSBjb25zdHJ1Y3RvcikvLy9cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIC8vIGZyb20gUnVsZUNvbnRleHRcbiAgICB0aGlzLnBhcmVudEN0eCA9IGN0eC5wYXJlbnRDdHg7XG4gICAgdGhpcy5pbnZva2luZ1N0YXRlID0gY3R4Lmludm9raW5nU3RhdGU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IGN0eC5zdGFydDtcbiAgICB0aGlzLnN0b3AgPSBjdHguc3RvcDtcbiAgICAvLyBjb3B5IGFueSBlcnJvciBub2RlcyB0byBhbHQgbGFiZWwgbm9kZVxuICAgIGlmKGN0eC5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIHJlc2V0IHBhcmVudCBwb2ludGVyIGZvciBhbnkgZXJyb3Igbm9kZXNcbiAgICBcdGN0eC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgRXJyb3JOb2RlSW1wbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50Q3R4ID0gdGhpcztcbiAgICAgICAgICAgIH1cblx0XHR9LCB0aGlzKTtcblx0fVxufTtcblxuLy8gRG91YmxlIGRpc3BhdGNoIG1ldGhvZHMgZm9yIGxpc3RlbmVyc1xuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmVudGVyUnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG59O1xuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuZXhpdFJ1bGUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xufTtcblxuLy8gKiBEb2VzIG5vdCBzZXQgcGFyZW50IGxpbms7IG90aGVyIGFkZCBtZXRob2RzIGRvIHRoYXQvLy9cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8vICogVXNlZCBieSBlbnRlck91dGVyQWx0IHRvIHRvc3Mgb3V0IGEgUnVsZUNvbnRleHQgcHJldmlvdXNseSBhZGRlZCBhc1xuLy8gd2UgZW50ZXJlZCBhIHJ1bGUuIElmIHdlIGhhdmUgLy8gbGFiZWwsIHdlIHdpbGwgbmVlZCB0byByZW1vdmVcbi8vIGdlbmVyaWMgcnVsZUNvbnRleHQgb2JqZWN0LlxuLy8gL1xuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLnJlbW92ZUxhc3RDaGlsZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmFkZFRva2VuTm9kZSA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgVGVybWluYWxOb2RlSW1wbCh0b2tlbik7XG4gICAgdGhpcy5hZGRDaGlsZChub2RlKTtcbiAgICBub2RlLnBhcmVudEN0eCA9IHRoaXM7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuYWRkRXJyb3JOb2RlID0gZnVuY3Rpb24oYmFkVG9rZW4pIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBFcnJvck5vZGVJbXBsKGJhZFRva2VuKTtcbiAgICB0aGlzLmFkZENoaWxkKG5vZGUpO1xuICAgIG5vZGUucGFyZW50Q3R4ID0gdGhpcztcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKGksIHR5cGUpIHtcblx0dHlwZSA9IHR5cGUgfHwgbnVsbDtcblx0aWYgKHRoaXMuY2hpbGRyZW4gPT09IG51bGwgfHwgaSA8IDAgfHwgaSA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICh0eXBlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG5cdH0gZWxzZSB7XG5cdFx0Zm9yKHZhciBqPTA7IGo8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltqXTtcblx0XHRcdGlmKGNoaWxkIGluc3RhbmNlb2YgdHlwZSkge1xuXHRcdFx0XHRpZihpPT09MCkge1xuXHRcdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpIC09IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbih0dHlwZSwgaSkge1xuXHRpZiAodGhpcy5jaGlsZHJlbiA9PT0gbnVsbCB8fCBpIDwgMCB8fCBpID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Zm9yKHZhciBqPTA7IGo8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bal07XG5cdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG5cdFx0XHRpZiAoY2hpbGQuc3ltYm9sLnR5cGUgPT09IHR0eXBlKSB7XG5cdFx0XHRcdGlmKGk9PT0wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgICAgICB9XG5cdH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRUb2tlbnMgPSBmdW5jdGlvbih0dHlwZSApIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbj09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHRmb3IodmFyIGo9MDsgajx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5zeW1ib2wudHlwZSA9PT0gdHR5cGUpIHtcblx0XHRcdFx0XHR0b2tlbnMucHVzaChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRva2VucztcbiAgICB9XG59O1xuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuZ2V0VHlwZWRSdWxlQ29udGV4dCA9IGZ1bmN0aW9uKGN0eFR5cGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZChpLCBjdHhUeXBlKTtcbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRUeXBlZFJ1bGVDb250ZXh0cyA9IGZ1bmN0aW9uKGN0eFR5cGUpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbj09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuXHRcdHZhciBjb250ZXh0cyA9IFtdO1xuXHRcdGZvcih2YXIgaj0wOyBqPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bal07XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBjdHhUeXBlKSB7XG5cdFx0XHRcdGNvbnRleHRzLnB1c2goY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29udGV4dHM7XG5cdH1cbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmNoaWxkcmVuPT09IG51bGwpIHtcblx0XHRyZXR1cm4gMDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cdH1cbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRTb3VyY2VJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKCB0aGlzLnN0YXJ0ID09PSBudWxsIHx8IHRoaXMuc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSU5WQUxJRF9JTlRFUlZBTDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc3RhcnQudG9rZW5JbmRleCwgdGhpcy5zdG9wLnRva2VuSW5kZXgpO1xuICAgIH1cbn07XG5cblJ1bGVDb250ZXh0LkVNUFRZID0gbmV3IFBhcnNlclJ1bGVDb250ZXh0KCk7XG5cbmZ1bmN0aW9uIEludGVycHJldGVyUnVsZUNvbnRleHQocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyLCBydWxlSW5kZXgpIHtcblx0UGFyc2VyUnVsZUNvbnRleHQuY2FsbChwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xuICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5JbnRlcnByZXRlclJ1bGVDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcbkludGVycHJldGVyUnVsZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJwcmV0ZXJSdWxlQ29udGV4dDtcblxuZXhwb3J0cy5QYXJzZXJSdWxlQ29udGV4dCA9IFBhcnNlclJ1bGVDb250ZXh0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9QYXJzZXJSdWxlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xucmVxdWlyZSgnLi9wb2x5ZmlsbHMvY29kZXBvaW50YXQnKTtcbnJlcXVpcmUoJy4vcG9seWZpbGxzL2Zyb21jb2RlcG9pbnQnKTtcblxuLy8gVmFjdXVtIGFsbCBpbnB1dCBmcm9tIGEgc3RyaW5nIGFuZCB0aGVuIHRyZWF0IGl0IGxpa2UgYSBidWZmZXIuXG5cbmZ1bmN0aW9uIF9sb2FkU3RyaW5nKHN0cmVhbSwgZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cykge1xuXHRzdHJlYW0uX2luZGV4ID0gMDtcblx0c3RyZWFtLmRhdGEgPSBbXTtcblx0aWYgKHN0cmVhbS5kZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0uc3RyZGF0YS5sZW5ndGg7ICkge1xuXHRcdFx0dmFyIGNvZGVQb2ludCA9IHN0cmVhbS5zdHJkYXRhLmNvZGVQb2ludEF0KGkpO1xuXHRcdFx0c3RyZWFtLmRhdGEucHVzaChjb2RlUG9pbnQpO1xuXHRcdFx0aSArPSBjb2RlUG9pbnQgPD0gMHhGRkZGID8gMSA6IDI7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLnN0cmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjb2RlVW5pdCA9IHN0cmVhbS5zdHJkYXRhLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRzdHJlYW0uZGF0YS5wdXNoKGNvZGVVbml0KTtcblx0XHR9XG5cdH1cblx0c3RyZWFtLl9zaXplID0gc3RyZWFtLmRhdGEubGVuZ3RoO1xufVxuXG4vLyBJZiBkZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzIGlzIHRydWUsIHRoZSBpbnB1dCBpcyB0cmVhdGVkXG4vLyBhcyBhIHNlcmllcyBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuLy9cbi8vIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIHRyZWF0ZWQgYXMgYSBzZXJpZXMgb2YgMTYtYml0IFVURi0xNiBjb2RlXG4vLyB1bml0cy5cbmZ1bmN0aW9uIElucHV0U3RyZWFtKGRhdGEsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcblx0dGhpcy5uYW1lID0gXCI8ZW1wdHk+XCI7XG5cdHRoaXMuc3RyZGF0YSA9IGRhdGE7XG5cdHRoaXMuZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cyA9IGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMgfHwgZmFsc2U7XG5cdF9sb2FkU3RyaW5nKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0U3RyZWFtLnByb3RvdHlwZSwgXCJpbmRleFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dFN0cmVhbS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG59KTtcblxuLy8gUmVzZXQgdGhlIHN0cmVhbSBzbyB0aGF0IGl0J3MgaW4gdGhlIHNhbWUgc3RhdGUgaXQgd2FzXG4vLyB3aGVuIHRoZSBvYmplY3Qgd2FzIGNyZWF0ZWQgKmV4Y2VwdCogdGhlIGRhdGEgYXJyYXkgaXMgbm90XG4vLyB0b3VjaGVkLlxuLy9cbklucHV0U3RyZWFtLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9pbmRleCA9IDA7XG59O1xuXG5JbnB1dFN0cmVhbS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fc2l6ZSkge1xuXHRcdC8vIGFzc2VydCB0aGlzLkxBKDEpID09IFRva2VuLkVPRlxuXHRcdHRocm93IChcImNhbm5vdCBjb25zdW1lIEVPRlwiKTtcblx0fVxuXHR0aGlzLl9pbmRleCArPSAxO1xufTtcblxuSW5wdXRTdHJlYW0ucHJvdG90eXBlLkxBID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdGlmIChvZmZzZXQgPT09IDApIHtcblx0XHRyZXR1cm4gMDsgLy8gdW5kZWZpbmVkXG5cdH1cblx0aWYgKG9mZnNldCA8IDApIHtcblx0XHRvZmZzZXQgKz0gMTsgLy8gZS5nLiwgdHJhbnNsYXRlIExBKC0xKSB0byB1c2Ugb2Zmc2V0PTBcblx0fVxuXHR2YXIgcG9zID0gdGhpcy5faW5kZXggKyBvZmZzZXQgLSAxO1xuXHRpZiAocG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5fc2l6ZSkgeyAvLyBpbnZhbGlkXG5cdFx0cmV0dXJuIFRva2VuLkVPRjtcblx0fVxuXHRyZXR1cm4gdGhpcy5kYXRhW3Bvc107XG59O1xuXG5JbnB1dFN0cmVhbS5wcm90b3R5cGUuTFQgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0cmV0dXJuIHRoaXMuTEEob2Zmc2V0KTtcbn07XG5cbi8vIG1hcmsvcmVsZWFzZSBkbyBub3RoaW5nOyB3ZSBoYXZlIGVudGlyZSBidWZmZXJcbklucHV0U3RyZWFtLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAtMTtcbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24obWFya2VyKSB7XG59O1xuXG4vLyBjb25zdW1lKCkgYWhlYWQgdW50aWwgcD09X2luZGV4OyBjYW4ndCBqdXN0IHNldCBwPV9pbmRleCBhcyB3ZSBtdXN0XG4vLyB1cGRhdGUgbGluZSBhbmQgY29sdW1uLiBJZiB3ZSBzZWVrIGJhY2t3YXJkcywganVzdCBzZXQgcFxuLy9cbklucHV0U3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24oX2luZGV4KSB7XG5cdGlmIChfaW5kZXggPD0gdGhpcy5faW5kZXgpIHtcblx0XHR0aGlzLl9pbmRleCA9IF9pbmRleDsgLy8ganVzdCBqdW1wOyBkb24ndCB1cGRhdGUgc3RyZWFtIHN0YXRlIChsaW5lLFxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLilcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gc2VlayBmb3J3YXJkXG5cdHRoaXMuX2luZGV4ID0gTWF0aC5taW4oX2luZGV4LCB0aGlzLl9zaXplKTtcbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oc3RhcnQsIHN0b3ApIHtcblx0aWYgKHN0b3AgPj0gdGhpcy5fc2l6ZSkge1xuXHRcdHN0b3AgPSB0aGlzLl9zaXplIC0gMTtcblx0fVxuXHRpZiAoc3RhcnQgPj0gdGhpcy5fc2l6ZSkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0aGlzLmRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcblx0XHRcdHZhciByZXN1bHQgPSBcIlwiO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IHN0b3A7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5kYXRhW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnN0cmRhdGEuc2xpY2Uoc3RhcnQsIHN0b3AgKyAxKTtcblx0XHR9XG5cdH1cbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zdHJkYXRhO1xufTtcblxuZXhwb3J0cy5JbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0lucHV0U3RyZWFtLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgMyIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi8uLi9VdGlscycpO1xudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xudmFyIFJ1bGVOb2RlID0gcmVxdWlyZSgnLi9UcmVlJykuUnVsZU5vZGU7XG52YXIgRXJyb3JOb2RlID0gcmVxdWlyZSgnLi9UcmVlJykuRXJyb3JOb2RlO1xudmFyIFRlcm1pbmFsTm9kZSA9IHJlcXVpcmUoJy4vVHJlZScpLlRlcm1pbmFsTm9kZTtcbnZhciBQYXJzZXJSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUGFyc2VyUnVsZUNvbnRleHQnKS5QYXJzZXJSdWxlQ29udGV4dDtcbnZhciBSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUnVsZUNvbnRleHQnKS5SdWxlQ29udGV4dDtcbnZhciBJTlZBTElEX0FMVF9OVU1CRVIgPSByZXF1aXJlKCcuLy4uL2F0bi9BVE4nKS5JTlZBTElEX0FMVF9OVU1CRVI7XG5cblxuLyoqIEEgc2V0IG9mIHV0aWxpdHkgcm91dGluZXMgdXNlZnVsIGZvciBhbGwga2luZHMgb2YgQU5UTFIgdHJlZXMuICovXG5mdW5jdGlvbiBUcmVlcygpIHtcbn1cblxuLy8gUHJpbnQgb3V0IGEgd2hvbGUgdHJlZSBpbiBMSVNQIGZvcm0uIHtAbGluayAvL2dldE5vZGVUZXh0fSBpcyB1c2VkIG9uIHRoZVxuLy8gIG5vZGUgcGF5bG9hZHMgdG8gZ2V0IHRoZSB0ZXh0IGZvciB0aGUgbm9kZXMuICBEZXRlY3Rcbi8vICBwYXJzZSB0cmVlcyBhbmQgZXh0cmFjdCBkYXRhIGFwcHJvcHJpYXRlbHkuXG5UcmVlcy50b1N0cmluZ1RyZWUgPSBmdW5jdGlvbih0cmVlLCBydWxlTmFtZXMsIHJlY29nKSB7XG5cdHJ1bGVOYW1lcyA9IHJ1bGVOYW1lcyB8fCBudWxsO1xuXHRyZWNvZyA9IHJlY29nIHx8IG51bGw7XG4gICAgaWYocmVjb2chPT1udWxsKSB7XG4gICAgICAgcnVsZU5hbWVzID0gcmVjb2cucnVsZU5hbWVzO1xuICAgIH1cbiAgICB2YXIgcyA9IFRyZWVzLmdldE5vZGVUZXh0KHRyZWUsIHJ1bGVOYW1lcyk7XG4gICAgcyA9IFV0aWxzLmVzY2FwZVdoaXRlc3BhY2UocywgZmFsc2UpO1xuICAgIHZhciBjID0gdHJlZS5nZXRDaGlsZENvdW50KCk7XG4gICAgaWYoYz09PTApIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHZhciByZXMgPSBcIihcIiArIHMgKyAnICc7XG4gICAgaWYoYz4wKSB7XG4gICAgICAgIHMgPSBUcmVlcy50b1N0cmluZ1RyZWUodHJlZS5nZXRDaGlsZCgwKSwgcnVsZU5hbWVzKTtcbiAgICAgICAgcmVzID0gcmVzLmNvbmNhdChzKTtcbiAgICB9XG4gICAgZm9yKHZhciBpPTE7aTxjO2krKykge1xuICAgICAgICBzID0gVHJlZXMudG9TdHJpbmdUcmVlKHRyZWUuZ2V0Q2hpbGQoaSksIHJ1bGVOYW1lcyk7XG4gICAgICAgIHJlcyA9IHJlcy5jb25jYXQoJyAnICsgcyk7XG4gICAgfVxuICAgIHJlcyA9IHJlcy5jb25jYXQoXCIpXCIpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG5UcmVlcy5nZXROb2RlVGV4dCA9IGZ1bmN0aW9uKHQsIHJ1bGVOYW1lcywgcmVjb2cpIHtcblx0cnVsZU5hbWVzID0gcnVsZU5hbWVzIHx8IG51bGw7XG5cdHJlY29nID0gcmVjb2cgfHwgbnVsbDtcbiAgICBpZihyZWNvZyE9PW51bGwpIHtcbiAgICAgICAgcnVsZU5hbWVzID0gcmVjb2cucnVsZU5hbWVzO1xuICAgIH1cbiAgICBpZihydWxlTmFtZXMhPT1udWxsKSB7XG4gICAgICAgaWYgKHQgaW5zdGFuY2VvZiBSdWxlQ29udGV4dCkge1xuICAgICAgICAgICB2YXIgYWx0TnVtYmVyID0gdC5nZXRBbHROdW1iZXIoKTtcbiAgICAgICAgICAgaWYgKCBhbHROdW1iZXIhPUlOVkFMSURfQUxUX05VTUJFUiApIHtcbiAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZXNbdC5ydWxlSW5kZXhdK1wiOlwiK2FsdE51bWJlcjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gcnVsZU5hbWVzW3QucnVsZUluZGV4XTtcbiAgICAgICB9IGVsc2UgaWYgKCB0IGluc3RhbmNlb2YgRXJyb3JOb2RlKSB7XG4gICAgICAgICAgIHJldHVybiB0LnRvU3RyaW5nKCk7XG4gICAgICAgfSBlbHNlIGlmKHQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgaWYodC5zeW1ib2whPT1udWxsKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gdC5zeW1ib2wudGV4dDtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gcmVjb2cgZm9yIHJ1bGUgbmFtZXNcbiAgICB2YXIgcGF5bG9hZCA9IHQuZ2V0UGF5bG9hZCgpO1xuICAgIGlmIChwYXlsb2FkIGluc3RhbmNlb2YgVG9rZW4gKSB7XG4gICAgICAgcmV0dXJuIHBheWxvYWQudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHQuZ2V0UGF5bG9hZCgpLnRvU3RyaW5nKCk7XG59O1xuXG5cbi8vIFJldHVybiBvcmRlcmVkIGxpc3Qgb2YgYWxsIGNoaWxkcmVuIG9mIHRoaXMgbm9kZVxuVHJlZXMuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbih0KSB7XG5cdHZhciBsaXN0ID0gW107XG5cdGZvcih2YXIgaT0wO2k8dC5nZXRDaGlsZENvdW50KCk7aSsrKSB7XG5cdFx0bGlzdC5wdXNoKHQuZ2V0Q2hpbGQoaSkpO1xuXHR9XG5cdHJldHVybiBsaXN0O1xufTtcblxuLy8gUmV0dXJuIGEgbGlzdCBvZiBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgbm9kZS4gIFRoZSBmaXJzdCBub2RlIG9mXG4vLyAgbGlzdCBpcyB0aGUgcm9vdCBhbmQgdGhlIGxhc3QgaXMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUuXG4vL1xuVHJlZXMuZ2V0QW5jZXN0b3JzID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB0ID0gdC5nZXRQYXJlbnQoKTtcbiAgICB3aGlsZSh0IT09bnVsbCkge1xuICAgICAgICBhbmNlc3RvcnMgPSBbdF0uY29uY2F0KGFuY2VzdG9ycyk7XG4gICAgICAgIHQgPSB0LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3JzO1xufTtcblxuVHJlZXMuZmluZEFsbFRva2VuTm9kZXMgPSBmdW5jdGlvbih0LCB0dHlwZSkge1xuICAgIHJldHVybiBUcmVlcy5maW5kQWxsTm9kZXModCwgdHR5cGUsIHRydWUpO1xufTtcblxuVHJlZXMuZmluZEFsbFJ1bGVOb2RlcyA9IGZ1bmN0aW9uKHQsIHJ1bGVJbmRleCkge1xuXHRyZXR1cm4gVHJlZXMuZmluZEFsbE5vZGVzKHQsIHJ1bGVJbmRleCwgZmFsc2UpO1xufTtcblxuVHJlZXMuZmluZEFsbE5vZGVzID0gZnVuY3Rpb24odCwgaW5kZXgsIGZpbmRUb2tlbnMpIHtcblx0dmFyIG5vZGVzID0gW107XG5cdFRyZWVzLl9maW5kQWxsTm9kZXModCwgaW5kZXgsIGZpbmRUb2tlbnMsIG5vZGVzKTtcblx0cmV0dXJuIG5vZGVzO1xufTtcblxuVHJlZXMuX2ZpbmRBbGxOb2RlcyA9IGZ1bmN0aW9uKHQsIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcykge1xuXHQvLyBjaGVjayB0aGlzIG5vZGUgKHRoZSByb290KSBmaXJzdFxuXHRpZihmaW5kVG9rZW5zICYmICh0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSkge1xuXHRcdGlmKHQuc3ltYm9sLnR5cGU9PT1pbmRleCkge1xuXHRcdFx0bm9kZXMucHVzaCh0KTtcblx0XHR9XG5cdH0gZWxzZSBpZighZmluZFRva2VucyAmJiAodCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0KSkge1xuXHRcdGlmKHQucnVsZUluZGV4PT09aW5kZXgpIHtcblx0XHRcdG5vZGVzLnB1c2godCk7XG5cdFx0fVxuXHR9XG5cdC8vIGNoZWNrIGNoaWxkcmVuXG5cdGZvcih2YXIgaT0wO2k8dC5nZXRDaGlsZENvdW50KCk7aSsrKSB7XG5cdFx0VHJlZXMuX2ZpbmRBbGxOb2Rlcyh0LmdldENoaWxkKGkpLCBpbmRleCwgZmluZFRva2Vucywgbm9kZXMpO1xuXHR9XG59O1xuXG5UcmVlcy5kZXNjZW5kYW50cyA9IGZ1bmN0aW9uKHQpIHtcblx0dmFyIG5vZGVzID0gW3RdO1xuICAgIGZvcih2YXIgaT0wO2k8dC5nZXRDaGlsZENvdW50KCk7aSsrKSB7XG4gICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KFRyZWVzLmRlc2NlbmRhbnRzKHQuZ2V0Q2hpbGQoaSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufTtcblxuXG5leHBvcnRzLlRyZWVzID0gVHJlZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L3RyZWUvVHJlZXMuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLy4uL1Rva2VuJykuVG9rZW47XG52YXIgQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG52YXIgQVROVHlwZSA9IHJlcXVpcmUoJy4vQVROVHlwZScpLkFUTlR5cGU7XG52YXIgQVROU3RhdGVzID0gcmVxdWlyZSgnLi9BVE5TdGF0ZScpO1xudmFyIEFUTlN0YXRlID0gQVROU3RhdGVzLkFUTlN0YXRlO1xudmFyIEJhc2ljU3RhdGUgPSBBVE5TdGF0ZXMuQmFzaWNTdGF0ZTtcbnZhciBEZWNpc2lvblN0YXRlID0gQVROU3RhdGVzLkRlY2lzaW9uU3RhdGU7XG52YXIgQmxvY2tTdGFydFN0YXRlID0gQVROU3RhdGVzLkJsb2NrU3RhcnRTdGF0ZTtcbnZhciBCbG9ja0VuZFN0YXRlID0gQVROU3RhdGVzLkJsb2NrRW5kU3RhdGU7XG52YXIgTG9vcEVuZFN0YXRlID0gQVROU3RhdGVzLkxvb3BFbmRTdGF0ZTtcbnZhciBSdWxlU3RhcnRTdGF0ZSA9IEFUTlN0YXRlcy5SdWxlU3RhcnRTdGF0ZTtcbnZhciBSdWxlU3RvcFN0YXRlID0gQVROU3RhdGVzLlJ1bGVTdG9wU3RhdGU7XG52YXIgVG9rZW5zU3RhcnRTdGF0ZSA9IEFUTlN0YXRlcy5Ub2tlbnNTdGFydFN0YXRlO1xudmFyIFBsdXNMb29wYmFja1N0YXRlID0gQVROU3RhdGVzLlBsdXNMb29wYmFja1N0YXRlO1xudmFyIFN0YXJMb29wYmFja1N0YXRlID0gQVROU3RhdGVzLlN0YXJMb29wYmFja1N0YXRlO1xudmFyIFN0YXJMb29wRW50cnlTdGF0ZSA9IEFUTlN0YXRlcy5TdGFyTG9vcEVudHJ5U3RhdGU7XG52YXIgUGx1c0Jsb2NrU3RhcnRTdGF0ZSA9IEFUTlN0YXRlcy5QbHVzQmxvY2tTdGFydFN0YXRlO1xudmFyIFN0YXJCbG9ja1N0YXJ0U3RhdGUgPSBBVE5TdGF0ZXMuU3RhckJsb2NrU3RhcnRTdGF0ZTtcbnZhciBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IEFUTlN0YXRlcy5CYXNpY0Jsb2NrU3RhcnRTdGF0ZTtcbnZhciBUcmFuc2l0aW9ucyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbicpO1xudmFyIFRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5UcmFuc2l0aW9uO1xudmFyIEF0b21UcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuQXRvbVRyYW5zaXRpb247XG52YXIgU2V0VHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlNldFRyYW5zaXRpb247XG52YXIgTm90U2V0VHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLk5vdFNldFRyYW5zaXRpb247XG52YXIgUnVsZVRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5SdWxlVHJhbnNpdGlvbjtcbnZhciBSYW5nZVRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5SYW5nZVRyYW5zaXRpb247XG52YXIgQWN0aW9uVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLkFjdGlvblRyYW5zaXRpb247XG52YXIgRXBzaWxvblRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5FcHNpbG9uVHJhbnNpdGlvbjtcbnZhciBXaWxkY2FyZFRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5XaWxkY2FyZFRyYW5zaXRpb247XG52YXIgUHJlZGljYXRlVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlByZWRpY2F0ZVRyYW5zaXRpb247XG52YXIgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbjtcbnZhciBJbnRlcnZhbFNldCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbFNldDtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbnZhciBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zID0gcmVxdWlyZSgnLi9BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zJykuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucztcbnZhciBMZXhlckFjdGlvbnMgPSByZXF1aXJlKCcuL0xleGVyQWN0aW9uJyk7XG52YXIgTGV4ZXJBY3Rpb25UeXBlID0gTGV4ZXJBY3Rpb25zLkxleGVyQWN0aW9uVHlwZTtcbnZhciBMZXhlclNraXBBY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJTa2lwQWN0aW9uO1xudmFyIExleGVyQ2hhbm5lbEFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlckNoYW5uZWxBY3Rpb247XG52YXIgTGV4ZXJDdXN0b21BY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJDdXN0b21BY3Rpb247XG52YXIgTGV4ZXJNb3JlQWN0aW9uID0gTGV4ZXJBY3Rpb25zLkxleGVyTW9yZUFjdGlvbjtcbnZhciBMZXhlclR5cGVBY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJUeXBlQWN0aW9uO1xudmFyIExleGVyUHVzaE1vZGVBY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJQdXNoTW9kZUFjdGlvbjtcbnZhciBMZXhlclBvcE1vZGVBY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJQb3BNb2RlQWN0aW9uO1xudmFyIExleGVyTW9kZUFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlck1vZGVBY3Rpb247XG4vLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCBzdXBwb3J0ZWQgc2VyaWFsaXplZCBVVUlELlxuLy8gc3RpY2sgdG8gc2VyaWFsaXplZCB2ZXJzaW9uIGZvciBub3csIHdlIGRvbid0IG5lZWQgYSBVVUlEIGluc3RhbmNlXG52YXIgQkFTRV9TRVJJQUxJWkVEX1VVSUQgPSBcIkFBREI4RDdFLUFFRUYtNDQxNS1BRDJCLTgyMDRENkNGMDQyRVwiO1xuXG4vL1xuLy8gVGhpcyBVVUlEIGluZGljYXRlcyB0aGUgc2VyaWFsaXplZCBBVE4gY29udGFpbnMgdHdvIHNldHMgb2Zcbi8vIEludGVydmFsU2V0cywgd2hlcmUgdGhlIHNlY29uZCBzZXQncyB2YWx1ZXMgYXJlIGVuY29kZWQgYXNcbi8vIDMyLWJpdCBpbnRlZ2VycyB0byBzdXBwb3J0IHRoZSBmdWxsIFVuaWNvZGUgU01QIHJhbmdlIHVwIHRvIFUrMTBGRkZGLlxuLy9cbnZhciBBRERFRF9VTklDT0RFX1NNUCA9IFwiNTk2Mjc3ODQtM0JFNS00MTdBLUI5RUItODEzMUE3Mjg2MDg5XCI7XG5cbi8vIFRoaXMgbGlzdCBjb250YWlucyBhbGwgb2YgdGhlIGN1cnJlbnRseSBzdXBwb3J0ZWQgVVVJRHMsIG9yZGVyZWQgYnkgd2hlblxuLy8gdGhlIGZlYXR1cmUgZmlyc3QgYXBwZWFyZWQgaW4gdGhpcyBicmFuY2guXG52YXIgU1VQUE9SVEVEX1VVSURTID0gWyBCQVNFX1NFUklBTElaRURfVVVJRCwgQURERURfVU5JQ09ERV9TTVAgXTtcblxudmFyIFNFUklBTElaRURfVkVSU0lPTiA9IDM7XG5cbi8vIFRoaXMgaXMgdGhlIGN1cnJlbnQgc2VyaWFsaXplZCBVVUlELlxudmFyIFNFUklBTElaRURfVVVJRCA9IEFEREVEX1VOSUNPREVfU01QO1xuXG5mdW5jdGlvbiBpbml0QXJyYXkoIGxlbmd0aCwgdmFsdWUpIHtcblx0dmFyIHRtcCA9IFtdO1xuXHR0bXBbbGVuZ3RoLTFdID0gdmFsdWU7XG5cdHJldHVybiB0bXAubWFwKGZ1bmN0aW9uKGkpIHtyZXR1cm4gdmFsdWU7fSk7XG59XG5cbmZ1bmN0aW9uIEFUTkRlc2VyaWFsaXplciAob3B0aW9ucykge1xuXG4gICAgaWYgKCBvcHRpb25zPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zID09PSBudWxsICkge1xuICAgICAgICBvcHRpb25zID0gQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5kZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0YXRlRmFjdG9yaWVzID0gbnVsbDtcbiAgICB0aGlzLmFjdGlvbkZhY3RvcmllcyA9IG51bGw7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuLy8gRGV0ZXJtaW5lcyBpZiBhIHBhcnRpY3VsYXIgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBhbiBBVE4gc3VwcG9ydHNcbi8vIGEgcGFydGljdWxhciBmZWF0dXJlLCBpZGVudGlmaWVkIGJ5IHRoZSB7QGxpbmsgVVVJRH0gdXNlZCBmb3Igc2VyaWFsaXppbmdcbi8vIHRoZSBBVE4gYXQgdGhlIHRpbWUgdGhlIGZlYXR1cmUgd2FzIGZpcnN0IGludHJvZHVjZWQuXG4vL1xuLy8gQHBhcmFtIGZlYXR1cmUgVGhlIHtAbGluayBVVUlEfSBtYXJraW5nIHRoZSBmaXJzdCB0aW1lIHRoZSBmZWF0dXJlIHdhc1xuLy8gc3VwcG9ydGVkIGluIHRoZSBzZXJpYWxpemVkIEFUTi5cbi8vIEBwYXJhbSBhY3R1YWxVdWlkIFRoZSB7QGxpbmsgVVVJRH0gb2YgdGhlIGFjdHVhbCBzZXJpYWxpemVkIEFUTiB3aGljaCBpc1xuLy8gY3VycmVudGx5IGJlaW5nIGRlc2VyaWFsaXplZC5cbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIHRoZSB7QGNvZGUgYWN0dWFsVXVpZH0gdmFsdWUgcmVwcmVzZW50cyBhXG4vLyBzZXJpYWxpemVkIEFUTiBhdCBvciBhZnRlciB0aGUgZmVhdHVyZSBpZGVudGlmaWVkIGJ5IHtAY29kZSBmZWF0dXJlfSB3YXNcbi8vIGludHJvZHVjZWQ7IG90aGVyd2lzZSwge0Bjb2RlIGZhbHNlfS5cblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5pc0ZlYXR1cmVTdXBwb3J0ZWQgPSBmdW5jdGlvbihmZWF0dXJlLCBhY3R1YWxVdWlkKSB7XG4gICAgdmFyIGlkeDEgPSBTVVBQT1JURURfVVVJRFMuaW5kZXhPZihmZWF0dXJlKTtcbiAgICBpZiAoaWR4MTwwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkeDIgPSBTVVBQT1JURURfVVVJRFMuaW5kZXhPZihhY3R1YWxVdWlkKTtcbiAgICByZXR1cm4gaWR4MiA+PSBpZHgxO1xufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0KGRhdGEpO1xuICAgIHRoaXMuY2hlY2tWZXJzaW9uKCk7XG4gICAgdGhpcy5jaGVja1VVSUQoKTtcbiAgICB2YXIgYXRuID0gdGhpcy5yZWFkQVROKCk7XG4gICAgdGhpcy5yZWFkU3RhdGVzKGF0bik7XG4gICAgdGhpcy5yZWFkUnVsZXMoYXRuKTtcbiAgICB0aGlzLnJlYWRNb2RlcyhhdG4pO1xuICAgIHZhciBzZXRzID0gW107XG4gICAgLy8gRmlyc3QsIGRlc2VyaWFsaXplIHNldHMgd2l0aCAxNi1iaXQgYXJndW1lbnRzIDw9IFUrRkZGRi5cbiAgICB0aGlzLnJlYWRTZXRzKGF0biwgc2V0cywgdGhpcy5yZWFkSW50LmJpbmQodGhpcykpO1xuICAgIC8vIE5leHQsIGlmIHRoZSBBVE4gd2FzIHNlcmlhbGl6ZWQgd2l0aCB0aGUgVW5pY29kZSBTTVAgZmVhdHVyZSxcbiAgICAvLyBkZXNlcmlhbGl6ZSBzZXRzIHdpdGggMzItYml0IGFyZ3VtZW50cyA8PSBVKzEwRkZGRi5cbiAgICBpZiAodGhpcy5pc0ZlYXR1cmVTdXBwb3J0ZWQoQURERURfVU5JQ09ERV9TTVAsIHRoaXMudXVpZCkpIHtcbiAgICAgICAgdGhpcy5yZWFkU2V0cyhhdG4sIHNldHMsIHRoaXMucmVhZEludDMyLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB0aGlzLnJlYWRFZGdlcyhhdG4sIHNldHMpO1xuICAgIHRoaXMucmVhZERlY2lzaW9ucyhhdG4pO1xuICAgIHRoaXMucmVhZExleGVyQWN0aW9ucyhhdG4pO1xuICAgIHRoaXMubWFya1ByZWNlZGVuY2VEZWNpc2lvbnMoYXRuKTtcbiAgICB0aGlzLnZlcmlmeUFUTihhdG4pO1xuICAgIGlmICh0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgJiYgYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLlBBUlNFUiApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyhhdG4pO1xuICAgICAgICAvLyByZS12ZXJpZnkgYWZ0ZXIgbW9kaWZpY2F0aW9uXG4gICAgICAgIHRoaXMudmVyaWZ5QVROKGF0bik7XG4gICAgfVxuICAgIHJldHVybiBhdG47XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgYWRqdXN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgdiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIHY+MSAgPyB2LTIgOiB2ICsgNjU1MzM7XG5cdH07XG4gICAgdmFyIHRlbXAgPSBkYXRhLnNwbGl0KFwiXCIpLm1hcChhZGp1c3QpO1xuICAgIC8vIGRvbid0IGFkanVzdCB0aGUgZmlyc3QgdmFsdWUgc2luY2UgdGhhdCdzIHRoZSB2ZXJzaW9uIG51bWJlclxuICAgIHRlbXBbMF0gPSBkYXRhLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhpcy5kYXRhID0gdGVtcDtcbiAgICB0aGlzLnBvcyA9IDA7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmNoZWNrVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gdGhpcy5yZWFkSW50KCk7XG4gICAgaWYgKCB2ZXJzaW9uICE9PSBTRVJJQUxJWkVEX1ZFUlNJT04gKSB7XG4gICAgICAgIHRocm93IChcIkNvdWxkIG5vdCBkZXNlcmlhbGl6ZSBBVE4gd2l0aCB2ZXJzaW9uIFwiICsgdmVyc2lvbiArIFwiIChleHBlY3RlZCBcIiArIFNFUklBTElaRURfVkVSU0lPTiArIFwiKS5cIik7XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5jaGVja1VVSUQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXVpZCA9IHRoaXMucmVhZFVVSUQoKTtcbiAgICBpZiAoU1VQUE9SVEVEX1VVSURTLmluZGV4T2YodXVpZCk8MCkge1xuICAgICAgICB0aHJvdyAoXCJDb3VsZCBub3QgZGVzZXJpYWxpemUgQVROIHdpdGggVVVJRDogXCIgKyB1dWlkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIChleHBlY3RlZCBcIiArIFNFUklBTElaRURfVVVJRCArIFwiIG9yIGEgbGVnYWN5IFVVSUQpLlwiLCB1dWlkLCBTRVJJQUxJWkVEX1VVSUQpO1xuICAgIH1cbiAgICB0aGlzLnV1aWQgPSB1dWlkO1xufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkQVROID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdyYW1tYXJUeXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgdmFyIG1heFRva2VuVHlwZSA9IHRoaXMucmVhZEludCgpO1xuICAgIHJldHVybiBuZXcgQVROKGdyYW1tYXJUeXBlLCBtYXhUb2tlblR5cGUpO1xufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkU3RhdGVzID0gZnVuY3Rpb24oYXRuKSB7XG5cdHZhciBqLCBwYWlyLCBzdGF0ZU51bWJlcjtcbiAgICB2YXIgbG9vcEJhY2tTdGF0ZU51bWJlcnMgPSBbXTtcbiAgICB2YXIgZW5kU3RhdGVOdW1iZXJzID0gW107XG4gICAgdmFyIG5zdGF0ZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBmb3IodmFyIGk9MDsgaTxuc3RhdGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIC8vIGlnbm9yZSBiYWQgdHlwZSBvZiBzdGF0ZXNcbiAgICAgICAgaWYgKHN0eXBlPT09QVROU3RhdGUuSU5WQUxJRF9UWVBFKSB7XG4gICAgICAgICAgICBhdG4uYWRkU3RhdGUobnVsbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZUluZGV4ID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGlmIChydWxlSW5kZXggPT09IDB4RkZGRikge1xuICAgICAgICAgICAgcnVsZUluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlRmFjdG9yeShzdHlwZSwgcnVsZUluZGV4KTtcbiAgICAgICAgaWYgKHN0eXBlID09PSBBVE5TdGF0ZS5MT09QX0VORCkgeyAvLyBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIHZhciBsb29wQmFja1N0YXRlTnVtYmVyID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgICAgICBsb29wQmFja1N0YXRlTnVtYmVycy5wdXNoKFtzLCBsb29wQmFja1N0YXRlTnVtYmVyXSk7XG4gICAgICAgIH0gZWxzZSBpZihzIGluc3RhbmNlb2YgQmxvY2tTdGFydFN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZW5kU3RhdGVOdW1iZXIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICAgIGVuZFN0YXRlTnVtYmVycy5wdXNoKFtzLCBlbmRTdGF0ZU51bWJlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGF0bi5hZGRTdGF0ZShzKTtcbiAgICB9XG4gICAgLy8gZGVsYXkgdGhlIGFzc2lnbm1lbnQgb2YgbG9vcCBiYWNrIGFuZCBlbmQgc3RhdGVzIHVudGlsIHdlIGtub3cgYWxsIHRoZVxuXHQvLyBzdGF0ZSBpbnN0YW5jZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkXG4gICAgZm9yIChqPTA7IGo8bG9vcEJhY2tTdGF0ZU51bWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFpciA9IGxvb3BCYWNrU3RhdGVOdW1iZXJzW2pdO1xuICAgICAgICBwYWlyWzBdLmxvb3BCYWNrU3RhdGUgPSBhdG4uc3RhdGVzW3BhaXJbMV1dO1xuICAgIH1cblxuICAgIGZvciAoaj0wOyBqPGVuZFN0YXRlTnVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYWlyID0gZW5kU3RhdGVOdW1iZXJzW2pdO1xuICAgICAgICBwYWlyWzBdLmVuZFN0YXRlID0gYXRuLnN0YXRlc1twYWlyWzFdXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtTm9uR3JlZWR5U3RhdGVzID0gdGhpcy5yZWFkSW50KCk7XG4gICAgZm9yIChqPTA7IGo8bnVtTm9uR3JlZWR5U3RhdGVzOyBqKyspIHtcbiAgICAgICAgc3RhdGVOdW1iZXIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgYXRuLnN0YXRlc1tzdGF0ZU51bWJlcl0ubm9uR3JlZWR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbnVtUHJlY2VkZW5jZVN0YXRlcyA9IHRoaXMucmVhZEludCgpO1xuICAgIGZvciAoaj0wOyBqPG51bVByZWNlZGVuY2VTdGF0ZXM7IGorKykge1xuICAgICAgICBzdGF0ZU51bWJlciA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXS5pc1ByZWNlZGVuY2VSdWxlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRSdWxlcyA9IGZ1bmN0aW9uKGF0bikge1xuICAgIHZhciBpO1xuICAgIHZhciBucnVsZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBpZiAoYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSICkge1xuICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlID0gaW5pdEFycmF5KG5ydWxlcywgMCk7XG4gICAgfVxuICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlID0gaW5pdEFycmF5KG5ydWxlcywgMCk7XG4gICAgZm9yIChpPTA7IGk8bnJ1bGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBhdG4uc3RhdGVzW3NdO1xuICAgICAgICBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIGlmICggYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSICkge1xuICAgICAgICAgICAgdmFyIHRva2VuVHlwZSA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlID0gVG9rZW4uRU9GO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IHRva2VuVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdG4ucnVsZVRvU3RvcFN0YXRlID0gaW5pdEFycmF5KG5ydWxlcywgMCk7XG4gICAgZm9yIChpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdG4ucnVsZVRvU3RvcFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0gPSBzdGF0ZTtcbiAgICAgICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhdGUucnVsZUluZGV4XS5zdG9wU3RhdGUgPSBzdGF0ZTtcbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRNb2RlcyA9IGZ1bmN0aW9uKGF0bikge1xuICAgIHZhciBubW9kZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8bm1vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgYXRuLm1vZGVUb1N0YXJ0U3RhdGUucHVzaChhdG4uc3RhdGVzW3NdKTtcbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRTZXRzID0gZnVuY3Rpb24oYXRuLCBzZXRzLCByZWFkVW5pY29kZSkge1xuICAgIHZhciBtID0gdGhpcy5yZWFkSW50KCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPG07IGkrKykge1xuICAgICAgICB2YXIgaXNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgICBzZXRzLnB1c2goaXNldCk7XG4gICAgICAgIHZhciBuID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIHZhciBjb250YWluc0VvZiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBpZiAoY29udGFpbnNFb2YhPT0wKSB7XG4gICAgICAgICAgICBpc2V0LmFkZE9uZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaj0wOyBqPG47IGorKykge1xuICAgICAgICAgICAgdmFyIGkxID0gcmVhZFVuaWNvZGUoKTtcbiAgICAgICAgICAgIHZhciBpMiA9IHJlYWRVbmljb2RlKCk7XG4gICAgICAgICAgICBpc2V0LmFkZFJhbmdlKGkxLCBpMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRFZGdlcyA9IGZ1bmN0aW9uKGF0biwgc2V0cykge1xuXHR2YXIgaSwgaiwgc3RhdGUsIHRyYW5zLCB0YXJnZXQ7XG4gICAgdmFyIG5lZGdlcyA9IHRoaXMucmVhZEludCgpO1xuICAgIGZvciAoaT0wOyBpPG5lZGdlczsgaSsrKSB7XG4gICAgICAgIHZhciBzcmMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIHRyZyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgdHR5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIGFyZzEgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIGFyZzIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIGFyZzMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdHJhbnMgPSB0aGlzLmVkZ2VGYWN0b3J5KGF0biwgdHR5cGUsIHNyYywgdHJnLCBhcmcxLCBhcmcyLCBhcmczLCBzZXRzKTtcbiAgICAgICAgdmFyIHNyY1N0YXRlID0gYXRuLnN0YXRlc1tzcmNdO1xuICAgICAgICBzcmNTdGF0ZS5hZGRUcmFuc2l0aW9uKHRyYW5zKTtcbiAgICB9XG4gICAgLy8gZWRnZXMgZm9yIHJ1bGUgc3RvcCBzdGF0ZXMgY2FuIGJlIGRlcml2ZWQsIHNvIHRoZXkgYXJlbid0IHNlcmlhbGl6ZWRcbiAgICBmb3IgKGk9MDsgaTxhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcbiAgICAgICAgZm9yIChqPTA7IGo8c3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cdFx0XHR2YXIgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IC0xO1xuXHRcdFx0aWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW3QudGFyZ2V0LnJ1bGVJbmRleF0uaXNQcmVjZWRlbmNlUnVsZSkge1xuXHRcdFx0XHRpZiAodC5wcmVjZWRlbmNlID09PSAwKSB7XG5cdFx0XHRcdFx0b3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IHQudGFyZ2V0LnJ1bGVJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0cmFucyA9IG5ldyBFcHNpbG9uVHJhbnNpdGlvbih0LmZvbGxvd1N0YXRlLCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuKTtcbiAgICAgICAgICAgIGF0bi5ydWxlVG9TdG9wU3RhdGVbdC50YXJnZXQucnVsZUluZGV4XS5hZGRUcmFuc2l0aW9uKHRyYW5zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaT0wOyBpPGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8ga25vdyB0aGUgZW5kIHN0YXRlIHRvIHNldCBpdHMgc3RhcnQgc3RhdGVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lbmRTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IChcIklsbGVnYWxTdGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJsb2NrIGVuZCBzdGF0ZXMgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB0byBhIHNpbmdsZSBibG9jayBzdGFydFxuXHRcdFx0Ly8gc3RhdGVcbiAgICAgICAgICAgIGlmICggc3RhdGUuZW5kU3RhdGUuc3RhcnRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IChcIklsbGVnYWxTdGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmVuZFN0YXRlLnN0YXJ0U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChqPTA7IGo8c3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50cmFuc2l0aW9uc1tqXS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFBsdXNCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lmxvb3BCYWNrU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChqPTA7IGo8c3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50cmFuc2l0aW9uc1tqXS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZERlY2lzaW9ucyA9IGZ1bmN0aW9uKGF0bikge1xuICAgIHZhciBuZGVjaXNpb25zID0gdGhpcy5yZWFkSW50KCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPG5kZWNpc2lvbnM7IGkrKykge1xuICAgICAgICB2YXIgcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgZGVjU3RhdGUgPSBhdG4uc3RhdGVzW3NdO1xuICAgICAgICBhdG4uZGVjaXNpb25Ub1N0YXRlLnB1c2goZGVjU3RhdGUpO1xuICAgICAgICBkZWNTdGF0ZS5kZWNpc2lvbiA9IGk7XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkTGV4ZXJBY3Rpb25zID0gZnVuY3Rpb24oYXRuKSB7XG4gICAgaWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5MRVhFUikge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgYXRuLmxleGVyQWN0aW9ucyA9IGluaXRBcnJheShjb3VudCwgbnVsbCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICAgICAgdmFyIGRhdGExID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgICAgICBpZiAoZGF0YTEgPT09IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIGRhdGExID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YTIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhMiA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgZGF0YTIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZXhlckFjdGlvbiA9IHRoaXMubGV4ZXJBY3Rpb25GYWN0b3J5KGFjdGlvblR5cGUsIGRhdGExLCBkYXRhMik7XG4gICAgICAgICAgICBhdG4ubGV4ZXJBY3Rpb25zW2ldID0gbGV4ZXJBY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gZnVuY3Rpb24oYXRuKSB7XG5cdHZhciBpO1xuICAgIHZhciBjb3VudCA9IGF0bi5ydWxlVG9TdGFydFN0YXRlLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpPGNvdW50OyBpKyspIHtcbiAgICAgICAgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IGF0bi5tYXhUb2tlblR5cGUgKyBpICsgMTtcbiAgICB9XG4gICAgZm9yKGk9MDsgaTxjb3VudDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbihhdG4sIGkpO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGF0biwgaWR4KSB7XG5cdHZhciBpLCBzdGF0ZTtcbiAgICB2YXIgYnlwYXNzU3RhcnQgPSBuZXcgQmFzaWNCbG9ja1N0YXJ0U3RhdGUoKTtcbiAgICBieXBhc3NTdGFydC5ydWxlSW5kZXggPSBpZHg7XG4gICAgYXRuLmFkZFN0YXRlKGJ5cGFzc1N0YXJ0KTtcblxuICAgIHZhciBieXBhc3NTdG9wID0gbmV3IEJsb2NrRW5kU3RhdGUoKTtcbiAgICBieXBhc3NTdG9wLnJ1bGVJbmRleCA9IGlkeDtcbiAgICBhdG4uYWRkU3RhdGUoYnlwYXNzU3RvcCk7XG5cbiAgICBieXBhc3NTdGFydC5lbmRTdGF0ZSA9IGJ5cGFzc1N0b3A7XG4gICAgYXRuLmRlZmluZURlY2lzaW9uU3RhdGUoYnlwYXNzU3RhcnQpO1xuXG4gICAgYnlwYXNzU3RvcC5zdGFydFN0YXRlID0gYnlwYXNzU3RhcnQ7XG5cbiAgICB2YXIgZXhjbHVkZVRyYW5zaXRpb24gPSBudWxsO1xuICAgIHZhciBlbmRTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaWR4XS5pc1ByZWNlZGVuY2VSdWxlKSB7XG4gICAgICAgIC8vIHdyYXAgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBydWxlIHRvIHRoZSBTdGFyTG9vcEVudHJ5U3RhdGVcbiAgICAgICAgZW5kU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IoaT0wOyBpPGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlSXNFbmRTdGF0ZUZvcihzdGF0ZSwgaWR4KSkge1xuICAgICAgICAgICAgICAgIGVuZFN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgZXhjbHVkZVRyYW5zaXRpb24gPSBzdGF0ZS5sb29wQmFja1N0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNsdWRlVHJhbnNpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKFwiQ291bGRuJ3QgaWRlbnRpZnkgZmluYWwgc3RhdGUgb2YgdGhlIHByZWNlZGVuY2UgcnVsZSBwcmVmaXggc2VjdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRTdGF0ZSA9IGF0bi5ydWxlVG9TdG9wU3RhdGVbaWR4XTtcbiAgICB9XG5cbiAgICAvLyBhbGwgbm9uLWV4Y2x1ZGVkIHRyYW5zaXRpb25zIHRoYXQgY3VycmVudGx5IHRhcmdldCBlbmQgc3RhdGUgbmVlZCB0b1xuXHQvLyB0YXJnZXQgYmxvY2tFbmQgaW5zdGVhZFxuICAgIGZvcihpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb25zW2pdO1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gPT09IGV4Y2x1ZGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbi50YXJnZXQgPT09IGVuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi50YXJnZXQgPSBieXBhc3NTdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxsIHRyYW5zaXRpb25zIGxlYXZpbmcgdGhlIHJ1bGUgc3RhcnQgc3RhdGUgbmVlZCB0byBsZWF2ZSBibG9ja1N0YXJ0XG5cdC8vIGluc3RlYWRcbiAgICB2YXIgcnVsZVRvU3RhcnRTdGF0ZSA9IGF0bi5ydWxlVG9TdGFydFN0YXRlW2lkeF07XG4gICAgdmFyIGNvdW50ID0gcnVsZVRvU3RhcnRTdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKCBjb3VudCA+IDApIHtcbiAgICAgICAgYnlwYXNzU3RhcnQuYWRkVHJhbnNpdGlvbihydWxlVG9TdGFydFN0YXRlLnRyYW5zaXRpb25zW2NvdW50LTFdKTtcbiAgICAgICAgcnVsZVRvU3RhcnRTdGF0ZS50cmFuc2l0aW9ucyA9IHJ1bGVUb1N0YXJ0U3RhdGUudHJhbnNpdGlvbnMuc2xpY2UoLTEpO1xuICAgIH1cbiAgICAvLyBsaW5rIHRoZSBuZXcgc3RhdGVzXG4gICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaWR4XS5hZGRUcmFuc2l0aW9uKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihieXBhc3NTdGFydCkpO1xuICAgIGJ5cGFzc1N0b3AuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24oZW5kU3RhdGUpKTtcblxuICAgIHZhciBtYXRjaFN0YXRlID0gbmV3IEJhc2ljU3RhdGUoKTtcbiAgICBhdG4uYWRkU3RhdGUobWF0Y2hTdGF0ZSk7XG4gICAgbWF0Y2hTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBBdG9tVHJhbnNpdGlvbihieXBhc3NTdG9wLCBhdG4ucnVsZVRvVG9rZW5UeXBlW2lkeF0pKTtcbiAgICBieXBhc3NTdGFydC5hZGRUcmFuc2l0aW9uKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihtYXRjaFN0YXRlKSk7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnN0YXRlSXNFbmRTdGF0ZUZvciA9IGZ1bmN0aW9uKHN0YXRlLCBpZHgpIHtcbiAgICBpZiAoIHN0YXRlLnJ1bGVJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoISggc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWF5YmVMb29wRW5kU3RhdGUgPSBzdGF0ZS50cmFuc2l0aW9uc1tzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggLSAxXS50YXJnZXQ7XG4gICAgaWYgKCEoIG1heWJlTG9vcEVuZFN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1heWJlTG9vcEVuZFN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgJiZcbiAgICAgICAgKG1heWJlTG9vcEVuZFN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vL1xuLy8gQW5hbHl6ZSB0aGUge0BsaW5rIFN0YXJMb29wRW50cnlTdGF0ZX0gc3RhdGVzIGluIHRoZSBzcGVjaWZpZWQgQVROIHRvIHNldFxuLy8gdGhlIHtAbGluayBTdGFyTG9vcEVudHJ5U3RhdGUvL2lzUHJlY2VkZW5jZURlY2lzaW9ufSBmaWVsZCB0byB0aGVcbi8vIGNvcnJlY3QgdmFsdWUuXG4vL1xuLy8gQHBhcmFtIGF0biBUaGUgQVROLlxuLy9cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUubWFya1ByZWNlZGVuY2VEZWNpc2lvbnMgPSBmdW5jdGlvbihhdG4pIHtcblx0Zm9yKHZhciBpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG5cdFx0aWYgKCEoIHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYW5hbHl6ZSB0aGUgQVROIHRvIGRldGVybWluZSBpZiB0aGlzIEFUTiBkZWNpc2lvbiBzdGF0ZSBpcyB0aGVcbiAgICAgICAgLy8gZGVjaXNpb24gZm9yIHRoZSBjbG9zdXJlIGJsb2NrIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIGFcbiAgICAgICAgLy8gcHJlY2VkZW5jZSBydWxlIHNob3VsZCBjb250aW51ZSBvciBjb21wbGV0ZS5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKCBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUxvb3BFbmRTdGF0ZSA9IHN0YXRlLnRyYW5zaXRpb25zW3N0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCAtIDFdLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICggbWF5YmVMb29wRW5kU3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG1heWJlTG9vcEVuZFN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlY2VkZW5jZURlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblx0fVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS52ZXJpZnlBVE4gPSBmdW5jdGlvbihhdG4pIHtcbiAgICBpZiAoIXRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy52ZXJpZnlBVE4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB2ZXJpZnkgYXNzdW1wdGlvbnNcblx0Zm9yKHZhciBpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyB8fCBzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPD0gMSk7XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFBsdXNCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSAgaWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmxvb3BCYWNrU3RhdGUgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPT09IDIpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zWzFdLnRhcmdldCBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbighc3RhdGUubm9uR3JlZWR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9uc1sxXS50YXJnZXQgaW5zdGFuY2VvZiBTdGFyQmxvY2tTdGFydFN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLm5vbkdyZWVkeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93KFwiSWxsZWdhbFN0YXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BiYWNrU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdGFydFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnN0b3BTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuZW5kU3RhdGUgIT09IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgQmxvY2tFbmRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5zdGFydFN0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIERlY2lzaW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoIDw9IDEgfHwgc3RhdGUuZGVjaXNpb24gPj0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCA8PSAxIHx8IChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKTtcbiAgICAgICAgfVxuXHR9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmNoZWNrQ29uZGl0aW9uID0gZnVuY3Rpb24oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlPT09bnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSWxsZWdhbFN0YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgKG1lc3NhZ2UpO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZEludCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsb3cgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICB2YXIgaGlnaCA9IHRoaXMucmVhZEludCgpO1xuICAgIHJldHVybiBsb3cgfCAoaGlnaCA8PCAxNik7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRMb25nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvdyA9IHRoaXMucmVhZEludDMyKCk7XG4gICAgdmFyIGhpZ2ggPSB0aGlzLnJlYWRJbnQzMigpO1xuICAgIHJldHVybiAobG93ICYgMHgwMDAwMDAwMEZGRkZGRkZGKSB8IChoaWdoIDw8IDMyKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGVUb0hleCgpIHtcblx0dmFyIGJ0aCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdFx0YnRoW2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKS50b1VwcGVyQ2FzZSgpO1xuXHR9XG5cdHJldHVybiBidGg7XG59XG5cbnZhciBieXRlVG9IZXggPSBjcmVhdGVCeXRlVG9IZXgoKTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkVVVJRCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYmIgPSBbXTtcblx0Zm9yKHZhciBpPTc7aT49MDtpLS0pIHtcblx0XHR2YXIgaW50ID0gdGhpcy5yZWFkSW50KCk7XG5cdFx0LyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG5cdFx0YmJbKDIqaSkrMV0gPSBpbnQgJiAweEZGO1xuXHRcdGJiWzIqaV0gPSAoaW50ID4+IDgpICYgMHhGRjtcblx0fVxuICAgIHJldHVybiBieXRlVG9IZXhbYmJbMF1dICsgYnl0ZVRvSGV4W2JiWzFdXSArXG4gICAgYnl0ZVRvSGV4W2JiWzJdXSArIGJ5dGVUb0hleFtiYlszXV0gKyAnLScgK1xuICAgIGJ5dGVUb0hleFtiYls0XV0gKyBieXRlVG9IZXhbYmJbNV1dICsgJy0nICtcbiAgICBieXRlVG9IZXhbYmJbNl1dICsgYnl0ZVRvSGV4W2JiWzddXSArICctJyArXG4gICAgYnl0ZVRvSGV4W2JiWzhdXSArIGJ5dGVUb0hleFtiYls5XV0gKyAnLScgK1xuICAgIGJ5dGVUb0hleFtiYlsxMF1dICsgYnl0ZVRvSGV4W2JiWzExXV0gK1xuICAgIGJ5dGVUb0hleFtiYlsxMl1dICsgYnl0ZVRvSGV4W2JiWzEzXV0gK1xuICAgIGJ5dGVUb0hleFtiYlsxNF1dICsgYnl0ZVRvSGV4W2JiWzE1XV07XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmVkZ2VGYWN0b3J5ID0gZnVuY3Rpb24oYXRuLCB0eXBlLCBzcmMsIHRyZywgYXJnMSwgYXJnMiwgYXJnMywgc2V0cykge1xuICAgIHZhciB0YXJnZXQgPSBhdG4uc3RhdGVzW3RyZ107XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFRyYW5zaXRpb24uRVBTSUxPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBFcHNpbG9uVHJhbnNpdGlvbih0YXJnZXQpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5SQU5HRTpcbiAgICAgICAgcmV0dXJuIGFyZzMgIT09IDAgPyBuZXcgUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgVG9rZW4uRU9GLCBhcmcyKSA6IG5ldyBSYW5nZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyKTtcbiAgICBjYXNlIFRyYW5zaXRpb24uUlVMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlVHJhbnNpdGlvbihhdG4uc3RhdGVzW2FyZzFdLCBhcmcyLCBhcmczLCB0YXJnZXQpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5QUkVESUNBVEU6XG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljYXRlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIsIGFyZzMgIT09IDApO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5QUkVDRURFTkNFOlxuICAgICAgICByZXR1cm4gbmV3IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLkFUT006XG4gICAgICAgIHJldHVybiBhcmczICE9PSAwID8gbmV3IEF0b21UcmFuc2l0aW9uKHRhcmdldCwgVG9rZW4uRU9GKSA6IG5ldyBBdG9tVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5BQ1RJT046XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIsIGFyZzMgIT09IDApO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5TRVQ6XG4gICAgICAgIHJldHVybiBuZXcgU2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldHNbYXJnMV0pO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5OT1RfU0VUOlxuICAgICAgICByZXR1cm4gbmV3IE5vdFNldFRyYW5zaXRpb24odGFyZ2V0LCBzZXRzW2FyZzFdKTtcbiAgICBjYXNlIFRyYW5zaXRpb24uV0lMRENBUkQ6XG4gICAgICAgIHJldHVybiBuZXcgV2lsZGNhcmRUcmFuc2l0aW9uKHRhcmdldCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgXCJUaGUgc3BlY2lmaWVkIHRyYW5zaXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIgaXMgbm90IHZhbGlkLlwiO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuc3RhdGVGYWN0b3J5ID0gZnVuY3Rpb24odHlwZSwgcnVsZUluZGV4KSB7XG4gICAgaWYgKHRoaXMuc3RhdGVGYWN0b3JpZXMgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHNmID0gW107XG4gICAgICAgIHNmW0FUTlN0YXRlLklOVkFMSURfVFlQRV0gPSBudWxsO1xuICAgICAgICBzZltBVE5TdGF0ZS5CQVNJQ10gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBCYXNpY1N0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlJVTEVfU1RBUlRdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUnVsZVN0YXJ0U3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuQkxPQ0tfU1RBUlRdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQmFzaWNCbG9ja1N0YXJ0U3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUExVU19CTE9DS19TVEFSVF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQbHVzQmxvY2tTdGFydFN0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlNUQVJfQkxPQ0tfU1RBUlRdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgU3RhckJsb2NrU3RhcnRTdGF0ZSgpOyB9O1xuICAgICAgICBzZltBVE5TdGF0ZS5UT0tFTl9TVEFSVF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBUb2tlbnNTdGFydFN0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlJVTEVfU1RPUF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBSdWxlU3RvcFN0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLkJMT0NLX0VORF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBCbG9ja0VuZFN0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlNUQVJfTE9PUF9CQUNLXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFN0YXJMb29wYmFja1N0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlNUQVJfTE9PUF9FTlRSWV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBTdGFyTG9vcEVudHJ5U3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUExVU19MT09QX0JBQ0tdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUGx1c0xvb3BiYWNrU3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuTE9PUF9FTkRdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTG9vcEVuZFN0YXRlKCk7IH07XG4gICAgICAgIHRoaXMuc3RhdGVGYWN0b3JpZXMgPSBzZjtcbiAgICB9XG4gICAgaWYgKHR5cGU+dGhpcy5zdGF0ZUZhY3Rvcmllcy5sZW5ndGggfHwgdGhpcy5zdGF0ZUZhY3Rvcmllc1t0eXBlXSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyhcIlRoZSBzcGVjaWZpZWQgc3RhdGUgdHlwZSBcIiArIHR5cGUgKyBcIiBpcyBub3QgdmFsaWQuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdGF0ZUZhY3Rvcmllc1t0eXBlXSgpO1xuICAgICAgICBpZiAocyE9PW51bGwpIHtcbiAgICAgICAgICAgIHMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmxleGVyQWN0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGExLCBkYXRhMikge1xuICAgIGlmICh0aGlzLmFjdGlvbkZhY3RvcmllcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgYWYgPSBbXTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLkNIQU5ORUxdID0gZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IHJldHVybiBuZXcgTGV4ZXJDaGFubmVsQWN0aW9uKGRhdGExKTsgfTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLkNVU1RPTV0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIG5ldyBMZXhlckN1c3RvbUFjdGlvbihkYXRhMSwgZGF0YTIpOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuTU9ERV0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIG5ldyBMZXhlck1vZGVBY3Rpb24oZGF0YTEpOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuTU9SRV0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIExleGVyTW9yZUFjdGlvbi5JTlNUQU5DRTsgfTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLlBPUF9NT0RFXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gTGV4ZXJQb3BNb2RlQWN0aW9uLklOU1RBTkNFOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuUFVTSF9NT0RFXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gbmV3IExleGVyUHVzaE1vZGVBY3Rpb24oZGF0YTEpOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuU0tJUF0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIExleGVyU2tpcEFjdGlvbi5JTlNUQU5DRTsgfTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLlRZUEVdID0gZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IHJldHVybiBuZXcgTGV4ZXJUeXBlQWN0aW9uKGRhdGExKTsgfTtcbiAgICAgICAgdGhpcy5hY3Rpb25GYWN0b3JpZXMgPSBhZjtcbiAgICB9XG4gICAgaWYgKHR5cGU+dGhpcy5hY3Rpb25GYWN0b3JpZXMubGVuZ3RoIHx8IHRoaXMuYWN0aW9uRmFjdG9yaWVzW3R5cGVdID09PSBudWxsKSB7XG4gICAgICAgIHRocm93KFwiVGhlIHNwZWNpZmllZCBsZXhlciBhY3Rpb24gdHlwZSBcIiArIHR5cGUgKyBcIiBpcyBub3QgdmFsaWQuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbkZhY3Rvcmllc1t0eXBlXShkYXRhMSwgZGF0YTIpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5BVE5EZXNlcmlhbGl6ZXIgPSBBVE5EZXNlcmlhbGl6ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9BVE5EZXNlcmlhbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG5mdW5jdGlvbiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKGNvcHlGcm9tKSB7XG5cdGlmKGNvcHlGcm9tPT09dW5kZWZpbmVkKSB7XG5cdFx0Y29weUZyb20gPSBudWxsO1xuXHR9XG5cdHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmlmeUFUTiA9IGNvcHlGcm9tPT09bnVsbCA/IHRydWUgOiBjb3B5RnJvbS52ZXJpZnlBVE47XG4gICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IGNvcHlGcm9tPT09bnVsbCA/IGZhbHNlIDogY29weUZyb20uZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyA9IG5ldyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XG5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLmRlZmF1bHRPcHRpb25zLnJlYWRPbmx5ID0gdHJ1ZTtcblxuLy8gICAgZGVmIF9fc2V0YXR0cl9fKHNlbGYsIGtleSwgdmFsdWUpOlxuLy8gICAgICAgIGlmIGtleSE9XCJyZWFkT25seVwiIGFuZCBzZWxmLnJlYWRPbmx5OlxuLy8gICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oXCJUaGUgb2JqZWN0IGlzIHJlYWQgb25seS5cIilcbi8vICAgICAgICBzdXBlcih0eXBlKHNlbGYpLCBzZWxmKS5fX3NldGF0dHJfXyhrZXksdmFsdWUpXG5cbmV4cG9ydHMuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbiAvL1xuXG5mdW5jdGlvbiBMZXhlckFjdGlvblR5cGUoKSB7XG59XG5cbkxleGVyQWN0aW9uVHlwZS5DSEFOTkVMID0gMDsgICAgIC8vVGhlIHR5cGUgb2YgYSB7QGxpbmsgTGV4ZXJDaGFubmVsQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuQ1VTVE9NID0gMTsgICAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyQ3VzdG9tQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuTU9ERSA9IDI7ICAgICAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyTW9kZUFjdGlvbn0gYWN0aW9uLlxuTGV4ZXJBY3Rpb25UeXBlLk1PUkUgPSAzOyAgICAgICAgLy9UaGUgdHlwZSBvZiBhIHtAbGluayBMZXhlck1vcmVBY3Rpb259IGFjdGlvbi5cbkxleGVyQWN0aW9uVHlwZS5QT1BfTU9ERSA9IDQ7ICAgIC8vVGhlIHR5cGUgb2YgYSB7QGxpbmsgTGV4ZXJQb3BNb2RlQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuUFVTSF9NT0RFID0gNTsgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyUHVzaE1vZGVBY3Rpb259IGFjdGlvbi5cbkxleGVyQWN0aW9uVHlwZS5TS0lQID0gNjsgICAgICAgIC8vVGhlIHR5cGUgb2YgYSB7QGxpbmsgTGV4ZXJTa2lwQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuVFlQRSA9IDc7ICAgICAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyVHlwZUFjdGlvbn0gYWN0aW9uLlxuXG5mdW5jdGlvbiBMZXhlckFjdGlvbihhY3Rpb24pIHtcbiAgICB0aGlzLmFjdGlvblR5cGUgPSBhY3Rpb247XG4gICAgdGhpcy5pc1Bvc2l0aW9uRGVwZW5kZW50ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVyQWN0aW9uLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcbiAgICB0aGlzLnVwZGF0ZUhhc2hDb2RlKGhhc2gpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpXG59O1xuXG5MZXhlckFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlKTtcbn07XG5cbkxleGVyQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbn07XG5cblxuXG4vL1xuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIHNraXB9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vc2tpcH0uXG4vL1xuLy8gPHA+VGhlIHtAY29kZSBza2lwfSBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXG4vLyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBleHBvc2VkIGJ5IHtAbGluayAvL0lOU1RBTkNFfS48L3A+XG5mdW5jdGlvbiBMZXhlclNraXBBY3Rpb24oKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgTGV4ZXJBY3Rpb25UeXBlLlNLSVApO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJTa2lwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlclNraXBBY3Rpb247XG5cbi8vIFByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgcGFyYW1ldGVybGVzcyBsZXhlciBhY3Rpb24uXG5MZXhlclNraXBBY3Rpb24uSU5TVEFOQ0UgPSBuZXcgTGV4ZXJTa2lwQWN0aW9uKCk7XG5cbkxleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyKSB7XG4gICAgbGV4ZXIuc2tpcCgpO1xufTtcblxuTGV4ZXJTa2lwQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJza2lwXCI7XG59O1xuXG4vLyAgSW1wbGVtZW50cyB0aGUge0Bjb2RlIHR5cGV9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vc2V0VHlwZX1cbi8vIHdpdGggdGhlIGFzc2lnbmVkIHR5cGUuXG5mdW5jdGlvbiBMZXhlclR5cGVBY3Rpb24odHlwZSkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsIExleGVyQWN0aW9uVHlwZS5UWVBFKTtcblx0dGhpcy50eXBlID0gdHlwZTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkxleGVyVHlwZUFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlclR5cGVBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJUeXBlQWN0aW9uO1xuXG5MZXhlclR5cGVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLnR5cGUgPSB0aGlzLnR5cGU7XG59O1xuXG5MZXhlclR5cGVBY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy50eXBlKTtcbn07XG5cblxuTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBMZXhlclR5cGVBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBvdGhlci50eXBlO1xuICAgIH1cbn07XG5cbkxleGVyVHlwZUFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0eXBlKFwiICsgdGhpcy50eXBlICsgXCIpXCI7XG59O1xuXG4vLyBJbXBsZW1lbnRzIHRoZSB7QGNvZGUgcHVzaE1vZGV9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nXG4vLyB7QGxpbmsgTGV4ZXIvL3B1c2hNb2RlfSB3aXRoIHRoZSBhc3NpZ25lZCBtb2RlLlxuZnVuY3Rpb24gTGV4ZXJQdXNoTW9kZUFjdGlvbihtb2RlKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgTGV4ZXJBY3Rpb25UeXBlLlBVU0hfTU9ERSk7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyUHVzaE1vZGVBY3Rpb247XG5cbi8vIDxwPlRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyLy9wdXNoTW9kZX0gd2l0aCB0aGVcbi8vIHZhbHVlIHByb3ZpZGVkIGJ5IHtAbGluayAvL2dldE1vZGV9LjwvcD5cbkxleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLnB1c2hNb2RlKHRoaXMubW9kZSk7XG59O1xuXG5MZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLmFjdGlvblR5cGUsIHRoaXMubW9kZSk7XG59O1xuXG5MZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJQdXNoTW9kZUFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IG90aGVyLm1vZGU7XG4gICAgfVxufTtcblxuTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwicHVzaE1vZGUoXCIgKyB0aGlzLm1vZGUgKyBcIilcIjtcbn07XG5cblxuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIHBvcE1vZGV9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vcG9wTW9kZX0uXG4vL1xuLy8gPHA+VGhlIHtAY29kZSBwb3BNb2RlfSBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXG4vLyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBleHBvc2VkIGJ5IHtAbGluayAvL0lOU1RBTkNFfS48L3A+XG5mdW5jdGlvbiBMZXhlclBvcE1vZGVBY3Rpb24oKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcyxMZXhlckFjdGlvblR5cGUuUE9QX01PREUpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVyUG9wTW9kZUFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlclBvcE1vZGVBY3Rpb247XG5cbkxleGVyUG9wTW9kZUFjdGlvbi5JTlNUQU5DRSA9IG5ldyBMZXhlclBvcE1vZGVBY3Rpb24oKTtcblxuLy8gPHA+VGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3BvcE1vZGV9LjwvcD5cbkxleGVyUG9wTW9kZUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyKSB7XG4gICAgbGV4ZXIucG9wTW9kZSgpO1xufTtcblxuTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJwb3BNb2RlXCI7XG59O1xuXG4vLyBJbXBsZW1lbnRzIHRoZSB7QGNvZGUgbW9yZX0gbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyLy9tb3JlfS5cbi8vXG4vLyA8cD5UaGUge0Bjb2RlIG1vcmV9IGNvbW1hbmQgZG9lcyBub3QgaGF2ZSBhbnkgcGFyYW1ldGVycywgc28gdGhpcyBhY3Rpb24gaXNcbi8vIGltcGxlbWVudGVkIGFzIGEgc2luZ2xldG9uIGluc3RhbmNlIGV4cG9zZWQgYnkge0BsaW5rIC8vSU5TVEFOQ0V9LjwvcD5cbmZ1bmN0aW9uIExleGVyTW9yZUFjdGlvbigpIHtcblx0TGV4ZXJBY3Rpb24uY2FsbCh0aGlzLCBMZXhlckFjdGlvblR5cGUuTU9SRSk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5MZXhlck1vcmVBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyTW9yZUFjdGlvbjtcblxuTGV4ZXJNb3JlQWN0aW9uLklOU1RBTkNFID0gbmV3IExleGVyTW9yZUFjdGlvbigpO1xuXG4vLyA8cD5UaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vcG9wTW9kZX0uPC9wPlxuTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICBsZXhlci5tb3JlKCk7XG59O1xuXG5MZXhlck1vcmVBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwibW9yZVwiO1xufTtcblxuXG4vLyBJbXBsZW1lbnRzIHRoZSB7QGNvZGUgbW9kZX0gbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyLy9tb2RlfSB3aXRoXG4vLyB0aGUgYXNzaWduZWQgbW9kZS5cbmZ1bmN0aW9uIExleGVyTW9kZUFjdGlvbihtb2RlKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgTGV4ZXJBY3Rpb25UeXBlLk1PREUpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVyTW9kZUFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlck1vZGVBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJNb2RlQWN0aW9uO1xuXG4vLyA8cD5UaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vbW9kZX0gd2l0aCB0aGVcbi8vIHZhbHVlIHByb3ZpZGVkIGJ5IHtAbGluayAvL2dldE1vZGV9LjwvcD5cbkxleGVyTW9kZUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyKSB7XG4gICAgbGV4ZXIubW9kZSh0aGlzLm1vZGUpO1xufTtcblxuTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLmFjdGlvblR5cGUsIHRoaXMubW9kZSk7XG59O1xuXG5MZXhlck1vZGVBY3Rpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBMZXhlck1vZGVBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBvdGhlci5tb2RlO1xuICAgIH1cbn07XG5cbkxleGVyTW9kZUFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJtb2RlKFwiICsgdGhpcy5tb2RlICsgXCIpXCI7XG59O1xuXG4vLyBFeGVjdXRlcyBhIGN1c3RvbSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZyB7QGxpbmsgUmVjb2duaXplci8vYWN0aW9ufSB3aXRoIHRoZVxuLy8gcnVsZSBhbmQgYWN0aW9uIGluZGV4ZXMgYXNzaWduZWQgdG8gdGhlIGN1c3RvbSBhY3Rpb24uIFRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuLy8gYSBjdXN0b20gYWN0aW9uIGlzIGFkZGVkIHRvIHRoZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGxleGVyIGluIGFuIG92ZXJyaWRlXG4vLyBvZiB7QGxpbmsgUmVjb2duaXplci8vYWN0aW9ufSB3aGVuIHRoZSBncmFtbWFyIGlzIGNvbXBpbGVkLlxuLy9cbi8vIDxwPlRoaXMgY2xhc3MgbWF5IHJlcHJlc2VudCBlbWJlZGRlZCBhY3Rpb25zIGNyZWF0ZWQgd2l0aCB0aGUgPGNvZGU+ey4uLn08L2NvZGU+XG4vLyBzeW50YXggaW4gQU5UTFIgNCwgYXMgd2VsbCBhcyBhY3Rpb25zIGNyZWF0ZWQgZm9yIGxleGVyIGNvbW1hbmRzIHdoZXJlIHRoZVxuLy8gY29tbWFuZCBhcmd1bWVudCBjb3VsZCBub3QgYmUgZXZhbHVhdGVkIHdoZW4gdGhlIGdyYW1tYXIgd2FzIGNvbXBpbGVkLjwvcD5cblxuXG4gICAgLy8gQ29uc3RydWN0cyBhIGN1c3RvbSBsZXhlciBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHJ1bGUgYW5kIGFjdGlvblxuICAgIC8vIGluZGV4ZXMuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0gcnVsZUluZGV4IFRoZSBydWxlIGluZGV4IHRvIHVzZSBmb3IgY2FsbHMgdG9cbiAgICAvLyB7QGxpbmsgUmVjb2duaXplci8vYWN0aW9ufS5cbiAgICAvLyBAcGFyYW0gYWN0aW9uSW5kZXggVGhlIGFjdGlvbiBpbmRleCB0byB1c2UgZm9yIGNhbGxzIHRvXG4gICAgLy8ge0BsaW5rIFJlY29nbml6ZXIvL2FjdGlvbn0uXG5cbmZ1bmN0aW9uIExleGVyQ3VzdG9tQWN0aW9uKHJ1bGVJbmRleCwgYWN0aW9uSW5kZXgpIHtcblx0TGV4ZXJBY3Rpb24uY2FsbCh0aGlzLCBMZXhlckFjdGlvblR5cGUuQ1VTVE9NKTtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcbiAgICB0aGlzLmFjdGlvbkluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgdGhpcy5pc1Bvc2l0aW9uRGVwZW5kZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJDdXN0b21BY3Rpb247XG5cbi8vIDxwPkN1c3RvbSBhY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vYWN0aW9ufSB3aXRoIHRoZVxuLy8gYXBwcm9wcmlhdGUgcnVsZSBhbmQgYWN0aW9uIGluZGV4ZXMuPC9wPlxuTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLmFjdGlvbihudWxsLCB0aGlzLnJ1bGVJbmRleCwgdGhpcy5hY3Rpb25JbmRleCk7XG59O1xuXG5MZXhlckN1c3RvbUFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLnJ1bGVJbmRleCwgdGhpcy5hY3Rpb25JbmRleCk7XG59O1xuXG5MZXhlckN1c3RvbUFjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIChvdGhlciBpbnN0YW5jZW9mIExleGVyQ3VzdG9tQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZUluZGV4ID09PSBvdGhlci5ydWxlSW5kZXggJiYgdGhpcy5hY3Rpb25JbmRleCA9PT0gb3RoZXIuYWN0aW9uSW5kZXg7XG4gICAgfVxufTtcblxuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIGNoYW5uZWx9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nXG4vLyB7QGxpbmsgTGV4ZXIvL3NldENoYW5uZWx9IHdpdGggdGhlIGFzc2lnbmVkIGNoYW5uZWwuXG4vLyBDb25zdHJ1Y3RzIGEgbmV3IHtAY29kZSBjaGFubmVsfSBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGNoYW5uZWwgdmFsdWUuXG4vLyBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB2YWx1ZSB0byBwYXNzIHRvIHtAbGluayBMZXhlci8vc2V0Q2hhbm5lbH0uXG5mdW5jdGlvbiBMZXhlckNoYW5uZWxBY3Rpb24oY2hhbm5lbCkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsIExleGVyQWN0aW9uVHlwZS5DSEFOTkVMKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5MZXhlckNoYW5uZWxBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyQ2hhbm5lbEFjdGlvbjtcblxuLy8gPHA+VGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3NldENoYW5uZWx9IHdpdGggdGhlXG4vLyB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgLy9nZXRDaGFubmVsfS48L3A+XG5MZXhlckNoYW5uZWxBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLl9jaGFubmVsID0gdGhpcy5jaGFubmVsO1xufTtcblxuTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLmFjdGlvblR5cGUsIHRoaXMuY2hhbm5lbCk7XG59O1xuXG5MZXhlckNoYW5uZWxBY3Rpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBMZXhlckNoYW5uZWxBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsID09PSBvdGhlci5jaGFubmVsO1xuICAgIH1cbn07XG5cbkxleGVyQ2hhbm5lbEFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJjaGFubmVsKFwiICsgdGhpcy5jaGFubmVsICsgXCIpXCI7XG59O1xuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMZXhlckFjdGlvbn0gaXMgdXNlZCBmb3IgdHJhY2tpbmcgaW5wdXQgb2Zmc2V0c1xuLy8gZm9yIHBvc2l0aW9uLWRlcGVuZGVudCBhY3Rpb25zIHdpdGhpbiBhIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfS5cbi8vXG4vLyA8cD5UaGlzIGFjdGlvbiBpcyBub3Qgc2VyaWFsaXplZCBhcyBwYXJ0IG9mIHRoZSBBVE4sIGFuZCBpcyBvbmx5IHJlcXVpcmVkIGZvclxuLy8gcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMgd2hpY2ggYXBwZWFyIGF0IGEgbG9jYXRpb24gb3RoZXIgdGhhbiB0aGVcbi8vIGVuZCBvZiBhIHJ1bGUuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IERGQSBvcHRpbWl6YXRpb25zIGVtcGxveWVkIGZvclxuLy8gbGV4ZXIgYWN0aW9ucywgc2VlIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yLy9hcHBlbmR9IGFuZFxuLy8ge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3IvL2ZpeE9mZnNldEJlZm9yZU1hdGNofS48L3A+XG5cbi8vIENvbnN0cnVjdHMgYSBuZXcgaW5kZXhlZCBjdXN0b20gYWN0aW9uIGJ5IGFzc29jaWF0aW5nIGEgY2hhcmFjdGVyIG9mZnNldFxuLy8gd2l0aCBhIHtAbGluayBMZXhlckFjdGlvbn0uXG4vL1xuLy8gPHA+Tm90ZTogVGhpcyBjbGFzcyBpcyBvbmx5IHJlcXVpcmVkIGZvciBsZXhlciBhY3Rpb25zIGZvciB3aGljaFxuLy8ge0BsaW5rIExleGVyQWN0aW9uLy9pc1Bvc2l0aW9uRGVwZW5kZW50fSByZXR1cm5zIHtAY29kZSB0cnVlfS48L3A+XG4vL1xuLy8gQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIGlucHV0IHtAbGluayBDaGFyU3RyZWFtfSwgcmVsYXRpdmUgdG9cbi8vIHRoZSB0b2tlbiBzdGFydCBpbmRleCwgYXQgd2hpY2ggdGhlIHNwZWNpZmllZCBsZXhlciBhY3Rpb24gc2hvdWxkIGJlXG4vLyBleGVjdXRlZC5cbi8vIEBwYXJhbSBhY3Rpb24gVGhlIGxleGVyIGFjdGlvbiB0byBleGVjdXRlIGF0IGEgcGFydGljdWxhciBvZmZzZXQgaW4gdGhlXG4vLyBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0uXG5mdW5jdGlvbiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ob2Zmc2V0LCBhY3Rpb24pIHtcblx0TGV4ZXJBY3Rpb24uY2FsbCh0aGlzLCBhY3Rpb24uYWN0aW9uVHlwZSk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5pc1Bvc2l0aW9uRGVwZW5kZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb247XG5cbi8vIDxwPlRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayAvL2V4ZWN1dGV9IG9uIHRoZSByZXN1bHQgb2Yge0BsaW5rIC8vZ2V0QWN0aW9ufVxuLy8gdXNpbmcgdGhlIHByb3ZpZGVkIHtAY29kZSBsZXhlcn0uPC9wPlxuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICAvLyBhc3N1bWUgdGhlIGlucHV0IHN0cmVhbSBwb3NpdGlvbiB3YXMgcHJvcGVybHkgc2V0IGJ5IHRoZSBjYWxsaW5nIGNvZGVcbiAgICB0aGlzLmFjdGlvbi5leGVjdXRlKGxleGVyKTtcbn07XG5cbkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLm9mZnNldCwgdGhpcy5hY3Rpb24pO1xufTtcblxuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ID09PSBvdGhlci5vZmZzZXQgJiYgdGhpcy5hY3Rpb24gPT09IG90aGVyLmFjdGlvbjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuTGV4ZXJBY3Rpb25UeXBlID0gTGV4ZXJBY3Rpb25UeXBlO1xuZXhwb3J0cy5MZXhlclNraXBBY3Rpb24gPSBMZXhlclNraXBBY3Rpb247XG5leHBvcnRzLkxleGVyQ2hhbm5lbEFjdGlvbiA9IExleGVyQ2hhbm5lbEFjdGlvbjtcbmV4cG9ydHMuTGV4ZXJDdXN0b21BY3Rpb24gPSBMZXhlckN1c3RvbUFjdGlvbjtcbmV4cG9ydHMuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uID0gTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uO1xuZXhwb3J0cy5MZXhlck1vcmVBY3Rpb24gPSBMZXhlck1vcmVBY3Rpb247XG5leHBvcnRzLkxleGVyVHlwZUFjdGlvbiA9IExleGVyVHlwZUFjdGlvbjtcbmV4cG9ydHMuTGV4ZXJQdXNoTW9kZUFjdGlvbiA9IExleGVyUHVzaE1vZGVBY3Rpb247XG5leHBvcnRzLkxleGVyUG9wTW9kZUFjdGlvbiA9IExleGVyUG9wTW9kZUFjdGlvbjtcbmV4cG9ydHMuTGV4ZXJNb2RlQWN0aW9uID0gTGV4ZXJNb2RlQWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vTGV4ZXJBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBDb25zb2xlRXJyb3JMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZXJyb3IvRXJyb3JMaXN0ZW5lcicpLkNvbnNvbGVFcnJvckxpc3RlbmVyO1xudmFyIFByb3h5RXJyb3JMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZXJyb3IvRXJyb3JMaXN0ZW5lcicpLlByb3h5RXJyb3JMaXN0ZW5lcjtcblxuZnVuY3Rpb24gUmVjb2duaXplcigpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbIENvbnNvbGVFcnJvckxpc3RlbmVyLklOU1RBTkNFIF07XG4gICAgdGhpcy5faW50ZXJwID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZU51bWJlciA9IC0xO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5SZWNvZ25pemVyLnRva2VuVHlwZU1hcENhY2hlID0ge307XG5SZWNvZ25pemVyLnJ1bGVJbmRleE1hcENhY2hlID0ge307XG5cblxuUmVjb2duaXplci5wcm90b3R5cGUuY2hlY2tWZXJzaW9uID0gZnVuY3Rpb24odG9vbFZlcnNpb24pIHtcbiAgICB2YXIgcnVudGltZVZlcnNpb24gPSBcIjQuNy4xXCI7XG4gICAgaWYgKHJ1bnRpbWVWZXJzaW9uIT09dG9vbFZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBTlRMUiBydW50aW1lIGFuZCBnZW5lcmF0ZWQgY29kZSB2ZXJzaW9ucyBkaXNhZ3JlZTogXCIrcnVudGltZVZlcnNpb24rXCIhPVwiK3Rvb2xWZXJzaW9uKTtcbiAgICB9XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5hZGRFcnJvckxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5yZW1vdmVFcnJvckxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xufTtcblxuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG9rZW5UeXBlTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRva2VuTmFtZXMgPSB0aGlzLmdldFRva2VuTmFtZXMoKTtcbiAgICBpZiAodG9rZW5OYW1lcz09PW51bGwpIHtcbiAgICAgICAgdGhyb3coXCJUaGUgY3VycmVudCByZWNvZ25pemVyIGRvZXMgbm90IHByb3ZpZGUgYSBsaXN0IG9mIHRva2VuIG5hbWVzLlwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudG9rZW5UeXBlTWFwQ2FjaGVbdG9rZW5OYW1lc107XG4gICAgaWYocmVzdWx0PT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHRva2VuTmFtZXMucmVkdWNlKGZ1bmN0aW9uKG8sIGssIGkpIHsgb1trXSA9IGk7IH0pO1xuICAgICAgICByZXN1bHQuRU9GID0gVG9rZW4uRU9GO1xuICAgICAgICB0aGlzLnRva2VuVHlwZU1hcENhY2hlW3Rva2VuTmFtZXNdID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gR2V0IGEgbWFwIGZyb20gcnVsZSBuYW1lcyB0byBydWxlIGluZGV4ZXMuXG4vL1xuLy8gPHA+VXNlZCBmb3IgWFBhdGggYW5kIHRyZWUgcGF0dGVybiBjb21waWxhdGlvbi48L3A+XG4vL1xuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0UnVsZUluZGV4TWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ1bGVOYW1lcyA9IHRoaXMucnVsZU5hbWVzO1xuICAgIGlmIChydWxlTmFtZXM9PT1udWxsKSB7XG4gICAgICAgIHRocm93KFwiVGhlIGN1cnJlbnQgcmVjb2duaXplciBkb2VzIG5vdCBwcm92aWRlIGEgbGlzdCBvZiBydWxlIG5hbWVzLlwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucnVsZUluZGV4TWFwQ2FjaGVbcnVsZU5hbWVzXTtcbiAgICBpZihyZXN1bHQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcnVsZU5hbWVzLnJlZHVjZShmdW5jdGlvbihvLCBrLCBpKSB7IG9ba10gPSBpOyB9KTtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXhNYXBDYWNoZVtydWxlTmFtZXNdID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG9rZW5UeXBlID0gZnVuY3Rpb24odG9rZW5OYW1lKSB7XG4gICAgdmFyIHR0eXBlID0gdGhpcy5nZXRUb2tlblR5cGVNYXAoKVt0b2tlbk5hbWVdO1xuICAgIGlmICh0dHlwZSAhPT11bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHR0eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBUb2tlbi5JTlZBTElEX1RZUEU7XG4gICAgfVxufTtcblxuXG4vLyBXaGF0IGlzIHRoZSBlcnJvciBoZWFkZXIsIG5vcm1hbGx5IGxpbmUvY2hhcmFjdGVyIHBvc2l0aW9uIGluZm9ybWF0aW9uPy8vXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRFcnJvckhlYWRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbGluZSA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKS5saW5lO1xuICAgIHZhciBjb2x1bW4gPSBlLmdldE9mZmVuZGluZ1Rva2VuKCkuY29sdW1uO1xuICAgIHJldHVybiBcImxpbmUgXCIgKyBsaW5lICsgXCI6XCIgKyBjb2x1bW47XG59O1xuXG5cbi8vIEhvdyBzaG91bGQgYSB0b2tlbiBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3IgbWVzc2FnZT8gVGhlIGRlZmF1bHRcbi8vICBpcyB0byBkaXNwbGF5IGp1c3QgdGhlIHRleHQsIGJ1dCBkdXJpbmcgZGV2ZWxvcG1lbnQgeW91IG1pZ2h0XG4vLyAgd2FudCB0byBoYXZlIGEgbG90IG9mIGluZm9ybWF0aW9uIHNwaXQgb3V0LiAgT3ZlcnJpZGUgaW4gdGhhdCBjYXNlXG4vLyAgdG8gdXNlIHQudG9TdHJpbmcoKSAod2hpY2gsIGZvciBDb21tb25Ub2tlbiwgZHVtcHMgZXZlcnl0aGluZyBhYm91dFxuLy8gIHRoZSB0b2tlbikuIFRoaXMgaXMgYmV0dGVyIHRoYW4gZm9yY2luZyB5b3UgdG8gb3ZlcnJpZGUgYSBtZXRob2QgaW5cbi8vICB5b3VyIHRva2VuIG9iamVjdHMgYmVjYXVzZSB5b3UgZG9uJ3QgaGF2ZSB0byBnbyBtb2RpZnkgeW91ciBsZXhlclxuLy8gIHNvIHRoYXQgaXQgY3JlYXRlcyBhIG5ldyBKYXZhIHR5cGUuXG4vL1xuLy8gQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBieSB0aGUgQU5UTFIgNCBSdW50aW1lLiBTcGVjaWZpY1xuLy8gaW1wbGVtZW50YXRpb25zIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3l9IG1heSBwcm92aWRlIGEgc2ltaWxhclxuLy8gZmVhdHVyZSB3aGVuIG5lY2Vzc2FyeS4gRm9yIGV4YW1wbGUsIHNlZVxuLy8ge0BsaW5rIERlZmF1bHRFcnJvclN0cmF0ZWd5Ly9nZXRUb2tlbkVycm9yRGlzcGxheX0uXG4vL1xuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG9rZW5FcnJvckRpc3BsYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHQ9PT1udWxsKSB7XG4gICAgICAgIHJldHVybiBcIjxubyB0b2tlbj5cIjtcbiAgICB9XG4gICAgdmFyIHMgPSB0LnRleHQ7XG4gICAgaWYgKHM9PT1udWxsKSB7XG4gICAgICAgIGlmICh0LnR5cGU9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHMgPSBcIjxFT0Y+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gXCI8XCIgKyB0LnR5cGUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzID0gcy5yZXBsYWNlKFwiXFxuXCIsXCJcXFxcblwiKS5yZXBsYWNlKFwiXFxyXCIsXCJcXFxcclwiKS5yZXBsYWNlKFwiXFx0XCIsXCJcXFxcdFwiKTtcbiAgICByZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5RXJyb3JMaXN0ZW5lcih0aGlzLl9saXN0ZW5lcnMpO1xufTtcblxuLy8gc3ViY2xhc3MgbmVlZHMgdG8gb3ZlcnJpZGUgdGhlc2UgaWYgdGhlcmUgYXJlIHNlbXByZWRzIG9yIGFjdGlvbnNcbi8vIHRoYXQgdGhlIEFUTiBpbnRlcnAgbmVlZHMgdG8gZXhlY3V0ZVxuUmVjb2duaXplci5wcm90b3R5cGUuc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBydWxlSW5kZXgsIGFjdGlvbkluZGV4KSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5wcmVjcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4ICwgcHJlY2VkZW5jZSkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy9JbmRpY2F0ZSB0aGF0IHRoZSByZWNvZ25pemVyIGhhcyBjaGFuZ2VkIGludGVybmFsIHN0YXRlIHRoYXQgaXNcbi8vY29uc2lzdGVudCB3aXRoIHRoZSBBVE4gc3RhdGUgcGFzc2VkIGluLiAgVGhpcyB3YXkgd2UgYWx3YXlzIGtub3dcbi8vd2hlcmUgd2UgYXJlIGluIHRoZSBBVE4gYXMgdGhlIHBhcnNlciBnb2VzIGFsb25nLiBUaGUgcnVsZVxuLy9jb250ZXh0IG9iamVjdHMgZm9ybSBhIHN0YWNrIHRoYXQgbGV0cyB1cyBzZWUgdGhlIHN0YWNrIG9mXG4vL2ludm9raW5nIHJ1bGVzLiBDb21iaW5lIHRoaXMgYW5kIHdlIGhhdmUgY29tcGxldGUgQVROXG4vL2NvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24uXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvZ25pemVyLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdGF0ZU51bWJlcjtcblx0fSxcblx0c2V0IDogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHR0aGlzLl9zdGF0ZU51bWJlciA9IHN0YXRlO1xuXHR9XG59KTtcblxuXG5leHBvcnRzLlJlY29nbml6ZXIgPSBSZWNvZ25pemVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L1JlY29nbml6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG52YXIgREZBU3RhdGUgPSByZXF1aXJlKCcuLy4uL2RmYS9ERkFTdGF0ZScpLkRGQVN0YXRlO1xudmFyIEFUTkNvbmZpZ1NldCA9IHJlcXVpcmUoJy4vQVROQ29uZmlnU2V0JykuQVROQ29uZmlnU2V0O1xudmFyIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0ID0gcmVxdWlyZSgnLi8uLi9QcmVkaWN0aW9uQ29udGV4dCcpLmdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0O1xuXG5mdW5jdGlvbiBBVE5TaW11bGF0b3IoYXRuLCBzaGFyZWRDb250ZXh0Q2FjaGUpIHtcblxuICAgIC8vIFRoZSBjb250ZXh0IGNhY2hlIG1hcHMgYWxsIFByZWRpY3Rpb25Db250ZXh0IG9iamVjdHMgdGhhdCBhcmUgPT1cbiAgICAvLyAgdG8gYSBzaW5nbGUgY2FjaGVkIGNvcHkuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyBhbGwgY29udGV4dHNcbiAgICAvLyAgaW4gYWxsIEFUTkNvbmZpZ3MgaW4gYWxsIERGQSBzdGF0ZXMuICBXZSByZWJ1aWxkIGVhY2ggQVROQ29uZmlnU2V0XG4gICAgLy8gIHRvIHVzZSBvbmx5IGNhY2hlZCBub2Rlcy9ncmFwaHMgaW4gYWRkREZBU3RhdGUoKS4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vICBmaWxsIHRoaXMgZHVyaW5nIGNsb3N1cmUoKSBzaW5jZSB0aGVyZSBhcmUgbG90cyBvZiBjb250ZXh0cyB0aGF0XG4gICAgLy8gIHBvcCB1cCBidXQgYXJlIG5vdCB1c2VkIGV2ZXIgYWdhaW4uIEl0IGFsc28gZ3JlYXRseSBzbG93cyBkb3duIGNsb3N1cmUoKS5cbiAgICAvL1xuICAgIC8vICA8cD5UaGlzIGNhY2hlIG1ha2VzIGEgaHVnZSBkaWZmZXJlbmNlIGluIG1lbW9yeSBhbmQgYSBsaXR0bGUgYml0IGluIHNwZWVkLlxuICAgIC8vICBGb3IgdGhlIEphdmEgZ3JhbW1hciBvbiBqYXZhLiosIGl0IGRyb3BwZWQgdGhlIG1lbW9yeSByZXF1aXJlbWVudHNcbiAgICAvLyAgYXQgdGhlIGVuZCBmcm9tIDI1TSB0byAxNk0uIFdlIGRvbid0IHN0b3JlIGFueSBvZiB0aGUgZnVsbCBjb250ZXh0XG4gICAgLy8gIGdyYXBocyBpbiB0aGUgREZBIGJlY2F1c2UgdGhleSBhcmUgbGltaXRlZCB0byBsb2NhbCBjb250ZXh0IG9ubHksXG4gICAgLy8gIGJ1dCBhcHBhcmVudGx5IHRoZXJlJ3MgYSBsb3Qgb2YgcmVwZXRpdGlvbiB0aGVyZSBhcyB3ZWxsLiBXZSBvcHRpbWl6ZVxuICAgIC8vICB0aGUgY29uZmlnIGNvbnRleHRzIGJlZm9yZSBzdG9yaW5nIHRoZSBjb25maWcgc2V0IGluIHRoZSBERkEgc3RhdGVzXG4gICAgLy8gIGJ5IGxpdGVyYWxseSByZWJ1aWxkaW5nIHRoZW0gd2l0aCBjYWNoZWQgc3ViZ3JhcGhzIG9ubHkuPC9wPlxuICAgIC8vXG4gICAgLy8gIDxwPkkgdHJpZWQgYSBjYWNoZSBmb3IgdXNlIGR1cmluZyBjbG9zdXJlIG9wZXJhdGlvbnMsIHRoYXQgd2FzXG4gICAgLy8gIHdoYWNrZWQgYWZ0ZXIgZWFjaCBhZGFwdGl2ZVByZWRpY3QoKS4gSXQgY29zdCBhIGxpdHRsZSBiaXRcbiAgICAvLyAgbW9yZSB0aW1lIEkgdGhpbmsgYW5kIGRvZXNuJ3Qgc2F2ZSBvbiB0aGUgb3ZlcmFsbCBmb290cHJpbnRcbiAgICAvLyAgc28gaXQncyBub3Qgd29ydGggdGhlIGNvbXBsZXhpdHkuPC9wPlxuICAgIC8vL1xuICAgIHRoaXMuYXRuID0gYXRuO1xuICAgIHRoaXMuc2hhcmVkQ29udGV4dENhY2hlID0gc2hhcmVkQ29udGV4dENhY2hlO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBNdXN0IGRpc3Rpbmd1aXNoIGJldHdlZW4gbWlzc2luZyBlZGdlIGFuZCBlZGdlIHdlIGtub3cgbGVhZHMgbm93aGVyZS8vL1xuQVROU2ltdWxhdG9yLkVSUk9SID0gbmV3IERGQVN0YXRlKDB4N0ZGRkZGRkYsIG5ldyBBVE5Db25maWdTZXQoKSk7XG5cblxuQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRDYWNoZWRDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLnNoYXJlZENvbnRleHRDYWNoZSA9PT1udWxsKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgIHJldHVybiBnZXRDYWNoZWRQcmVkaWN0aW9uQ29udGV4dChjb250ZXh0LCB0aGlzLnNoYXJlZENvbnRleHRDYWNoZSwgdmlzaXRlZCk7XG59O1xuXG5leHBvcnRzLkFUTlNpbXVsYXRvciA9IEFUTlNpbXVsYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vQVROU2ltdWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuLy9cbi8vIFRoaXMgZW51bWVyYXRpb24gZGVmaW5lcyB0aGUgcHJlZGljdGlvbiBtb2RlcyBhdmFpbGFibGUgaW4gQU5UTFIgNCBhbG9uZyB3aXRoXG4vLyB1dGlsaXR5IG1ldGhvZHMgZm9yIGFuYWx5emluZyBjb25maWd1cmF0aW9uIHNldHMgZm9yIGNvbmZsaWN0cyBhbmQvb3Jcbi8vIGFtYmlndWl0aWVzLlxuXG52YXIgU2V0ID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLlNldDtcbnZhciBNYXAgPSByZXF1aXJlKCcuLy4uL1V0aWxzJykuTWFwO1xudmFyIEJpdFNldCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5CaXRTZXQ7XG52YXIgQWx0RGljdCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5BbHREaWN0O1xudmFyIEFUTiA9IHJlcXVpcmUoJy4vQVROJykuQVROO1xudmFyIFJ1bGVTdG9wU3RhdGUgPSByZXF1aXJlKCcuL0FUTlN0YXRlJykuUnVsZVN0b3BTdGF0ZTtcbnZhciBBVE5Db25maWdTZXQgPSByZXF1aXJlKCcuL0FUTkNvbmZpZ1NldCcpLkFUTkNvbmZpZ1NldDtcbnZhciBBVE5Db25maWcgPSByZXF1aXJlKCcuL0FUTkNvbmZpZycpLkFUTkNvbmZpZztcbnZhciBTZW1hbnRpY0NvbnRleHQgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlNlbWFudGljQ29udGV4dDtcbnZhciBIYXNoID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpLkhhc2g7XG52YXIgaGFzaFN0dWZmID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLmhhc2hTdHVmZjtcbnZhciBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5lcXVhbEFycmF5cztcblxuZnVuY3Rpb24gUHJlZGljdGlvbk1vZGUoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG4vL1xuLy8gVGhlIFNMTCgqKSBwcmVkaWN0aW9uIG1vZGUuIFRoaXMgcHJlZGljdGlvbiBtb2RlIGlnbm9yZXMgdGhlIGN1cnJlbnRcbi8vIHBhcnNlciBjb250ZXh0IHdoZW4gbWFraW5nIHByZWRpY3Rpb25zLiBUaGlzIGlzIHRoZSBmYXN0ZXN0IHByZWRpY3Rpb25cbi8vIG1vZGUsIGFuZCBwcm92aWRlcyBjb3JyZWN0IHJlc3VsdHMgZm9yIG1hbnkgZ3JhbW1hcnMuIFRoaXMgcHJlZGljdGlvblxuLy8gbW9kZSBpcyBtb3JlIHBvd2VyZnVsIHRoYW4gdGhlIHByZWRpY3Rpb24gbW9kZSBwcm92aWRlZCBieSBBTlRMUiAzLCBidXRcbi8vIG1heSByZXN1bHQgaW4gc3ludGF4IGVycm9ycyBmb3IgZ3JhbW1hciBhbmQgaW5wdXQgY29tYmluYXRpb25zIHdoaWNoIGFyZVxuLy8gbm90IFNMTC5cbi8vXG4vLyA8cD5cbi8vIFdoZW4gdXNpbmcgdGhpcyBwcmVkaWN0aW9uIG1vZGUsIHRoZSBwYXJzZXIgd2lsbCBlaXRoZXIgcmV0dXJuIGEgY29ycmVjdFxuLy8gcGFyc2UgdHJlZSAoaS5lLiB0aGUgc2FtZSBwYXJzZSB0cmVlIHRoYXQgd291bGQgYmUgcmV0dXJuZWQgd2l0aCB0aGVcbi8vIHtAbGluayAvL0xMfSBwcmVkaWN0aW9uIG1vZGUpLCBvciBpdCB3aWxsIHJlcG9ydCBhIHN5bnRheCBlcnJvci4gSWYgYVxuLy8gc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkIHdoZW4gdXNpbmcgdGhlIHtAbGluayAvL1NMTH0gcHJlZGljdGlvbiBtb2RlLFxuLy8gaXQgbWF5IGJlIGR1ZSB0byBlaXRoZXIgYW4gYWN0dWFsIHN5bnRheCBlcnJvciBpbiB0aGUgaW5wdXQgb3IgaW5kaWNhdGVcbi8vIHRoYXQgdGhlIHBhcnRpY3VsYXIgY29tYmluYXRpb24gb2YgZ3JhbW1hciBhbmQgaW5wdXQgcmVxdWlyZXMgdGhlIG1vcmVcbi8vIHBvd2VyZnVsIHtAbGluayAvL0xMfSBwcmVkaWN0aW9uIGFiaWxpdGllcyB0byBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuPC9wPlxuLy9cbi8vIDxwPlxuLy8gVGhpcyBwcmVkaWN0aW9uIG1vZGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgZ3VhcmFudGVlcyBmb3IgcHJlZGljdGlvblxuLy8gYmVoYXZpb3IgZm9yIHN5bnRhY3RpY2FsbHktaW5jb3JyZWN0IGlucHV0cy48L3A+XG4vL1xuUHJlZGljdGlvbk1vZGUuU0xMID0gMDtcbi8vXG4vLyBUaGUgTEwoKikgcHJlZGljdGlvbiBtb2RlLiBUaGlzIHByZWRpY3Rpb24gbW9kZSBhbGxvd3MgdGhlIGN1cnJlbnQgcGFyc2VyXG4vLyBjb250ZXh0IHRvIGJlIHVzZWQgZm9yIHJlc29sdmluZyBTTEwgY29uZmxpY3RzIHRoYXQgb2NjdXIgZHVyaW5nXG4vLyBwcmVkaWN0aW9uLiBUaGlzIGlzIHRoZSBmYXN0ZXN0IHByZWRpY3Rpb24gbW9kZSB0aGF0IGd1YXJhbnRlZXMgY29ycmVjdFxuLy8gcGFyc2UgcmVzdWx0cyBmb3IgYWxsIGNvbWJpbmF0aW9ucyBvZiBncmFtbWFycyB3aXRoIHN5bnRhY3RpY2FsbHkgY29ycmVjdFxuLy8gaW5wdXRzLlxuLy9cbi8vIDxwPlxuLy8gV2hlbiB1c2luZyB0aGlzIHByZWRpY3Rpb24gbW9kZSwgdGhlIHBhcnNlciB3aWxsIG1ha2UgY29ycmVjdCBkZWNpc2lvbnNcbi8vIGZvciBhbGwgc3ludGFjdGljYWxseS1jb3JyZWN0IGdyYW1tYXIgYW5kIGlucHV0IGNvbWJpbmF0aW9ucy4gSG93ZXZlciwgaW5cbi8vIGNhc2VzIHdoZXJlIHRoZSBncmFtbWFyIGlzIHRydWx5IGFtYmlndW91cyB0aGlzIHByZWRpY3Rpb24gbW9kZSBtaWdodCBub3Rcbi8vIHJlcG9ydCBhIHByZWNpc2UgYW5zd2VyIGZvciA8ZW0+ZXhhY3RseSB3aGljaDwvZW0+IGFsdGVybmF0aXZlcyBhcmVcbi8vIGFtYmlndW91cy48L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGlzIHByZWRpY3Rpb24gbW9kZSBkb2VzIG5vdCBwcm92aWRlIGFueSBndWFyYW50ZWVzIGZvciBwcmVkaWN0aW9uXG4vLyBiZWhhdmlvciBmb3Igc3ludGFjdGljYWxseS1pbmNvcnJlY3QgaW5wdXRzLjwvcD5cbi8vXG5QcmVkaWN0aW9uTW9kZS5MTCA9IDE7XG4vL1xuLy8gVGhlIExMKCopIHByZWRpY3Rpb24gbW9kZSB3aXRoIGV4YWN0IGFtYmlndWl0eSBkZXRlY3Rpb24uIEluIGFkZGl0aW9uIHRvXG4vLyB0aGUgY29ycmVjdG5lc3MgZ3VhcmFudGVlcyBwcm92aWRlZCBieSB0aGUge0BsaW5rIC8vTEx9IHByZWRpY3Rpb24gbW9kZSxcbi8vIHRoaXMgcHJlZGljdGlvbiBtb2RlIGluc3RydWN0cyB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0gdG8gZGV0ZXJtaW5lIHRoZVxuLy8gY29tcGxldGUgYW5kIGV4YWN0IHNldCBvZiBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzIGZvciBldmVyeSBhbWJpZ3VvdXNcbi8vIGRlY2lzaW9uIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmcuXG4vL1xuLy8gPHA+XG4vLyBUaGlzIHByZWRpY3Rpb24gbW9kZSBtYXkgYmUgdXNlZCBmb3IgZGlhZ25vc2luZyBhbWJpZ3VpdGllcyBkdXJpbmdcbi8vIGdyYW1tYXIgZGV2ZWxvcG1lbnQuIER1ZSB0byB0aGUgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQgb2YgY2FsY3VsYXRpbmcgc2V0c1xuLy8gb2YgYW1iaWd1b3VzIGFsdGVybmF0aXZlcywgdGhpcyBwcmVkaWN0aW9uIG1vZGUgc2hvdWxkIGJlIGF2b2lkZWQgd2hlblxuLy8gdGhlIGV4YWN0IHJlc3VsdHMgYXJlIG5vdCBuZWNlc3NhcnkuPC9wPlxuLy9cbi8vIDxwPlxuLy8gVGhpcyBwcmVkaWN0aW9uIG1vZGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgZ3VhcmFudGVlcyBmb3IgcHJlZGljdGlvblxuLy8gYmVoYXZpb3IgZm9yIHN5bnRhY3RpY2FsbHktaW5jb3JyZWN0IGlucHV0cy48L3A+XG4vL1xuUHJlZGljdGlvbk1vZGUuTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OID0gMjtcblxuXG4vL1xuLy8gQ29tcHV0ZXMgdGhlIFNMTCBwcmVkaWN0aW9uIHRlcm1pbmF0aW9uIGNvbmRpdGlvbi5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgbWV0aG9kIGNvbXB1dGVzIHRoZSBTTEwgcHJlZGljdGlvbiB0ZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIGJvdGggb2Zcbi8vIHRoZSBmb2xsb3dpbmcgY2FzZXMuPC9wPlxuLy9cbi8vIDx1bD5cbi8vIDxsaT5UaGUgdXN1YWwgU0xMK0xMIGZhbGxiYWNrIHVwb24gU0xMIGNvbmZsaWN0PC9saT5cbi8vIDxsaT5QdXJlIFNMTCB3aXRob3V0IExMIGZhbGxiYWNrPC9saT5cbi8vIDwvdWw+XG4vL1xuLy8gPHA+PHN0cm9uZz5DT01CSU5FRCBTTEwrTEwgUEFSU0lORzwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5XaGVuIExMLWZhbGxiYWNrIGlzIGVuYWJsZWQgdXBvbiBTTEwgY29uZmxpY3QsIGNvcnJlY3QgcHJlZGljdGlvbnMgYXJlXG4vLyBlbnN1cmVkIHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSB0ZXJtaW5hdGlvbiBjb25kaXRpb24gaXMgY29tcHV0ZWQgYnkgdGhpc1xuLy8gbWV0aG9kLiBEdWUgdG8gdGhlIHN1YnN0YW50aWFsbHkgaGlnaGVyIGNvc3Qgb2YgTEwgcHJlZGljdGlvbiwgdGhlXG4vLyBwcmVkaWN0aW9uIHNob3VsZCBvbmx5IGZhbGwgYmFjayB0byBMTCB3aGVuIHRoZSBhZGRpdGlvbmFsIGxvb2thaGVhZFxuLy8gY2Fubm90IGxlYWQgdG8gYSB1bmlxdWUgU0xMIHByZWRpY3Rpb24uPC9wPlxuLy9cbi8vIDxwPkFzc3VtaW5nIGNvbWJpbmVkIFNMTCtMTCBwYXJzaW5nLCBhbiBTTEwgY29uZmlndXJhdGlvbiBzZXQgd2l0aCBvbmx5XG4vLyBjb25mbGljdGluZyBzdWJzZXRzIHNob3VsZCBmYWxsIGJhY2sgdG8gZnVsbCBMTCwgZXZlbiBpZiB0aGVcbi8vIGNvbmZpZ3VyYXRpb24gc2V0cyBkb24ndCByZXNvbHZlIHRvIHRoZSBzYW1lIGFsdGVybmF0aXZlIChlLmcuXG4vLyB7QGNvZGUgezEsMn19IGFuZCB7QGNvZGUgezMsNH19LiBJZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLWNvbmZsaWN0aW5nXG4vLyBjb25maWd1cmF0aW9uLCBTTEwgY291bGQgY29udGludWUgd2l0aCB0aGUgaG9wZXMgdGhhdCBtb3JlIGxvb2thaGVhZCB3aWxsXG4vLyByZXNvbHZlIHZpYSBvbmUgb2YgdGhvc2Ugbm9uLWNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb25zLjwvcD5cbi8vXG4vLyA8cD5IZXJlJ3MgdGhlIHByZWRpY3Rpb24gdGVybWluYXRpb24gcnVsZSB0aGVtOiBTTEwgKGZvciBTTEwrTEwgcGFyc2luZylcbi8vIHN0b3BzIHdoZW4gaXQgc2VlcyBvbmx5IGNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb24gc3Vic2V0cy4gSW4gY29udHJhc3QsXG4vLyBmdWxsIExMIGtlZXBzIGdvaW5nIHdoZW4gdGhlcmUgaXMgdW5jZXJ0YWludHkuPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+SEVVUklTVElDPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPkFzIGEgaGV1cmlzdGljLCB3ZSBzdG9wIHByZWRpY3Rpb24gd2hlbiB3ZSBzZWUgYW55IGNvbmZsaWN0aW5nIHN1YnNldFxuLy8gdW5sZXNzIHdlIHNlZSBhIHN0YXRlIHRoYXQgb25seSBoYXMgb25lIGFsdGVybmF0aXZlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbi8vIFRoZSBzaW5nbGUtYWx0LXN0YXRlIHRoaW5nIGxldHMgcHJlZGljdGlvbiBjb250aW51ZSB1cG9uIHJ1bGVzIGxpa2Vcbi8vIChvdGhlcndpc2UsIGl0IHdvdWxkIGFkbWl0IGRlZmVhdCB0b28gc29vbik6PC9wPlxuLy9cbi8vIDxwPntAY29kZSBbMTJ8MXxbXSwgNnwyfFtdLCAxMnwyfFtdXS4gcyA6IChJRCB8IElEIElEPykgJzsnIDt9PC9wPlxuLy9cbi8vIDxwPldoZW4gdGhlIEFUTiBzaW11bGF0aW9uIHJlYWNoZXMgdGhlIHN0YXRlIGJlZm9yZSB7QGNvZGUgJzsnfSwgaXQgaGFzIGFcbi8vIERGQSBzdGF0ZSB0aGF0IGxvb2tzIGxpa2U6IHtAY29kZSBbMTJ8MXxbXSwgNnwyfFtdLCAxMnwyfFtdXX0uIE5hdHVyYWxseVxuLy8ge0Bjb2RlIDEyfDF8W119IGFuZCB7QGNvZGUgMTJ8MnxbXX0gY29uZmxpY3QsIGJ1dCB3ZSBjYW5ub3Qgc3RvcFxuLy8gcHJvY2Vzc2luZyB0aGlzIG5vZGUgYmVjYXVzZSBhbHRlcm5hdGl2ZSB0byBoYXMgYW5vdGhlciB3YXkgdG8gY29udGludWUsXG4vLyB2aWEge0Bjb2RlIFs2fDJ8W11dfS48L3A+XG4vL1xuLy8gPHA+SXQgYWxzbyBsZXQncyB1cyBjb250aW51ZSBmb3IgdGhpcyBydWxlOjwvcD5cbi8vXG4vLyA8cD57QGNvZGUgWzF8MXxbXSwgMXwyfFtdLCA4fDN8W11dIGEgOiBBIHwgQSB8IEEgQiA7fTwvcD5cbi8vXG4vLyA8cD5BZnRlciBtYXRjaGluZyBpbnB1dCBBLCB3ZSByZWFjaCB0aGUgc3RvcCBzdGF0ZSBmb3IgcnVsZSBBLCBzdGF0ZSAxLlxuLy8gU3RhdGUgOCBpcyB0aGUgc3RhdGUgcmlnaHQgYmVmb3JlIEIuIENsZWFybHkgYWx0ZXJuYXRpdmVzIDEgYW5kIDJcbi8vIGNvbmZsaWN0IGFuZCBubyBhbW91bnQgb2YgZnVydGhlciBsb29rYWhlYWQgd2lsbCBzZXBhcmF0ZSB0aGUgdHdvLlxuLy8gSG93ZXZlciwgYWx0ZXJuYXRpdmUgMyB3aWxsIGJlIGFibGUgdG8gY29udGludWUgYW5kIHNvIHdlIGRvIG5vdCBzdG9wXG4vLyB3b3JraW5nIG9uIHRoaXMgc3RhdGUuIEluIHRoZSBwcmV2aW91cyBleGFtcGxlLCB3ZSdyZSBjb25jZXJuZWQgd2l0aFxuLy8gc3RhdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29uZmxpY3RpbmcgYWx0ZXJuYXRpdmVzLiBIZXJlIGFsdCAzIGlzIG5vdFxuLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBjb25maWdzLCBidXQgc2luY2Ugd2UgY2FuIGNvbnRpbnVlXG4vLyBsb29raW5nIGZvciBpbnB1dCByZWFzb25hYmx5LCBkb24ndCBkZWNsYXJlIHRoZSBzdGF0ZSBkb25lLjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPlBVUkUgU0xMIFBBUlNJTkc8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+VG8gaGFuZGxlIHB1cmUgU0xMIHBhcnNpbmcsIGFsbCB3ZSBoYXZlIHRvIGRvIGlzIG1ha2Ugc3VyZSB0aGF0IHdlXG4vLyBjb21iaW5lIHN0YWNrIGNvbnRleHRzIGZvciBjb25maWd1cmF0aW9ucyB0aGF0IGRpZmZlciBvbmx5IGJ5IHNlbWFudGljXG4vLyBwcmVkaWNhdGUuIEZyb20gdGhlcmUsIHdlIGNhbiBkbyB0aGUgdXN1YWwgU0xMIHRlcm1pbmF0aW9uIGhldXJpc3RpYy48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5QUkVESUNBVEVTIElOIFNMTCtMTCBQQVJTSU5HPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlNMTCBkZWNpc2lvbnMgZG9uJ3QgZXZhbHVhdGUgcHJlZGljYXRlcyB1bnRpbCBhZnRlciB0aGV5IHJlYWNoIERGQSBzdG9wXG4vLyBzdGF0ZXMgYmVjYXVzZSB0aGV5IG5lZWQgdG8gY3JlYXRlIHRoZSBERkEgY2FjaGUgdGhhdCB3b3JrcyBpbiBhbGxcbi8vIHNlbWFudGljIHNpdHVhdGlvbnMuIEluIGNvbnRyYXN0LCBmdWxsIExMIGV2YWx1YXRlcyBwcmVkaWNhdGVzIGNvbGxlY3RlZFxuLy8gZHVyaW5nIHN0YXJ0IHN0YXRlIGNvbXB1dGF0aW9uIHNvIGl0IGNhbiBpZ25vcmUgcHJlZGljYXRlcyB0aGVyZWFmdGVyLlxuLy8gVGhpcyBtZWFucyB0aGF0IFNMTCB0ZXJtaW5hdGlvbiBkZXRlY3Rpb24gY2FuIHRvdGFsbHkgaWdub3JlIHNlbWFudGljXG4vLyBwcmVkaWNhdGVzLjwvcD5cbi8vXG4vLyA8cD5JbXBsZW1lbnRhdGlvbi13aXNlLCB7QGxpbmsgQVROQ29uZmlnU2V0fSBjb21iaW5lcyBzdGFjayBjb250ZXh0cyBidXQgbm90XG4vLyBzZW1hbnRpYyBwcmVkaWNhdGUgY29udGV4dHMgc28gd2UgbWlnaHQgc2VlIHR3byBjb25maWd1cmF0aW9ucyBsaWtlIHRoZVxuLy8gZm9sbG93aW5nLjwvcD5cbi8vXG4vLyA8cD57QGNvZGUgKHMsIDEsIHgsIHt9KSwgKHMsIDEsIHgnLCB7cH0pfTwvcD5cbi8vXG4vLyA8cD5CZWZvcmUgdGVzdGluZyB0aGVzZSBjb25maWd1cmF0aW9ucyBhZ2FpbnN0IG90aGVycywgd2UgaGF2ZSB0byBtZXJnZVxuLy8ge0Bjb2RlIHh9IGFuZCB7QGNvZGUgeCd9ICh3aXRob3V0IG1vZGlmeWluZyB0aGUgZXhpc3RpbmcgY29uZmlndXJhdGlvbnMpLlxuLy8gRm9yIGV4YW1wbGUsIHdlIHRlc3Qge0Bjb2RlICh4K3gnKT09eCcnfSB3aGVuIGxvb2tpbmcgZm9yIGNvbmZsaWN0cyBpblxuLy8gdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9ucy48L3A+XG4vL1xuLy8gPHA+e0Bjb2RlIChzLCAxLCB4LCB7fSksIChzLCAxLCB4Jywge3B9KSwgKHMsIDIsIHgnJywge30pfTwvcD5cbi8vXG4vLyA8cD5JZiB0aGUgY29uZmlndXJhdGlvbiBzZXQgaGFzIHByZWRpY2F0ZXMgKGFzIGluZGljYXRlZCBieVxuLy8ge0BsaW5rIEFUTkNvbmZpZ1NldC8vaGFzU2VtYW50aWNDb250ZXh0fSksIHRoaXMgYWxnb3JpdGhtIG1ha2VzIGEgY29weSBvZlxuLy8gdGhlIGNvbmZpZ3VyYXRpb25zIHRvIHN0cmlwIG91dCBhbGwgb2YgdGhlIHByZWRpY2F0ZXMgc28gdGhhdCBhIHN0YW5kYXJkXG4vLyB7QGxpbmsgQVROQ29uZmlnU2V0fSB3aWxsIG1lcmdlIGV2ZXJ5dGhpbmcgaWdub3JpbmcgcHJlZGljYXRlcy48L3A+XG4vL1xuUHJlZGljdGlvbk1vZGUuaGFzU0xMQ29uZmxpY3RUZXJtaW5hdGluZ1ByZWRpY3Rpb24gPSBmdW5jdGlvbiggbW9kZSwgY29uZmlncykge1xuICAgIC8vIENvbmZpZ3MgaW4gcnVsZSBzdG9wIHN0YXRlcyBpbmRpY2F0ZSByZWFjaGluZyB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvblxuICAgIC8vIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiBzdGFydCBydWxlIChmdWxsIGNvbnRleHQpLiBJZiBhbGxcbiAgICAvLyBjb25maWdzIG1lZXQgdGhpcyBjb25kaXRpb24sIHRoZW4gbm9uZSBvZiB0aGUgY29uZmlndXJhdGlvbnMgaXMgYWJsZVxuICAgIC8vIHRvIG1hdGNoIGFkZGl0aW9uYWwgaW5wdXQgc28gd2UgdGVybWluYXRlIHByZWRpY3Rpb24uXG4gICAgLy9cbiAgICBpZiAoUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHB1cmUgU0xMIG1vZGUgcGFyc2luZ1xuICAgIGlmIChtb2RlID09PSBQcmVkaWN0aW9uTW9kZS5TTEwpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIHdpdGggY29tYmluaW5nIGNvbmZpZ3MgZnJvbSBkaWZmZXJlbnQgc2VtYW50aWNcbiAgICAgICAgLy8gY29udGV4dHMgaWYgd2UgY2FuIGZhaWwgb3ZlciB0byBmdWxsIExMOyBjb3N0cyBtb3JlIHRpbWVcbiAgICAgICAgLy8gc2luY2Ugd2UnbGwgb2Z0ZW4gZmFpbCBvdmVyIGFueXdheS5cbiAgICAgICAgaWYgKGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkdXAgY29uZmlncywgdG9zc2luZyBvdXQgc2VtYW50aWMgcHJlZGljYXRlc1xuICAgICAgICAgICAgdmFyIGR1cCA9IG5ldyBBVE5Db25maWdTZXQoKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8Y29uZmlncy5pdGVtcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICBcdHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c2VtYW50aWNDb250ZXh0OlNlbWFudGljQ29udGV4dC5OT05FfSwgYyk7XG4gICAgICAgICAgICAgICAgZHVwLmFkZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZ3MgPSBkdXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IHdlIGhhdmUgY29tYmluZWQgY29udGV4dHMgZm9yIGNvbmZpZ3Mgd2l0aCBkaXNzaW1pbGFyIHByZWRzXG4gICAgfVxuICAgIC8vIHB1cmUgU0xMIG9yIGNvbWJpbmVkIFNMTCtMTCBtb2RlIHBhcnNpbmdcbiAgICB2YXIgYWx0c2V0cyA9IFByZWRpY3Rpb25Nb2RlLmdldENvbmZsaWN0aW5nQWx0U3Vic2V0cyhjb25maWdzKTtcbiAgICByZXR1cm4gUHJlZGljdGlvbk1vZGUuaGFzQ29uZmxpY3RpbmdBbHRTZXQoYWx0c2V0cykgJiYgIVByZWRpY3Rpb25Nb2RlLmhhc1N0YXRlQXNzb2NpYXRlZFdpdGhPbmVBbHQoY29uZmlncyk7XG59O1xuXG4vLyBDaGVja3MgaWYgYW55IGNvbmZpZ3VyYXRpb24gaW4ge0Bjb2RlIGNvbmZpZ3N9IGlzIGluIGFcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfS4gQ29uZmlndXJhdGlvbnMgbWVldGluZyB0aGlzIGNvbmRpdGlvbiBoYXZlIHJlYWNoZWRcbi8vIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiBzdGFydCBydWxlIChmdWxsXG4vLyBjb250ZXh0KS5cbi8vXG4vLyBAcGFyYW0gY29uZmlncyB0aGUgY29uZmlndXJhdGlvbiBzZXQgdG8gdGVzdFxuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgYW55IGNvbmZpZ3VyYXRpb24gaW4ge0Bjb2RlIGNvbmZpZ3N9IGlzIGluIGFcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfSwgb3RoZXJ3aXNlIHtAY29kZSBmYWxzZX1cblByZWRpY3Rpb25Nb2RlLmhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcblx0Zm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgYyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgIGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIENoZWNrcyBpZiBhbGwgY29uZmlndXJhdGlvbnMgaW4ge0Bjb2RlIGNvbmZpZ3N9IGFyZSBpbiBhXG4vLyB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0uIENvbmZpZ3VyYXRpb25zIG1lZXRpbmcgdGhpcyBjb25kaXRpb24gaGF2ZSByZWFjaGVkXG4vLyB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvbiBydWxlIChsb2NhbCBjb250ZXh0KSBvciBlbmQgb2Ygc3RhcnQgcnVsZSAoZnVsbFxuLy8gY29udGV4dCkuXG4vL1xuLy8gQHBhcmFtIGNvbmZpZ3MgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHRvIHRlc3Rcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGFsbCBjb25maWd1cmF0aW9ucyBpbiB7QGNvZGUgY29uZmlnc30gYXJlIGluIGFcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfSwgb3RoZXJ3aXNlIHtAY29kZSBmYWxzZX1cblByZWRpY3Rpb25Nb2RlLmFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzID0gZnVuY3Rpb24oY29uZmlncykge1xuXHRmb3IodmFyIGk9MDtpPGNvbmZpZ3MuaXRlbXMubGVuZ3RoO2krKykge1xuXHRcdHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKCEoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy9cbi8vIEZ1bGwgTEwgcHJlZGljdGlvbiB0ZXJtaW5hdGlvbi5cbi8vXG4vLyA8cD5DYW4gd2Ugc3RvcCBsb29raW5nIGFoZWFkIGR1cmluZyBBVE4gc2ltdWxhdGlvbiBvciBpcyB0aGVyZSBzb21lXG4vLyB1bmNlcnRhaW50eSBhcyB0byB3aGljaCBhbHRlcm5hdGl2ZSB3ZSB3aWxsIHVsdGltYXRlbHkgcGljaywgYWZ0ZXJcbi8vIGNvbnN1bWluZyBtb3JlIGlucHV0PyBFdmVuIGlmIHRoZXJlIGFyZSBwYXJ0aWFsIGNvbmZsaWN0cywgd2UgbWlnaHQga25vd1xuLy8gdGhhdCBldmVyeXRoaW5nIGlzIGdvaW5nIHRvIHJlc29sdmUgdG8gdGhlIHNhbWUgbWluaW11bSBhbHRlcm5hdGl2ZS4gVGhhdFxuLy8gbWVhbnMgd2UgY2FuIHN0b3Agc2luY2Ugbm8gbW9yZSBsb29rYWhlYWQgd2lsbCBjaGFuZ2UgdGhhdCBmYWN0LiBPbiB0aGVcbi8vIG90aGVyIGhhbmQsIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGNvbmZsaWN0cyB0aGF0IHJlc29sdmUgdG8gZGlmZmVyZW50XG4vLyBtaW5pbXVtcy4gVGhhdCBtZWFucyB3ZSBuZWVkIG1vcmUgbG9vayBhaGVhZCB0byBkZWNpZGUgd2hpY2ggb2YgdGhvc2Vcbi8vIGFsdGVybmF0aXZlcyB3ZSBzaG91bGQgcHJlZGljdC48L3A+XG4vL1xuLy8gPHA+VGhlIGJhc2ljIGlkZWEgaXMgdG8gc3BsaXQgdGhlIHNldCBvZiBjb25maWd1cmF0aW9ucyB7QGNvZGUgQ30sIGludG9cbi8vIGNvbmZsaWN0aW5nIHN1YnNldHMge0Bjb2RlIChzLCBfLCBjdHgsIF8pfSBhbmQgc2luZ2xldG9uIHN1YnNldHMgd2l0aFxuLy8gbm9uLWNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb25zLiBUd28gY29uZmlndXJhdGlvbnMgY29uZmxpY3QgaWYgdGhleSBoYXZlXG4vLyBpZGVudGljYWwge0BsaW5rIEFUTkNvbmZpZy8vc3RhdGV9IGFuZCB7QGxpbmsgQVROQ29uZmlnLy9jb250ZXh0fSB2YWx1ZXNcbi8vIGJ1dCBkaWZmZXJlbnQge0BsaW5rIEFUTkNvbmZpZy8vYWx0fSB2YWx1ZSwgZS5nLiB7QGNvZGUgKHMsIGksIGN0eCwgXyl9XG4vLyBhbmQge0Bjb2RlIChzLCBqLCBjdHgsIF8pfSBmb3Ige0Bjb2RlIGkhPWp9LjwvcD5cbi8vXG4vLyA8cD5SZWR1Y2UgdGhlc2UgY29uZmlndXJhdGlvbiBzdWJzZXRzIHRvIHRoZSBzZXQgb2YgcG9zc2libGUgYWx0ZXJuYXRpdmVzLlxuLy8gWW91IGNhbiBjb21wdXRlIHRoZSBhbHRlcm5hdGl2ZSBzdWJzZXRzIGluIG9uZSBwYXNzIGFzIGZvbGxvd3M6PC9wPlxuLy9cbi8vIDxwPntAY29kZSBBX3MsY3R4ID0ge2kgfCAocywgaSwgY3R4LCBfKX19IGZvciBlYWNoIGNvbmZpZ3VyYXRpb24gaW5cbi8vIHtAY29kZSBDfSBob2xkaW5nIHtAY29kZSBzfSBhbmQge0Bjb2RlIGN0eH0gZml4ZWQuPC9wPlxuLy9cbi8vIDxwPk9yIGluIHBzZXVkby1jb2RlLCBmb3IgZWFjaCBjb25maWd1cmF0aW9uIHtAY29kZSBjfSBpbiB7QGNvZGUgQ306PC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBtYXBbY10gVT0gYy57QGxpbmsgQVROQ29uZmlnLy9hbHQgYWx0fSAvLyBtYXAgaGFzaC9lcXVhbHMgdXNlcyBzIGFuZCB4LCBub3Rcbi8vIGFsdCBhbmQgbm90IHByZWRcbi8vIDwvcHJlPlxuLy9cbi8vIDxwPlRoZSB2YWx1ZXMgaW4ge0Bjb2RlIG1hcH0gYXJlIHRoZSBzZXQgb2Yge0Bjb2RlIEFfcyxjdHh9IHNldHMuPC9wPlxuLy9cbi8vIDxwPklmIHtAY29kZSB8QV9zLGN0eHw9MX0gdGhlbiB0aGVyZSBpcyBubyBjb25mbGljdCBhc3NvY2lhdGVkIHdpdGhcbi8vIHtAY29kZSBzfSBhbmQge0Bjb2RlIGN0eH0uPC9wPlxuLy9cbi8vIDxwPlJlZHVjZSB0aGUgc3Vic2V0cyB0byBzaW5nbGV0b25zIGJ5IGNob29zaW5nIGEgbWluaW11bSBvZiBlYWNoIHN1YnNldC4gSWZcbi8vIHRoZSB1bmlvbiBvZiB0aGVzZSBhbHRlcm5hdGl2ZSBzdWJzZXRzIGlzIGEgc2luZ2xldG9uLCB0aGVuIG5vIGFtb3VudCBvZlxuLy8gbW9yZSBsb29rYWhlYWQgd2lsbCBoZWxwIHVzLiBXZSB3aWxsIGFsd2F5cyBwaWNrIHRoYXQgYWx0ZXJuYXRpdmUuIElmLFxuLy8gaG93ZXZlciwgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBhbHRlcm5hdGl2ZSwgdGhlbiB3ZSBhcmUgdW5jZXJ0YWluIHdoaWNoXG4vLyBhbHRlcm5hdGl2ZSB0byBwcmVkaWN0IGFuZCBtdXN0IGNvbnRpbnVlIGxvb2tpbmcgZm9yIHJlc29sdXRpb24uIFdlIG1heVxuLy8gb3IgbWF5IG5vdCBkaXNjb3ZlciBhbiBhbWJpZ3VpdHkgaW4gdGhlIGZ1dHVyZSwgZXZlbiBpZiB0aGVyZSBhcmUgbm9cbi8vIGNvbmZsaWN0aW5nIHN1YnNldHMgdGhpcyByb3VuZC48L3A+XG4vL1xuLy8gPHA+VGhlIGJpZ2dlc3Qgc2luIGlzIHRvIHRlcm1pbmF0ZSBlYXJseSBiZWNhdXNlIGl0IG1lYW5zIHdlJ3ZlIG1hZGUgYVxuLy8gZGVjaXNpb24gYnV0IHdlcmUgdW5jZXJ0YWluIGFzIHRvIHRoZSBldmVudHVhbCBvdXRjb21lLiBXZSBoYXZlbid0IHVzZWRcbi8vIGVub3VnaCBsb29rYWhlYWQuIE9uIHRoZSBvdGhlciBoYW5kLCBhbm5vdW5jaW5nIGEgY29uZmxpY3QgdG9vIGxhdGUgaXMgbm9cbi8vIGJpZyBkZWFsOyB5b3Ugd2lsbCBzdGlsbCBoYXZlIHRoZSBjb25mbGljdC4gSXQncyBqdXN0IGluZWZmaWNpZW50LiBJdFxuLy8gbWlnaHQgZXZlbiBsb29rIHVudGlsIHRoZSBlbmQgb2YgZmlsZS48L3A+XG4vL1xuLy8gPHA+Tm8gc3BlY2lhbCBjb25zaWRlcmF0aW9uIGZvciBzZW1hbnRpYyBwcmVkaWNhdGVzIGlzIHJlcXVpcmVkIGJlY2F1c2Vcbi8vIHByZWRpY2F0ZXMgYXJlIGV2YWx1YXRlZCBvbi10aGUtZmx5IGZvciBmdWxsIExMIHByZWRpY3Rpb24sIGVuc3VyaW5nIHRoYXRcbi8vIG5vIGNvbmZpZ3VyYXRpb24gY29udGFpbnMgYSBzZW1hbnRpYyBjb250ZXh0IGR1cmluZyB0aGUgdGVybWluYXRpb25cbi8vIGNoZWNrLjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPkNPTkZMSUNUSU5HIENPTkZJR1M8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+VHdvIGNvbmZpZ3VyYXRpb25zIHtAY29kZSAocywgaSwgeCl9IGFuZCB7QGNvZGUgKHMsIGosIHgnKX0sIGNvbmZsaWN0XG4vLyB3aGVuIHtAY29kZSBpIT1qfSBidXQge0Bjb2RlIHg9eCd9LiBCZWNhdXNlIHdlIG1lcmdlIGFsbFxuLy8ge0Bjb2RlIChzLCBpLCBfKX0gY29uZmlndXJhdGlvbnMgdG9nZXRoZXIsIHRoYXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgYXRcbi8vIG1vc3Qge0Bjb2RlIG59IGNvbmZpZ3VyYXRpb25zIGFzc29jaWF0ZWQgd2l0aCBzdGF0ZSB7QGNvZGUgc30gZm9yXG4vLyB7QGNvZGUgbn0gcG9zc2libGUgYWx0ZXJuYXRpdmVzIGluIHRoZSBkZWNpc2lvbi4gVGhlIG1lcmdlZCBzdGFja3Ncbi8vIGNvbXBsaWNhdGUgdGhlIGNvbXBhcmlzb24gb2YgY29uZmlndXJhdGlvbiBjb250ZXh0cyB7QGNvZGUgeH0gYW5kXG4vLyB7QGNvZGUgeCd9LiBTYW0gY2hlY2tzIHRvIHNlZSBpZiBvbmUgaXMgYSBzdWJzZXQgb2YgdGhlIG90aGVyIGJ5IGNhbGxpbmdcbi8vIG1lcmdlIGFuZCBjaGVja2luZyB0byBzZWUgaWYgdGhlIG1lcmdlZCByZXN1bHQgaXMgZWl0aGVyIHtAY29kZSB4fSBvclxuLy8ge0Bjb2RlIHgnfS4gSWYgdGhlIHtAY29kZSB4fSBhc3NvY2lhdGVkIHdpdGggbG93ZXN0IGFsdGVybmF0aXZlIHtAY29kZSBpfVxuLy8gaXMgdGhlIHN1cGVyc2V0LCB0aGVuIHtAY29kZSBpfSBpcyB0aGUgb25seSBwb3NzaWJsZSBwcmVkaWN0aW9uIHNpbmNlIHRoZVxuLy8gb3RoZXJzIHJlc29sdmUgdG8ge0Bjb2RlIG1pbihpKX0gYXMgd2VsbC4gSG93ZXZlciwgaWYge0Bjb2RlIHh9IGlzXG4vLyBhc3NvY2lhdGVkIHdpdGgge0Bjb2RlIGo+aX0gdGhlbiBhdCBsZWFzdCBvbmUgc3RhY2sgY29uZmlndXJhdGlvbiBmb3Jcbi8vIHtAY29kZSBqfSBpcyBub3QgaW4gY29uZmxpY3Qgd2l0aCBhbHRlcm5hdGl2ZSB7QGNvZGUgaX0uIFRoZSBhbGdvcml0aG1cbi8vIHNob3VsZCBrZWVwIGdvaW5nLCBsb29raW5nIGZvciBtb3JlIGxvb2thaGVhZCBkdWUgdG8gdGhlIHVuY2VydGFpbnR5LjwvcD5cbi8vXG4vLyA8cD5Gb3Igc2ltcGxpY2l0eSwgSSdtIGRvaW5nIGEgZXF1YWxpdHkgY2hlY2sgYmV0d2VlbiB7QGNvZGUgeH0gYW5kXG4vLyB7QGNvZGUgeCd9IHRoYXQgbGV0cyB0aGUgYWxnb3JpdGhtIGNvbnRpbnVlIHRvIGNvbnN1bWUgbG9va2FoZWFkIGxvbmdlclxuLy8gdGhhbiBuZWNlc3NhcnkuIFRoZSByZWFzb24gSSBsaWtlIHRoZSBlcXVhbGl0eSBpcyBvZiBjb3Vyc2UgdGhlXG4vLyBzaW1wbGljaXR5IGJ1dCBhbHNvIGJlY2F1c2UgdGhhdCBpcyB0aGUgdGVzdCB5b3UgbmVlZCB0byBkZXRlY3QgdGhlXG4vLyBhbHRlcm5hdGl2ZXMgdGhhdCBhcmUgYWN0dWFsbHkgaW4gY29uZmxpY3QuPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+Q09OVElOVUUvU1RPUCBSVUxFPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPkNvbnRpbnVlIGlmIHVuaW9uIG9mIHJlc29sdmVkIGFsdGVybmF0aXZlIHNldHMgZnJvbSBub24tY29uZmxpY3RpbmcgYW5kXG4vLyBjb25mbGljdGluZyBhbHRlcm5hdGl2ZSBzdWJzZXRzIGhhcyBtb3JlIHRoYW4gb25lIGFsdGVybmF0aXZlLiBXZSBhcmVcbi8vIHVuY2VydGFpbiBhYm91dCB3aGljaCBhbHRlcm5hdGl2ZSB0byBwcmVkaWN0LjwvcD5cbi8vXG4vLyA8cD5UaGUgY29tcGxldGUgc2V0IG9mIGFsdGVybmF0aXZlcywge0Bjb2RlIFtpIGZvciAoXyxpLF8pXX0sIHRlbGxzIHVzIHdoaWNoXG4vLyBhbHRlcm5hdGl2ZXMgYXJlIHN0aWxsIGluIHRoZSBydW5uaW5nIGZvciB0aGUgYW1vdW50IG9mIGlucHV0IHdlJ3ZlXG4vLyBjb25zdW1lZCBhdCB0aGlzIHBvaW50LiBUaGUgY29uZmxpY3Rpbmcgc2V0cyBsZXQgdXMgdG8gc3RyaXAgYXdheVxuLy8gY29uZmlndXJhdGlvbnMgdGhhdCB3b24ndCBsZWFkIHRvIG1vcmUgc3RhdGVzIGJlY2F1c2Ugd2UgcmVzb2x2ZVxuLy8gY29uZmxpY3RzIHRvIHRoZSBjb25maWd1cmF0aW9uIHdpdGggYSBtaW5pbXVtIGFsdGVybmF0ZSBmb3IgdGhlXG4vLyBjb25mbGljdGluZyBzZXQuPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+Q0FTRVM8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHVsPlxuLy9cbi8vIDxsaT5ubyBjb25mbGljdHMgYW5kIG1vcmUgdGhhbiAxIGFsdGVybmF0aXZlIGluIHNldCA9Jmd0OyBjb250aW51ZTwvbGk+XG4vL1xuLy8gPGxpPiB7QGNvZGUgKHMsIDEsIHgpfSwge0Bjb2RlIChzLCAyLCB4KX0sIHtAY29kZSAocywgMywgeil9LFxuLy8ge0Bjb2RlIChzJywgMSwgeSl9LCB7QGNvZGUgKHMnLCAyLCB5KX0geWllbGRzIG5vbi1jb25mbGljdGluZyBzZXRcbi8vIHtAY29kZSB7M319IFUgY29uZmxpY3Rpbmcgc2V0cyB7QGNvZGUgbWluKHsxLDJ9KX0gVSB7QGNvZGUgbWluKHsxLDJ9KX0gPVxuLy8ge0Bjb2RlIHsxLDN9fSA9Jmd0OyBjb250aW51ZVxuLy8gPC9saT5cbi8vXG4vLyA8bGk+e0Bjb2RlIChzLCAxLCB4KX0sIHtAY29kZSAocywgMiwgeCl9LCB7QGNvZGUgKHMnLCAxLCB5KX0sXG4vLyB7QGNvZGUgKHMnLCAyLCB5KX0sIHtAY29kZSAocycnLCAxLCB6KX0geWllbGRzIG5vbi1jb25mbGljdGluZyBzZXRcbi8vIHtAY29kZSB7MX19IFUgY29uZmxpY3Rpbmcgc2V0cyB7QGNvZGUgbWluKHsxLDJ9KX0gVSB7QGNvZGUgbWluKHsxLDJ9KX0gPVxuLy8ge0Bjb2RlIHsxfX0gPSZndDsgc3RvcCBhbmQgcHJlZGljdCAxPC9saT5cbi8vXG4vLyA8bGk+e0Bjb2RlIChzLCAxLCB4KX0sIHtAY29kZSAocywgMiwgeCl9LCB7QGNvZGUgKHMnLCAxLCB5KX0sXG4vLyB7QGNvZGUgKHMnLCAyLCB5KX0geWllbGRzIGNvbmZsaWN0aW5nLCByZWR1Y2VkIHNldHMge0Bjb2RlIHsxfX0gVVxuLy8ge0Bjb2RlIHsxfX0gPSB7QGNvZGUgezF9fSA9Jmd0OyBzdG9wIGFuZCBwcmVkaWN0IDEsIGNhbiBhbm5vdW5jZVxuLy8gYW1iaWd1aXR5IHtAY29kZSB7MSwyfX08L2xpPlxuLy9cbi8vIDxsaT57QGNvZGUgKHMsIDEsIHgpfSwge0Bjb2RlIChzLCAyLCB4KX0sIHtAY29kZSAocycsIDIsIHkpfSxcbi8vIHtAY29kZSAocycsIDMsIHkpfSB5aWVsZHMgY29uZmxpY3RpbmcsIHJlZHVjZWQgc2V0cyB7QGNvZGUgezF9fSBVXG4vLyB7QGNvZGUgezJ9fSA9IHtAY29kZSB7MSwyfX0gPSZndDsgY29udGludWU8L2xpPlxuLy9cbi8vIDxsaT57QGNvZGUgKHMsIDEsIHgpfSwge0Bjb2RlIChzLCAyLCB4KX0sIHtAY29kZSAocycsIDMsIHkpfSxcbi8vIHtAY29kZSAocycsIDQsIHkpfSB5aWVsZHMgY29uZmxpY3RpbmcsIHJlZHVjZWQgc2V0cyB7QGNvZGUgezF9fSBVXG4vLyB7QGNvZGUgezN9fSA9IHtAY29kZSB7MSwzfX0gPSZndDsgY29udGludWU8L2xpPlxuLy9cbi8vIDwvdWw+XG4vL1xuLy8gPHA+PHN0cm9uZz5FWEFDVCBBTUJJR1VJVFkgREVURUNUSU9OPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPklmIGFsbCBzdGF0ZXMgcmVwb3J0IHRoZSBzYW1lIGNvbmZsaWN0aW5nIHNldCBvZiBhbHRlcm5hdGl2ZXMsIHRoZW4gd2Vcbi8vIGtub3cgd2UgaGF2ZSB0aGUgZXhhY3QgYW1iaWd1aXR5IHNldC48L3A+XG4vL1xuLy8gPHA+PGNvZGU+fEFfPGVtPmk8L2VtPnwmZ3Q7MTwvY29kZT4gYW5kXG4vLyA8Y29kZT5BXzxlbT5pPC9lbT4gPSBBXzxlbT5qPC9lbT48L2NvZGU+IGZvciBhbGwgPGVtPmk8L2VtPiwgPGVtPmo8L2VtPi48L3A+XG4vL1xuLy8gPHA+SW4gb3RoZXIgd29yZHMsIHdlIGNvbnRpbnVlIGV4YW1pbmluZyBsb29rYWhlYWQgdW50aWwgYWxsIHtAY29kZSBBX2l9XG4vLyBoYXZlIG1vcmUgdGhhbiBvbmUgYWx0ZXJuYXRpdmUgYW5kIGFsbCB7QGNvZGUgQV9pfSBhcmUgdGhlIHNhbWUuIElmXG4vLyB7QGNvZGUgQT17ezEsMn0sIHsxLDN9fX0sIHRoZW4gcmVndWxhciBMTCBwcmVkaWN0aW9uIHdvdWxkIHRlcm1pbmF0ZVxuLy8gYmVjYXVzZSB0aGUgcmVzb2x2ZWQgc2V0IGlzIHtAY29kZSB7MX19LiBUbyBkZXRlcm1pbmUgd2hhdCB0aGUgcmVhbFxuLy8gYW1iaWd1aXR5IGlzLCB3ZSBoYXZlIHRvIGtub3cgd2hldGhlciB0aGUgYW1iaWd1aXR5IGlzIGJldHdlZW4gb25lIGFuZFxuLy8gdHdvIG9yIG9uZSBhbmQgdGhyZWUgc28gd2Uga2VlcCBnb2luZy4gV2UgY2FuIG9ubHkgc3RvcCBwcmVkaWN0aW9uIHdoZW5cbi8vIHdlIG5lZWQgZXhhY3QgYW1iaWd1aXR5IGRldGVjdGlvbiB3aGVuIHRoZSBzZXRzIGxvb2sgbGlrZVxuLy8ge0Bjb2RlIEE9e3sxLDJ9fX0gb3Ige0Bjb2RlIHt7MSwyfSx7MSwyfX19LCBldGMuLi48L3A+XG4vL1xuUHJlZGljdGlvbk1vZGUucmVzb2x2ZXNUb0p1c3RPbmVWaWFibGVBbHQgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgcmV0dXJuIFByZWRpY3Rpb25Nb2RlLmdldFNpbmdsZVZpYWJsZUFsdChhbHRzZXRzKTtcbn07XG5cbi8vXG4vLyBEZXRlcm1pbmVzIGlmIGV2ZXJ5IGFsdGVybmF0aXZlIHN1YnNldCBpbiB7QGNvZGUgYWx0c2V0c30gY29udGFpbnMgbW9yZVxuLy8gdGhhbiBvbmUgYWx0ZXJuYXRpdmUuXG4vL1xuLy8gQHBhcmFtIGFsdHNldHMgYSBjb2xsZWN0aW9uIG9mIGFsdGVybmF0aXZlIHN1YnNldHNcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGV2ZXJ5IHtAbGluayBCaXRTZXR9IGluIHtAY29kZSBhbHRzZXRzfSBoYXNcbi8vIHtAbGluayBCaXRTZXQvL2NhcmRpbmFsaXR5IGNhcmRpbmFsaXR5fSAmZ3Q7IDEsIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9XG4vL1xuUHJlZGljdGlvbk1vZGUuYWxsU3Vic2V0c0NvbmZsaWN0ID0gZnVuY3Rpb24oYWx0c2V0cykge1xuICAgIHJldHVybiAhIFByZWRpY3Rpb25Nb2RlLmhhc05vbkNvbmZsaWN0aW5nQWx0U2V0KGFsdHNldHMpO1xufTtcbi8vXG4vLyBEZXRlcm1pbmVzIGlmIGFueSBzaW5nbGUgYWx0ZXJuYXRpdmUgc3Vic2V0IGluIHtAY29kZSBhbHRzZXRzfSBjb250YWluc1xuLy8gZXhhY3RseSBvbmUgYWx0ZXJuYXRpdmUuXG4vL1xuLy8gQHBhcmFtIGFsdHNldHMgYSBjb2xsZWN0aW9uIG9mIGFsdGVybmF0aXZlIHN1YnNldHNcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIHtAY29kZSBhbHRzZXRzfSBjb250YWlucyBhIHtAbGluayBCaXRTZXR9IHdpdGhcbi8vIHtAbGluayBCaXRTZXQvL2NhcmRpbmFsaXR5IGNhcmRpbmFsaXR5fSAxLCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuLy9cblByZWRpY3Rpb25Nb2RlLmhhc05vbkNvbmZsaWN0aW5nQWx0U2V0ID0gZnVuY3Rpb24oYWx0c2V0cykge1xuXHRmb3IodmFyIGk9MDtpPGFsdHNldHMubGVuZ3RoO2krKykge1xuXHRcdHZhciBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgaWYgKGFsdHMubGVuZ3RoPT09MSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8vXG4vLyBEZXRlcm1pbmVzIGlmIGFueSBzaW5nbGUgYWx0ZXJuYXRpdmUgc3Vic2V0IGluIHtAY29kZSBhbHRzZXRzfSBjb250YWluc1xuLy8gbW9yZSB0aGFuIG9uZSBhbHRlcm5hdGl2ZS5cbi8vXG4vLyBAcGFyYW0gYWx0c2V0cyBhIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgc3Vic2V0c1xuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYge0Bjb2RlIGFsdHNldHN9IGNvbnRhaW5zIGEge0BsaW5rIEJpdFNldH0gd2l0aFxuLy8ge0BsaW5rIEJpdFNldC8vY2FyZGluYWxpdHkgY2FyZGluYWxpdHl9ICZndDsgMSwgb3RoZXJ3aXNlIHtAY29kZSBmYWxzZX1cbi8vXG5QcmVkaWN0aW9uTW9kZS5oYXNDb25mbGljdGluZ0FsdFNldCA9IGZ1bmN0aW9uKGFsdHNldHMpIHtcblx0Zm9yKHZhciBpPTA7aTxhbHRzZXRzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgYWx0cyA9IGFsdHNldHNbaV07XG4gICAgICAgIGlmIChhbHRzLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXHR9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy9cbi8vIERldGVybWluZXMgaWYgZXZlcnkgYWx0ZXJuYXRpdmUgc3Vic2V0IGluIHtAY29kZSBhbHRzZXRzfSBpcyBlcXVpdmFsZW50LlxuLy9cbi8vIEBwYXJhbSBhbHRzZXRzIGEgY29sbGVjdGlvbiBvZiBhbHRlcm5hdGl2ZSBzdWJzZXRzXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiBldmVyeSBtZW1iZXIgb2Yge0Bjb2RlIGFsdHNldHN9IGlzIGVxdWFsIHRvIHRoZVxuLy8gb3RoZXJzLCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuLy9cblByZWRpY3Rpb25Nb2RlLmFsbFN1YnNldHNFcXVhbCA9IGZ1bmN0aW9uKGFsdHNldHMpIHtcbiAgICB2YXIgZmlyc3QgPSBudWxsO1xuXHRmb3IodmFyIGk9MDtpPGFsdHNldHMubGVuZ3RoO2krKykge1xuXHRcdHZhciBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgaWYgKGZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBmaXJzdCA9IGFsdHM7XG4gICAgICAgIH0gZWxzZSBpZiAoYWx0cyE9PWZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy9cbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBhbHRlcm5hdGl2ZSBwcmVkaWN0ZWQgYnkgYWxsIGFsdGVybmF0aXZlIHN1YnNldHMgaW5cbi8vIHtAY29kZSBhbHRzZXRzfS4gSWYgbm8gc3VjaCBhbHRlcm5hdGl2ZSBleGlzdHMsIHRoaXMgbWV0aG9kIHJldHVybnNcbi8vIHtAbGluayBBVE4vL0lOVkFMSURfQUxUX05VTUJFUn0uXG4vL1xuLy8gQHBhcmFtIGFsdHNldHMgYSBjb2xsZWN0aW9uIG9mIGFsdGVybmF0aXZlIHN1YnNldHNcbi8vXG5QcmVkaWN0aW9uTW9kZS5nZXRVbmlxdWVBbHQgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgdmFyIGFsbCA9IFByZWRpY3Rpb25Nb2RlLmdldEFsdHMoYWx0c2V0cyk7XG4gICAgaWYgKGFsbC5sZW5ndGg9PT0xKSB7XG4gICAgICAgIHJldHVybiBhbGwubWluVmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICB9XG59O1xuXG4vLyBHZXRzIHRoZSBjb21wbGV0ZSBzZXQgb2YgcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmVzIGZvciBhIGNvbGxlY3Rpb24gb2Zcbi8vIGFsdGVybmF0aXZlIHN1YnNldHMuIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHVuaW9uIG9mIGVhY2gge0BsaW5rIEJpdFNldH1cbi8vIGluIHtAY29kZSBhbHRzZXRzfS5cbi8vXG4vLyBAcGFyYW0gYWx0c2V0cyBhIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgc3Vic2V0c1xuLy8gQHJldHVybiB0aGUgc2V0IG9mIHJlcHJlc2VudGVkIGFsdGVybmF0aXZlcyBpbiB7QGNvZGUgYWx0c2V0c31cbi8vXG5QcmVkaWN0aW9uTW9kZS5nZXRBbHRzID0gZnVuY3Rpb24oYWx0c2V0cykge1xuICAgIHZhciBhbGwgPSBuZXcgQml0U2V0KCk7XG4gICAgYWx0c2V0cy5tYXAoIGZ1bmN0aW9uKGFsdHMpIHsgYWxsLm9yKGFsdHMpOyB9KTtcbiAgICByZXR1cm4gYWxsO1xufTtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgY29uZmxpY3RpbmcgYWx0IHN1YnNldHMgZnJvbSBhIGNvbmZpZ3VyYXRpb24gc2V0LlxuLy8gRm9yIGVhY2ggY29uZmlndXJhdGlvbiB7QGNvZGUgY30gaW4ge0Bjb2RlIGNvbmZpZ3N9OlxuLy9cbi8vIDxwcmU+XG4vLyBtYXBbY10gVT0gYy57QGxpbmsgQVROQ29uZmlnLy9hbHQgYWx0fSAvLyBtYXAgaGFzaC9lcXVhbHMgdXNlcyBzIGFuZCB4LCBub3Rcbi8vIGFsdCBhbmQgbm90IHByZWRcbi8vIDwvcHJlPlxuXG5QcmVkaWN0aW9uTW9kZS5nZXRDb25mbGljdGluZ0FsdFN1YnNldHMgPSBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIGNvbmZpZ1RvQWx0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25maWdUb0FsdHMuaGFzaEZ1bmN0aW9uID0gZnVuY3Rpb24oY2ZnKSB7IGhhc2hTdHVmZihjZmcuc3RhdGUuc3RhdGVOdW1iZXIsIGNmZy5jb250ZXh0KTsgfTtcbiAgICBjb25maWdUb0FsdHMuZXF1YWxzRnVuY3Rpb24gPSBmdW5jdGlvbihjMSwgYzIpIHsgcmV0dXJuIGMxLnN0YXRlLnN0YXRlTnVtYmVyPT1jMi5zdGF0ZS5zdGF0ZU51bWJlciAmJiBjMS5jb250ZXh0LmVxdWFscyhjMi5jb250ZXh0KTt9XG4gICAgY29uZmlncy5pdGVtcy5tYXAoZnVuY3Rpb24oY2ZnKSB7XG4gICAgICAgIHZhciBhbHRzID0gY29uZmlnVG9BbHRzLmdldChjZmcpO1xuICAgICAgICBpZiAoYWx0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0cyA9IG5ldyBCaXRTZXQoKTtcbiAgICAgICAgICAgIGNvbmZpZ1RvQWx0cy5wdXQoY2ZnLCBhbHRzKTtcbiAgICAgICAgfVxuICAgICAgICBhbHRzLmFkZChjZmcuYWx0KTtcblx0fSk7XG4gICAgcmV0dXJuIGNvbmZpZ1RvQWx0cy5nZXRWYWx1ZXMoKTtcbn07XG5cbi8vXG4vLyBHZXQgYSBtYXAgZnJvbSBzdGF0ZSB0byBhbHQgc3Vic2V0IGZyb20gYSBjb25maWd1cmF0aW9uIHNldC4gRm9yIGVhY2hcbi8vIGNvbmZpZ3VyYXRpb24ge0Bjb2RlIGN9IGluIHtAY29kZSBjb25maWdzfTpcbi8vXG4vLyA8cHJlPlxuLy8gbWFwW2Mue0BsaW5rIEFUTkNvbmZpZy8vc3RhdGUgc3RhdGV9XSBVPSBjLntAbGluayBBVE5Db25maWcvL2FsdCBhbHR9XG4vLyA8L3ByZT5cbi8vXG5QcmVkaWN0aW9uTW9kZS5nZXRTdGF0ZVRvQWx0TWFwID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciBtID0gbmV3IEFsdERpY3QoKTtcbiAgICBjb25maWdzLml0ZW1zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBhbHRzID0gbS5nZXQoYy5zdGF0ZSk7XG4gICAgICAgIGlmIChhbHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRzID0gbmV3IEJpdFNldCgpO1xuICAgICAgICAgICAgbS5wdXQoYy5zdGF0ZSwgYWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYWx0cy5hZGQoYy5hbHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBtO1xufTtcblxuUHJlZGljdGlvbk1vZGUuaGFzU3RhdGVBc3NvY2lhdGVkV2l0aE9uZUFsdCA9IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICB2YXIgdmFsdWVzID0gUHJlZGljdGlvbk1vZGUuZ2V0U3RhdGVUb0FsdE1hcChjb25maWdzKS52YWx1ZXMoKTtcbiAgICBmb3IodmFyIGk9MDtpPHZhbHVlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaV0ubGVuZ3RoPT09MSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJlZGljdGlvbk1vZGUuZ2V0U2luZ2xlVmlhYmxlQWx0ID0gZnVuY3Rpb24oYWx0c2V0cykge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXHRmb3IodmFyIGk9MDtpPGFsdHNldHMubGVuZ3RoO2krKykge1xuXHRcdHZhciBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgdmFyIG1pbkFsdCA9IGFsdHMubWluVmFsdWUoKTtcbiAgICAgICAgaWYocmVzdWx0PT09bnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWluQWx0O1xuICAgICAgICB9IGVsc2UgaWYocmVzdWx0IT09bWluQWx0KSB7IC8vIG1vcmUgdGhhbiAxIHZpYWJsZSBhbHRcbiAgICAgICAgICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG5cdH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5QcmVkaWN0aW9uTW9kZSA9IFByZWRpY3Rpb25Nb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9QcmVkaWN0aW9uTW9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2NvZGVwb2ludGF0IHYwLjIuMCBieSBAbWF0aGlhcyAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KSB7XG5cdChmdW5jdGlvbigpIHtcblx0XHQndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXG5cdFx0dmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSUUgOCBvbmx5IHN1cHBvcnRzIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9uIERPTSBlbGVtZW50c1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHR2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgb2JqZWN0LCBvYmplY3QpICYmICRkZWZpbmVQcm9wZXJ0eTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHt9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0oKSk7XG5cdFx0dmFyIGNvZGVQb2ludEF0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdGlmICh0aGlzID09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuXHRcdFx0dmFyIHNpemUgPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0Ly8gYFRvSW50ZWdlcmBcblx0XHRcdHZhciBpbmRleCA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG5cdFx0XHRpZiAoaW5kZXggIT0gaW5kZXgpIHsgLy8gYmV0dGVyIGBpc05hTmBcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWNjb3VudCBmb3Igb3V0LW9mLWJvdW5kcyBpbmRpY2VzOlxuXHRcdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBHZXQgdGhlIGZpcnN0IGNvZGUgdW5pdFxuXHRcdFx0dmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0dmFyIHNlY29uZDtcblx0XHRcdGlmICggLy8gY2hlY2sgaWYgaXTigJlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgLy8gaGlnaCBzdXJyb2dhdGVcblx0XHRcdFx0c2l6ZSA+IGluZGV4ICsgMSAvLyB0aGVyZSBpcyBhIG5leHQgY29kZSB1bml0XG5cdFx0XHQpIHtcblx0XHRcdFx0c2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblx0XHRcdFx0aWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdFx0cmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmaXJzdDtcblx0XHR9O1xuXHRcdGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ2NvZGVQb2ludEF0Jywge1xuXHRcdFx0XHQndmFsdWUnOiBjb2RlUG9pbnRBdCxcblx0XHRcdFx0J2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdFx0XHRcdCd3cml0YWJsZSc6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG5cdFx0fVxuXHR9KCkpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L3BvbHlmaWxscy9jb2RlcG9pbnRhdC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4xIGJ5IEBtYXRoaWFzICovXG5pZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG5cdChmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJRSA4IG9ubHkgc3VwcG9ydHMgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgb24gRE9NIGVsZW1lbnRzXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHRcdHZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdFx0XHRcdHZhciByZXN1bHQgPSAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBvYmplY3QsIG9iamVjdCkgJiYgJGRlZmluZVByb3BlcnR5O1xuXHRcdFx0fSBjYXRjaChlcnJvcikge31cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSgpKTtcblx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0XHR2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXHRcdHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24oXykge1xuXHRcdFx0dmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuXHRcdFx0dmFyIGNvZGVVbml0cyA9IFtdO1xuXHRcdFx0dmFyIGhpZ2hTdXJyb2dhdGU7XG5cdFx0XHR2YXIgbG93U3Vycm9nYXRlO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGlmICghbGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG5cdFx0XHRcdFx0Y29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdFx0XHRjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdFx0XHRmbG9vcihjb2RlUG9pbnQpICE9IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7IC8vIEJNUCBjb2RlIHBvaW50XG5cdFx0XHRcdFx0Y29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcblx0XHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0XHRjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0XHRcdFx0XHRoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDA7XG5cdFx0XHRcdFx0bG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4REMwMDtcblx0XHRcdFx0XHRjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbmRleCArIDEgPT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcblx0XHRcdFx0XHRjb2RlVW5pdHMubGVuZ3RoID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcblx0XHRcdFx0J3ZhbHVlJzogZnJvbUNvZGVQb2ludCxcblx0XHRcdFx0J2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdFx0XHRcdCd3cml0YWJsZSc6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRTdHJpbmcuZnJvbUNvZGVQb2ludCA9IGZyb21Db2RlUG9pbnQ7XG5cdFx0fVxuXHR9KCkpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L3BvbHlmaWxscy9mcm9tY29kZXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLy4uL1Rva2VuJykuVG9rZW47XG52YXIgRXJyb3JzID0gcmVxdWlyZSgnLi9FcnJvcnMnKTtcbnZhciBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IEVycm9ycy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbnZhciBJbnB1dE1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3JzLklucHV0TWlzbWF0Y2hFeGNlcHRpb247XG52YXIgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uID0gRXJyb3JzLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjtcbnZhciBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbiA9IEVycm9ycy5QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbjtcbnZhciBBVE5TdGF0ZSA9IHJlcXVpcmUoJy4vLi4vYXRuL0FUTlN0YXRlJykuQVROU3RhdGU7XG52YXIgSW50ZXJ2YWwgPSByZXF1aXJlKCcuLy4uL0ludGVydmFsU2V0JykuSW50ZXJ2YWw7XG52YXIgSW50ZXJ2YWxTZXQgPSByZXF1aXJlKCcuLy4uL0ludGVydmFsU2V0JykuSW50ZXJ2YWxTZXQ7XG5cbmZ1bmN0aW9uIEVycm9yU3RyYXRlZ3koKSB7XG5cbn1cblxuRXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihyZWNvZ25pemVyKXtcbn07XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlY292ZXJJbmxpbmUgPSBmdW5jdGlvbihyZWNvZ25pemVyKXtcbn07XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlY292ZXIgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKXtcbn07XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbihyZWNvZ25pemVyKXtcbn07XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmluRXJyb3JSZWNvdmVyeU1vZGUgPSBmdW5jdGlvbihyZWNvZ25pemVyKXtcbn07XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24ocmVjb2duaXplcil7XG59O1xuXG5cblxuLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5fSB1c2VkIGZvclxuLy8gZXJyb3IgcmVwb3J0aW5nIGFuZCByZWNvdmVyeSBpbiBBTlRMUiBwYXJzZXJzLlxuLy9cbmZ1bmN0aW9uIERlZmF1bHRFcnJvclN0cmF0ZWd5KCkge1xuXHRFcnJvclN0cmF0ZWd5LmNhbGwodGhpcyk7XG4gICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVycm9yIHN0cmF0ZWd5IGlzIGN1cnJlbnRseSBcInJlY292ZXJpbmcgZnJvbSBhblxuICAgIC8vIGVycm9yXCIuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyByZXBvcnRpbmcgbXVsdGlwbGUgZXJyb3IgbWVzc2FnZXMgd2hpbGVcbiAgICAvLyBhdHRlbXB0aW5nIHRvIHJlY292ZXIgZnJvbSBhIGRldGVjdGVkIHN5bnRheCBlcnJvci5cbiAgICAvL1xuICAgIC8vIEBzZWUgLy9pbkVycm9yUmVjb3ZlcnlNb2RlXG4gICAgLy9cbiAgICB0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gZmFsc2U7XG5cbiAgICAvLyBUaGUgaW5kZXggaW50byB0aGUgaW5wdXQgc3RyZWFtIHdoZXJlIHRoZSBsYXN0IGVycm9yIG9jY3VycmVkLlxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdoZXJlIGFuIGVycm9yIGlzIGZvdW5kXG4gICAgLy8gYnV0IG5vIHRva2VuIGlzIGNvbnN1bWVkIGR1cmluZyByZWNvdmVyeS4uLmFub3RoZXIgZXJyb3IgaXMgZm91bmQsXG4gICAgLy8gYWQgbmF1c2V1bS4gVGhpcyBpcyBhIGZhaWxzYWZlIG1lY2hhbmlzbSB0byBndWFyYW50ZWUgdGhhdCBhdCBsZWFzdFxuICAgIC8vIG9uZSB0b2tlbi90cmVlIG5vZGUgaXMgY29uc3VtZWQgZm9yIHR3byBlcnJvcnMuXG4gICAgLy9cbiAgICB0aGlzLmxhc3RFcnJvckluZGV4ID0gLTE7XG4gICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yU3RyYXRlZ3kucHJvdG90eXBlKTtcbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlZmF1bHRFcnJvclN0cmF0ZWd5O1xuXG4vLyA8cD5UaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgY2FsbHMge0BsaW5rIC8vZW5kRXJyb3JDb25kaXRpb259IHRvXG4vLyBlbnN1cmUgdGhhdCB0aGUgaGFuZGxlciBpcyBub3QgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS48L3A+XG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdGhpcy5lbmRFcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbn07XG5cbi8vXG4vLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gZW50ZXIgZXJyb3IgcmVjb3ZlcnkgbW9kZSB3aGVuIGEgcmVjb2duaXRpb25cbi8vIGV4Y2VwdGlvbiBpcyByZXBvcnRlZC5cbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmJlZ2luRXJyb3JDb25kaXRpb24gPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IHRydWU7XG59O1xuXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuaW5FcnJvclJlY292ZXJ5TW9kZSA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvclJlY292ZXJ5TW9kZTtcbn07XG5cbi8vXG4vLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gbGVhdmUgZXJyb3IgcmVjb3ZlcnkgbW9kZSBhZnRlciByZWNvdmVyaW5nIGZyb21cbi8vIGEgcmVjb2duaXRpb24gZXhjZXB0aW9uLlxuLy9cbi8vIEBwYXJhbSByZWNvZ25pemVyXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmVuZEVycm9yQ29uZGl0aW9uID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHRoaXMuZXJyb3JSZWNvdmVyeU1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RFcnJvclN0YXRlcyA9IG51bGw7XG4gICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xufTtcblxuLy9cbi8vIHtAaW5oZXJpdERvY31cbi8vXG4vLyA8cD5UaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgY2FsbHMge0BsaW5rIC8vZW5kRXJyb3JDb25kaXRpb259LjwvcD5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVwb3J0TWF0Y2ggPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdGhpcy5lbmRFcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbn07XG5cbi8vXG4vLyB7QGluaGVyaXREb2N9XG4vL1xuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBpbW1lZGlhdGVseSBpZiB0aGUgaGFuZGxlciBpcyBhbHJlYWR5XG4vLyBpbiBlcnJvciByZWNvdmVyeSBtb2RlLiBPdGhlcndpc2UsIGl0IGNhbGxzIHtAbGluayAvL2JlZ2luRXJyb3JDb25kaXRpb259XG4vLyBhbmQgZGlzcGF0Y2hlcyB0aGUgcmVwb3J0aW5nIHRhc2sgYmFzZWQgb24gdGhlIHJ1bnRpbWUgdHlwZSBvZiB7QGNvZGUgZX1cbi8vIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHRhYmxlLjwvcD5cbi8vXG4vLyA8dWw+XG4vLyA8bGk+e0BsaW5rIE5vVmlhYmxlQWx0RXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xuLy8ge0BsaW5rIC8vcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZX08L2xpPlxuLy8gPGxpPntAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xuLy8ge0BsaW5rIC8vcmVwb3J0SW5wdXRNaXNtYXRjaH08L2xpPlxuLy8gPGxpPntAbGluayBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb259OiBEaXNwYXRjaGVzIHRoZSBjYWxsIHRvXG4vLyB7QGxpbmsgLy9yZXBvcnRGYWlsZWRQcmVkaWNhdGV9PC9saT5cbi8vIDxsaT5BbGwgb3RoZXIgdHlwZXM6IGNhbGxzIHtAbGluayBQYXJzZXIvL25vdGlmeUVycm9yTGlzdGVuZXJzfSB0byByZXBvcnRcbi8vIHRoZSBleGNlcHRpb248L2xpPlxuLy8gPC91bD5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKSB7XG4gICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHJlcG9ydGVkIGFuIGVycm9yIGFuZCBoYXZlIG5vdCBtYXRjaGVkIGEgdG9rZW5cbiAgIC8vIHlldCBzdWNjZXNzZnVsbHksIGRvbid0IHJlcG9ydCBhbnkgZXJyb3JzLlxuICAgIGlmKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xuICAgICAgICByZXR1cm47IC8vIGRvbid0IHJlcG9ydCBzcHVyaW91cyBlcnJvcnNcbiAgICB9XG4gICAgdGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgIGlmICggZSBpbnN0YW5jZW9mIE5vVmlhYmxlQWx0RXhjZXB0aW9uICkge1xuICAgICAgICB0aGlzLnJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUocmVjb2duaXplciwgZSk7XG4gICAgfSBlbHNlIGlmICggZSBpbnN0YW5jZW9mIElucHV0TWlzbWF0Y2hFeGNlcHRpb24gKSB7XG4gICAgICAgIHRoaXMucmVwb3J0SW5wdXRNaXNtYXRjaChyZWNvZ25pemVyLCBlKTtcbiAgICB9IGVsc2UgaWYgKCBlIGluc3RhbmNlb2YgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uICkge1xuICAgICAgICB0aGlzLnJlcG9ydEZhaWxlZFByZWRpY2F0ZShyZWNvZ25pemVyLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcInVua25vd24gcmVjb2duaXRpb24gZXJyb3IgdHlwZTogXCIgKyBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhlLmdldE9mZmVuZGluZ1Rva2VuKCksIGUuZ2V0TWVzc2FnZSgpLCBlKTtcbiAgICB9XG59O1xuLy9cbi8vIHtAaW5oZXJpdERvY31cbi8vXG4vLyA8cD5UaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXN5bmNocm9uaXplcyB0aGUgcGFyc2VyIGJ5IGNvbnN1bWluZyB0b2tlbnNcbi8vIHVudGlsIHdlIGZpbmQgb25lIGluIHRoZSByZXN5bmNocm9uaXphdGlvbiBzZXQtLWxvb3NlbHkgdGhlIHNldCBvZiB0b2tlbnNcbi8vIHRoYXQgY2FuIGZvbGxvdyB0aGUgY3VycmVudCBydWxlLjwvcD5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVjb3ZlciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGUpIHtcbiAgICBpZiAodGhpcy5sYXN0RXJyb3JJbmRleD09PXJlY29nbml6ZXIuZ2V0SW5wdXRTdHJlYW0oKS5pbmRleCAmJlxuICAgICAgICB0aGlzLmxhc3RFcnJvclN0YXRlcyAhPT0gbnVsbCAmJiB0aGlzLmxhc3RFcnJvclN0YXRlcy5pbmRleE9mKHJlY29nbml6ZXIuc3RhdGUpPj0wKSB7XG5cdFx0Ly8gdWggb2gsIGFub3RoZXIgZXJyb3IgYXQgc2FtZSB0b2tlbiBpbmRleCBhbmQgcHJldmlvdXNseS12aXNpdGVkXG5cdFx0Ly8gc3RhdGUgaW4gQVROOyBtdXN0IGJlIGEgY2FzZSB3aGVyZSBMVCgxKSBpcyBpbiB0aGUgcmVjb3Zlcnlcblx0XHQvLyB0b2tlbiBzZXQgc28gbm90aGluZyBnb3QgY29uc3VtZWQuIENvbnN1bWUgYSBzaW5nbGUgdG9rZW5cblx0XHQvLyBhdCBsZWFzdCB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3A7IHRoaXMgaXMgYSBmYWlsc2FmZS5cblx0XHRyZWNvZ25pemVyLmNvbnN1bWUoKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IHJlY29nbml6ZXIuX2lucHV0LmluZGV4O1xuICAgIGlmICh0aGlzLmxhc3RFcnJvclN0YXRlcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxhc3RFcnJvclN0YXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmxhc3RFcnJvclN0YXRlcy5wdXNoKHJlY29nbml6ZXIuc3RhdGUpO1xuICAgIHZhciBmb2xsb3dTZXQgPSB0aGlzLmdldEVycm9yUmVjb3ZlcnlTZXQocmVjb2duaXplcik7XG4gICAgdGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgZm9sbG93U2V0KTtcbn07XG5cbi8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kvL3N5bmN9IG1ha2VzIHN1cmVcbi8vIHRoYXQgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHN5bWJvbCBpcyBjb25zaXN0ZW50IHdpdGggd2hhdCB3ZXJlIGV4cGVjdGluZ1xuLy8gYXQgdGhpcyBwb2ludCBpbiB0aGUgQVROLiBZb3UgY2FuIGNhbGwgdGhpcyBhbnl0aW1lIGJ1dCBBTlRMUiBvbmx5XG4vLyBnZW5lcmF0ZXMgY29kZSB0byBjaGVjayBiZWZvcmUgc3VicnVsZXMvbG9vcHMgYW5kIGVhY2ggaXRlcmF0aW9uLlxuLy9cbi8vIDxwPkltcGxlbWVudHMgSmltIElkbGUncyBtYWdpYyBzeW5jIG1lY2hhbmlzbSBpbiBjbG9zdXJlcyBhbmQgb3B0aW9uYWxcbi8vIHN1YnJ1bGVzLiBFLmcuLDwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gYSA6IHN5bmMgKCBzdHVmZiBzeW5jICkqIDtcbi8vIHN5bmMgOiB7Y29uc3VtZSB0byB3aGF0IGNhbiBmb2xsb3cgc3luY30gO1xuLy8gPC9wcmU+XG4vL1xuLy8gQXQgdGhlIHN0YXJ0IG9mIGEgc3ViIHJ1bGUgdXBvbiBlcnJvciwge0BsaW5rIC8vc3luY30gcGVyZm9ybXMgc2luZ2xlXG4vLyB0b2tlbiBkZWxldGlvbiwgaWYgcG9zc2libGUuIElmIGl0IGNhbid0IGRvIHRoYXQsIGl0IGJhaWxzIG9uIHRoZSBjdXJyZW50XG4vLyBydWxlIGFuZCB1c2VzIHRoZSBkZWZhdWx0IGVycm9yIHJlY292ZXJ5LCB3aGljaCBjb25zdW1lcyB1bnRpbCB0aGVcbi8vIHJlc3luY2hyb25pemF0aW9uIHNldCBvZiB0aGUgY3VycmVudCBydWxlLlxuLy9cbi8vIDxwPklmIHRoZSBzdWIgcnVsZSBpcyBvcHRpb25hbCAoe0Bjb2RlICguLi4pP30sIHtAY29kZSAoLi4uKSp9LCBvciBibG9ja1xuLy8gd2l0aCBhbiBlbXB0eSBhbHRlcm5hdGl2ZSksIHRoZW4gdGhlIGV4cGVjdGVkIHNldCBpbmNsdWRlcyB3aGF0IGZvbGxvd3Ncbi8vIHRoZSBzdWJydWxlLjwvcD5cbi8vXG4vLyA8cD5EdXJpbmcgbG9vcCBpdGVyYXRpb24sIGl0IGNvbnN1bWVzIHVudGlsIGl0IHNlZXMgYSB0b2tlbiB0aGF0IGNhbiBzdGFydCBhXG4vLyBzdWIgcnVsZSBvciB3aGF0IGZvbGxvd3MgbG9vcC4gWWVzLCB0aGF0IGlzIHByZXR0eSBhZ2dyZXNzaXZlLiBXZSBvcHQgdG9cbi8vIHN0YXkgaW4gdGhlIGxvb3AgYXMgbG9uZyBhcyBwb3NzaWJsZS48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5PUklHSU5TPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlByZXZpb3VzIHZlcnNpb25zIG9mIEFOVExSIGRpZCBhIHBvb3Igam9iIG9mIHRoZWlyIHJlY292ZXJ5IHdpdGhpbiBsb29wcy5cbi8vIEEgc2luZ2xlIG1pc21hdGNoIHRva2VuIG9yIG1pc3NpbmcgdG9rZW4gd291bGQgZm9yY2UgdGhlIHBhcnNlciB0byBiYWlsXG4vLyBvdXQgb2YgdGhlIGVudGlyZSBydWxlcyBzdXJyb3VuZGluZyB0aGUgbG9vcC4gU28sIGZvciBydWxlPC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBjbGFzc0RlZiA6ICdjbGFzcycgSUQgJ3snIG1lbWJlciogJ30nXG4vLyA8L3ByZT5cbi8vXG4vLyBpbnB1dCB3aXRoIGFuIGV4dHJhIHRva2VuIGJldHdlZW4gbWVtYmVycyB3b3VsZCBmb3JjZSB0aGUgcGFyc2VyIHRvXG4vLyBjb25zdW1lIHVudGlsIGl0IGZvdW5kIHRoZSBuZXh0IGNsYXNzIGRlZmluaXRpb24gcmF0aGVyIHRoYW4gdGhlIG5leHRcbi8vIG1lbWJlciBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IGNsYXNzLlxuLy9cbi8vIDxwPlRoaXMgZnVuY3Rpb25hbGl0eSBjb3N0IGEgbGl0dGxlIGJpdCBvZiBlZmZvcnQgYmVjYXVzZSB0aGUgcGFyc2VyIGhhcyB0b1xuLy8gY29tcGFyZSB0b2tlbiBzZXQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCBhdCBlYWNoIGl0ZXJhdGlvbi4gSWYgZm9yXG4vLyBzb21lIHJlYXNvbiBzcGVlZCBpcyBzdWZmZXJpbmcgZm9yIHlvdSwgeW91IGNhbiB0dXJuIG9mZiB0aGlzXG4vLyBmdW5jdGlvbmFsaXR5IGJ5IHNpbXBseSBvdmVycmlkaW5nIHRoaXMgbWV0aG9kIGFzIGEgYmxhbmsgeyB9LjwvcD5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAvLyBJZiBhbHJlYWR5IHJlY292ZXJpbmcsIGRvbid0IHRyeSB0byBzeW5jXG4gICAgaWYgKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzID0gcmVjb2duaXplci5faW50ZXJwLmF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XG4gICAgdmFyIGxhID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDEpO1xuICAgIC8vIHRyeSBjaGVhcGVyIHN1YnNldCBmaXJzdDsgbWlnaHQgZ2V0IGx1Y2t5LiBzZWVtcyB0byBzaGF2ZSBhIHdlZSBiaXQgb2ZmXG4gICAgdmFyIG5leHRUb2tlbnMgPSByZWNvZ25pemVyLmF0bi5uZXh0VG9rZW5zKHMpO1xuICAgIGlmIChuZXh0VG9rZW5zLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pIHx8IG5leHRUb2tlbnMuY29udGFpbnMobGEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChzLnN0YXRlVHlwZSkge1xuICAgIGNhc2UgQVROU3RhdGUuQkxPQ0tfU1RBUlQ6XG4gICAgY2FzZSBBVE5TdGF0ZS5TVEFSX0JMT0NLX1NUQVJUOlxuICAgIGNhc2UgQVROU3RhdGUuUExVU19CTE9DS19TVEFSVDpcbiAgICBjYXNlIEFUTlN0YXRlLlNUQVJfTE9PUF9FTlRSWTpcbiAgICAgICAvLyByZXBvcnQgZXJyb3IgYW5kIHJlY292ZXIgaWYgcG9zc2libGVcbiAgICAgICAgaWYoIHRoaXMuc2luZ2xlVG9rZW5EZWxldGlvbihyZWNvZ25pemVyKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBBVE5TdGF0ZS5QTFVTX0xPT1BfQkFDSzpcbiAgICBjYXNlIEFUTlN0YXRlLlNUQVJfTE9PUF9CQUNLOlxuICAgICAgICB0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgIHZhciBleHBlY3RpbmcgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgZXhwZWN0aW5nLmFkZFNldChyZWNvZ25pemVyLmdldEV4cGVjdGVkVG9rZW5zKCkpO1xuICAgICAgICB2YXIgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlID0gZXhwZWN0aW5nLmFkZFNldCh0aGlzLmdldEVycm9yUmVjb3ZlcnlTZXQocmVjb2duaXplcikpO1xuICAgICAgICB0aGlzLmNvbnN1bWVVbnRpbChyZWNvZ25pemVyLCB3aGF0Rm9sbG93c0xvb3BJdGVyYXRpb25PclJ1bGUpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHdlIGNhbid0IGlkZW50aWZ5IHRoZSBleGFjdCBraW5kIG9mIEFUTiBzdGF0ZVxuICAgIH1cbn07XG5cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHtAbGluayAvL3JlcG9ydEVycm9yfSB3aGVuIHRoZSBleGNlcHRpb24gaXMgYVxuLy8ge0BsaW5rIE5vVmlhYmxlQWx0RXhjZXB0aW9ufS5cbi8vXG4vLyBAc2VlIC8vcmVwb3J0RXJyb3Jcbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vLyBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKSB7XG4gICAgdmFyIHRva2VucyA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKTtcbiAgICB2YXIgaW5wdXQ7XG4gICAgaWYodG9rZW5zICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChlLnN0YXJ0VG9rZW4udHlwZT09PVRva2VuLkVPRikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIjxFT0Y+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dCA9IHRva2Vucy5nZXRUZXh0KG5ldyBJbnRlcnZhbChlLnN0YXJ0VG9rZW4udG9rZW5JbmRleCwgZS5vZmZlbmRpbmdUb2tlbi50b2tlbkluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dCA9IFwiPHVua25vd24gaW5wdXQ+XCI7XG4gICAgfVxuICAgIHZhciBtc2cgPSBcIm5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBhdCBpbnB1dCBcIiArIHRoaXMuZXNjYXBlV1NBbmRRdW90ZShpbnB1dCk7XG4gICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIGUub2ZmZW5kaW5nVG9rZW4sIGUpO1xufTtcblxuLy9cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHtAbGluayAvL3JlcG9ydEVycm9yfSB3aGVuIHRoZSBleGNlcHRpb24gaXMgYW5cbi8vIHtAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufS5cbi8vXG4vLyBAc2VlIC8vcmVwb3J0RXJyb3Jcbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vLyBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydElucHV0TWlzbWF0Y2ggPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKSB7XG4gICAgdmFyIG1zZyA9IFwibWlzbWF0Y2hlZCBpbnB1dCBcIiArIHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkoZS5vZmZlbmRpbmdUb2tlbikgK1xuICAgICAgICAgIFwiIGV4cGVjdGluZyBcIiArIGUuZ2V0RXhwZWN0ZWRUb2tlbnMoKS50b1N0cmluZyhyZWNvZ25pemVyLmxpdGVyYWxOYW1lcywgcmVjb2duaXplci5zeW1ib2xpY05hbWVzKTtcbiAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgZS5vZmZlbmRpbmdUb2tlbiwgZSk7XG59O1xuXG4vL1xuLy8gVGhpcyBpcyBjYWxsZWQgYnkge0BsaW5rIC8vcmVwb3J0RXJyb3J9IHdoZW4gdGhlIGV4Y2VwdGlvbiBpcyBhXG4vLyB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufS5cbi8vXG4vLyBAc2VlIC8vcmVwb3J0RXJyb3Jcbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vLyBAcGFyYW0gZSB0aGUgcmVjb2duaXRpb24gZXhjZXB0aW9uXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydEZhaWxlZFByZWRpY2F0ZSA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGUpIHtcbiAgICB2YXIgcnVsZU5hbWUgPSByZWNvZ25pemVyLnJ1bGVOYW1lc1tyZWNvZ25pemVyLl9jdHgucnVsZUluZGV4XTtcbiAgICB2YXIgbXNnID0gXCJydWxlIFwiICsgcnVsZU5hbWUgKyBcIiBcIiArIGUubWVzc2FnZTtcbiAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgZS5vZmZlbmRpbmdUb2tlbiwgZSk7XG59O1xuXG4vLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gcmVwb3J0IGEgc3ludGF4IGVycm9yIHdoaWNoIHJlcXVpcmVzIHRoZSByZW1vdmFsXG4vLyBvZiBhIHRva2VuIGZyb20gdGhlIGlucHV0IHN0cmVhbS4gQXQgdGhlIHRpbWUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGVcbi8vIGVycm9uZW91cyBzeW1ib2wgaXMgY3VycmVudCB7QGNvZGUgTFQoMSl9IHN5bWJvbCBhbmQgaGFzIG5vdCB5ZXQgYmVlblxuLy8gcmVtb3ZlZCBmcm9tIHRoZSBpbnB1dCBzdHJlYW0uIFdoZW4gdGhpcyBtZXRob2QgcmV0dXJucyxcbi8vIHtAY29kZSByZWNvZ25pemVyfSBpcyBpbiBlcnJvciByZWNvdmVyeSBtb2RlLlxuLy9cbi8vIDxwPlRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHtAbGluayAvL3NpbmdsZVRva2VuRGVsZXRpb259IGlkZW50aWZpZXNcbi8vIHNpbmdsZS10b2tlbiBkZWxldGlvbiBhcyBhIHZpYWJsZSByZWNvdmVyeSBzdHJhdGVneSBmb3IgYSBtaXNtYXRjaGVkXG4vLyBpbnB1dCBlcnJvci48L3A+XG4vL1xuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeSBpblxuLy8gZXJyb3IgcmVjb3ZlcnkgbW9kZS4gT3RoZXJ3aXNlLCBpdCBjYWxscyB7QGxpbmsgLy9iZWdpbkVycm9yQ29uZGl0aW9ufSB0b1xuLy8gZW50ZXIgZXJyb3IgcmVjb3ZlcnkgbW9kZSwgZm9sbG93ZWQgYnkgY2FsbGluZ1xuLy8ge0BsaW5rIFBhcnNlci8vbm90aWZ5RXJyb3JMaXN0ZW5lcnN9LjwvcD5cbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydFVud2FudGVkVG9rZW4gPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgaWYgKHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICB2YXIgdCA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgdmFyIHRva2VuTmFtZSA9IHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkodCk7XG4gICAgdmFyIGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgdmFyIG1zZyA9IFwiZXh0cmFuZW91cyBpbnB1dCBcIiArIHRva2VuTmFtZSArIFwiIGV4cGVjdGluZyBcIiArXG4gICAgICAgIGV4cGVjdGluZy50b1N0cmluZyhyZWNvZ25pemVyLmxpdGVyYWxOYW1lcywgcmVjb2duaXplci5zeW1ib2xpY05hbWVzKTtcbiAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgdCwgbnVsbCk7XG59O1xuLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIHJlcG9ydCBhIHN5bnRheCBlcnJvciB3aGljaCByZXF1aXJlcyB0aGVcbi8vIGluc2VydGlvbiBvZiBhIG1pc3NpbmcgdG9rZW4gaW50byB0aGUgaW5wdXQgc3RyZWFtLiBBdCB0aGUgdGltZSB0aGlzXG4vLyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgbWlzc2luZyB0b2tlbiBoYXMgbm90IHlldCBiZWVuIGluc2VydGVkLiBXaGVuIHRoaXNcbi8vIG1ldGhvZCByZXR1cm5zLCB7QGNvZGUgcmVjb2duaXplcn0gaXMgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS5cbi8vXG4vLyA8cD5UaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB7QGxpbmsgLy9zaW5nbGVUb2tlbkluc2VydGlvbn0gaWRlbnRpZmllc1xuLy8gc2luZ2xlLXRva2VuIGluc2VydGlvbiBhcyBhIHZpYWJsZSByZWNvdmVyeSBzdHJhdGVneSBmb3IgYSBtaXNtYXRjaGVkXG4vLyBpbnB1dCBlcnJvci48L3A+XG4vL1xuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IHJldHVybnMgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeSBpblxuLy8gZXJyb3IgcmVjb3ZlcnkgbW9kZS4gT3RoZXJ3aXNlLCBpdCBjYWxscyB7QGxpbmsgLy9iZWdpbkVycm9yQ29uZGl0aW9ufSB0b1xuLy8gZW50ZXIgZXJyb3IgcmVjb3ZlcnkgbW9kZSwgZm9sbG93ZWQgYnkgY2FsbGluZ1xuLy8ge0BsaW5rIFBhcnNlci8vbm90aWZ5RXJyb3JMaXN0ZW5lcnN9LjwvcD5cbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplciB0aGUgcGFyc2VyIGluc3RhbmNlXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydE1pc3NpbmdUb2tlbiA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoIHRoaXMuaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICB2YXIgdCA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgdmFyIGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgdmFyIG1zZyA9IFwibWlzc2luZyBcIiArIGV4cGVjdGluZy50b1N0cmluZyhyZWNvZ25pemVyLmxpdGVyYWxOYW1lcywgcmVjb2duaXplci5zeW1ib2xpY05hbWVzKSArXG4gICAgICAgICAgXCIgYXQgXCIgKyB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xuICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnLCB0LCBudWxsKTtcbn07XG5cbi8vIDxwPlRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGF0dGVtcHRzIHRvIHJlY292ZXIgZnJvbSB0aGUgbWlzbWF0Y2hlZCBpbnB1dFxuLy8gYnkgdXNpbmcgc2luZ2xlIHRva2VuIGluc2VydGlvbiBhbmQgZGVsZXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBJZiB0aGVcbi8vIHJlY292ZXJ5IGF0dGVtcHQgZmFpbHMsIHRoaXMgbWV0aG9kIHRocm93cyBhblxuLy8ge0BsaW5rIElucHV0TWlzbWF0Y2hFeGNlcHRpb259LjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPkVYVFJBIFRPS0VOPC9zdHJvbmc+IChzaW5nbGUgdG9rZW4gZGVsZXRpb24pPC9wPlxuLy9cbi8vIDxwPntAY29kZSBMQSgxKX0gaXMgbm90IHdoYXQgd2UgYXJlIGxvb2tpbmcgZm9yLiBJZiB7QGNvZGUgTEEoMil9IGhhcyB0aGVcbi8vIHJpZ2h0IHRva2VuLCBob3dldmVyLCB0aGVuIGFzc3VtZSB7QGNvZGUgTEEoMSl9IGlzIHNvbWUgZXh0cmEgc3B1cmlvdXNcbi8vIHRva2VuIGFuZCBkZWxldGUgaXQuIFRoZW4gY29uc3VtZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHRva2VuICh3aGljaCB3YXNcbi8vIHRoZSB7QGNvZGUgTEEoMil9IHRva2VuKSBhcyB0aGUgc3VjY2Vzc2Z1bCByZXN1bHQgb2YgdGhlIG1hdGNoIG9wZXJhdGlvbi48L3A+XG4vL1xuLy8gPHA+VGhpcyByZWNvdmVyeSBzdHJhdGVneSBpcyBpbXBsZW1lbnRlZCBieSB7QGxpbmtcbi8vIC8vc2luZ2xlVG9rZW5EZWxldGlvbn0uPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+TUlTU0lORyBUT0tFTjwvc3Ryb25nPiAoc2luZ2xlIHRva2VuIGluc2VydGlvbik8L3A+XG4vL1xuLy8gPHA+SWYgY3VycmVudCB0b2tlbiAoYXQge0Bjb2RlIExBKDEpfSkgaXMgY29uc2lzdGVudCB3aXRoIHdoYXQgY291bGQgY29tZVxuLy8gYWZ0ZXIgdGhlIGV4cGVjdGVkIHtAY29kZSBMQSgxKX0gdG9rZW4sIHRoZW4gYXNzdW1lIHRoZSB0b2tlbiBpcyBtaXNzaW5nXG4vLyBhbmQgdXNlIHRoZSBwYXJzZXIncyB7QGxpbmsgVG9rZW5GYWN0b3J5fSB0byBjcmVhdGUgaXQgb24gdGhlIGZseS4gVGhlXG4vLyBcImluc2VydGlvblwiIGlzIHBlcmZvcm1lZCBieSByZXR1cm5pbmcgdGhlIGNyZWF0ZWQgdG9rZW4gYXMgdGhlIHN1Y2Nlc3NmdWxcbi8vIHJlc3VsdCBvZiB0aGUgbWF0Y2ggb3BlcmF0aW9uLjwvcD5cbi8vXG4vLyA8cD5UaGlzIHJlY292ZXJ5IHN0cmF0ZWd5IGlzIGltcGxlbWVudGVkIGJ5IHtAbGlua1xuLy8gLy9zaW5nbGVUb2tlbkluc2VydGlvbn0uPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+RVhBTVBMRTwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5Gb3IgZXhhbXBsZSwgSW5wdXQge0Bjb2RlIGk9KDM7fSBpcyBjbGVhcmx5IG1pc3NpbmcgdGhlIHtAY29kZSAnKSd9LiBXaGVuXG4vLyB0aGUgcGFyc2VyIHJldHVybnMgZnJvbSB0aGUgbmVzdGVkIGNhbGwgdG8ge0Bjb2RlIGV4cHJ9LCBpdCB3aWxsIGhhdmVcbi8vIGNhbGwgY2hhaW46PC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBzdGF0ICZyYXJyOyBleHByICZyYXJyOyBhdG9tXG4vLyA8L3ByZT5cbi8vXG4vLyBhbmQgaXQgd2lsbCBiZSB0cnlpbmcgdG8gbWF0Y2ggdGhlIHtAY29kZSAnKSd9IGF0IHRoaXMgcG9pbnQgaW4gdGhlXG4vLyBkZXJpdmF0aW9uOlxuLy9cbi8vIDxwcmU+XG4vLyA9Jmd0OyBJRCAnPScgJygnIElOVCAnKScgKCcrJyBhdG9tKSogJzsnXG4vLyBeXG4vLyA8L3ByZT5cbi8vXG4vLyBUaGUgYXR0ZW1wdCB0byBtYXRjaCB7QGNvZGUgJyknfSB3aWxsIGZhaWwgd2hlbiBpdCBzZWVzIHtAY29kZSAnOyd9IGFuZFxuLy8gY2FsbCB7QGxpbmsgLy9yZWNvdmVySW5saW5lfS4gVG8gcmVjb3ZlciwgaXQgc2VlcyB0aGF0IHtAY29kZSBMQSgxKT09JzsnfVxuLy8gaXMgaW4gdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHRoZSB7QGNvZGUgJyknfSB0b2tlbiByZWZlcmVuY2Vcbi8vIGluIHJ1bGUge0Bjb2RlIGF0b219LiBJdCBjYW4gYXNzdW1lIHRoYXQgeW91IGZvcmdvdCB0aGUge0Bjb2RlICcpJ30uXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlY292ZXJJbmxpbmUgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgLy8gU0lOR0xFIFRPS0VOIERFTEVUSU9OXG4gICAgdmFyIG1hdGNoZWRTeW1ib2wgPSB0aGlzLnNpbmdsZVRva2VuRGVsZXRpb24ocmVjb2duaXplcik7XG4gICAgaWYgKG1hdGNoZWRTeW1ib2wgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBkZWxldGVkIHRoZSBleHRyYSB0b2tlbi5cbiAgICAgICAgLy8gbm93LCBtb3ZlIHBhc3QgdHR5cGUgdG9rZW4gYXMgaWYgYWxsIHdlcmUgb2tcbiAgICAgICAgcmVjb2duaXplci5jb25zdW1lKCk7XG4gICAgICAgIHJldHVybiBtYXRjaGVkU3ltYm9sO1xuICAgIH1cbiAgICAvLyBTSU5HTEUgVE9LRU4gSU5TRVJUSU9OXG4gICAgaWYgKHRoaXMuc2luZ2xlVG9rZW5JbnNlcnRpb24ocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWlzc2luZ1N5bWJvbChyZWNvZ25pemVyKTtcbiAgICB9XG4gICAgLy8gZXZlbiB0aGF0IGRpZG4ndCB3b3JrOyBtdXN0IHRocm93IHRoZSBleGNlcHRpb25cbiAgICB0aHJvdyBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKTtcbn07XG5cbi8vXG4vLyBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBzaW5nbGUtdG9rZW4gaW5zZXJ0aW9uIGlubGluZSBlcnJvciByZWNvdmVyeVxuLy8gc3RyYXRlZ3kuIEl0IGlzIGNhbGxlZCBieSB7QGxpbmsgLy9yZWNvdmVySW5saW5lfSBpZiB0aGUgc2luZ2xlLXRva2VuXG4vLyBkZWxldGlvbiBzdHJhdGVneSBmYWlscyB0byByZWNvdmVyIGZyb20gdGhlIG1pc21hdGNoZWQgaW5wdXQuIElmIHRoaXNcbi8vIG1ldGhvZCByZXR1cm5zIHtAY29kZSB0cnVlfSwge0Bjb2RlIHJlY29nbml6ZXJ9IHdpbGwgYmUgaW4gZXJyb3IgcmVjb3Zlcnlcbi8vIG1vZGUuXG4vL1xuLy8gPHA+VGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBzaW5nbGUtdG9rZW4gaW5zZXJ0aW9uIGlzIHZpYWJsZSBieVxuLy8gY2hlY2tpbmcgaWYgdGhlIHtAY29kZSBMQSgxKX0gaW5wdXQgc3ltYm9sIGNvdWxkIGJlIHN1Y2Nlc3NmdWxseSBtYXRjaGVkXG4vLyBpZiBpdCB3ZXJlIGluc3RlYWQgdGhlIHtAY29kZSBMQSgyKX0gc3ltYm9sLiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zXG4vLyB7QGNvZGUgdHJ1ZX0sIHRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBpbnNlcnRpbmcgYVxuLy8gdG9rZW4gd2l0aCB0aGUgY29ycmVjdCB0eXBlIHRvIHByb2R1Y2UgdGhpcyBiZWhhdmlvci48L3A+XG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgc2luZ2xlLXRva2VuIGluc2VydGlvbiBpcyBhIHZpYWJsZSByZWNvdmVyeVxuLy8gc3RyYXRlZ3kgZm9yIHRoZSBjdXJyZW50IG1pc21hdGNoZWQgaW5wdXQsIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9XG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnNpbmdsZVRva2VuSW5zZXJ0aW9uID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHZhciBjdXJyZW50U3ltYm9sVHlwZSA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MQSgxKTtcbiAgICAvLyBpZiBjdXJyZW50IHRva2VuIGlzIGNvbnNpc3RlbnQgd2l0aCB3aGF0IGNvdWxkIGNvbWUgYWZ0ZXIgY3VycmVudFxuICAgIC8vIEFUTiBzdGF0ZSwgdGhlbiB3ZSBrbm93IHdlJ3JlIG1pc3NpbmcgYSB0b2tlbjsgZXJyb3IgcmVjb3ZlcnlcbiAgICAvLyBpcyBmcmVlIHRvIGNvbmp1cmUgdXAgYW5kIGluc2VydCB0aGUgbWlzc2luZyB0b2tlblxuICAgIHZhciBhdG4gPSByZWNvZ25pemVyLl9pbnRlcnAuYXRuO1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBhdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xuICAgIHZhciBuZXh0ID0gY3VycmVudFN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldDtcbiAgICB2YXIgZXhwZWN0aW5nQXRMTDIgPSBhdG4ubmV4dFRva2VucyhuZXh0LCByZWNvZ25pemVyLl9jdHgpO1xuICAgIGlmIChleHBlY3RpbmdBdExMMi5jb250YWlucyhjdXJyZW50U3ltYm9sVHlwZSkgKXtcbiAgICAgICAgdGhpcy5yZXBvcnRNaXNzaW5nVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vLyBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBzaW5nbGUtdG9rZW4gZGVsZXRpb24gaW5saW5lIGVycm9yIHJlY292ZXJ5XG4vLyBzdHJhdGVneS4gSXQgaXMgY2FsbGVkIGJ5IHtAbGluayAvL3JlY292ZXJJbmxpbmV9IHRvIGF0dGVtcHQgdG8gcmVjb3ZlclxuLy8gZnJvbSBtaXNtYXRjaGVkIGlucHV0LiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwsIHRoZSBwYXJzZXIgYW5kIGVycm9yXG4vLyBoYW5kbGVyIHN0YXRlIHdpbGwgbm90IGhhdmUgY2hhbmdlZC4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBub24tbnVsbCxcbi8vIHtAY29kZSByZWNvZ25pemVyfSB3aWxsIDxlbT5ub3Q8L2VtPiBiZSBpbiBlcnJvciByZWNvdmVyeSBtb2RlIHNpbmNlIHRoZVxuLy8gcmV0dXJuZWQgdG9rZW4gd2FzIGEgc3VjY2Vzc2Z1bCBtYXRjaC5cbi8vXG4vLyA8cD5JZiB0aGUgc2luZ2xlLXRva2VuIGRlbGV0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoaXMgbWV0aG9kIGNhbGxzXG4vLyB7QGxpbmsgLy9yZXBvcnRVbndhbnRlZFRva2VufSB0byByZXBvcnQgdGhlIGVycm9yLCBmb2xsb3dlZCBieVxuLy8ge0BsaW5rIFBhcnNlci8vY29uc3VtZX0gdG8gYWN0dWFsbHkgXCJkZWxldGVcIiB0aGUgZXh0cmFuZW91cyB0b2tlbi4gVGhlbixcbi8vIGJlZm9yZSByZXR1cm5pbmcge0BsaW5rIC8vcmVwb3J0TWF0Y2h9IGlzIGNhbGxlZCB0byBzaWduYWwgYSBzdWNjZXNzZnVsXG4vLyBtYXRjaC48L3A+XG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy8gQHJldHVybiB0aGUgc3VjY2Vzc2Z1bGx5IG1hdGNoZWQge0BsaW5rIFRva2VufSBpbnN0YW5jZSBpZiBzaW5nbGUtdG9rZW5cbi8vIGRlbGV0aW9uIHN1Y2Nlc3NmdWxseSByZWNvdmVycyBmcm9tIHRoZSBtaXNtYXRjaGVkIGlucHV0LCBvdGhlcndpc2Vcbi8vIHtAY29kZSBudWxsfVxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5zaW5nbGVUb2tlbkRlbGV0aW9uID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHZhciBuZXh0VG9rZW5UeXBlID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDIpO1xuICAgIHZhciBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgIGlmIChleHBlY3RpbmcuY29udGFpbnMobmV4dFRva2VuVHlwZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRVbndhbnRlZFRva2VuKHJlY29nbml6ZXIpO1xuICAgICAgICAvLyBwcmludChcInJlY292ZXJGcm9tTWlzbWF0Y2hlZFRva2VuIGRlbGV0aW5nIFwiIFxcXG4gICAgICAgIC8vICsgc3RyKHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MVCgxKSkgXFxcbiAgICAgICAgLy8gKyBcIiBzaW5jZSBcIiArIHN0cihyZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTFQoMikpIFxcXG4gICAgICAgIC8vICsgXCIgaXMgd2hhdCB3ZSB3YW50XCIsIGZpbGU9c3lzLnN0ZGVycilcbiAgICAgICAgcmVjb2duaXplci5jb25zdW1lKCk7IC8vIHNpbXBseSBkZWxldGUgZXh0cmEgdG9rZW5cbiAgICAgICAgLy8gd2Ugd2FudCB0byByZXR1cm4gdGhlIHRva2VuIHdlJ3JlIGFjdHVhbGx5IG1hdGNoaW5nXG4gICAgICAgIHZhciBtYXRjaGVkU3ltYm9sID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5yZXBvcnRNYXRjaChyZWNvZ25pemVyKTsgLy8gd2Uga25vdyBjdXJyZW50IHRva2VuIGlzIGNvcnJlY3RcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRTeW1ib2w7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLy8gQ29uanVyZSB1cCBhIG1pc3NpbmcgdG9rZW4gZHVyaW5nIGVycm9yIHJlY292ZXJ5LlxuLy9cbi8vIFRoZSByZWNvZ25pemVyIGF0dGVtcHRzIHRvIHJlY292ZXIgZnJvbSBzaW5nbGUgbWlzc2luZ1xuLy8gc3ltYm9scy4gQnV0LCBhY3Rpb25zIG1pZ2h0IHJlZmVyIHRvIHRoYXQgbWlzc2luZyBzeW1ib2wuXG4vLyBGb3IgZXhhbXBsZSwgeD1JRCB7ZigkeCk7fS4gVGhlIGFjdGlvbiBjbGVhcmx5IGFzc3VtZXNcbi8vIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gaWRlbnRpZmllciBtYXRjaGVkIHByZXZpb3VzbHkgYW5kIHRoYXRcbi8vICR4IHBvaW50cyBhdCB0aGF0IHRva2VuLiBJZiB0aGF0IHRva2VuIGlzIG1pc3NpbmcsIGJ1dFxuLy8gdGhlIG5leHQgdG9rZW4gaW4gdGhlIHN0cmVhbSBpcyB3aGF0IHdlIHdhbnQgd2UgYXNzdW1lIHRoYXRcbi8vIHRoaXMgdG9rZW4gaXMgbWlzc2luZyBhbmQgd2Uga2VlcCBnb2luZy4gQmVjYXVzZSB3ZVxuLy8gaGF2ZSB0byByZXR1cm4gc29tZSB0b2tlbiB0byByZXBsYWNlIHRoZSBtaXNzaW5nIHRva2VuLFxuLy8gd2UgaGF2ZSB0byBjb25qdXJlIG9uZSB1cC4gVGhpcyBtZXRob2QgZ2l2ZXMgdGhlIHVzZXIgY29udHJvbFxuLy8gb3ZlciB0aGUgdG9rZW5zIHJldHVybmVkIGZvciBtaXNzaW5nIHRva2Vucy4gTW9zdGx5LFxuLy8geW91IHdpbGwgd2FudCB0byBjcmVhdGUgc29tZXRoaW5nIHNwZWNpYWwgZm9yIGlkZW50aWZpZXJcbi8vIHRva2Vucy4gRm9yIGxpdGVyYWxzIHN1Y2ggYXMgJ3snIGFuZCAnLCcsIHRoZSBkZWZhdWx0XG4vLyBhY3Rpb24gaW4gdGhlIHBhcnNlciBvciB0cmVlIHBhcnNlciB3b3Jrcy4gSXQgc2ltcGx5IGNyZWF0ZXNcbi8vIGEgQ29tbW9uVG9rZW4gb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUuIFRoZSB0ZXh0IHdpbGwgYmUgdGhlIHRva2VuLlxuLy8gSWYgeW91IGNoYW5nZSB3aGF0IHRva2VucyBtdXN0IGJlIGNyZWF0ZWQgYnkgdGhlIGxleGVyLFxuLy8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0b2tlbnMuXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmdldE1pc3NpbmdTeW1ib2wgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdmFyIGN1cnJlbnRTeW1ib2wgPSByZWNvZ25pemVyLmdldEN1cnJlbnRUb2tlbigpO1xuICAgIHZhciBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgIHZhciBleHBlY3RlZFRva2VuVHlwZSA9IGV4cGVjdGluZy5maXJzdCgpOyAvLyBnZXQgYW55IGVsZW1lbnRcbiAgICB2YXIgdG9rZW5UZXh0O1xuICAgIGlmIChleHBlY3RlZFRva2VuVHlwZT09PVRva2VuLkVPRikge1xuICAgICAgICB0b2tlblRleHQgPSBcIjxtaXNzaW5nIEVPRj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlblRleHQgPSBcIjxtaXNzaW5nIFwiICsgcmVjb2duaXplci5saXRlcmFsTmFtZXNbZXhwZWN0ZWRUb2tlblR5cGVdICsgXCI+XCI7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gY3VycmVudFN5bWJvbDtcbiAgICB2YXIgbG9va2JhY2sgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTFQoLTEpO1xuICAgIGlmIChjdXJyZW50LnR5cGU9PT1Ub2tlbi5FT0YgJiYgbG9va2JhY2sgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudCA9IGxvb2tiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb2duaXplci5nZXRUb2tlbkZhY3RvcnkoKS5jcmVhdGUoY3VycmVudC5zb3VyY2UsXG4gICAgICAgIGV4cGVjdGVkVG9rZW5UeXBlLCB0b2tlblRleHQsIFRva2VuLkRFRkFVTFRfQ0hBTk5FTCxcbiAgICAgICAgLTEsIC0xLCBjdXJyZW50LmxpbmUsIGN1cnJlbnQuY29sdW1uKTtcbn07XG5cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5nZXRFeHBlY3RlZFRva2VucyA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICByZXR1cm4gcmVjb2duaXplci5nZXRFeHBlY3RlZFRva2VucygpO1xufTtcblxuLy8gSG93IHNob3VsZCBhIHRva2VuIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBtZXNzYWdlPyBUaGUgZGVmYXVsdFxuLy8gaXMgdG8gZGlzcGxheSBqdXN0IHRoZSB0ZXh0LCBidXQgZHVyaW5nIGRldmVsb3BtZW50IHlvdSBtaWdodFxuLy8gd2FudCB0byBoYXZlIGEgbG90IG9mIGluZm9ybWF0aW9uIHNwaXQgb3V0LiBPdmVycmlkZSBpbiB0aGF0IGNhc2Vcbi8vIHRvIHVzZSB0LnRvU3RyaW5nKCkgKHdoaWNoLCBmb3IgQ29tbW9uVG9rZW4sIGR1bXBzIGV2ZXJ5dGhpbmcgYWJvdXRcbi8vIHRoZSB0b2tlbikuIFRoaXMgaXMgYmV0dGVyIHRoYW4gZm9yY2luZyB5b3UgdG8gb3ZlcnJpZGUgYSBtZXRob2QgaW5cbi8vIHlvdXIgdG9rZW4gb2JqZWN0cyBiZWNhdXNlIHlvdSBkb24ndCBoYXZlIHRvIGdvIG1vZGlmeSB5b3VyIGxleGVyXG4vLyBzbyB0aGF0IGl0IGNyZWF0ZXMgYSBuZXcgSmF2YSB0eXBlLlxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5nZXRUb2tlbkVycm9yRGlzcGxheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCI8bm8gdG9rZW4+XCI7XG4gICAgfVxuICAgIHZhciBzID0gdC50ZXh0O1xuICAgIGlmIChzID09PSBudWxsKSB7XG4gICAgICAgIGlmICh0LnR5cGU9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHMgPSBcIjxFT0Y+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gXCI8XCIgKyB0LnR5cGUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc2NhcGVXU0FuZFF1b3RlKHMpO1xufTtcblxuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmVzY2FwZVdTQW5kUXVvdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgcyA9IHMucmVwbGFjZSgvXFxuL2csXCJcXFxcblwiKTtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHIvZyxcIlxcXFxyXCIpO1xuICAgIHMgPSBzLnJlcGxhY2UoL1xcdC9nLFwiXFxcXHRcIik7XG4gICAgcmV0dXJuIFwiJ1wiICsgcyArIFwiJ1wiO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZXJyb3IgcmVjb3Zlcnkgc2V0IGZvciB0aGUgY3VycmVudCBydWxlLiBEdXJpbmdcbi8vIHJ1bGUgaW52b2NhdGlvbiwgdGhlIHBhcnNlciBwdXNoZXMgdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW5cbi8vIGZvbGxvdyB0aGF0IHJ1bGUgcmVmZXJlbmNlIG9uIHRoZSBzdGFjazsgdGhpcyBhbW91bnRzIHRvXG4vLyBjb21wdXRpbmcgRklSU1Qgb2Ygd2hhdCBmb2xsb3dzIHRoZSBydWxlIHJlZmVyZW5jZSBpbiB0aGVcbi8vIGVuY2xvc2luZyBydWxlLiBTZWUgTGluZWFyQXBwcm94aW1hdG9yLkZJUlNUKCkuXG4vLyBUaGlzIGxvY2FsIGZvbGxvdyBzZXQgb25seSBpbmNsdWRlcyB0b2tlbnNcbi8vIGZyb20gd2l0aGluIHRoZSBydWxlOyBpLmUuLCB0aGUgRklSU1QgY29tcHV0YXRpb24gZG9uZSBieVxuLy8gQU5UTFIgc3RvcHMgYXQgdGhlIGVuZCBvZiBhIHJ1bGUuXG4vL1xuLy8gRVhBTVBMRVxuLy9cbi8vIFdoZW4geW91IGZpbmQgYSBcIm5vIHZpYWJsZSBhbHQgZXhjZXB0aW9uXCIsIHRoZSBpbnB1dCBpcyBub3Rcbi8vIGNvbnNpc3RlbnQgd2l0aCBhbnkgb2YgdGhlIGFsdGVybmF0aXZlcyBmb3IgcnVsZSByLiBUaGUgYmVzdFxuLy8gdGhpbmcgdG8gZG8gaXMgdG8gY29uc3VtZSB0b2tlbnMgdW50aWwgeW91IHNlZSBzb21ldGhpbmcgdGhhdFxuLy8gY2FuIGxlZ2FsbHkgZm9sbG93IGEgY2FsbCB0byByLy9vciogYW55IHJ1bGUgdGhhdCBjYWxsZWQgci5cbi8vIFlvdSBkb24ndCB3YW50IHRoZSBleGFjdCBzZXQgb2YgdmlhYmxlIG5leHQgdG9rZW5zIGJlY2F1c2UgdGhlXG4vLyBpbnB1dCBtaWdodCBqdXN0IGJlIG1pc3NpbmcgYSB0b2tlbi0teW91IG1pZ2h0IGNvbnN1bWUgdGhlXG4vLyByZXN0IG9mIHRoZSBpbnB1dCBsb29raW5nIGZvciBvbmUgb2YgdGhlIG1pc3NpbmcgdG9rZW5zLlxuLy9cbi8vIENvbnNpZGVyIGdyYW1tYXI6XG4vL1xuLy8gYSA6ICdbJyBiICddJ1xuLy8gfCAnKCcgYiAnKSdcbi8vIDtcbi8vIGIgOiBjICdeJyBJTlQgO1xuLy8gYyA6IElEXG4vLyB8IElOVFxuLy8gO1xuLy9cbi8vIEF0IGVhY2ggcnVsZSBpbnZvY2F0aW9uLCB0aGUgc2V0IG9mIHRva2VucyB0aGF0IGNvdWxkIGZvbGxvd1xuLy8gdGhhdCBydWxlIGlzIHB1c2hlZCBvbiBhIHN0YWNrLiBIZXJlIGFyZSB0aGUgdmFyaW91c1xuLy8gY29udGV4dC1zZW5zaXRpdmUgZm9sbG93IHNldHM6XG4vL1xuLy8gRk9MTE9XKGIxX2luX2EpID0gRklSU1QoJ10nKSA9ICddJ1xuLy8gRk9MTE9XKGIyX2luX2EpID0gRklSU1QoJyknKSA9ICcpJ1xuLy8gRk9MTE9XKGNfaW5fYikgPSBGSVJTVCgnXicpID0gJ14nXG4vL1xuLy8gVXBvbiBlcnJvbmVvdXMgaW5wdXQgXCJbXVwiLCB0aGUgY2FsbCBjaGFpbiBpc1xuLy9cbi8vIGEgLT4gYiAtPiBjXG4vL1xuLy8gYW5kLCBoZW5jZSwgdGhlIGZvbGxvdyBjb250ZXh0IHN0YWNrIGlzOlxuLy9cbi8vIGRlcHRoIGZvbGxvdyBzZXQgc3RhcnQgb2YgcnVsZSBleGVjdXRpb25cbi8vIDAgPEVPRj4gYSAoZnJvbSBtYWluKCkpXG4vLyAxICddJyBiXG4vLyAyICdeJyBjXG4vL1xuLy8gTm90aWNlIHRoYXQgJyknIGlzIG5vdCBpbmNsdWRlZCwgYmVjYXVzZSBiIHdvdWxkIGhhdmUgdG8gaGF2ZVxuLy8gYmVlbiBjYWxsZWQgZnJvbSBhIGRpZmZlcmVudCBjb250ZXh0IGluIHJ1bGUgYSBmb3IgJyknIHRvIGJlXG4vLyBpbmNsdWRlZC5cbi8vXG4vLyBGb3IgZXJyb3IgcmVjb3ZlcnksIHdlIGNhbm5vdCBjb25zaWRlciBGT0xMT1coYylcbi8vIChjb250ZXh0LXNlbnNpdGl2ZSBvciBvdGhlcndpc2UpLiBXZSBuZWVkIHRoZSBjb21iaW5lZCBzZXQgb2Zcbi8vIGFsbCBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1cgc2V0cy0tdGhlIHNldCBvZiBhbGwgdG9rZW5zIHRoYXRcbi8vIGNvdWxkIGZvbGxvdyBhbnkgcmVmZXJlbmNlIGluIHRoZSBjYWxsIGNoYWluLiBXZSBuZWVkIHRvXG4vLyByZXN5bmMgdG8gb25lIG9mIHRob3NlIHRva2Vucy4gTm90ZSB0aGF0IEZPTExPVyhjKT0nXicgYW5kIGlmXG4vLyB3ZSByZXN5bmMnZCB0byB0aGF0IHRva2VuLCB3ZSdkIGNvbnN1bWUgdW50aWwgRU9GLiBXZSBuZWVkIHRvXG4vLyBzeW5jIHRvIGNvbnRleHQtc2Vuc2l0aXZlIEZPTExPV3MgZm9yIGEsIGIsIGFuZCBjOiB7J10nLCdeJ30uXG4vLyBJbiB0aGlzIGNhc2UsIGZvciBpbnB1dCBcIltdXCIsIExBKDEpIGlzICddJyBhbmQgaW4gdGhlIHNldCwgc28gd2Ugd291bGRcbi8vIG5vdCBjb25zdW1lIGFueXRoaW5nLiBBZnRlciBwcmludGluZyBhbiBlcnJvciwgcnVsZSBjIHdvdWxkXG4vLyByZXR1cm4gbm9ybWFsbHkuIFJ1bGUgYiB3b3VsZCBub3QgZmluZCB0aGUgcmVxdWlyZWQgJ14nIHRob3VnaC5cbi8vIEF0IHRoaXMgcG9pbnQsIGl0IGdldHMgYSBtaXNtYXRjaGVkIHRva2VuIGVycm9yIGFuZCB0aHJvd3MgYW5cbi8vIGV4Y2VwdGlvbiAoc2luY2UgTEEoMSkgaXMgbm90IGluIHRoZSB2aWFibGUgZm9sbG93aW5nIHRva2VuXG4vLyBzZXQpLiBUaGUgcnVsZSBleGNlcHRpb24gaGFuZGxlciB0cmllcyB0byByZWNvdmVyLCBidXQgZmluZHNcbi8vIHRoZSBzYW1lIHJlY292ZXJ5IHNldCBhbmQgZG9lc24ndCBjb25zdW1lIGFueXRoaW5nLiBSdWxlIGJcbi8vIGV4aXRzIG5vcm1hbGx5IHJldHVybmluZyB0byBydWxlIGEuIE5vdyBpdCBmaW5kcyB0aGUgJ10nIChhbmRcbi8vIHdpdGggdGhlIHN1Y2Nlc3NmdWwgbWF0Y2ggZXhpdHMgZXJyb3JSZWNvdmVyeSBtb2RlKS5cbi8vXG4vLyBTbywgeW91IGNhbiBzZWUgdGhhdCB0aGUgcGFyc2VyIHdhbGtzIHVwIHRoZSBjYWxsIGNoYWluIGxvb2tpbmdcbi8vIGZvciB0aGUgdG9rZW4gdGhhdCB3YXMgYSBtZW1iZXIgb2YgdGhlIHJlY292ZXJ5IHNldC5cbi8vXG4vLyBFcnJvcnMgYXJlIG5vdCBnZW5lcmF0ZWQgaW4gZXJyb3JSZWNvdmVyeSBtb2RlLlxuLy9cbi8vIEFOVExSJ3MgZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtIGlzIGJhc2VkIHVwb24gb3JpZ2luYWwgaWRlYXM6XG4vL1xuLy8gXCJBbGdvcml0aG1zICsgRGF0YSBTdHJ1Y3R1cmVzID0gUHJvZ3JhbXNcIiBieSBOaWtsYXVzIFdpcnRoXG4vL1xuLy8gYW5kXG4vL1xuLy8gXCJBIG5vdGUgb24gZXJyb3IgcmVjb3ZlcnkgaW4gcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2Vyc1wiOlxuLy8gaHR0cDovL3BvcnRhbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD05NDc5MDIuOTQ3OTA1XG4vL1xuLy8gTGF0ZXIsIEpvc2VmIEdyb3NjaCBoYWQgc29tZSBnb29kIGlkZWFzOlxuLy9cbi8vIFwiRWZmaWNpZW50IGFuZCBDb21mb3J0YWJsZSBFcnJvciBSZWNvdmVyeSBpbiBSZWN1cnNpdmUgRGVzY2VudFxuLy8gUGFyc2Vyc1wiOlxuLy8gZnRwOi8vd3d3LmNvY29sYWIuY29tL3Byb2R1Y3RzL2NvY2t0YWlsL2RvY2E0LnBzL2VsbC5wcy56aXBcbi8vXG4vLyBMaWtlIEdyb3NjaCBJIGltcGxlbWVudCBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1cgc2V0cyB0aGF0IGFyZSBjb21iaW5lZFxuLy8gYXQgcnVuLXRpbWUgdXBvbiBlcnJvciB0byBhdm9pZCBvdmVyaGVhZCBkdXJpbmcgcGFyc2luZy5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuZ2V0RXJyb3JSZWNvdmVyeVNldCA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICB2YXIgYXRuID0gcmVjb2duaXplci5faW50ZXJwLmF0bjtcbiAgICB2YXIgY3R4ID0gcmVjb2duaXplci5fY3R4O1xuICAgIHZhciByZWNvdmVyU2V0ID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgd2hpbGUgKGN0eCAhPT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZT49MCkge1xuICAgICAgICAvLyBjb21wdXRlIHdoYXQgZm9sbG93cyB3aG8gaW52b2tlZCB1c1xuICAgICAgICB2YXIgaW52b2tpbmdTdGF0ZSA9IGF0bi5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xuICAgICAgICB2YXIgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgICAgICB2YXIgZm9sbG93ID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xuICAgICAgICByZWNvdmVyU2V0LmFkZFNldChmb2xsb3cpO1xuICAgICAgICBjdHggPSBjdHgucGFyZW50Q3R4O1xuICAgIH1cbiAgICByZWNvdmVyU2V0LnJlbW92ZU9uZShUb2tlbi5FUFNJTE9OKTtcbiAgICByZXR1cm4gcmVjb3ZlclNldDtcbn07XG5cbi8vIENvbnN1bWUgdG9rZW5zIHVudGlsIG9uZSBtYXRjaGVzIHRoZSBnaXZlbiB0b2tlbiBzZXQuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5jb25zdW1lVW50aWwgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBzZXQpIHtcbiAgICB2YXIgdHR5cGUgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTEEoMSk7XG4gICAgd2hpbGUoIHR0eXBlICE9PSBUb2tlbi5FT0YgJiYgIXNldC5jb250YWlucyh0dHlwZSkpIHtcbiAgICAgICAgcmVjb2duaXplci5jb25zdW1lKCk7XG4gICAgICAgIHR0eXBlID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDEpO1xuICAgIH1cbn07XG5cbi8vXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3l9IHJlc3BvbmRzIHRvIHN5bnRheCBlcnJvcnNcbi8vIGJ5IGltbWVkaWF0ZWx5IGNhbmNlbGluZyB0aGUgcGFyc2Ugb3BlcmF0aW9uIHdpdGggYVxuLy8ge0BsaW5rIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9ufS4gVGhlIGltcGxlbWVudGF0aW9uIGVuc3VyZXMgdGhhdCB0aGVcbi8vIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dC8vZXhjZXB0aW9ufSBmaWVsZCBpcyBzZXQgZm9yIGFsbCBwYXJzZSB0cmVlIG5vZGVzXG4vLyB0aGF0IHdlcmUgbm90IGNvbXBsZXRlZCBwcmlvciB0byBlbmNvdW50ZXJpbmcgdGhlIGVycm9yLlxuLy9cbi8vIDxwPlxuLy8gVGhpcyBlcnJvciBzdHJhdGVneSBpcyB1c2VmdWwgaW4gdGhlIGZvbGxvd2luZyBzY2VuYXJpb3MuPC9wPlxuLy9cbi8vIDx1bD5cbi8vIDxsaT48c3Ryb25nPlR3by1zdGFnZSBwYXJzaW5nOjwvc3Ryb25nPiBUaGlzIGVycm9yIHN0cmF0ZWd5IGFsbG93cyB0aGUgZmlyc3Rcbi8vIHN0YWdlIG9mIHR3by1zdGFnZSBwYXJzaW5nIHRvIGltbWVkaWF0ZWx5IHRlcm1pbmF0ZSBpZiBhbiBlcnJvciBpc1xuLy8gZW5jb3VudGVyZWQsIGFuZCBpbW1lZGlhdGVseSBmYWxsIGJhY2sgdG8gdGhlIHNlY29uZCBzdGFnZS4gSW4gYWRkaXRpb24gdG9cbi8vIGF2b2lkaW5nIHdhc3RlZCB3b3JrIGJ5IGF0dGVtcHRpbmcgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBoZXJlLCB0aGUgZW1wdHlcbi8vIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBCYWlsRXJyb3JTdHJhdGVneS8vc3luY30gaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIG9mXG4vLyB0aGUgZmlyc3Qgc3RhZ2UuPC9saT5cbi8vIDxsaT48c3Ryb25nPlNpbGVudCB2YWxpZGF0aW9uOjwvc3Ryb25nPiBXaGVuIHN5bnRheCBlcnJvcnMgYXJlIG5vdCBiZWluZ1xuLy8gcmVwb3J0ZWQgb3IgbG9nZ2VkLCBhbmQgdGhlIHBhcnNlIHJlc3VsdCBpcyBzaW1wbHkgaWdub3JlZCBpZiBlcnJvcnMgb2NjdXIsXG4vLyB0aGUge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5fSBhdm9pZHMgd2FzdGluZyB3b3JrIG9uIHJlY292ZXJpbmcgZnJvbSBlcnJvcnNcbi8vIHdoZW4gdGhlIHJlc3VsdCB3aWxsIGJlIGlnbm9yZWQgZWl0aGVyIHdheS48L2xpPlxuLy8gPC91bD5cbi8vXG4vLyA8cD5cbi8vIHtAY29kZSBteXBhcnNlci5zZXRFcnJvckhhbmRsZXIobmV3IEJhaWxFcnJvclN0cmF0ZWd5KCkpO308L3A+XG4vL1xuLy8gQHNlZSBQYXJzZXIvL3NldEVycm9ySGFuZGxlcihBTlRMUkVycm9yU3RyYXRlZ3kpXG4vL1xuZnVuY3Rpb24gQmFpbEVycm9yU3RyYXRlZ3koKSB7XG5cdERlZmF1bHRFcnJvclN0cmF0ZWd5LmNhbGwodGhpcyk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5CYWlsRXJyb3JTdHJhdGVneS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSk7XG5CYWlsRXJyb3JTdHJhdGVneS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYWlsRXJyb3JTdHJhdGVneTtcblxuLy8gSW5zdGVhZCBvZiByZWNvdmVyaW5nIGZyb20gZXhjZXB0aW9uIHtAY29kZSBlfSwgcmUtdGhyb3cgaXQgd3JhcHBlZFxuLy8gaW4gYSB7QGxpbmsgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb259IHNvIGl0IGlzIG5vdCBjYXVnaHQgYnkgdGhlXG4vLyBydWxlIGZ1bmN0aW9uIGNhdGNoZXMuIFVzZSB7QGxpbmsgRXhjZXB0aW9uLy9nZXRDYXVzZSgpfSB0byBnZXQgdGhlXG4vLyBvcmlnaW5hbCB7QGxpbmsgUmVjb2duaXRpb25FeGNlcHRpb259LlxuLy9cbkJhaWxFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZWNvdmVyID0gZnVuY3Rpb24ocmVjb2duaXplciwgZSkge1xuICAgIHZhciBjb250ZXh0ID0gcmVjb2duaXplci5fY3R4O1xuICAgIHdoaWxlIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQuZXhjZXB0aW9uID0gZTtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Q3R4O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24oZSk7XG59O1xuXG4vLyBNYWtlIHN1cmUgd2UgZG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGlubGluZTsgaWYgdGhlIHBhcnNlclxuLy8gc3VjY2Vzc2Z1bGx5IHJlY292ZXJzLCBpdCB3b24ndCB0aHJvdyBhbiBleGNlcHRpb24uXG4vL1xuQmFpbEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlY292ZXJJbmxpbmUgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdGhpcy5yZWNvdmVyKHJlY29nbml6ZXIsIG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIpKTtcbn07XG5cbi8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBwcm9ibGVtcyBpbiBzdWJydWxlcy4vL1xuQmFpbEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgLy8gcGFzc1xufTtcblxuZXhwb3J0cy5CYWlsRXJyb3JTdHJhdGVneSA9IEJhaWxFcnJvclN0cmF0ZWd5O1xuZXhwb3J0cy5EZWZhdWx0RXJyb3JTdHJhdGVneSA9IERlZmF1bHRFcnJvclN0cmF0ZWd5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2Vycm9yL0Vycm9yU3RyYXRlZ3kuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy8gR2VuZXJhdGVkIGZyb20gQy5nNCBieSBBTlRMUiA0LjcuMVxyXG4vLyBqc2hpbnQgaWdub3JlOiBzdGFydFxyXG52YXIgYW50bHI0ID0gcmVxdWlyZSgnYW50bHI0L2luZGV4Jyk7XHJcblxyXG4vLyBUaGlzIGNsYXNzIGRlZmluZXMgYSBjb21wbGV0ZSBnZW5lcmljIHZpc2l0b3IgZm9yIGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyLlxyXG5cclxuZnVuY3Rpb24gQ1Zpc2l0b3IoKSB7XHJcbiAgYW50bHI0LnRyZWUuUGFyc2VUcmVlVmlzaXRvci5jYWxsKHRoaXMpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5DVmlzaXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC50cmVlLlBhcnNlVHJlZVZpc2l0b3IucHJvdG90eXBlKTtcclxuQ1Zpc2l0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1Zpc2l0b3I7XHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNwcmltYXJ5RXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2dlbmVyaWNTZWxlY3Rpb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdlbmVyaWNTZWxlY3Rpb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2dlbmVyaWNBc3NvY0xpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdlbmVyaWNBc3NvY0xpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2dlbmVyaWNBc3NvY2lhdGlvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0R2VuZXJpY0Fzc29jaWF0aW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNwb3N0Zml4RXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0UG9zdGZpeEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2FyZ3VtZW50RXhwcmVzc2lvbkxpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFyZ3VtZW50RXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3VuYXJ5RXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciN1bmFyeU9wZXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRVbmFyeU9wZXJhdG9yID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNjYXN0RXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI211bHRpcGxpY2F0aXZlRXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0TXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNhZGRpdGl2ZUV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFkZGl0aXZlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjc2hpZnRFeHByZXNzaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRTaGlmdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3JlbGF0aW9uYWxFeHByZXNzaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWxhdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZXF1YWxpdHlFeHByZXNzaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRFcXVhbGl0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2FuZEV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2V4Y2x1c2l2ZU9yRXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhjbHVzaXZlT3JFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNpbmNsdXNpdmVPckV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluY2x1c2l2ZU9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjbG9naWNhbEFuZEV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdExvZ2ljYWxBbmRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNsb2dpY2FsT3JFeHByZXNzaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRMb2dpY2FsT3JFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNjb25kaXRpb25hbEV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjYXNzaWdubWVudEV4cHJlc3Npb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNhc3NpZ25tZW50T3BlcmF0b3IuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2lnbm1lbnRPcGVyYXRvciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjY29uc3RhbnRFeHByZXNzaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2RlY2xhcmF0aW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZGVjbGFyYXRpb25TcGVjaWZpZXJzLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvblNwZWNpZmllcnMgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2RlY2xhcmF0aW9uU3BlY2lmaWVyczIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uU3BlY2lmaWVyczIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2RlY2xhcmF0aW9uU3BlY2lmaWVyLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvblNwZWNpZmllciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjaW5pdERlY2xhcmF0b3JMaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbml0RGVjbGFyYXRvckxpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2luaXREZWNsYXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbml0RGVjbGFyYXRvciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjc3RvcmFnZUNsYXNzU3BlY2lmaWVyLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdG9yYWdlQ2xhc3NTcGVjaWZpZXIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3R5cGVTcGVjaWZpZXIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGVTcGVjaWZpZXIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3N0cnVjdE9yVW5pb25TcGVjaWZpZXIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0cnVjdE9yVW5pb25TcGVjaWZpZXIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3N0cnVjdE9yVW5pb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0cnVjdE9yVW5pb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3N0cnVjdERlY2xhcmF0aW9uTGlzdC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RydWN0RGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNzdHJ1Y3REZWNsYXJhdGlvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RydWN0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3NwZWNpZmllclF1YWxpZmllckxpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNwZWNpZmllclF1YWxpZmllckxpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3N0cnVjdERlY2xhcmF0b3JMaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdHJ1Y3REZWNsYXJhdG9yTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjc3RydWN0RGVjbGFyYXRvci5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RydWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZW51bVNwZWNpZmllci5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RW51bVNwZWNpZmllciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZW51bWVyYXRvckxpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVudW1lcmF0b3JMaXN0ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNlbnVtZXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbnVtZXJhdG9yID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNlbnVtZXJhdGlvbkNvbnN0YW50LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbnVtZXJhdGlvbkNvbnN0YW50ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNhdG9taWNUeXBlU3BlY2lmaWVyLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdG9taWNUeXBlU3BlY2lmaWVyID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciN0eXBlUXVhbGlmaWVyLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlUXVhbGlmaWVyID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNmdW5jdGlvblNwZWNpZmllci5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25TcGVjaWZpZXIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2FsaWdubWVudFNwZWNpZmllci5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxpZ25tZW50U3BlY2lmaWVyID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNkZWNsYXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdG9yID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNkaXJlY3REZWNsYXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3REZWNsYXJhdG9yID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNnY2NEZWNsYXJhdG9yRXh0ZW5zaW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRHY2NEZWNsYXJhdG9yRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNnY2NBdHRyaWJ1dGVTcGVjaWZpZXIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdjY0F0dHJpYnV0ZVNwZWNpZmllciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZ2NjQXR0cmlidXRlTGlzdC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0R2NjQXR0cmlidXRlTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZ2NjQXR0cmlidXRlLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRHY2NBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI25lc3RlZFBhcmVudGhlc2VzQmxvY2suXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5lc3RlZFBhcmVudGhlc2VzQmxvY2sgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3BvaW50ZXIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBvaW50ZXIgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3R5cGVRdWFsaWZpZXJMaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlUXVhbGlmaWVyTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjcGFyYW1ldGVyVHlwZUxpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBhcmFtZXRlclR5cGVMaXN0ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNwYXJhbWV0ZXJMaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRQYXJhbWV0ZXJMaXN0ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNwYXJhbWV0ZXJEZWNsYXJhdGlvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0UGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2lkZW50aWZpZXJMaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZGVudGlmaWVyTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjdHlwZU5hbWUuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGVOYW1lID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNhYnN0cmFjdERlY2xhcmF0b3IuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFic3RyYWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3R5cGVkZWZOYW1lLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlZGVmTmFtZSA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjaW5pdGlhbGl6ZXIuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNpbml0aWFsaXplckxpc3QuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluaXRpYWxpemVyTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZGVzaWduYXRpb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlc2lnbmF0aW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNkZXNpZ25hdG9yTGlzdC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVzaWduYXRvckxpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2Rlc2lnbmF0b3IuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlc2lnbmF0b3IgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3N0YXRpY0Fzc2VydERlY2xhcmF0aW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0aWNBc3NlcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjc3RhdGVtZW50LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2xhYmVsZWRTdGF0ZW1lbnQuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdExhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2NvbXBvdW5kU3RhdGVtZW50LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21wb3VuZFN0YXRlbWVudCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjYmxvY2tJdGVtTGlzdC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QmxvY2tJdGVtTGlzdCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjYmxvY2tJdGVtLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRCbG9ja0l0ZW0gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2V4cHJlc3Npb25TdGF0ZW1lbnQuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3NlbGVjdGlvblN0YXRlbWVudC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VsZWN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNpdGVyYXRpb25TdGF0ZW1lbnQuXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEl0ZXJhdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZm9yQ29uZGl0aW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRGb3JDb25kaXRpb24gPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI2ZvckRlY2xhcmF0aW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRGb3JEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZm9yRXhwcmVzc2lvbi5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Rm9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjanVtcFN0YXRlbWVudC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0SnVtcFN0YXRlbWVudCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjY29tcGlsYXRpb25Vbml0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21waWxhdGlvblVuaXQgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBDUGFyc2VyI3RyYW5zbGF0aW9uVW5pdC5cclxuQ1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJhbnNsYXRpb25Vbml0ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNleHRlcm5hbERlY2xhcmF0aW9uLlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgQ1BhcnNlciNmdW5jdGlvbkRlZmluaXRpb24uXHJcbkNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IENQYXJzZXIjZGVjbGFyYXRpb25MaXN0LlxyXG5DVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbkxpc3QgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcblxyXG5leHBvcnRzLkNWaXNpdG9yID0gQ1Zpc2l0b3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbWFwcGVyL0NWaXNpdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsImNvbnN0IGFudGxyNCA9IHJlcXVpcmUoJ2FudGxyNCcpO1xyXG5jb25zdCBDTGV4ZXIgPSByZXF1aXJlKCcuL0NMZXhlcicpO1xyXG5jb25zdCBDUGFyc2VyID0gcmVxdWlyZSgnLi9DUGFyc2VyJyk7XHJcbmNvbnN0IENWaXNpdG9yID0gcmVxdWlyZSgnLi9DVmlzaXRvcicpO1xyXG5jb25zdCBhbnRscjR0cmVlID0gcmVxdWlyZSgnYW50bHI0L3RyZWUvVHJlZS5qcycpO1xyXG5cclxuY2xhc3MgQ01hcHBlciBleHRlbmRzIENWaXNpdG9yLkNWaXNpdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaXNEZWJ1Z01vZGUpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9pc0RlYnVnTW9kZSA9IGlzRGVidWdNb2RlO1xyXG4gIH1cclxuXHJcbiAgcGFyc2UoY29kZSkge1xyXG4gICAgY29uc3QgY2hhcnMgPSBuZXcgYW50bHI0LklucHV0U3RyZWFtKGNvZGUpO1xyXG4gICAgY29uc3QgW3RyZWUsIHBhcnNlcl0gPSB0aGlzLnBhcnNlQ29yZShjaGFycyk7XHJcbiAgICByZXR1cm4gdGhpcy52aXNpdCh0cmVlKTtcclxuICB9XHJcblxyXG4gIGdldFJhd1RyZWUoY29kZSkge1xyXG4gICAgY29uc3QgY2hhcnMgPSBuZXcgYW50bHI0LklucHV0U3RyZWFtKGNvZGUpO1xyXG4gICAgcmV0dXJuIHRoaXMucGFyc2VDb3JlKGNoYXJzKTtcclxuICB9XHJcblxyXG4gIHBhcnNlQ29yZShjaGFycykge1xyXG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgQ0xleGVyLkNMZXhlcihjaGFycyk7XHJcbiAgICBjb25zdCB0b2tlbnMgPSBuZXcgYW50bHI0LkNvbW1vblRva2VuU3RyZWFtKGxleGVyKTtcclxuICAgIHRoaXMucGFyc2VyID0gbmV3IENQYXJzZXIuQ1BhcnNlcih0b2tlbnMpO1xyXG4gICAgdGhpcy5wYXJzZXIuYnVpbGRQYXJzZVRyZWVzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHRyZWUgPSB0aGlzLnBhcnNlci5jb21waWxhdGlvblVuaXQoKTtcclxuICAgIHJldHVybiBbdHJlZSwgdGhpcy5wYXJzZXJdO1xyXG4gIH1cclxuICB2aXNpdCh0cmVlKSB7XHJcbiAgICBpZiAodGhpcy5faXNEZWJ1Z01vZGUpIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJlZS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0KGVsZW1lbnQpO1xyXG4gICAgICAgIH0sICAgICAgICAgICAgICB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoISh0cmVlIGluc3RhbmNlb2YgYW50bHI0dHJlZS5UZXJtaW5hbE5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSB0aGlzLnBhcnNlci5ydWxlTmFtZXNbdHJlZS5ydWxlSW5kZXhdO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCcqKiogdmlzaXQgUnVsZSA6ICcgKyBydWxlTmFtZSArICcgKioqJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmV0ID0gc3VwZXIudmlzaXQodHJlZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdyZXR1cm5lZDogJyArIHJldCk7XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gc3VwZXIudmlzaXQodHJlZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2aXNpdENoaWxkcmVuKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW4pO1xyXG4gIH1cclxuXHJcbiAgdmlzaXRUZXJtaW5hbChub2RlKSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0KCk7XHJcbiAgICBpZiAodGhpcy5faXNEZWJ1Z01vZGUpIHtcclxuICAgICAgY29uc3QgX3BsdXMgPSAndmlzaXQgVEVSTUlOQUwgOiAnICsgdGV4dDtcclxuICAgICAgY29uc29sZS5sb2coX3BsdXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbiAgfVxyXG5cclxuICAvLyB2aXNpdFRyYW5zbGF0aW9uVW5pdChub2RlKSB7XHJcbiAgLy8gICBjb25zdCBwcm9ncmFtID0gbmV3IFVuaVByb2dyYW0oKTtcclxuICAvLyAgIHJldHVybiBwcm9ncmFtO1xyXG4gIC8vIH1cclxuICB2aXNpdERlY2xhcmF0b3Iobm9kZSkge1xyXG4gICAgcmV0dXJuIHN1cGVyLnZpc2l0RGVjbGFyYXRpb24obm9kZSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuQ01hcHBlciA9IENNYXBwZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hcHBlci9DTWFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbmV4cG9ydHMuQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG5leHBvcnRzLkFUTkRlc2VyaWFsaXplciA9IHJlcXVpcmUoJy4vQVRORGVzZXJpYWxpemVyJykuQVRORGVzZXJpYWxpemVyO1xuZXhwb3J0cy5MZXhlckFUTlNpbXVsYXRvciA9IHJlcXVpcmUoJy4vTGV4ZXJBVE5TaW11bGF0b3InKS5MZXhlckFUTlNpbXVsYXRvcjtcbmV4cG9ydHMuUGFyc2VyQVROU2ltdWxhdG9yID0gcmVxdWlyZSgnLi9QYXJzZXJBVE5TaW11bGF0b3InKS5QYXJzZXJBVE5TaW11bGF0b3I7XG5leHBvcnRzLlByZWRpY3Rpb25Nb2RlID0gcmVxdWlyZSgnLi9QcmVkaWN0aW9uTW9kZScpLlByZWRpY3Rpb25Nb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG52YXIgU2V0ID0gcmVxdWlyZSgnLi9VdGlscycpLlNldDtcbnZhciBCaXRTZXQgPSByZXF1aXJlKCcuL1V0aWxzJykuQml0U2V0O1xudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xudmFyIEFUTkNvbmZpZyA9IHJlcXVpcmUoJy4vYXRuL0FUTkNvbmZpZycpLkFUTkNvbmZpZztcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbnZhciBJbnRlcnZhbFNldCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbFNldDtcbnZhciBSdWxlU3RvcFN0YXRlID0gcmVxdWlyZSgnLi9hdG4vQVROU3RhdGUnKS5SdWxlU3RvcFN0YXRlO1xudmFyIFJ1bGVUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9hdG4vVHJhbnNpdGlvbicpLlJ1bGVUcmFuc2l0aW9uO1xudmFyIE5vdFNldFRyYW5zaXRpb24gPSByZXF1aXJlKCcuL2F0bi9UcmFuc2l0aW9uJykuTm90U2V0VHJhbnNpdGlvbjtcbnZhciBXaWxkY2FyZFRyYW5zaXRpb24gPSByZXF1aXJlKCcuL2F0bi9UcmFuc2l0aW9uJykuV2lsZGNhcmRUcmFuc2l0aW9uO1xudmFyIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vYXRuL1RyYW5zaXRpb24nKS5BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb247XG5cbnZhciBwYyA9IHJlcXVpcmUoJy4vUHJlZGljdGlvbkNvbnRleHQnKTtcbnZhciBwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dCA9IHBjLnByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0O1xudmFyIFByZWRpY3Rpb25Db250ZXh0ID0gcGMuUHJlZGljdGlvbkNvbnRleHQ7XG52YXIgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgPSBwYy5TaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcblxuZnVuY3Rpb24gTEwxQW5hbHl6ZXIgKGF0bikge1xuICAgIHRoaXMuYXRuID0gYXRuO1xufVxuXG4vLyogU3BlY2lhbCB2YWx1ZSBhZGRlZCB0byB0aGUgbG9va2FoZWFkIHNldHMgdG8gaW5kaWNhdGUgdGhhdCB3ZSBoaXRcbi8vICBhIHByZWRpY2F0ZSBkdXJpbmcgYW5hbHlzaXMgaWYge0Bjb2RlIHNlZVRocnVQcmVkcz09ZmFsc2V9LlxuLy8vXG5MTDFBbmFseXplci5ISVRfUFJFRCA9IFRva2VuLklOVkFMSURfVFlQRTtcblxuXG4vLypcbi8vIENhbGN1bGF0ZXMgdGhlIFNMTCgxKSBleHBlY3RlZCBsb29rYWhlYWQgc2V0IGZvciBlYWNoIG91dGdvaW5nIHRyYW5zaXRpb25cbi8vIG9mIGFuIHtAbGluayBBVE5TdGF0ZX0uIFRoZSByZXR1cm5lZCBhcnJheSBoYXMgb25lIGVsZW1lbnQgZm9yIGVhY2hcbi8vIG91dGdvaW5nIHRyYW5zaXRpb24gaW4ge0Bjb2RlIHN9LiBJZiB0aGUgY2xvc3VyZSBmcm9tIHRyYW5zaXRpb25cbi8vIDxlbT5pPC9lbT4gbGVhZHMgdG8gYSBzZW1hbnRpYyBwcmVkaWNhdGUgYmVmb3JlIG1hdGNoaW5nIGEgc3ltYm9sLCB0aGVcbi8vIGVsZW1lbnQgYXQgaW5kZXggPGVtPmk8L2VtPiBvZiB0aGUgcmVzdWx0IHdpbGwgYmUge0Bjb2RlIG51bGx9LlxuLy9cbi8vIEBwYXJhbSBzIHRoZSBBVE4gc3RhdGVcbi8vIEByZXR1cm4gdGhlIGV4cGVjdGVkIHN5bWJvbHMgZm9yIGVhY2ggb3V0Z29pbmcgdHJhbnNpdGlvbiBvZiB7QGNvZGUgc30uXG4vLy9cbkxMMUFuYWx5emVyLnByb3RvdHlwZS5nZXREZWNpc2lvbkxvb2thaGVhZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAocyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gcy50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgdmFyIGxvb2sgPSBbXTtcbiAgICBmb3IodmFyIGFsdD0wOyBhbHQ8IGNvdW50OyBhbHQrKykge1xuICAgICAgICBsb29rW2FsdF0gPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgdmFyIGxvb2tCdXN5ID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgc2VlVGhydVByZWRzID0gZmFsc2U7IC8vIGZhaWwgdG8gZ2V0IGxvb2thaGVhZCB1cG9uIHByZWRcbiAgICAgICAgdGhpcy5fTE9PSyhzLnRyYW5zaXRpb24oYWx0KS50YXJnZXQsIG51bGwsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZLFxuICAgICAgICAgICAgICBsb29rW2FsdF0sIGxvb2tCdXN5LCBuZXcgQml0U2V0KCksIHNlZVRocnVQcmVkcywgZmFsc2UpO1xuICAgICAgICAvLyBXaXBlIG91dCBsb29rYWhlYWQgZm9yIHRoaXMgYWx0ZXJuYXRpdmUgaWYgd2UgZm91bmQgbm90aGluZ1xuICAgICAgICAvLyBvciB3ZSBoYWQgYSBwcmVkaWNhdGUgd2hlbiB3ZSAhc2VlVGhydVByZWRzXG4gICAgICAgIGlmIChsb29rW2FsdF0ubGVuZ3RoPT09MCB8fCBsb29rW2FsdF0uY29udGFpbnMoTEwxQW5hbHl6ZXIuSElUX1BSRUQpKSB7XG4gICAgICAgICAgICBsb29rW2FsdF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb29rO1xufTtcblxuLy8qXG4vLyBDb21wdXRlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHtAY29kZSBzfSBpbiB0aGUgQVROIGluIHRoZVxuLy8gc3BlY2lmaWVkIHtAY29kZSBjdHh9LlxuLy9cbi8vIDxwPklmIHtAY29kZSBjdHh9IGlzIHtAY29kZSBudWxsfSBhbmQgdGhlIGVuZCBvZiB0aGUgcnVsZSBjb250YWluaW5nXG4vLyB7QGNvZGUgc30gaXMgcmVhY2hlZCwge0BsaW5rIFRva2VuLy9FUFNJTE9OfSBpcyBhZGRlZCB0byB0aGUgcmVzdWx0IHNldC5cbi8vIElmIHtAY29kZSBjdHh9IGlzIG5vdCB7QGNvZGUgbnVsbH0gYW5kIHRoZSBlbmQgb2YgdGhlIG91dGVybW9zdCBydWxlIGlzXG4vLyByZWFjaGVkLCB7QGxpbmsgVG9rZW4vL0VPRn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuPC9wPlxuLy9cbi8vIEBwYXJhbSBzIHRoZSBBVE4gc3RhdGVcbi8vIEBwYXJhbSBzdG9wU3RhdGUgdGhlIEFUTiBzdGF0ZSB0byBzdG9wIGF0LiBUaGlzIGNhbiBiZSBhXG4vLyB7QGxpbmsgQmxvY2tFbmRTdGF0ZX0gdG8gZGV0ZWN0IGVwc2lsb24gcGF0aHMgdGhyb3VnaCBhIGNsb3N1cmUuXG4vLyBAcGFyYW0gY3R4IHRoZSBjb21wbGV0ZSBwYXJzZXIgY29udGV4dCwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSBjb250ZXh0XG4vLyBzaG91bGQgYmUgaWdub3JlZFxuLy9cbi8vIEByZXR1cm4gVGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHtAY29kZSBzfSBpbiB0aGUgQVROIGluIHRoZVxuLy8gc3BlY2lmaWVkIHtAY29kZSBjdHh9LlxuLy8vXG5MTDFBbmFseXplci5wcm90b3R5cGUuTE9PSyA9IGZ1bmN0aW9uKHMsIHN0b3BTdGF0ZSwgY3R4KSB7XG4gICAgdmFyIHIgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICB2YXIgc2VlVGhydVByZWRzID0gdHJ1ZTsgLy8gaWdub3JlIHByZWRzOyBnZXQgYWxsIGxvb2thaGVhZFxuXHRjdHggPSBjdHggfHwgbnVsbDtcbiAgICB2YXIgbG9va0NvbnRleHQgPSBjdHghPT1udWxsID8gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQocy5hdG4sIGN0eCkgOiBudWxsO1xuICAgIHRoaXMuX0xPT0socywgc3RvcFN0YXRlLCBsb29rQ29udGV4dCwgciwgbmV3IFNldCgpLCBuZXcgQml0U2V0KCksIHNlZVRocnVQcmVkcywgdHJ1ZSk7XG4gICAgcmV0dXJuIHI7XG59O1xuXG4vLypcbi8vIENvbXB1dGUgc2V0IG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cge0Bjb2RlIHN9IGluIHRoZSBBVE4gaW4gdGhlXG4vLyBzcGVjaWZpZWQge0Bjb2RlIGN0eH0uXG4vL1xuLy8gPHA+SWYge0Bjb2RlIGN0eH0gaXMge0Bjb2RlIG51bGx9IGFuZCB7QGNvZGUgc3RvcFN0YXRlfSBvciB0aGUgZW5kIG9mIHRoZVxuLy8gcnVsZSBjb250YWluaW5nIHtAY29kZSBzfSBpcyByZWFjaGVkLCB7QGxpbmsgVG9rZW4vL0VQU0lMT059IGlzIGFkZGVkIHRvXG4vLyB0aGUgcmVzdWx0IHNldC4gSWYge0Bjb2RlIGN0eH0gaXMgbm90IHtAY29kZSBudWxsfSBhbmQge0Bjb2RlIGFkZEVPRn0gaXNcbi8vIHtAY29kZSB0cnVlfSBhbmQge0Bjb2RlIHN0b3BTdGF0ZX0gb3IgdGhlIGVuZCBvZiB0aGUgb3V0ZXJtb3N0IHJ1bGUgaXNcbi8vIHJlYWNoZWQsIHtAbGluayBUb2tlbi8vRU9GfSBpcyBhZGRlZCB0byB0aGUgcmVzdWx0IHNldC48L3A+XG4vL1xuLy8gQHBhcmFtIHMgdGhlIEFUTiBzdGF0ZS5cbi8vIEBwYXJhbSBzdG9wU3RhdGUgdGhlIEFUTiBzdGF0ZSB0byBzdG9wIGF0LiBUaGlzIGNhbiBiZSBhXG4vLyB7QGxpbmsgQmxvY2tFbmRTdGF0ZX0gdG8gZGV0ZWN0IGVwc2lsb24gcGF0aHMgdGhyb3VnaCBhIGNsb3N1cmUuXG4vLyBAcGFyYW0gY3R4IFRoZSBvdXRlciBjb250ZXh0LCBvciB7QGNvZGUgbnVsbH0gaWYgdGhlIG91dGVyIGNvbnRleHQgc2hvdWxkXG4vLyBub3QgYmUgdXNlZC5cbi8vIEBwYXJhbSBsb29rIFRoZSByZXN1bHQgbG9va2FoZWFkIHNldC5cbi8vIEBwYXJhbSBsb29rQnVzeSBBIHNldCB1c2VkIGZvciBwcmV2ZW50aW5nIGVwc2lsb24gY2xvc3VyZXMgaW4gdGhlIEFUTlxuLy8gZnJvbSBjYXVzaW5nIGEgc3RhY2sgb3ZlcmZsb3cuIE91dHNpZGUgY29kZSBzaG91bGQgcGFzc1xuLy8ge0Bjb2RlIG5ldyBTZXQ8QVROQ29uZmlnPn0gZm9yIHRoaXMgYXJndW1lbnQuXG4vLyBAcGFyYW0gY2FsbGVkUnVsZVN0YWNrIEEgc2V0IHVzZWQgZm9yIHByZXZlbnRpbmcgbGVmdCByZWN1cnNpb24gaW4gdGhlXG4vLyBBVE4gZnJvbSBjYXVzaW5nIGEgc3RhY2sgb3ZlcmZsb3cuIE91dHNpZGUgY29kZSBzaG91bGQgcGFzc1xuLy8ge0Bjb2RlIG5ldyBCaXRTZXQoKX0gZm9yIHRoaXMgYXJndW1lbnQuXG4vLyBAcGFyYW0gc2VlVGhydVByZWRzIHtAY29kZSB0cnVlfSB0byB0cnVlIHNlbWFudGljIHByZWRpY2F0ZXMgYXNcbi8vIGltcGxpY2l0bHkge0Bjb2RlIHRydWV9IGFuZCBcInNlZSB0aHJvdWdoIHRoZW1cIiwgb3RoZXJ3aXNlIHtAY29kZSBmYWxzZX1cbi8vIHRvIHRyZWF0IHNlbWFudGljIHByZWRpY2F0ZXMgYXMgb3BhcXVlIGFuZCBhZGQge0BsaW5rIC8vSElUX1BSRUR9IHRvIHRoZVxuLy8gcmVzdWx0IGlmIG9uZSBpcyBlbmNvdW50ZXJlZC5cbi8vIEBwYXJhbSBhZGRFT0YgQWRkIHtAbGluayBUb2tlbi8vRU9GfSB0byB0aGUgcmVzdWx0IGlmIHRoZSBlbmQgb2YgdGhlXG4vLyBvdXRlcm1vc3QgY29udGV4dCBpcyByZWFjaGVkLiBUaGlzIHBhcmFtZXRlciBoYXMgbm8gZWZmZWN0IGlmIHtAY29kZSBjdHh9XG4vLyBpcyB7QGNvZGUgbnVsbH0uXG4vLy9cbkxMMUFuYWx5emVyLnByb3RvdHlwZS5fTE9PSyA9IGZ1bmN0aW9uKHMsIHN0b3BTdGF0ZSAsIGN0eCwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpIHtcbiAgICB2YXIgYyA9IG5ldyBBVE5Db25maWcoe3N0YXRlOnMsIGFsdDowLCBjb250ZXh0OiBjdHh9LCBudWxsKTtcbiAgICBpZiAobG9va0J1c3kuY29udGFpbnMoYykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb29rQnVzeS5hZGQoYyk7XG4gICAgaWYgKHMgPT09IHN0b3BTdGF0ZSkge1xuICAgICAgICBpZiAoY3R4ID09PW51bGwpIHtcbiAgICAgICAgICAgIGxvb2suYWRkT25lKFRva2VuLkVQU0lMT04pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5pc0VtcHR5KCkgJiYgYWRkRU9GKSB7XG4gICAgICAgICAgICBsb29rLmFkZE9uZShUb2tlbi5FT0YpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSApIHtcbiAgICAgICAgaWYgKGN0eCA9PT1udWxsKSB7XG4gICAgICAgICAgICBsb29rLmFkZE9uZShUb2tlbi5FUFNJTE9OKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguaXNFbXB0eSgpICYmIGFkZEVPRikge1xuICAgICAgICAgICAgbG9vay5hZGRPbmUoVG9rZW4uRU9GKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuICAgICAgICAgICAgLy8gcnVuIHRocnUgYWxsIHBvc3NpYmxlIHN0YWNrIHRvcHMgaW4gY3R4XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxjdHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY3R4LmdldFJldHVyblN0YXRlKGkpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGNhbGxlZFJ1bGVTdGFjay5jb250YWlucyhyZXR1cm5TdGF0ZS5ydWxlSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZFJ1bGVTdGFjay5yZW1vdmUocmV0dXJuU3RhdGUucnVsZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fTE9PSyhyZXR1cm5TdGF0ZSwgc3RvcFN0YXRlLCBjdHguZ2V0UGFyZW50KGkpLCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZFJ1bGVTdGFjay5hZGQocmV0dXJuU3RhdGUucnVsZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajxzLnRyYW5zaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciB0ID0gcy50cmFuc2l0aW9uc1tqXTtcbiAgICAgICAgaWYgKHQuY29uc3RydWN0b3IgPT09IFJ1bGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkUnVsZVN0YWNrLmNvbnRhaW5zKHQudGFyZ2V0LnJ1bGVJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKGN0eCwgdC5mb2xsb3dTdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxlZFJ1bGVTdGFjay5hZGQodC50YXJnZXQucnVsZUluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9MT09LKHQudGFyZ2V0LCBzdG9wU3RhdGUsIG5ld0NvbnRleHQsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLnJlbW92ZSh0LnRhcmdldC5ydWxlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gKSB7XG4gICAgICAgICAgICBpZiAoc2VlVGhydVByZWRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9vay5hZGRPbmUoTEwxQW5hbHl6ZXIuSElUX1BSRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIHQuaXNFcHNpbG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9MT09LKHQudGFyZ2V0LCBzdG9wU3RhdGUsIGN0eCwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xuICAgICAgICB9IGVsc2UgaWYgKHQuY29uc3RydWN0b3IgPT09IFdpbGRjYXJkVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgbG9vay5hZGRSYW5nZSggVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gdC5sYWJlbDtcbiAgICAgICAgICAgIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gc2V0LmNvbXBsZW1lbnQoVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9vay5hZGRTZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydHMuTEwxQW5hbHl6ZXIgPSBMTDFBbmFseXplcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0xMMUFuYWx5emVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gUmVwcmVzZW50cyB0aGUgdHlwZSBvZiByZWNvZ25pemVyIGFuIEFUTiBhcHBsaWVzIHRvLlxuXG5mdW5jdGlvbiBBVE5UeXBlKCkge1xuXG59XG5cbkFUTlR5cGUuTEVYRVIgPSAwO1xuQVROVHlwZS5QQVJTRVIgPSAxO1xuXG5leHBvcnRzLkFUTlR5cGUgPSBBVE5UeXBlO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTlR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gV2hlbiB3ZSBoaXQgYW4gYWNjZXB0IHN0YXRlIGluIGVpdGhlciB0aGUgREZBIG9yIHRoZSBBVE4sIHdlXG4vLyAgaGF2ZSB0byBub3RpZnkgdGhlIGNoYXJhY3RlciBzdHJlYW0gdG8gc3RhcnQgYnVmZmVyaW5nIGNoYXJhY3RlcnNcbi8vICB2aWEge0BsaW5rIEludFN0cmVhbS8vbWFya30gYW5kIHJlY29yZCB0aGUgY3VycmVudCBzdGF0ZS4gVGhlIGN1cnJlbnQgc2ltIHN0YXRlXG4vLyAgaW5jbHVkZXMgdGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgaW5wdXQsIHRoZSBjdXJyZW50IGxpbmUsXG4vLyAgYW5kIGN1cnJlbnQgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHRoYXQgbGluZS4gTm90ZSB0aGF0IHRoZSBMZXhlciBpc1xuLy8gIHRyYWNraW5nIHRoZSBzdGFydGluZyBsaW5lIGFuZCBjaGFyYWN0ZXJpemF0aW9uIG9mIHRoZSB0b2tlbi4gVGhlc2Vcbi8vICB2YXJpYWJsZXMgdHJhY2sgdGhlIFwic3RhdGVcIiBvZiB0aGUgc2ltdWxhdG9yIHdoZW4gaXQgaGl0cyBhbiBhY2NlcHQgc3RhdGUuXG4vL1xuLy8gIDxwPldlIHRyYWNrIHRoZXNlIHZhcmlhYmxlcyBzZXBhcmF0ZWx5IGZvciB0aGUgREZBIGFuZCBBVE4gc2ltdWxhdGlvblxuLy8gIGJlY2F1c2UgdGhlIERGQSBzaW11bGF0aW9uIG9mdGVuIGhhcyB0byBmYWlsIG92ZXIgdG8gdGhlIEFUTlxuLy8gIHNpbXVsYXRpb24uIElmIHRoZSBBVE4gc2ltdWxhdGlvbiBmYWlscywgd2UgbmVlZCB0aGUgREZBIHRvIGZhbGxcbi8vICBiYWNrIHRvIGl0cyBwcmV2aW91c2x5IGFjY2VwdGVkIHN0YXRlLCBpZiBhbnkuIElmIHRoZSBBVE4gc3VjY2VlZHMsXG4vLyAgdGhlbiB0aGUgQVROIGRvZXMgdGhlIGFjY2VwdCBhbmQgdGhlIERGQSBzaW11bGF0b3IgdGhhdCBpbnZva2VkIGl0XG4vLyAgY2FuIHNpbXBseSByZXR1cm4gdGhlIHByZWRpY3RlZCB0b2tlbiB0eXBlLjwvcD5cbi8vL1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLy4uL1Rva2VuJykuVG9rZW47XG52YXIgTGV4ZXIgPSByZXF1aXJlKCcuLy4uL0xleGVyJykuTGV4ZXI7XG52YXIgQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG52YXIgQVROU2ltdWxhdG9yID0gcmVxdWlyZSgnLi9BVE5TaW11bGF0b3InKS5BVE5TaW11bGF0b3I7XG52YXIgREZBU3RhdGUgPSByZXF1aXJlKCcuLy4uL2RmYS9ERkFTdGF0ZScpLkRGQVN0YXRlO1xudmFyIEFUTkNvbmZpZ1NldCA9IHJlcXVpcmUoJy4vQVROQ29uZmlnU2V0JykuQVROQ29uZmlnU2V0O1xudmFyIE9yZGVyZWRBVE5Db25maWdTZXQgPSByZXF1aXJlKCcuL0FUTkNvbmZpZ1NldCcpLk9yZGVyZWRBVE5Db25maWdTZXQ7XG52YXIgUHJlZGljdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLy4uL1ByZWRpY3Rpb25Db250ZXh0JykuUHJlZGljdGlvbkNvbnRleHQ7XG52YXIgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLy4uL1ByZWRpY3Rpb25Db250ZXh0JykuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQ7XG52YXIgUnVsZVN0b3BTdGF0ZSA9IHJlcXVpcmUoJy4vQVROU3RhdGUnKS5SdWxlU3RvcFN0YXRlO1xudmFyIExleGVyQVROQ29uZmlnID0gcmVxdWlyZSgnLi9BVE5Db25maWcnKS5MZXhlckFUTkNvbmZpZztcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uJykuVHJhbnNpdGlvbjtcbnZhciBMZXhlckFjdGlvbkV4ZWN1dG9yID0gcmVxdWlyZSgnLi9MZXhlckFjdGlvbkV4ZWN1dG9yJykuTGV4ZXJBY3Rpb25FeGVjdXRvcjtcbnZhciBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uID0gcmVxdWlyZSgnLi8uLi9lcnJvci9FcnJvcnMnKS5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uO1xuXG5mdW5jdGlvbiByZXNldFNpbVN0YXRlKHNpbSkge1xuXHRzaW0uaW5kZXggPSAtMTtcblx0c2ltLmxpbmUgPSAwO1xuXHRzaW0uY29sdW1uID0gLTE7XG5cdHNpbS5kZmFTdGF0ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFNpbVN0YXRlKCkge1xuXHRyZXNldFNpbVN0YXRlKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuU2ltU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHJlc2V0U2ltU3RhdGUodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBMZXhlckFUTlNpbXVsYXRvcihyZWNvZywgYXRuLCBkZWNpc2lvblRvREZBLCBzaGFyZWRDb250ZXh0Q2FjaGUpIHtcblx0QVROU2ltdWxhdG9yLmNhbGwodGhpcywgYXRuLCBzaGFyZWRDb250ZXh0Q2FjaGUpO1xuXHR0aGlzLmRlY2lzaW9uVG9ERkEgPSBkZWNpc2lvblRvREZBO1xuXHR0aGlzLnJlY29nID0gcmVjb2c7XG5cdC8vIFRoZSBjdXJyZW50IHRva2VuJ3Mgc3RhcnRpbmcgaW5kZXggaW50byB0aGUgY2hhcmFjdGVyIHN0cmVhbS5cblx0Ly8gU2hhcmVkIGFjcm9zcyBERkEgdG8gQVROIHNpbXVsYXRpb24gaW4gY2FzZSB0aGUgQVROIGZhaWxzIGFuZCB0aGVcblx0Ly8gREZBIGRpZCBub3QgaGF2ZSBhIHByZXZpb3VzIGFjY2VwdCBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSB1c2UgdGhlXG5cdC8vIEFUTi1nZW5lcmF0ZWQgZXhjZXB0aW9uIG9iamVjdC5cblx0dGhpcy5zdGFydEluZGV4ID0gLTE7XG5cdC8vIGxpbmUgbnVtYmVyIDEuLm4gd2l0aGluIHRoZSBpbnB1dC8vL1xuXHR0aGlzLmxpbmUgPSAxO1xuXHQvLyBUaGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG5cdC8vIDAuLm4tMS8vL1xuXHR0aGlzLmNvbHVtbiA9IDA7XG5cdHRoaXMubW9kZSA9IExleGVyLkRFRkFVTFRfTU9ERTtcblx0Ly8gVXNlZCBkdXJpbmcgREZBL0FUTiBleGVjIHRvIHJlY29yZCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0IGNvbmZpZ3VyYXRpb25cblx0Ly8gaW5mb1xuXHR0aGlzLnByZXZBY2NlcHQgPSBuZXcgU2ltU3RhdGUoKTtcblx0Ly8gZG9uZVxuXHRyZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TaW11bGF0b3IucHJvdG90eXBlKTtcbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyQVROU2ltdWxhdG9yO1xuXG5MZXhlckFUTlNpbXVsYXRvci5kZWJ1ZyA9IGZhbHNlO1xuTGV4ZXJBVE5TaW11bGF0b3IuZGZhX2RlYnVnID0gZmFsc2U7XG5cbkxleGVyQVROU2ltdWxhdG9yLk1JTl9ERkFfRURHRSA9IDA7XG5MZXhlckFUTlNpbXVsYXRvci5NQVhfREZBX0VER0UgPSAxMjc7IC8vIGZvcmNlcyB1bmljb2RlIHRvIHN0YXkgaW4gQVROXG5cbkxleGVyQVROU2ltdWxhdG9yLm1hdGNoX2NhbGxzID0gMDtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvcHlTdGF0ZSA9IGZ1bmN0aW9uKHNpbXVsYXRvcikge1xuXHR0aGlzLmNvbHVtbiA9IHNpbXVsYXRvci5jb2x1bW47XG5cdHRoaXMubGluZSA9IHNpbXVsYXRvci5saW5lO1xuXHR0aGlzLm1vZGUgPSBzaW11bGF0b3IubW9kZTtcblx0dGhpcy5zdGFydEluZGV4ID0gc2ltdWxhdG9yLnN0YXJ0SW5kZXg7XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihpbnB1dCwgbW9kZSkge1xuXHR0aGlzLm1hdGNoX2NhbGxzICs9IDE7XG5cdHRoaXMubW9kZSA9IG1vZGU7XG5cdHZhciBtYXJrID0gaW5wdXQubWFyaygpO1xuXHR0cnkge1xuXHRcdHRoaXMuc3RhcnRJbmRleCA9IGlucHV0LmluZGV4O1xuXHRcdHRoaXMucHJldkFjY2VwdC5yZXNldCgpO1xuXHRcdHZhciBkZmEgPSB0aGlzLmRlY2lzaW9uVG9ERkFbbW9kZV07XG5cdFx0aWYgKGRmYS5zMCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWF0Y2hBVE4oaW5wdXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5leGVjQVROKGlucHV0LCBkZmEuczApO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpbnB1dC5yZWxlYXNlKG1hcmspO1xuXHR9XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5wcmV2QWNjZXB0LnJlc2V0KCk7XG5cdHRoaXMuc3RhcnRJbmRleCA9IC0xO1xuXHR0aGlzLmxpbmUgPSAxO1xuXHR0aGlzLmNvbHVtbiA9IDA7XG5cdHRoaXMubW9kZSA9IExleGVyLkRFRkFVTFRfTU9ERTtcbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5tYXRjaEFUTiA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHZhciBzdGFydFN0YXRlID0gdGhpcy5hdG4ubW9kZVRvU3RhcnRTdGF0ZVt0aGlzLm1vZGVdO1xuXG5cdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdGNvbnNvbGUubG9nKFwibWF0Y2hBVE4gbW9kZSBcIiArIHRoaXMubW9kZSArIFwiIHN0YXJ0OiBcIiArIHN0YXJ0U3RhdGUpO1xuXHR9XG5cdHZhciBvbGRfbW9kZSA9IHRoaXMubW9kZTtcblx0dmFyIHMwX2Nsb3N1cmUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGlucHV0LCBzdGFydFN0YXRlKTtcblx0dmFyIHN1cHByZXNzRWRnZSA9IHMwX2Nsb3N1cmUuaGFzU2VtYW50aWNDb250ZXh0O1xuXHRzMF9jbG9zdXJlLmhhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xuXG5cdHZhciBuZXh0ID0gdGhpcy5hZGRERkFTdGF0ZShzMF9jbG9zdXJlKTtcblx0aWYgKCFzdXBwcmVzc0VkZ2UpIHtcblx0XHR0aGlzLmRlY2lzaW9uVG9ERkFbdGhpcy5tb2RlXS5zMCA9IG5leHQ7XG5cdH1cblxuXHR2YXIgcHJlZGljdCA9IHRoaXMuZXhlY0FUTihpbnB1dCwgbmV4dCk7XG5cblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJERkEgYWZ0ZXIgbWF0Y2hBVE46IFwiICsgdGhpcy5kZWNpc2lvblRvREZBW29sZF9tb2RlXS50b0xleGVyU3RyaW5nKCkpO1xuXHR9XG5cdHJldHVybiBwcmVkaWN0O1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmV4ZWNBVE4gPSBmdW5jdGlvbihpbnB1dCwgZHMwKSB7XG5cdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdGNvbnNvbGUubG9nKFwic3RhcnQgc3RhdGUgY2xvc3VyZT1cIiArIGRzMC5jb25maWdzKTtcblx0fVxuXHRpZiAoZHMwLmlzQWNjZXB0U3RhdGUpIHtcblx0XHQvLyBhbGxvdyB6ZXJvLWxlbmd0aCB0b2tlbnNcblx0XHR0aGlzLmNhcHR1cmVTaW1TdGF0ZSh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBkczApO1xuXHR9XG5cdHZhciB0ID0gaW5wdXQuTEEoMSk7XG5cdHZhciBzID0gZHMwOyAvLyBzIGlzIGN1cnJlbnQvZnJvbSBERkEgc3RhdGVcblxuXHR3aGlsZSAodHJ1ZSkgeyAvLyB3aGlsZSBtb3JlIHdvcmtcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiZXhlY0FUTiBsb29wIHN0YXJ0aW5nIGNsb3N1cmU6IFwiICsgcy5jb25maWdzKTtcblx0XHR9XG5cblx0XHQvLyBBcyB3ZSBtb3ZlIHNyYy0+dHJnLCBzcmMtPnRyZywgd2Uga2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgdHJnIHRvXG5cdFx0Ly8gYXZvaWQgbG9va2luZyB1cCB0aGUgREZBIHN0YXRlIGFnYWluLCB3aGljaCBpcyBleHBlbnNpdmUuXG5cdFx0Ly8gSWYgdGhlIHByZXZpb3VzIHRhcmdldCB3YXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBERkEsIHdlIG1pZ2h0XG5cdFx0Ly8gYmUgYWJsZSB0byBhdm9pZCBkb2luZyBhIHJlYWNoIG9wZXJhdGlvbiB1cG9uIHQuIElmIHMhPW51bGwsXG5cdFx0Ly8gaXQgbWVhbnMgdGhhdCBzZW1hbnRpYyBwcmVkaWNhdGVzIGRpZG4ndCBwcmV2ZW50IHVzIGZyb21cblx0XHQvLyBjcmVhdGluZyBhIERGQSBzdGF0ZS4gT25jZSB3ZSBrbm93IHMhPW51bGwsIHdlIGNoZWNrIHRvIHNlZSBpZlxuXHRcdC8vIHRoZSBERkEgc3RhdGUgaGFzIGFuIGVkZ2UgYWxyZWFkeSBmb3IgdC4gSWYgc28sIHdlIGNhbiBqdXN0IHJldXNlXG5cdFx0Ly8gaXQncyBjb25maWd1cmF0aW9uIHNldDsgdGhlcmUncyBubyBwb2ludCBpbiByZS1jb21wdXRpbmcgaXQuXG5cdFx0Ly8gVGhpcyBpcyBraW5kIG9mIGxpa2UgZG9pbmcgREZBIHNpbXVsYXRpb24gd2l0aGluIHRoZSBBVE5cblx0XHQvLyBzaW11bGF0aW9uIGJlY2F1c2UgREZBIHNpbXVsYXRpb24gaXMgcmVhbGx5IGp1c3QgYSB3YXkgdG8gYXZvaWRcblx0XHQvLyBjb21wdXRpbmcgcmVhY2gvY2xvc3VyZSBzZXRzLiBUZWNobmljYWxseSwgb25jZSB3ZSBrbm93IHRoYXRcblx0XHQvLyB3ZSBoYXZlIGEgcHJldmlvdXNseSBhZGRlZCBERkEgc3RhdGUsIHdlIGNvdWxkIGp1bXAgb3ZlciB0b1xuXHRcdC8vIHRoZSBERkEgc2ltdWxhdG9yLiBCdXQsIHRoYXQgd291bGQgbWVhbiBwb3BwaW5nIGJhY2sgYW5kIGZvcnRoXG5cdFx0Ly8gYSBsb3QgYW5kIG1ha2luZyB0aGluZ3MgbW9yZSBjb21wbGljYXRlZCBhbGdvcml0aG1pY2FsbHkuXG5cdFx0Ly8gVGhpcyBvcHRpbWl6YXRpb24gbWFrZXMgYSBsb3Qgb2Ygc2Vuc2UgZm9yIGxvb3BzIHdpdGhpbiBERkEuXG5cdFx0Ly8gQSBjaGFyYWN0ZXIgd2lsbCB0YWtlIHVzIGJhY2sgdG8gYW4gZXhpc3RpbmcgREZBIHN0YXRlXG5cdFx0Ly8gdGhhdCBhbHJlYWR5IGhhcyBsb3RzIG9mIGVkZ2VzIG91dCBvZiBpdC4gZS5nLiwgLiogaW4gY29tbWVudHMuXG5cdFx0Ly8gcHJpbnQoXCJUYXJnZXQgZm9yOlwiICsgc3RyKHMpICsgXCIgYW5kOlwiICsgc3RyKHQpKVxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocywgdCk7XG5cdFx0Ly8gcHJpbnQoXCJFeGlzdGluZzpcIiArIHN0cih0YXJnZXQpKVxuXHRcdGlmICh0YXJnZXQgPT09IG51bGwpIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGlucHV0LCBzLCB0KTtcblx0XHRcdC8vIHByaW50KFwiQ29tcHV0ZWQ6XCIgKyBzdHIodGFyZ2V0KSlcblx0XHR9XG5cdFx0aWYgKHRhcmdldCA9PT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbnN1bWFibGUgaW5wdXQgZWxlbWVudCwgbWFrZSBzdXJlIHRvIGNvbnN1bWUgYmVmb3JlXG5cdFx0Ly8gY2FwdHVyaW5nIHRoZSBhY2NlcHQgc3RhdGUgc28gdGhlIGlucHV0IGluZGV4LCBsaW5lLCBhbmQgY2hhclxuXHRcdC8vIHBvc2l0aW9uIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgc3RhdGUgb2YgdGhlIGludGVycHJldGVyIGF0IHRoZVxuXHRcdC8vIGVuZCBvZiB0aGUgdG9rZW4uXG5cdFx0aWYgKHQgIT09IFRva2VuLkVPRikge1xuXHRcdFx0dGhpcy5jb25zdW1lKGlucHV0KTtcblx0XHR9XG5cdFx0aWYgKHRhcmdldC5pc0FjY2VwdFN0YXRlKSB7XG5cdFx0XHR0aGlzLmNhcHR1cmVTaW1TdGF0ZSh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCB0YXJnZXQpO1xuXHRcdFx0aWYgKHQgPT09IFRva2VuLkVPRikge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0dCA9IGlucHV0LkxBKDEpO1xuXHRcdHMgPSB0YXJnZXQ7IC8vIGZsaXA7IGN1cnJlbnQgREZBIHRhcmdldCBiZWNvbWVzIG5ldyBzcmMvZnJvbSBzdGF0ZVxuXHR9XG5cdHJldHVybiB0aGlzLmZhaWxPckFjY2VwdCh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBzLmNvbmZpZ3MsIHQpO1xufTtcblxuLy8gR2V0IGFuIGV4aXN0aW5nIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLiBJZiB0aGUgdGFyZ2V0IHN0YXRlXG4vLyBmb3IgdGhlIGVkZ2UgaGFzIG5vdCB5ZXQgYmVlbiBjb21wdXRlZCBvciBpcyBvdGhlcndpc2Ugbm90IGF2YWlsYWJsZSxcbi8vIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9LlxuLy9cbi8vIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxuLy8gQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXG4vLyBAcmV0dXJuIFRoZSBleGlzdGluZyB0YXJnZXQgREZBIHN0YXRlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc3ltYm9sXG4vLyB7QGNvZGUgdH0sIG9yIHtAY29kZSBudWxsfSBpZiB0aGUgdGFyZ2V0IHN0YXRlIGZvciB0aGlzIGVkZ2UgaXMgbm90XG4vLyBhbHJlYWR5IGNhY2hlZFxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUgPSBmdW5jdGlvbihzLCB0KSB7XG5cdGlmIChzLmVkZ2VzID09PSBudWxsIHx8IHQgPCBMZXhlckFUTlNpbXVsYXRvci5NSU5fREZBX0VER0UgfHwgdCA+IExleGVyQVROU2ltdWxhdG9yLk1BWF9ERkFfRURHRSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIHRhcmdldCA9IHMuZWRnZXNbdCAtIExleGVyQVROU2ltdWxhdG9yLk1JTl9ERkFfRURHRV07XG5cdGlmKHRhcmdldD09PXVuZGVmaW5lZCkge1xuXHRcdHRhcmdldCA9IG51bGw7XG5cdH1cblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnICYmIHRhcmdldCAhPT0gbnVsbCkge1xuXHRcdGNvbnNvbGUubG9nKFwicmV1c2Ugc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyICsgXCIgZWRnZSB0byBcIiArIHRhcmdldC5zdGF0ZU51bWJlcik7XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbi8vIENvbXB1dGUgYSB0YXJnZXQgc3RhdGUgZm9yIGFuIGVkZ2UgaW4gdGhlIERGQSwgYW5kIGF0dGVtcHQgdG8gYWRkIHRoZVxuLy8gY29tcHV0ZWQgc3RhdGUgYW5kIGNvcnJlc3BvbmRpbmcgZWRnZSB0byB0aGUgREZBLlxuLy9cbi8vIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgc3RyZWFtXG4vLyBAcGFyYW0gcyBUaGUgY3VycmVudCBERkEgc3RhdGVcbi8vIEBwYXJhbSB0IFRoZSBuZXh0IGlucHV0IHN5bWJvbFxuLy9cbi8vIEByZXR1cm4gVGhlIGNvbXB1dGVkIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcbi8vIHtAY29kZSB0fS4gSWYge0Bjb2RlIHR9IGRvZXMgbm90IGxlYWQgdG8gYSB2YWxpZCBERkEgc3RhdGUsIHRoaXMgbWV0aG9kXG4vLyByZXR1cm5zIHtAbGluayAvL0VSUk9SfS5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jb21wdXRlVGFyZ2V0U3RhdGUgPSBmdW5jdGlvbihpbnB1dCwgcywgdCkge1xuXHR2YXIgcmVhY2ggPSBuZXcgT3JkZXJlZEFUTkNvbmZpZ1NldCgpO1xuXHQvLyBpZiB3ZSBkb24ndCBmaW5kIGFuIGV4aXN0aW5nIERGQSBzdGF0ZVxuXHQvLyBGaWxsIHJlYWNoIHN0YXJ0aW5nIGZyb20gY2xvc3VyZSwgZm9sbG93aW5nIHQgdHJhbnNpdGlvbnNcblx0dGhpcy5nZXRSZWFjaGFibGVDb25maWdTZXQoaW5wdXQsIHMuY29uZmlncywgcmVhY2gsIHQpO1xuXG5cdGlmIChyZWFjaC5pdGVtcy5sZW5ndGggPT09IDApIHsgLy8gd2UgZ290IG5vd2hlcmUgb24gdCBmcm9tIHNcblx0XHRpZiAoIXJlYWNoLmhhc1NlbWFudGljQ29udGV4dCkge1xuXHRcdFx0Ly8gd2UgZ290IG5vd2hlcmUgb24gdCwgZG9uJ3QgdGhyb3cgb3V0IHRoaXMga25vd2xlZGdlOyBpdCdkXG5cdFx0XHQvLyBjYXVzZSBhIGZhaWxvdmVyIGZyb20gREZBIGxhdGVyLlxuXHRcdFx0dGhpcy5hZGRERkFFZGdlKHMsIHQsIEFUTlNpbXVsYXRvci5FUlJPUik7XG5cdFx0fVxuXHRcdC8vIHN0b3Agd2hlbiB3ZSBjYW4ndCBtYXRjaCBhbnkgbW9yZSBjaGFyXG5cdFx0cmV0dXJuIEFUTlNpbXVsYXRvci5FUlJPUjtcblx0fVxuXHQvLyBBZGQgYW4gZWRnZSBmcm9tIHMgdG8gdGFyZ2V0IERGQSBmb3VuZC9jcmVhdGVkIGZvciByZWFjaFxuXHRyZXR1cm4gdGhpcy5hZGRERkFFZGdlKHMsIHQsIG51bGwsIHJlYWNoKTtcbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5mYWlsT3JBY2NlcHQgPSBmdW5jdGlvbihwcmV2QWNjZXB0LCBpbnB1dCwgcmVhY2gsIHQpIHtcblx0aWYgKHRoaXMucHJldkFjY2VwdC5kZmFTdGF0ZSAhPT0gbnVsbCkge1xuXHRcdHZhciBsZXhlckFjdGlvbkV4ZWN1dG9yID0gcHJldkFjY2VwdC5kZmFTdGF0ZS5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuXHRcdHRoaXMuYWNjZXB0KGlucHV0LCBsZXhlckFjdGlvbkV4ZWN1dG9yLCB0aGlzLnN0YXJ0SW5kZXgsXG5cdFx0XHRcdHByZXZBY2NlcHQuaW5kZXgsIHByZXZBY2NlcHQubGluZSwgcHJldkFjY2VwdC5jb2x1bW4pO1xuXHRcdHJldHVybiBwcmV2QWNjZXB0LmRmYVN0YXRlLnByZWRpY3Rpb247XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaWYgbm8gYWNjZXB0IGFuZCBFT0YgaXMgZmlyc3QgY2hhciwgcmV0dXJuIEVPRlxuXHRcdGlmICh0ID09PSBUb2tlbi5FT0YgJiYgaW5wdXQuaW5kZXggPT09IHRoaXMuc3RhcnRJbmRleCkge1xuXHRcdFx0cmV0dXJuIFRva2VuLkVPRjtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5yZWNvZywgaW5wdXQsIHRoaXMuc3RhcnRJbmRleCwgcmVhY2gpO1xuXHR9XG59O1xuXG4vLyBHaXZlbiBhIHN0YXJ0aW5nIGNvbmZpZ3VyYXRpb24gc2V0LCBmaWd1cmUgb3V0IGFsbCBBVE4gY29uZmlndXJhdGlvbnNcbi8vIHdlIGNhbiByZWFjaCB1cG9uIGlucHV0IHtAY29kZSB0fS4gUGFyYW1ldGVyIHtAY29kZSByZWFjaH0gaXMgYSByZXR1cm5cbi8vIHBhcmFtZXRlci5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRSZWFjaGFibGVDb25maWdTZXQgPSBmdW5jdGlvbihpbnB1dCwgY2xvc3VyZSxcblx0XHRyZWFjaCwgdCkge1xuXHQvLyB0aGlzIGlzIHVzZWQgdG8gc2tpcCBwcm9jZXNzaW5nIGZvciBjb25maWdzIHdoaWNoIGhhdmUgYSBsb3dlciBwcmlvcml0eVxuXHQvLyB0aGFuIGEgY29uZmlnIHRoYXQgYWxyZWFkeSByZWFjaGVkIGFuIGFjY2VwdCBzdGF0ZSBmb3IgdGhlIHNhbWUgcnVsZVxuXHR2YXIgc2tpcEFsdCA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2xvc3VyZS5pdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjZmcgPSBjbG9zdXJlLml0ZW1zW2ldO1xuXHRcdHZhciBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gKGNmZy5hbHQgPT09IHNraXBBbHQpO1xuXHRcdGlmIChjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlICYmIGNmZy5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24pIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwidGVzdGluZyAlcyBhdCAlc1xcblwiLCB0aGlzLmdldFRva2VuTmFtZSh0KSwgY2ZnXG5cdFx0XHRcdFx0LnRvU3RyaW5nKHRoaXMucmVjb2csIHRydWUpKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjZmcuc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciB0cmFucyA9IGNmZy5zdGF0ZS50cmFuc2l0aW9uc1tqXTsgLy8gZm9yIGVhY2ggdHJhbnNpdGlvblxuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMuZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KTtcblx0XHRcdGlmICh0YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIGxleGVyQWN0aW9uRXhlY3V0b3IgPSBjZmcubGV4ZXJBY3Rpb25FeGVjdXRvcjtcblx0XHRcdFx0aWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRsZXhlckFjdGlvbkV4ZWN1dG9yID0gbGV4ZXJBY3Rpb25FeGVjdXRvci5maXhPZmZzZXRCZWZvcmVNYXRjaChpbnB1dC5pbmRleCAtIHRoaXMuc3RhcnRJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHRyZWF0RW9mQXNFcHNpbG9uID0gKHQgPT09IFRva2VuLkVPRik7XG5cdFx0XHRcdHZhciBjb25maWcgPSBuZXcgTGV4ZXJBVE5Db25maWcoe3N0YXRlOnRhcmdldCwgbGV4ZXJBY3Rpb25FeGVjdXRvcjpsZXhlckFjdGlvbkV4ZWN1dG9yfSwgY2ZnKTtcblx0XHRcdFx0aWYgKHRoaXMuY2xvc3VyZShpbnB1dCwgY29uZmlnLCByZWFjaCxcblx0XHRcdFx0XHRcdGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHRydWUsIHRyZWF0RW9mQXNFcHNpbG9uKSkge1xuXHRcdFx0XHRcdC8vIGFueSByZW1haW5pbmcgY29uZmlncyBmb3IgdGhpcyBhbHQgaGF2ZSBhIGxvd2VyIHByaW9yaXR5XG5cdFx0XHRcdFx0Ly8gdGhhbiB0aGUgb25lIHRoYXQganVzdCByZWFjaGVkIGFuIGFjY2VwdCBzdGF0ZS5cblx0XHRcdFx0XHRza2lwQWx0ID0gY2ZnLmFsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKGlucHV0LCBsZXhlckFjdGlvbkV4ZWN1dG9yLFxuXHRcdHN0YXJ0SW5kZXgsIGluZGV4LCBsaW5lLCBjaGFyUG9zKSB7XG5cdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdGNvbnNvbGUubG9nKFwiQUNUSU9OICVzXFxuXCIsIGxleGVyQWN0aW9uRXhlY3V0b3IpO1xuXHR9XG5cdC8vIHNlZWsgdG8gYWZ0ZXIgbGFzdCBjaGFyIGluIHRva2VuXG5cdGlucHV0LnNlZWsoaW5kZXgpO1xuXHR0aGlzLmxpbmUgPSBsaW5lO1xuXHR0aGlzLmNvbHVtbiA9IGNoYXJQb3M7XG5cdGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9PSBudWxsICYmIHRoaXMucmVjb2cgIT09IG51bGwpIHtcblx0XHRsZXhlckFjdGlvbkV4ZWN1dG9yLmV4ZWN1dGUodGhpcy5yZWNvZywgaW5wdXQsIHN0YXJ0SW5kZXgpO1xuXHR9XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0UmVhY2hhYmxlVGFyZ2V0ID0gZnVuY3Rpb24odHJhbnMsIHQpIHtcblx0aWYgKHRyYW5zLm1hdGNoZXModCwgMCwgTGV4ZXIuTUFYX0NIQVJfVkFMVUUpKSB7XG5cdFx0cmV0dXJuIHRyYW5zLnRhcmdldDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbXB1dGVTdGFydFN0YXRlID0gZnVuY3Rpb24oaW5wdXQsIHApIHtcblx0dmFyIGluaXRpYWxDb250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG5cdHZhciBjb25maWdzID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXQoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwLnRyYW5zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRhcmdldCA9IHAudHJhbnNpdGlvbnNbaV0udGFyZ2V0O1xuICAgICAgICB2YXIgY2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHtzdGF0ZTp0YXJnZXQsIGFsdDppKzEsIGNvbnRleHQ6aW5pdGlhbENvbnRleHR9LCBudWxsKTtcblx0XHR0aGlzLmNsb3N1cmUoaW5wdXQsIGNmZywgY29uZmlncywgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cdH1cblx0cmV0dXJuIGNvbmZpZ3M7XG59O1xuXG4vLyBTaW5jZSB0aGUgYWx0ZXJuYXRpdmVzIHdpdGhpbiBhbnkgbGV4ZXIgZGVjaXNpb24gYXJlIG9yZGVyZWQgYnlcbi8vIHByZWZlcmVuY2UsIHRoaXMgbWV0aG9kIHN0b3BzIHB1cnN1aW5nIHRoZSBjbG9zdXJlIGFzIHNvb24gYXMgYW4gYWNjZXB0XG4vLyBzdGF0ZSBpcyByZWFjaGVkLiBBZnRlciB0aGUgZmlyc3QgYWNjZXB0IHN0YXRlIGlzIHJlYWNoZWQgYnkgZGVwdGgtZmlyc3Rcbi8vIHNlYXJjaCBmcm9tIHtAY29kZSBjb25maWd9LCBhbGwgb3RoZXIgKHBvdGVudGlhbGx5IHJlYWNoYWJsZSkgc3RhdGVzIGZvclxuLy8gdGhpcyBydWxlIHdvdWxkIGhhdmUgYSBsb3dlciBwcmlvcml0eS5cbi8vXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiBhbiBhY2NlcHQgc3RhdGUgaXMgcmVhY2hlZCwgb3RoZXJ3aXNlXG4vLyB7QGNvZGUgZmFsc2V9LlxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNsb3N1cmUgPSBmdW5jdGlvbihpbnB1dCwgY29uZmlnLCBjb25maWdzLFxuXHRcdGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuXHR2YXIgY2ZnID0gbnVsbDtcblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJjbG9zdXJlKFwiICsgY29uZmlnLnRvU3RyaW5nKHRoaXMucmVjb2csIHRydWUpICsgXCIpXCIpO1xuXHR9XG5cdGlmIChjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0XHRpZiAodGhpcy5yZWNvZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNsb3N1cmUgYXQgJXMgcnVsZSBzdG9wICVzXFxuXCIsIHRoaXMucmVjb2cucnVsZU5hbWVzW2NvbmZpZy5zdGF0ZS5ydWxlSW5kZXhdLCBjb25maWcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjbG9zdXJlIGF0IHJ1bGUgc3RvcCAlc1xcblwiLCBjb25maWcpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY29uZmlnLmNvbnRleHQgPT09IG51bGwgfHwgY29uZmlnLmNvbnRleHQuaGFzRW1wdHlQYXRoKCkpIHtcblx0XHRcdGlmIChjb25maWcuY29udGV4dCA9PT0gbnVsbCB8fCBjb25maWcuY29udGV4dC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0Y29uZmlncy5hZGQoY29uZmlnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25maWdzLmFkZChuZXcgTGV4ZXJBVE5Db25maWcoeyBzdGF0ZTpjb25maWcuc3RhdGUsIGNvbnRleHQ6UHJlZGljdGlvbkNvbnRleHQuRU1QVFl9LCBjb25maWcpKTtcblx0XHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjb25maWcuY29udGV4dCAhPT0gbnVsbCAmJiAhY29uZmlnLmNvbnRleHQuaXNFbXB0eSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5jb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKSAhPT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0NvbnRleHQgPSBjb25maWcuY29udGV4dC5nZXRQYXJlbnQoaSk7IC8vIFwicG9wXCIgcmV0dXJuIHN0YXRlXG5cdFx0XHRcdFx0dmFyIHJldHVyblN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2NvbmZpZy5jb250ZXh0LmdldFJldHVyblN0YXRlKGkpXTtcblx0XHRcdFx0XHRjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoeyBzdGF0ZTpyZXR1cm5TdGF0ZSwgY29udGV4dDpuZXdDb250ZXh0IH0sIGNvbmZpZyk7XG5cdFx0XHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRoaXMuY2xvc3VyZShpbnB1dCwgY2ZnLFxuXHRcdFx0XHRcdFx0XHRjb25maWdzLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCBzcGVjdWxhdGl2ZSxcblx0XHRcdFx0XHRcdFx0dHJlYXRFb2ZBc0Vwc2lsb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlO1xuXHR9XG5cdC8vIG9wdGltaXphdGlvblxuXHRpZiAoIWNvbmZpZy5zdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zKSB7XG5cdFx0aWYgKCFjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlIHx8ICFjb25maWcucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKSB7XG5cdFx0XHRjb25maWdzLmFkZChjb25maWcpO1xuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGNvbmZpZy5zdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuXHRcdHZhciB0cmFucyA9IGNvbmZpZy5zdGF0ZS50cmFuc2l0aW9uc1tqXTtcblx0XHRjZmcgPSB0aGlzLmdldEVwc2lsb25UYXJnZXQoaW5wdXQsIGNvbmZpZywgdHJhbnMsIGNvbmZpZ3MsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XG5cdFx0aWYgKGNmZyAhPT0gbnVsbCkge1xuXHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRoaXMuY2xvc3VyZShpbnB1dCwgY2ZnLCBjb25maWdzLFxuXHRcdFx0XHRcdGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlO1xufTtcblxuLy8gc2lkZS1lZmZlY3Q6IGNhbiBhbHRlciBjb25maWdzLmhhc1NlbWFudGljQ29udGV4dFxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldEVwc2lsb25UYXJnZXQgPSBmdW5jdGlvbihpbnB1dCwgY29uZmlnLCB0cmFucyxcblx0XHRjb25maWdzLCBzcGVjdWxhdGl2ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcblx0dmFyIGNmZyA9IG51bGw7XG5cdGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5SVUxFKSB7XG5cdFx0dmFyIG5ld0NvbnRleHQgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUoY29uZmlnLmNvbnRleHQsIHRyYW5zLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcblx0XHRjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoIHsgc3RhdGU6dHJhbnMudGFyZ2V0LCBjb250ZXh0Om5ld0NvbnRleHR9LCBjb25maWcpO1xuXHR9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLlBSRUNFREVOQ0UpIHtcblx0XHR0aHJvdyBcIlByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBsZXhlcnMuXCI7XG5cdH0gZWxzZSBpZiAodHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uUFJFRElDQVRFKSB7XG5cdFx0Ly8gVHJhY2sgdHJhdmVyc2luZyBzZW1hbnRpYyBwcmVkaWNhdGVzLiBJZiB3ZSB0cmF2ZXJzZSxcblx0XHQvLyB3ZSBjYW5ub3QgYWRkIGEgREZBIHN0YXRlIGZvciB0aGlzIFwicmVhY2hcIiBjb21wdXRhdGlvblxuXHRcdC8vIGJlY2F1c2UgdGhlIERGQSB3b3VsZCBub3QgdGVzdCB0aGUgcHJlZGljYXRlIGFnYWluIGluIHRoZVxuXHRcdC8vIGZ1dHVyZS4gUmF0aGVyIHRoYW4gY3JlYXRpbmcgY29sbGVjdGlvbnMgb2Ygc2VtYW50aWMgcHJlZGljYXRlc1xuXHRcdC8vIGxpa2UgdjMgYW5kIHRlc3RpbmcgdGhlbSBvbiBwcmVkaWN0aW9uLCB2NCB3aWxsIHRlc3QgdGhlbSBvbiB0aGVcblx0XHQvLyBmbHkgYWxsIHRoZSB0aW1lIHVzaW5nIHRoZSBBVE4gbm90IHRoZSBERkEuIFRoaXMgaXMgc2xvd2VyIGJ1dFxuXHRcdC8vIHNlbWFudGljYWxseSBpdCdzIG5vdCB1c2VkIHRoYXQgb2Z0ZW4uIE9uZSBvZiB0aGUga2V5IGVsZW1lbnRzIHRvXG5cdFx0Ly8gdGhpcyBwcmVkaWNhdGUgbWVjaGFuaXNtIGlzIG5vdCBhZGRpbmcgREZBIHN0YXRlcyB0aGF0IHNlZVxuXHRcdC8vIHByZWRpY2F0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkcyBpbiB0aGUgQVROLiBGb3IgZXhhbXBsZSxcblxuXHRcdC8vIGEgOiBJRCB7cDF9PyB8IElEIHtwMn0/IDtcblxuXHRcdC8vIHNob3VsZCBjcmVhdGUgdGhlIHN0YXJ0IHN0YXRlIGZvciBydWxlICdhJyAodG8gc2F2ZSBzdGFydCBzdGF0ZVxuXHRcdC8vIGNvbXBldGl0aW9uKSwgYnV0IHNob3VsZCBub3QgY3JlYXRlIHRhcmdldCBvZiBJRCBzdGF0ZS4gVGhlXG5cdFx0Ly8gY29sbGVjdGlvbiBvZiBBVE4gc3RhdGVzIHRoZSBmb2xsb3dpbmcgSUQgcmVmZXJlbmNlcyBpbmNsdWRlc1xuXHRcdC8vIHN0YXRlcyByZWFjaGVkIGJ5IHRyYXZlcnNpbmcgcHJlZGljYXRlcy4gU2luY2UgdGhpcyBpcyB3aGVuIHdlXG5cdFx0Ly8gdGVzdCB0aGVtLCB3ZSBjYW5ub3QgY2FzaCB0aGUgREZBIHN0YXRlIHRhcmdldCBvZiBJRC5cblxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFVkFMIHJ1bGUgXCIgKyB0cmFucy5ydWxlSW5kZXggKyBcIjpcIiArIHRyYW5zLnByZWRJbmRleCk7XG5cdFx0fVxuXHRcdGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0ID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5ldmFsdWF0ZVByZWRpY2F0ZShpbnB1dCwgdHJhbnMucnVsZUluZGV4LCB0cmFucy5wcmVkSW5kZXgsIHNwZWN1bGF0aXZlKSkge1xuXHRcdFx0Y2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHsgc3RhdGU6dHJhbnMudGFyZ2V0fSwgY29uZmlnKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uQUNUSU9OKSB7XG5cdFx0aWYgKGNvbmZpZy5jb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0Lmhhc0VtcHR5UGF0aCgpKSB7XG5cdFx0XHQvLyBleGVjdXRlIGFjdGlvbnMgYW55d2hlcmUgaW4gdGhlIHN0YXJ0IHJ1bGUgZm9yIGEgdG9rZW4uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVE9ETzogaWYgdGhlIGVudHJ5IHJ1bGUgaXMgaW52b2tlZCByZWN1cnNpdmVseSwgc29tZVxuXHRcdFx0Ly8gYWN0aW9ucyBtYXkgYmUgZXhlY3V0ZWQgZHVyaW5nIHRoZSByZWN1cnNpdmUgY2FsbC4gVGhlXG5cdFx0XHQvLyBwcm9ibGVtIGNhbiBhcHBlYXIgd2hlbiBoYXNFbXB0eVBhdGgoKSBpcyB0cnVlIGJ1dFxuXHRcdFx0Ly8gaXNFbXB0eSgpIGlzIGZhbHNlLiBJbiB0aGlzIGNhc2UsIHRoZSBjb25maWcgbmVlZHMgdG8gYmVcblx0XHRcdC8vIHNwbGl0IGludG8gdHdvIGNvbnRleHRzIC0gb25lIHdpdGgganVzdCB0aGUgZW1wdHkgcGF0aFxuXHRcdFx0Ly8gYW5kIGFub3RoZXIgd2l0aCBldmVyeXRoaW5nIGJ1dCB0aGUgZW1wdHkgcGF0aC5cblx0XHRcdC8vIFVuZm9ydHVuYXRlbHksIHRoZSBjdXJyZW50IGFsZ29yaXRobSBkb2VzIG5vdCBhbGxvd1xuXHRcdFx0Ly8gZ2V0RXBzaWxvblRhcmdldCB0byByZXR1cm4gdHdvIGNvbmZpZ3VyYXRpb25zLCBzb1xuXHRcdFx0Ly8gYWRkaXRpb25hbCBtb2RpZmljYXRpb25zIGFyZSBuZWVkZWQgYmVmb3JlIHdlIGNhbiBzdXBwb3J0XG5cdFx0XHQvLyB0aGUgc3BsaXQgb3BlcmF0aW9uLlxuXHRcdFx0dmFyIGxleGVyQWN0aW9uRXhlY3V0b3IgPSBMZXhlckFjdGlvbkV4ZWN1dG9yLmFwcGVuZChjb25maWcubGV4ZXJBY3Rpb25FeGVjdXRvcixcblx0XHRcdFx0XHR0aGlzLmF0bi5sZXhlckFjdGlvbnNbdHJhbnMuYWN0aW9uSW5kZXhdKTtcblx0XHRcdGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7IHN0YXRlOnRyYW5zLnRhcmdldCwgbGV4ZXJBY3Rpb25FeGVjdXRvcjpsZXhlckFjdGlvbkV4ZWN1dG9yIH0sIGNvbmZpZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlnbm9yZSBhY3Rpb25zIGluIHJlZmVyZW5jZWQgcnVsZXNcblx0XHRcdGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyggeyBzdGF0ZTp0cmFucy50YXJnZXR9LCBjb25maWcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5FUFNJTE9OKSB7XG5cdFx0Y2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHsgc3RhdGU6dHJhbnMudGFyZ2V0fSwgY29uZmlnKTtcblx0fSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5BVE9NIHx8XG5cdFx0XHRcdHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLlJBTkdFIHx8XG5cdFx0XHRcdHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLlNFVCkge1xuXHRcdGlmICh0cmVhdEVvZkFzRXBzaWxvbikge1xuXHRcdFx0aWYgKHRyYW5zLm1hdGNoZXMoVG9rZW4uRU9GLCAwLCBMZXhlci5NQVhfQ0hBUl9WQUxVRSkpIHtcblx0XHRcdFx0Y2ZnID0gbmV3IExleGVyQVROQ29uZmlnKCB7IHN0YXRlOnRyYW5zLnRhcmdldCB9LCBjb25maWcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gY2ZnO1xufTtcblxuLy8gRXZhbHVhdGUgYSBwcmVkaWNhdGUgc3BlY2lmaWVkIGluIHRoZSBsZXhlci5cbi8vXG4vLyA8cD5JZiB7QGNvZGUgc3BlY3VsYXRpdmV9IGlzIHtAY29kZSB0cnVlfSwgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWZvcmVcbi8vIHtAbGluayAvL2NvbnN1bWV9IGZvciB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBjYWxsXG4vLyB7QGxpbmsgLy9jb25zdW1lfSBiZWZvcmUgZXZhbHVhdGluZyB0aGUgcHJlZGljYXRlIHRvIGVuc3VyZSBwb3NpdGlvblxuLy8gc2Vuc2l0aXZlIHZhbHVlcywgaW5jbHVkaW5nIHtAbGluayBMZXhlci8vZ2V0VGV4dH0sIHtAbGluayBMZXhlci8vZ2V0TGluZX0sXG4vLyBhbmQge0BsaW5rIExleGVyLy9nZXRjb2x1bW59LCBwcm9wZXJseSByZWZsZWN0IHRoZSBjdXJyZW50XG4vLyBsZXhlciBzdGF0ZS4gVGhpcyBtZXRob2Qgc2hvdWxkIHJlc3RvcmUge0Bjb2RlIGlucHV0fSBhbmQgdGhlIHNpbXVsYXRvclxuLy8gdG8gdGhlIG9yaWdpbmFsIHN0YXRlIGJlZm9yZSByZXR1cm5pbmcgKGkuZS4gdW5kbyB0aGUgYWN0aW9ucyBtYWRlIGJ5IHRoZVxuLy8gY2FsbCB0byB7QGxpbmsgLy9jb25zdW1lfS48L3A+XG4vL1xuLy8gQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJlYW0uXG4vLyBAcGFyYW0gcnVsZUluZGV4IFRoZSBydWxlIGNvbnRhaW5pbmcgdGhlIHByZWRpY2F0ZS5cbi8vIEBwYXJhbSBwcmVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBwcmVkaWNhdGUgd2l0aGluIHRoZSBydWxlLlxuLy8gQHBhcmFtIHNwZWN1bGF0aXZlIHtAY29kZSB0cnVlfSBpZiB0aGUgY3VycmVudCBpbmRleCBpbiB7QGNvZGUgaW5wdXR9IGlzXG4vLyBvbmUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgcHJlZGljYXRlJ3MgbG9jYXRpb24uXG4vL1xuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvXG4vLyB7QGNvZGUgdHJ1ZX0uXG4vLyAvXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZXZhbHVhdGVQcmVkaWNhdGUgPSBmdW5jdGlvbihpbnB1dCwgcnVsZUluZGV4LFxuXHRcdHByZWRJbmRleCwgc3BlY3VsYXRpdmUpIHtcblx0Ly8gYXNzdW1lIHRydWUgaWYgbm8gcmVjb2duaXplciB3YXMgcHJvdmlkZWRcblx0aWYgKHRoaXMucmVjb2cgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIXNwZWN1bGF0aXZlKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVjb2cuc2VtcHJlZChudWxsLCBydWxlSW5kZXgsIHByZWRJbmRleCk7XG5cdH1cblx0dmFyIHNhdmVkY29sdW1uID0gdGhpcy5jb2x1bW47XG5cdHZhciBzYXZlZExpbmUgPSB0aGlzLmxpbmU7XG5cdHZhciBpbmRleCA9IGlucHV0LmluZGV4O1xuXHR2YXIgbWFya2VyID0gaW5wdXQubWFyaygpO1xuXHR0cnkge1xuXHRcdHRoaXMuY29uc3VtZShpbnB1dCk7XG5cdFx0cmV0dXJuIHRoaXMucmVjb2cuc2VtcHJlZChudWxsLCBydWxlSW5kZXgsIHByZWRJbmRleCk7XG5cdH0gZmluYWxseSB7XG5cdFx0dGhpcy5jb2x1bW4gPSBzYXZlZGNvbHVtbjtcblx0XHR0aGlzLmxpbmUgPSBzYXZlZExpbmU7XG5cdFx0aW5wdXQuc2VlayhpbmRleCk7XG5cdFx0aW5wdXQucmVsZWFzZShtYXJrZXIpO1xuXHR9XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY2FwdHVyZVNpbVN0YXRlID0gZnVuY3Rpb24oc2V0dGluZ3MsIGlucHV0LCBkZmFTdGF0ZSkge1xuXHRzZXR0aW5ncy5pbmRleCA9IGlucHV0LmluZGV4O1xuXHRzZXR0aW5ncy5saW5lID0gdGhpcy5saW5lO1xuXHRzZXR0aW5ncy5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcblx0c2V0dGluZ3MuZGZhU3RhdGUgPSBkZmFTdGF0ZTtcbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5hZGRERkFFZGdlID0gZnVuY3Rpb24oZnJvbV8sIHRrLCB0bywgY2Zncykge1xuXHRpZiAodG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdHRvID0gbnVsbDtcblx0fVxuXHRpZiAoY2ZncyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y2ZncyA9IG51bGw7XG5cdH1cblx0aWYgKHRvID09PSBudWxsICYmIGNmZ3MgIT09IG51bGwpIHtcblx0XHQvLyBsZWFkaW5nIHRvIHRoaXMgY2FsbCwgQVROQ29uZmlnU2V0Lmhhc1NlbWFudGljQ29udGV4dCBpcyB1c2VkIGFzIGFcblx0XHQvLyBtYXJrZXIgaW5kaWNhdGluZyBkeW5hbWljIHByZWRpY2F0ZSBldmFsdWF0aW9uIG1ha2VzIHRoaXMgZWRnZVxuXHRcdC8vIGRlcGVuZGVudCBvbiB0aGUgc3BlY2lmaWMgaW5wdXQgc2VxdWVuY2UsIHNvIHRoZSBzdGF0aWMgZWRnZSBpbiB0aGVcblx0XHQvLyBERkEgc2hvdWxkIGJlIG9taXR0ZWQuIFRoZSB0YXJnZXQgREZBU3RhdGUgaXMgc3RpbGwgY3JlYXRlZCBzaW5jZVxuXHRcdC8vIGV4ZWNBVE4gaGFzIHRoZSBhYmlsaXR5IHRvIHJlc3luY2hyb25pemUgd2l0aCB0aGUgREZBIHN0YXRlIGNhY2hlXG5cdFx0Ly8gZm9sbG93aW5nIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGlvbiBzdGVwLlxuXHRcdC8vXG5cdFx0Ly8gVEpQIG5vdGVzOiBuZXh0IHRpbWUgdGhyb3VnaCB0aGUgREZBLCB3ZSBzZWUgYSBwcmVkIGFnYWluIGFuZCBldmFsLlxuXHRcdC8vIElmIHRoYXQgZ2V0cyB1cyB0byBhIHByZXZpb3VzbHkgY3JlYXRlZCAoYnV0IGRhbmdsaW5nKSBERkFcblx0XHQvLyBzdGF0ZSwgd2UgY2FuIGNvbnRpbnVlIGluIHB1cmUgREZBIG1vZGUgZnJvbSB0aGVyZS5cblx0XHQvLyAvXG5cdFx0dmFyIHN1cHByZXNzRWRnZSA9IGNmZ3MuaGFzU2VtYW50aWNDb250ZXh0O1xuXHRcdGNmZ3MuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XG5cblx0XHR0byA9IHRoaXMuYWRkREZBU3RhdGUoY2Zncyk7XG5cblx0XHRpZiAoc3VwcHJlc3NFZGdlKSB7XG5cdFx0XHRyZXR1cm4gdG87XG5cdFx0fVxuXHR9XG5cdC8vIGFkZCB0aGUgZWRnZVxuXHRpZiAodGsgPCBMZXhlckFUTlNpbXVsYXRvci5NSU5fREZBX0VER0UgfHwgdGsgPiBMZXhlckFUTlNpbXVsYXRvci5NQVhfREZBX0VER0UpIHtcblx0XHQvLyBPbmx5IHRyYWNrIGVkZ2VzIHdpdGhpbiB0aGUgREZBIGJvdW5kc1xuXHRcdHJldHVybiB0bztcblx0fVxuXHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRjb25zb2xlLmxvZyhcIkVER0UgXCIgKyBmcm9tXyArIFwiIC0+IFwiICsgdG8gKyBcIiB1cG9uIFwiICsgdGspO1xuXHR9XG5cdGlmIChmcm9tXy5lZGdlcyA9PT0gbnVsbCkge1xuXHRcdC8vIG1ha2Ugcm9vbSBmb3IgdG9rZW5zIDEuLm4gYW5kIC0xIG1hc3F1ZXJhZGluZyBhcyBpbmRleCAwXG5cdFx0ZnJvbV8uZWRnZXMgPSBbXTtcblx0fVxuXHRmcm9tXy5lZGdlc1t0ayAtIExleGVyQVROU2ltdWxhdG9yLk1JTl9ERkFfRURHRV0gPSB0bzsgLy8gY29ubmVjdFxuXG5cdHJldHVybiB0bztcbn07XG5cbi8vIEFkZCBhIG5ldyBERkEgc3RhdGUgaWYgdGhlcmUgaXNuJ3Qgb25lIHdpdGggdGhpcyBzZXQgb2Zcbi8vIGNvbmZpZ3VyYXRpb25zIGFscmVhZHkuIFRoaXMgbWV0aG9kIGFsc28gZGV0ZWN0cyB0aGUgZmlyc3Rcbi8vIGNvbmZpZ3VyYXRpb24gY29udGFpbmluZyBhbiBBVE4gcnVsZSBzdG9wIHN0YXRlLiBMYXRlciwgd2hlblxuLy8gdHJhdmVyc2luZyB0aGUgREZBLCB3ZSB3aWxsIGtub3cgd2hpY2ggcnVsZSB0byBhY2NlcHQuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuYWRkREZBU3RhdGUgPSBmdW5jdGlvbihjb25maWdzKSB7XG5cdHZhciBwcm9wb3NlZCA9IG5ldyBERkFTdGF0ZShudWxsLCBjb25maWdzKTtcblx0dmFyIGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUgPSBudWxsO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2ZnID0gY29uZmlncy5pdGVtc1tpXTtcblx0XHRpZiAoY2ZnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuXHRcdFx0Zmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSA9IGNmZztcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRpZiAoZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSAhPT0gbnVsbCkge1xuXHRcdHByb3Bvc2VkLmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuXHRcdHByb3Bvc2VkLmxleGVyQWN0aW9uRXhlY3V0b3IgPSBmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlLmxleGVyQWN0aW9uRXhlY3V0b3I7XG5cdFx0cHJvcG9zZWQucHJlZGljdGlvbiA9IHRoaXMuYXRuLnJ1bGVUb1Rva2VuVHlwZVtmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlLnN0YXRlLnJ1bGVJbmRleF07XG5cdH1cblx0dmFyIGRmYSA9IHRoaXMuZGVjaXNpb25Ub0RGQVt0aGlzLm1vZGVdO1xuXHR2YXIgZXhpc3RpbmcgPSBkZmEuc3RhdGVzLmdldChwcm9wb3NlZCk7XG5cdGlmIChleGlzdGluZyE9PW51bGwpIHtcblx0XHRyZXR1cm4gZXhpc3Rpbmc7XG5cdH1cblx0dmFyIG5ld1N0YXRlID0gcHJvcG9zZWQ7XG5cdG5ld1N0YXRlLnN0YXRlTnVtYmVyID0gZGZhLnN0YXRlcy5sZW5ndGg7XG5cdGNvbmZpZ3Muc2V0UmVhZG9ubHkodHJ1ZSk7XG5cdG5ld1N0YXRlLmNvbmZpZ3MgPSBjb25maWdzO1xuXHRkZmEuc3RhdGVzLmFkZChuZXdTdGF0ZSk7XG5cdHJldHVybiBuZXdTdGF0ZTtcbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRERkEgPSBmdW5jdGlvbihtb2RlKSB7XG5cdHJldHVybiB0aGlzLmRlY2lzaW9uVG9ERkFbbW9kZV07XG59O1xuXG4vLyBHZXQgdGhlIHRleHQgbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBjdXJyZW50IHRva2VuLlxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBpbmRleCBpcyBmaXJzdCBsb29rYWhlYWQgY2hhciwgZG9uJ3QgaW5jbHVkZS5cblx0cmV0dXJuIGlucHV0LmdldFRleHQodGhpcy5zdGFydEluZGV4LCBpbnB1dC5pbmRleCAtIDEpO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHR2YXIgY3VyQ2hhciA9IGlucHV0LkxBKDEpO1xuXHRpZiAoY3VyQ2hhciA9PT0gXCJcXG5cIi5jaGFyQ29kZUF0KDApKSB7XG5cdFx0dGhpcy5saW5lICs9IDE7XG5cdFx0dGhpcy5jb2x1bW4gPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuY29sdW1uICs9IDE7XG5cdH1cblx0aW5wdXQuY29uc3VtZSgpO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFRva2VuTmFtZSA9IGZ1bmN0aW9uKHR0KSB7XG5cdGlmICh0dCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gXCJFT0ZcIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHR0KSArIFwiJ1wiO1xuXHR9XG59O1xuXG5leHBvcnRzLkxleGVyQVROU2ltdWxhdG9yID0gTGV4ZXJBVE5TaW11bGF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0xleGVyQVROU2ltdWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy9cbi8vIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgVG9rZW5GYWN0b3J5fSBjcmVhdGVzXG4vLyB7QGxpbmsgQ29tbW9uVG9rZW59IG9iamVjdHMuXG4vL1xuXG52YXIgQ29tbW9uVG9rZW4gPSByZXF1aXJlKCcuL1Rva2VuJykuQ29tbW9uVG9rZW47XG5cbmZ1bmN0aW9uIFRva2VuRmFjdG9yeSgpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIENvbW1vblRva2VuRmFjdG9yeShjb3B5VGV4dCkge1xuXHRUb2tlbkZhY3RvcnkuY2FsbCh0aGlzKTtcbiAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgQ29tbW9uVG9rZW4vL3NldFRleHR9IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAvLyBjb25zdHJ1Y3RpbmcgdG9rZW5zIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSB0ZXh0LiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXNcbiAgICAvLyB3aGVyZSB0aGUgaW5wdXQgc3RyZWFtIG1pZ2h0IG5vdCBiZSBhYmxlIHRvIHByb3ZpZGUgYXJiaXRyYXJ5IHN1YnN0cmluZ3NcbiAgICAvLyBvZiB0ZXh0IGZyb20gdGhlIGlucHV0IGFmdGVyIHRoZSBsZXhlciBjcmVhdGVzIGEgdG9rZW4gKGUuZy4gdGhlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENoYXJTdHJlYW0vL2dldFRleHR9IGluXG4gICAgLy8ge0BsaW5rIFVuYnVmZmVyZWRDaGFyU3RyZWFtfSB0aHJvd3MgYW5cbiAgICAvLyB7QGxpbmsgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb259KS4gRXhwbGljaXRseSBzZXR0aW5nIHRoZSB0b2tlbiB0ZXh0XG4gICAgLy8gYWxsb3dzIHtAbGluayBUb2tlbi8vZ2V0VGV4dH0gdG8gYmUgY2FsbGVkIGF0IGFueSB0aW1lIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgLy8gaW5wdXQgc3RyZWFtIGltcGxlbWVudGF0aW9uLlxuICAgIC8vXG4gICAgLy8gPHA+XG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMge0Bjb2RlIGZhbHNlfSB0byBhdm9pZCB0aGUgcGVyZm9ybWFuY2UgYW5kIG1lbW9yeVxuICAgIC8vIG92ZXJoZWFkIG9mIGNvcHlpbmcgdGV4dCBmb3IgZXZlcnkgdG9rZW4gdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLjwvcD5cbiAgICAvL1xuICAgIHRoaXMuY29weVRleHQgPSBjb3B5VGV4dD09PXVuZGVmaW5lZCA/IGZhbHNlIDogY29weVRleHQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5Db21tb25Ub2tlbkZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUb2tlbkZhY3RvcnkucHJvdG90eXBlKTtcbkNvbW1vblRva2VuRmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21tb25Ub2tlbkZhY3Rvcnk7XG5cbi8vXG4vLyBUaGUgZGVmYXVsdCB7QGxpbmsgQ29tbW9uVG9rZW5GYWN0b3J5fSBpbnN0YW5jZS5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgdG9rZW4gZmFjdG9yeSBkb2VzIG5vdCBleHBsaWNpdGx5IGNvcHkgdG9rZW4gdGV4dCB3aGVuIGNvbnN0cnVjdGluZ1xuLy8gdG9rZW5zLjwvcD5cbi8vXG5Db21tb25Ub2tlbkZhY3RvcnkuREVGQVVMVCA9IG5ldyBDb21tb25Ub2tlbkZhY3RvcnkoKTtcblxuQ29tbW9uVG9rZW5GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHR5cGUsIHRleHQsIGNoYW5uZWwsIHN0YXJ0LCBzdG9wLCBsaW5lLCBjb2x1bW4pIHtcbiAgICB2YXIgdCA9IG5ldyBDb21tb25Ub2tlbihzb3VyY2UsIHR5cGUsIGNoYW5uZWwsIHN0YXJ0LCBzdG9wKTtcbiAgICB0LmxpbmUgPSBsaW5lO1xuICAgIHQuY29sdW1uID0gY29sdW1uO1xuICAgIGlmICh0ZXh0ICE9PW51bGwpIHtcbiAgICAgICAgdC50ZXh0ID0gdGV4dDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29weVRleHQgJiYgc291cmNlWzFdICE9PW51bGwpIHtcbiAgICAgICAgdC50ZXh0ID0gc291cmNlWzFdLmdldFRleHQoc3RhcnQsc3RvcCk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcblxuQ29tbW9uVG9rZW5GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVUaGluID0gZnVuY3Rpb24odHlwZSwgdGV4dCkge1xuICAgIHZhciB0ID0gbmV3IENvbW1vblRva2VuKG51bGwsIHR5cGUpO1xuICAgIHQudGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5leHBvcnRzLkNvbW1vblRva2VuRmFjdG9yeSA9IENvbW1vblRva2VuRmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9Db21tb25Ub2tlbkZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gUmVwcmVzZW50cyBhbiBleGVjdXRvciBmb3IgYSBzZXF1ZW5jZSBvZiBsZXhlciBhY3Rpb25zIHdoaWNoIHRyYXZlcnNlZCBkdXJpbmdcbi8vIHRoZSBtYXRjaGluZyBvcGVyYXRpb24gb2YgYSBsZXhlciBydWxlICh0b2tlbikuXG4vL1xuLy8gPHA+VGhlIGV4ZWN1dG9yIHRyYWNrcyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnNcbi8vIGVmZmljaWVudGx5LCBlbnN1cmluZyB0aGF0IGFjdGlvbnMgYXBwZWFyaW5nIG9ubHkgYXQgdGhlIGVuZCBvZiB0aGUgcnVsZSBkb1xuLy8gbm90IGNhdXNlIGJsb2F0aW5nIG9mIHRoZSB7QGxpbmsgREZBfSBjcmVhdGVkIGZvciB0aGUgbGV4ZXIuPC9wPlxuXG52YXIgaGFzaFN0dWZmID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpLmhhc2hTdHVmZjtcbnZhciBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24gPSByZXF1aXJlKCcuL0xleGVyQWN0aW9uJykuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uO1xuXG5mdW5jdGlvbiBMZXhlckFjdGlvbkV4ZWN1dG9yKGxleGVyQWN0aW9ucykge1xuXHR0aGlzLmxleGVyQWN0aW9ucyA9IGxleGVyQWN0aW9ucyA9PT0gbnVsbCA/IFtdIDogbGV4ZXJBY3Rpb25zO1xuXHQvLyBDYWNoZXMgdGhlIHJlc3VsdCBvZiB7QGxpbmsgLy9oYXNoQ29kZX0gc2luY2UgdGhlIGhhc2ggY29kZSBpcyBhbiBlbGVtZW50XG5cdC8vIG9mIHRoZSBwZXJmb3JtYW5jZS1jcml0aWNhbCB7QGxpbmsgTGV4ZXJBVE5Db25maWcvL2hhc2hDb2RlfSBvcGVyYXRpb24uXG5cdHRoaXMuY2FjaGVkSGFzaENvZGUgPSBoYXNoU3R1ZmYobGV4ZXJBY3Rpb25zKTsgLy8gXCJcIi5qb2luKFtzdHIobGEpIGZvciBsYSBpblxuXHQvLyBsZXhlckFjdGlvbnNdKSlcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIENyZWF0ZXMgYSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gd2hpY2ggZXhlY3V0ZXMgdGhlIGFjdGlvbnMgZm9yXG4vLyB0aGUgaW5wdXQge0Bjb2RlIGxleGVyQWN0aW9uRXhlY3V0b3J9IGZvbGxvd2VkIGJ5IGEgc3BlY2lmaWVkXG4vLyB7QGNvZGUgbGV4ZXJBY3Rpb259LlxuLy9cbi8vIEBwYXJhbSBsZXhlckFjdGlvbkV4ZWN1dG9yIFRoZSBleGVjdXRvciBmb3IgYWN0aW9ucyBhbHJlYWR5IHRyYXZlcnNlZCBieVxuLy8gdGhlIGxleGVyIHdoaWxlIG1hdGNoaW5nIGEgdG9rZW4gd2l0aGluIGEgcGFydGljdWxhclxuLy8ge0BsaW5rIExleGVyQVROQ29uZmlnfS4gSWYgdGhpcyBpcyB7QGNvZGUgbnVsbH0sIHRoZSBtZXRob2QgYmVoYXZlcyBhc1xuLy8gdGhvdWdoIGl0IHdlcmUgYW4gZW1wdHkgZXhlY3V0b3IuXG4vLyBAcGFyYW0gbGV4ZXJBY3Rpb24gVGhlIGxleGVyIGFjdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBhY3Rpb25zXG4vLyBzcGVjaWZpZWQgaW4ge0Bjb2RlIGxleGVyQWN0aW9uRXhlY3V0b3J9LlxuLy9cbi8vIEByZXR1cm4gQSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gZm9yIGV4ZWN1dGluZyB0aGUgY29tYmluZSBhY3Rpb25zXG4vLyBvZiB7QGNvZGUgbGV4ZXJBY3Rpb25FeGVjdXRvcn0gYW5kIHtAY29kZSBsZXhlckFjdGlvbn0uXG5MZXhlckFjdGlvbkV4ZWN1dG9yLmFwcGVuZCA9IGZ1bmN0aW9uKGxleGVyQWN0aW9uRXhlY3V0b3IsIGxleGVyQWN0aW9uKSB7XG5cdGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG5ldyBMZXhlckFjdGlvbkV4ZWN1dG9yKFsgbGV4ZXJBY3Rpb24gXSk7XG5cdH1cblx0dmFyIGxleGVyQWN0aW9ucyA9IGxleGVyQWN0aW9uRXhlY3V0b3IubGV4ZXJBY3Rpb25zLmNvbmNhdChbIGxleGVyQWN0aW9uIF0pO1xuXHRyZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IobGV4ZXJBY3Rpb25zKTtcbn07XG5cbi8vIENyZWF0ZXMgYSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0gd2hpY2ggZW5jb2RlcyB0aGUgY3VycmVudCBvZmZzZXRcbi8vIGZvciBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucy5cbi8vXG4vLyA8cD5Ob3JtYWxseSwgd2hlbiB0aGUgZXhlY3V0b3IgZW5jb3VudGVycyBsZXhlciBhY3Rpb25zIHdoZXJlXG4vLyB7QGxpbmsgTGV4ZXJBY3Rpb24vL2lzUG9zaXRpb25EZXBlbmRlbnR9IHJldHVybnMge0Bjb2RlIHRydWV9LCBpdCBjYWxsc1xuLy8ge0BsaW5rIEludFN0cmVhbS8vc2Vla30gb24gdGhlIGlucHV0IHtAbGluayBDaGFyU3RyZWFtfSB0byBzZXQgdGhlIGlucHV0XG4vLyBwb3NpdGlvbiB0byB0aGUgPGVtPmVuZDwvZW0+IG9mIHRoZSBjdXJyZW50IHRva2VuLiBUaGlzIGJlaGF2aW9yIHByb3ZpZGVzXG4vLyBmb3IgZWZmaWNpZW50IERGQSByZXByZXNlbnRhdGlvbiBvZiBsZXhlciBhY3Rpb25zIHdoaWNoIGFwcGVhciBhdCB0aGUgZW5kXG4vLyBvZiBhIGxleGVyIHJ1bGUsIGV2ZW4gd2hlbiB0aGUgbGV4ZXIgcnVsZSBtYXRjaGVzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBjaGFyYWN0ZXJzLjwvcD5cbi8vXG4vLyA8cD5QcmlvciB0byB0cmF2ZXJzaW5nIGEgbWF0Y2ggdHJhbnNpdGlvbiBpbiB0aGUgQVROLCB0aGUgY3VycmVudCBvZmZzZXRcbi8vIGZyb20gdGhlIHRva2VuIHN0YXJ0IGluZGV4IGlzIGFzc2lnbmVkIHRvIGFsbCBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXJcbi8vIGFjdGlvbnMgd2hpY2ggaGF2ZSBub3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIGEgZml4ZWQgb2Zmc2V0LiBCeSBzdG9yaW5nXG4vLyB0aGUgb2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgdG9rZW4gc3RhcnQgaW5kZXgsIHRoZSBERkEgcmVwcmVzZW50YXRpb24gb2Zcbi8vIGxleGVyIGFjdGlvbnMgd2hpY2ggYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgdG9rZW5zIHJlbWFpbnMgZWZmaWNpZW50IGR1ZVxuLy8gdG8gc2hhcmluZyBhbW9uZyB0b2tlbnMgb2YgdGhlIHNhbWUgbGVuZ3RoLCByZWdhcmRsZXNzIG9mIHRoZWlyIGFic29sdXRlXG4vLyBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgc3RyZWFtLjwvcD5cbi8vXG4vLyA8cD5JZiB0aGUgY3VycmVudCBleGVjdXRvciBhbHJlYWR5IGhhcyBvZmZzZXRzIGFzc2lnbmVkIHRvIGFsbFxuLy8gcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMsIHRoZSBtZXRob2QgcmV0dXJucyB7QGNvZGUgdGhpc30uPC9wPlxuLy9cbi8vIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0IHRvIGFzc2lnbiB0byBhbGwgcG9zaXRpb24tZGVwZW5kZW50XG4vLyBsZXhlciBhY3Rpb25zIHdoaWNoIGRvIG5vdCBhbHJlYWR5IGhhdmUgb2Zmc2V0cyBhc3NpZ25lZC5cbi8vXG4vLyBAcmV0dXJuIEEge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9IHdoaWNoIHN0b3JlcyBpbnB1dCBzdHJlYW0gb2Zmc2V0c1xuLy8gZm9yIGFsbCBwb3NpdGlvbi1kZXBlbmRlbnQgbGV4ZXIgYWN0aW9ucy5cbi8vIC9cbkxleGVyQWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLmZpeE9mZnNldEJlZm9yZU1hdGNoID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdHZhciB1cGRhdGVkTGV4ZXJBY3Rpb25zID0gbnVsbDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxleGVyQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLmxleGVyQWN0aW9uc1tpXS5pc1Bvc2l0aW9uRGVwZW5kZW50ICYmXG5cdFx0XHRcdCEodGhpcy5sZXhlckFjdGlvbnNbaV0gaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pKSB7XG5cdFx0XHRpZiAodXBkYXRlZExleGVyQWN0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0XHR1cGRhdGVkTGV4ZXJBY3Rpb25zID0gdGhpcy5sZXhlckFjdGlvbnMuY29uY2F0KFtdKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZWRMZXhlckFjdGlvbnNbaV0gPSBuZXcgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKG9mZnNldCxcblx0XHRcdFx0XHR0aGlzLmxleGVyQWN0aW9uc1tpXSk7XG5cdFx0fVxuXHR9XG5cdGlmICh1cGRhdGVkTGV4ZXJBY3Rpb25zID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBMZXhlckFjdGlvbkV4ZWN1dG9yKHVwZGF0ZWRMZXhlckFjdGlvbnMpO1xuXHR9XG59O1xuXG4vLyBFeGVjdXRlIHRoZSBhY3Rpb25zIGVuY2Fwc3VsYXRlZCBieSB0aGlzIGV4ZWN1dG9yIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhXG4vLyBwYXJ0aWN1bGFyIHtAbGluayBMZXhlcn0uXG4vL1xuLy8gPHA+VGhpcyBtZXRob2QgY2FsbHMge0BsaW5rIEludFN0cmVhbS8vc2Vla30gdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGVcbi8vIHtAY29kZSBpbnB1dH0ge0BsaW5rIENoYXJTdHJlYW19IHByaW9yIHRvIGNhbGxpbmdcbi8vIHtAbGluayBMZXhlckFjdGlvbi8vZXhlY3V0ZX0gb24gYSBwb3NpdGlvbi1kZXBlbmRlbnQgYWN0aW9uLiBCZWZvcmUgdGhlXG4vLyBtZXRob2QgcmV0dXJucywgdGhlIGlucHV0IHBvc2l0aW9uIHdpbGwgYmUgcmVzdG9yZWQgdG8gdGhlIHNhbWUgcG9zaXRpb25cbi8vIGl0IHdhcyBpbiB3aGVuIHRoZSBtZXRob2Qgd2FzIGludm9rZWQuPC9wPlxuLy9cbi8vIEBwYXJhbSBsZXhlciBUaGUgbGV4ZXIgaW5zdGFuY2UuXG4vLyBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHN0cmVhbSB3aGljaCBpcyB0aGUgc291cmNlIGZvciB0aGUgY3VycmVudCB0b2tlbi5cbi8vIFdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgY3VycmVudCB7QGxpbmsgSW50U3RyZWFtLy9pbmRleH0gZm9yXG4vLyB7QGNvZGUgaW5wdXR9IHNob3VsZCBiZSB0aGUgc3RhcnQgb2YgdGhlIGZvbGxvd2luZyB0b2tlbiwgaS5lLiAxXG4vLyBjaGFyYWN0ZXIgcGFzdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuLy8gQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHRva2VuIHN0YXJ0IGluZGV4LiBUaGlzIHZhbHVlIG1heSBiZSBwYXNzZWQgdG9cbi8vIHtAbGluayBJbnRTdHJlYW0vL3NlZWt9IHRvIHNldCB0aGUge0Bjb2RlIGlucHV0fSBwb3NpdGlvbiB0byB0aGUgYmVnaW5uaW5nXG4vLyBvZiB0aGUgdG9rZW4uXG4vLyAvXG5MZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIsIGlucHV0LCBzdGFydEluZGV4KSB7XG5cdHZhciByZXF1aXJlc1NlZWsgPSBmYWxzZTtcblx0dmFyIHN0b3BJbmRleCA9IGlucHV0LmluZGV4O1xuXHR0cnkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXhlckFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsZXhlckFjdGlvbiA9IHRoaXMubGV4ZXJBY3Rpb25zW2ldO1xuXHRcdFx0aWYgKGxleGVyQWN0aW9uIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSB7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBsZXhlckFjdGlvbi5vZmZzZXQ7XG5cdFx0XHRcdGlucHV0LnNlZWsoc3RhcnRJbmRleCArIG9mZnNldCk7XG5cdFx0XHRcdGxleGVyQWN0aW9uID0gbGV4ZXJBY3Rpb24uYWN0aW9uO1xuXHRcdFx0XHRyZXF1aXJlc1NlZWsgPSAoc3RhcnRJbmRleCArIG9mZnNldCkgIT09IHN0b3BJbmRleDtcblx0XHRcdH0gZWxzZSBpZiAobGV4ZXJBY3Rpb24uaXNQb3NpdGlvbkRlcGVuZGVudCkge1xuXHRcdFx0XHRpbnB1dC5zZWVrKHN0b3BJbmRleCk7XG5cdFx0XHRcdHJlcXVpcmVzU2VlayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0bGV4ZXJBY3Rpb24uZXhlY3V0ZShsZXhlcik7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlmIChyZXF1aXJlc1NlZWspIHtcblx0XHRcdGlucHV0LnNlZWsoc3RvcEluZGV4KTtcblx0XHR9XG5cdH1cbn07XG5cbkxleGVyQWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xufTtcblxuTGV4ZXJBY3Rpb25FeGVjdXRvci5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5jYWNoZWRIYXNoQ29kZSk7XG59O1xuXG5cbkxleGVyQWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBMZXhlckFjdGlvbkV4ZWN1dG9yKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIGlmICh0aGlzLmNhY2hlZEhhc2hDb2RlICE9IG90aGVyLmNhY2hlZEhhc2hDb2RlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2UgaWYgKHRoaXMubGV4ZXJBY3Rpb25zLmxlbmd0aCAhPSBvdGhlci5sZXhlckFjdGlvbnMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBudW1BY3Rpb25zID0gdGhpcy5sZXhlckFjdGlvbnMubGVuZ3RoXG5cdFx0Zm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbnVtQWN0aW9uczsgKytpZHgpIHtcblx0XHRcdGlmICghdGhpcy5sZXhlckFjdGlvbnNbaWR4XS5lcXVhbHMob3RoZXIubGV4ZXJBY3Rpb25zW2lkeF0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbmV4cG9ydHMuTGV4ZXJBY3Rpb25FeGVjdXRvciA9IExleGVyQWN0aW9uRXhlY3V0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0xleGVyQWN0aW9uRXhlY3V0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG4vL1xuLy8gVGhlIGVtYm9kaW1lbnQgb2YgdGhlIGFkYXB0aXZlIExMKCopLCBBTEwoKiksIHBhcnNpbmcgc3RyYXRlZ3kuXG4vL1xuLy8gPHA+XG4vLyBUaGUgYmFzaWMgY29tcGxleGl0eSBvZiB0aGUgYWRhcHRpdmUgc3RyYXRlZ3kgbWFrZXMgaXQgaGFyZGVyIHRvIHVuZGVyc3RhbmQuXG4vLyBXZSBiZWdpbiB3aXRoIEFUTiBzaW11bGF0aW9uIHRvIGJ1aWxkIHBhdGhzIGluIGEgREZBLiBTdWJzZXF1ZW50IHByZWRpY3Rpb25cbi8vIHJlcXVlc3RzIGdvIHRocm91Z2ggdGhlIERGQSBmaXJzdC4gSWYgdGhleSByZWFjaCBhIHN0YXRlIHdpdGhvdXQgYW4gZWRnZSBmb3Jcbi8vIHRoZSBjdXJyZW50IHN5bWJvbCwgdGhlIGFsZ29yaXRobSBmYWlscyBvdmVyIHRvIHRoZSBBVE4gc2ltdWxhdGlvbiB0b1xuLy8gY29tcGxldGUgdGhlIERGQSBwYXRoIGZvciB0aGUgY3VycmVudCBpbnB1dCAodW50aWwgaXQgZmluZHMgYSBjb25mbGljdCBzdGF0ZVxuLy8gb3IgdW5pcXVlbHkgcHJlZGljdGluZyBzdGF0ZSkuPC9wPlxuLy9cbi8vIDxwPlxuLy8gQWxsIG9mIHRoYXQgaXMgZG9uZSB3aXRob3V0IHVzaW5nIHRoZSBvdXRlciBjb250ZXh0IGJlY2F1c2Ugd2Ugd2FudCB0byBjcmVhdGVcbi8vIGEgREZBIHRoYXQgaXMgbm90IGRlcGVuZGVudCB1cG9uIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2sgd2hlbiB3ZSBkbyBhXG4vLyBwcmVkaWN0aW9uLiBPbmUgREZBIHdvcmtzIGluIGFsbCBjb250ZXh0cy4gV2UgYXZvaWQgdXNpbmcgY29udGV4dCBub3Rcbi8vIG5lY2Vzc2FyaWx5IGJlY2F1c2UgaXQncyBzbG93ZXIsIGFsdGhvdWdoIGl0IGNhbiBiZSwgYnV0IGJlY2F1c2Ugb2YgdGhlIERGQVxuLy8gY2FjaGluZyBwcm9ibGVtLiBUaGUgY2xvc3VyZSByb3V0aW5lIG9ubHkgY29uc2lkZXJzIHRoZSBydWxlIGludm9jYXRpb24gc3RhY2tcbi8vIGNyZWF0ZWQgZHVyaW5nIHByZWRpY3Rpb24gYmVnaW5uaW5nIGluIHRoZSBkZWNpc2lvbiBydWxlLiBGb3IgZXhhbXBsZSwgaWZcbi8vIHByZWRpY3Rpb24gb2NjdXJzIHdpdGhvdXQgaW52b2tpbmcgYW5vdGhlciBydWxlJ3MgQVROLCB0aGVyZSBhcmUgbm8gY29udGV4dFxuLy8gc3RhY2tzIGluIHRoZSBjb25maWd1cmF0aW9ucy4gV2hlbiBsYWNrIG9mIGNvbnRleHQgbGVhZHMgdG8gYSBjb25mbGljdCwgd2Vcbi8vIGRvbid0IGtub3cgaWYgaXQncyBhbiBhbWJpZ3VpdHkgb3IgYSB3ZWFrbmVzcyBpbiB0aGUgc3Ryb25nIExMKCopIHBhcnNpbmdcbi8vIHN0cmF0ZWd5ICh2ZXJzdXMgZnVsbCBMTCgqKSkuPC9wPlxuLy9cbi8vIDxwPlxuLy8gV2hlbiBTTEwgeWllbGRzIGEgY29uZmlndXJhdGlvbiBzZXQgd2l0aCBjb25mbGljdCwgd2UgcmV3aW5kIHRoZSBpbnB1dCBhbmRcbi8vIHJldHJ5IHRoZSBBVE4gc2ltdWxhdGlvbiwgdGhpcyB0aW1lIHVzaW5nIGZ1bGwgb3V0ZXIgY29udGV4dCB3aXRob3V0IGFkZGluZ1xuLy8gdG8gdGhlIERGQS4gQ29uZmlndXJhdGlvbiBjb250ZXh0IHN0YWNrcyB3aWxsIGJlIHRoZSBmdWxsIGludm9jYXRpb24gc3RhY2tzXG4vLyBmcm9tIHRoZSBzdGFydCBydWxlLiBJZiB3ZSBnZXQgYSBjb25mbGljdCB1c2luZyBmdWxsIGNvbnRleHQsIHRoZW4gd2UgY2FuXG4vLyBkZWZpbml0aXZlbHkgc2F5IHdlIGhhdmUgYSB0cnVlIGFtYmlndWl0eSBmb3IgdGhhdCBpbnB1dCBzZXF1ZW5jZS4gSWYgd2Vcbi8vIGRvbid0IGdldCBhIGNvbmZsaWN0LCBpdCBpbXBsaWVzIHRoYXQgdGhlIGRlY2lzaW9uIGlzIHNlbnNpdGl2ZSB0byB0aGUgb3V0ZXJcbi8vIGNvbnRleHQuIChJdCBpcyBub3QgY29udGV4dC1zZW5zaXRpdmUgaW4gdGhlIHNlbnNlIG9mIGNvbnRleHQtc2Vuc2l0aXZlXG4vLyBncmFtbWFycy4pPC9wPlxuLy9cbi8vIDxwPlxuLy8gVGhlIG5leHQgdGltZSB3ZSByZWFjaCB0aGlzIERGQSBzdGF0ZSB3aXRoIGFuIFNMTCBjb25mbGljdCwgdGhyb3VnaCBERkFcbi8vIHNpbXVsYXRpb24sIHdlIHdpbGwgYWdhaW4gcmV0cnkgdGhlIEFUTiBzaW11bGF0aW9uIHVzaW5nIGZ1bGwgY29udGV4dCBtb2RlLlxuLy8gVGhpcyBpcyBzbG93IGJlY2F1c2Ugd2UgY2FuJ3Qgc2F2ZSB0aGUgcmVzdWx0cyBhbmQgaGF2ZSB0byBcImludGVycHJldFwiIHRoZVxuLy8gQVROIGVhY2ggdGltZSB3ZSBnZXQgdGhhdCBpbnB1dC48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPkNBQ0hJTkcgRlVMTCBDT05URVhUIFBSRURJQ1RJT05TPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlxuLy8gV2UgY291bGQgY2FjaGUgcmVzdWx0cyBmcm9tIGZ1bGwgY29udGV4dCB0byBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUgZWFzaWx5IGFuZFxuLy8gdGhhdCBzYXZlcyBhIGxvdCBvZiB0aW1lIGJ1dCBkb2Vzbid0IHdvcmsgaW4gcHJlc2VuY2Ugb2YgcHJlZGljYXRlcy4gVGhlIHNldFxuLy8gb2YgdmlzaWJsZSBwcmVkaWNhdGVzIGZyb20gdGhlIEFUTiBzdGFydCBzdGF0ZSBjaGFuZ2VzIGRlcGVuZGluZyBvbiB0aGVcbi8vIGNvbnRleHQsIGJlY2F1c2UgY2xvc3VyZSBjYW4gZmFsbCBvZmYgdGhlIGVuZCBvZiBhIHJ1bGUuIEkgdHJpZWQgdG8gY2FjaGVcbi8vIHR1cGxlcyAoc3RhY2sgY29udGV4dCwgc2VtYW50aWMgY29udGV4dCwgcHJlZGljdGVkIGFsdCkgYnV0IGl0IHdhcyBzbG93ZXJcbi8vIHRoYW4gaW50ZXJwcmV0aW5nIGFuZCBtdWNoIG1vcmUgY29tcGxpY2F0ZWQuIEFsc28gcmVxdWlyZWQgYSBodWdlIGFtb3VudCBvZlxuLy8gbWVtb3J5LiBUaGUgZ29hbCBpcyBub3QgdG8gY3JlYXRlIHRoZSB3b3JsZCdzIGZhc3Rlc3QgcGFyc2VyIGFueXdheS4gSSdkIGxpa2Vcbi8vIHRvIGtlZXAgdGhpcyBhbGdvcml0aG0gc2ltcGxlLiBCeSBsYXVuY2hpbmcgbXVsdGlwbGUgdGhyZWFkcywgd2UgY2FuIGltcHJvdmVcbi8vIHRoZSBzcGVlZCBvZiBwYXJzaW5nIGFjcm9zcyBhIGxhcmdlIG51bWJlciBvZiBmaWxlcy48L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGVyZSBpcyBubyBzdHJpY3Qgb3JkZXJpbmcgYmV0d2VlbiB0aGUgYW1vdW50IG9mIGlucHV0IHVzZWQgYnkgU0xMIHZzIExMLFxuLy8gd2hpY2ggbWFrZXMgaXQgcmVhbGx5IGhhcmQgdG8gYnVpbGQgYSBjYWNoZSBmb3IgZnVsbCBjb250ZXh0LiBMZXQncyBzYXkgdGhhdFxuLy8gd2UgaGF2ZSBpbnB1dCBBIEIgQyB0aGF0IGxlYWRzIHRvIGFuIFNMTCBjb25mbGljdCB3aXRoIGZ1bGwgY29udGV4dCBYLiBUaGF0XG4vLyBpbXBsaWVzIHRoYXQgdXNpbmcgWCB3ZSBtaWdodCBvbmx5IHVzZSBBIEIgYnV0IHdlIGNvdWxkIGFsc28gdXNlIEEgQiBDIEQgdG9cbi8vIHJlc29sdmUgY29uZmxpY3QuIElucHV0IEEgQiBDIEQgY291bGQgcHJlZGljdCBhbHRlcm5hdGl2ZSAxIGluIG9uZSBwb3NpdGlvblxuLy8gaW4gdGhlIGlucHV0IGFuZCBBIEIgQyBFIGNvdWxkIHByZWRpY3QgYWx0ZXJuYXRpdmUgMiBpbiBhbm90aGVyIHBvc2l0aW9uIGluXG4vLyBpbnB1dC4gVGhlIGNvbmZsaWN0aW5nIFNMTCBjb25maWd1cmF0aW9ucyBjb3VsZCBzdGlsbCBiZSBub24tdW5pcXVlIGluIHRoZVxuLy8gZnVsbCBjb250ZXh0IHByZWRpY3Rpb24sIHdoaWNoIHdvdWxkIGxlYWQgdXMgdG8gcmVxdWlyaW5nIG1vcmUgaW5wdXQgdGhhbiB0aGVcbi8vIG9yaWdpbmFsIEEgQiBDLlx0VG8gbWFrZSBhXHRwcmVkaWN0aW9uIGNhY2hlIHdvcmssIHdlIGhhdmUgdG8gdHJhY2tcdHRoZSBleGFjdFxuLy8gaW5wdXRcdHVzZWQgZHVyaW5nIHRoZSBwcmV2aW91cyBwcmVkaWN0aW9uLiBUaGF0IGFtb3VudHMgdG8gYSBjYWNoZSB0aGF0IG1hcHNcbi8vIFggdG8gYSBzcGVjaWZpYyBERkEgZm9yIHRoYXQgY29udGV4dC48L3A+XG4vL1xuLy8gPHA+XG4vLyBTb21ldGhpbmcgc2hvdWxkIGJlIGRvbmUgZm9yIGxlZnQtcmVjdXJzaXZlIGV4cHJlc3Npb24gcHJlZGljdGlvbnMuIFRoZXkgYXJlXG4vLyBsaWtlbHkgTEwoMSkgKyBwcmVkIGV2YWwuIEVhc2llciB0byBkbyB0aGUgd2hvbGUgU0xMIHVubGVzcyBlcnJvciBhbmQgcmV0cnlcbi8vIHdpdGggZnVsbCBMTCB0aGluZyBTYW0gZG9lcy48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPkFWT0lESU5HIEZVTEwgQ09OVEVYVCBQUkVESUNUSU9OPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlxuLy8gV2UgYXZvaWQgZG9pbmcgZnVsbCBjb250ZXh0IHJldHJ5IHdoZW4gdGhlIG91dGVyIGNvbnRleHQgaXMgZW1wdHksIHdlIGRpZCBub3Rcbi8vIGRpcCBpbnRvIHRoZSBvdXRlciBjb250ZXh0IGJ5IGZhbGxpbmcgb2ZmIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHN0YXRlIHJ1bGUsXG4vLyBvciB3aGVuIHdlIGZvcmNlIFNMTCBtb2RlLjwvcD5cbi8vXG4vLyA8cD5cbi8vIEFzIGFuIGV4YW1wbGUgb2YgdGhlIG5vdCBkaXAgaW50byBvdXRlciBjb250ZXh0IGNhc2UsIGNvbnNpZGVyIGFzIHN1cGVyXG4vLyBjb25zdHJ1Y3RvciBjYWxscyB2ZXJzdXMgZnVuY3Rpb24gY2FsbHMuIE9uZSBncmFtbWFyIG1pZ2h0IGxvb2sgbGlrZVxuLy8gdGhpczo8L3A+XG4vL1xuLy8gPHByZT5cbi8vIGN0b3JCb2R5XG4vLyAgIDogJ3snIHN1cGVyQ2FsbD8gc3RhdCogJ30nXG4vLyAgIDtcbi8vIDwvcHJlPlxuLy9cbi8vIDxwPlxuLy8gT3IsIHlvdSBtaWdodCBzZWUgc29tZXRoaW5nIGxpa2U8L3A+XG4vL1xuLy8gPHByZT5cbi8vIHN0YXRcbi8vICAgOiBzdXBlckNhbGwgJzsnXG4vLyAgIHwgZXhwcmVzc2lvbiAnOydcbi8vICAgfCAuLi5cbi8vICAgO1xuLy8gPC9wcmU+XG4vL1xuLy8gPHA+XG4vLyBJbiBib3RoIGNhc2VzIEkgYmVsaWV2ZSB0aGF0IG5vIGNsb3N1cmUgb3BlcmF0aW9ucyB3aWxsIGRpcCBpbnRvIHRoZSBvdXRlclxuLy8gY29udGV4dC4gSW4gdGhlIGZpcnN0IGNhc2UgY3RvckJvZHkgaW4gdGhlIHdvcnN0IGNhc2Ugd2lsbCBzdG9wIGF0IHRoZSAnfScuXG4vLyBJbiB0aGUgMm5kIGNhc2UgaXQgc2hvdWxkIHN0b3AgYXQgdGhlICc7Jy4gQm90aCBjYXNlcyBzaG91bGQgc3RheSB3aXRoaW4gdGhlXG4vLyBlbnRyeSBydWxlIGFuZCBub3QgZGlwIGludG8gdGhlIG91dGVyIGNvbnRleHQuPC9wPlxuLy9cbi8vIDxwPlxuLy8gPHN0cm9uZz5QUkVESUNBVEVTPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlxuLy8gUHJlZGljYXRlcyBhcmUgYWx3YXlzIGV2YWx1YXRlZCBpZiBwcmVzZW50IGluIGVpdGhlciBTTEwgb3IgTEwgYm90aC4gU0xMIGFuZFxuLy8gTEwgc2ltdWxhdGlvbiBkZWFscyB3aXRoIHByZWRpY2F0ZXMgZGlmZmVyZW50bHkuIFNMTCBjb2xsZWN0cyBwcmVkaWNhdGVzIGFzXG4vLyBpdCBwZXJmb3JtcyBjbG9zdXJlIG9wZXJhdGlvbnMgbGlrZSBBTlRMUiB2MyBkaWQuIEl0IGRlbGF5cyBwcmVkaWNhdGVcbi8vIGV2YWx1YXRpb24gdW50aWwgaXQgcmVhY2hlcyBhbmQgYWNjZXB0IHN0YXRlLiBUaGlzIGFsbG93cyB1cyB0byBjYWNoZSB0aGUgU0xMXG4vLyBBVE4gc2ltdWxhdGlvbiB3aGVyZWFzLCBpZiB3ZSBoYWQgZXZhbHVhdGVkIHByZWRpY2F0ZXMgb24tdGhlLWZseSBkdXJpbmdcbi8vIGNsb3N1cmUsIHRoZSBERkEgc3RhdGUgY29uZmlndXJhdGlvbiBzZXRzIHdvdWxkIGJlIGRpZmZlcmVudCBhbmQgd2UgY291bGRuJ3Rcbi8vIGJ1aWxkIHVwIGEgc3VpdGFibGUgREZBLjwvcD5cbi8vXG4vLyA8cD5cbi8vIFdoZW4gYnVpbGRpbmcgYSBERkEgYWNjZXB0IHN0YXRlIGR1cmluZyBBVE4gc2ltdWxhdGlvbiwgd2UgZXZhbHVhdGUgYW55XG4vLyBwcmVkaWNhdGVzIGFuZCByZXR1cm4gdGhlIHNvbGUgc2VtYW50aWNhbGx5IHZhbGlkIGFsdGVybmF0aXZlLiBJZiB0aGVyZSBpc1xuLy8gbW9yZSB0aGFuIDEgYWx0ZXJuYXRpdmUsIHdlIHJlcG9ydCBhbiBhbWJpZ3VpdHkuIElmIHRoZXJlIGFyZSAwIGFsdGVybmF0aXZlcyxcbi8vIHdlIHRocm93IGFuIGV4Y2VwdGlvbi4gQWx0ZXJuYXRpdmVzIHdpdGhvdXQgcHJlZGljYXRlcyBhY3QgbGlrZSB0aGV5IGhhdmVcbi8vIHRydWUgcHJlZGljYXRlcy4gVGhlIHNpbXBsZSB3YXkgdG8gdGhpbmsgYWJvdXQgaXQgaXMgdG8gc3RyaXAgYXdheSBhbGxcbi8vIGFsdGVybmF0aXZlcyB3aXRoIGZhbHNlIHByZWRpY2F0ZXMgYW5kIGNob29zZSB0aGUgbWluaW11bSBhbHRlcm5hdGl2ZSB0aGF0XG4vLyByZW1haW5zLjwvcD5cbi8vXG4vLyA8cD5cbi8vIFdoZW4gd2Ugc3RhcnQgaW4gdGhlIERGQSBhbmQgcmVhY2ggYW4gYWNjZXB0IHN0YXRlIHRoYXQncyBwcmVkaWNhdGVkLCB3ZSB0ZXN0XG4vLyB0aG9zZSBhbmQgcmV0dXJuIHRoZSBtaW5pbXVtIHNlbWFudGljYWxseSB2aWFibGUgYWx0ZXJuYXRpdmUuIElmIG5vXG4vLyBhbHRlcm5hdGl2ZXMgYXJlIHZpYWJsZSwgd2UgdGhyb3cgYW4gZXhjZXB0aW9uLjwvcD5cbi8vXG4vLyA8cD5cbi8vIER1cmluZyBmdWxsIExMIEFUTiBzaW11bGF0aW9uLCBjbG9zdXJlIGFsd2F5cyBldmFsdWF0ZXMgcHJlZGljYXRlcyBhbmRcbi8vIG9uLXRoZS1mbHkuIFRoaXMgaXMgY3J1Y2lhbCB0byByZWR1Y2luZyB0aGUgY29uZmlndXJhdGlvbiBzZXQgc2l6ZSBkdXJpbmdcbi8vIGNsb3N1cmUuIEl0IGhpdHMgYSBsYW5kbWluZSB3aGVuIHBhcnNpbmcgd2l0aCB0aGUgSmF2YSBncmFtbWFyLCBmb3IgZXhhbXBsZSxcbi8vIHdpdGhvdXQgdGhpcyBvbi10aGUtZmx5IGV2YWx1YXRpb24uPC9wPlxuLy9cbi8vIDxwPlxuLy8gPHN0cm9uZz5TSEFSSU5HIERGQTwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5cbi8vIEFsbCBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgcGFyc2VyIHNoYXJlIHRoZSBzYW1lIGRlY2lzaW9uIERGQXMgdGhyb3VnaCBhXG4vLyBzdGF0aWMgZmllbGQuIEVhY2ggaW5zdGFuY2UgZ2V0cyBpdHMgb3duIEFUTiBzaW11bGF0b3IgYnV0IHRoZXkgc2hhcmUgdGhlXG4vLyBzYW1lIHtAbGluayAvL2RlY2lzaW9uVG9ERkF9IGZpZWxkLiBUaGV5IGFsc28gc2hhcmUgYVxuLy8ge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0Q2FjaGV9IG9iamVjdCB0aGF0IG1ha2VzIHN1cmUgdGhhdCBhbGxcbi8vIHtAbGluayBQcmVkaWN0aW9uQ29udGV4dH0gb2JqZWN0cyBhcmUgc2hhcmVkIGFtb25nIHRoZSBERkEgc3RhdGVzLiBUaGlzIG1ha2VzXG4vLyBhIGJpZyBzaXplIGRpZmZlcmVuY2UuPC9wPlxuLy9cbi8vIDxwPlxuLy8gPHN0cm9uZz5USFJFQUQgU0FGRVRZPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlxuLy8gVGhlIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3J9IGxvY2tzIG9uIHRoZSB7QGxpbmsgLy9kZWNpc2lvblRvREZBfSBmaWVsZCB3aGVuXG4vLyBpdCBhZGRzIGEgbmV3IERGQSBvYmplY3QgdG8gdGhhdCBhcnJheS4ge0BsaW5rIC8vYWRkREZBRWRnZX1cbi8vIGxvY2tzIG9uIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uIHdoZW4gc2V0dGluZyB0aGVcbi8vIHtAbGluayBERkFTdGF0ZS8vZWRnZXN9IGZpZWxkLiB7QGxpbmsgLy9hZGRERkFTdGF0ZX0gbG9ja3Mgb25cbi8vIHRoZSBERkEgZm9yIHRoZSBjdXJyZW50IGRlY2lzaW9uIHdoZW4gbG9va2luZyB1cCBhIERGQSBzdGF0ZSB0byBzZWUgaWYgaXRcbi8vIGFscmVhZHkgZXhpc3RzLiBXZSBtdXN0IG1ha2Ugc3VyZSB0aGF0IGFsbCByZXF1ZXN0cyB0byBhZGQgREZBIHN0YXRlcyB0aGF0XG4vLyBhcmUgZXF1aXZhbGVudCByZXN1bHQgaW4gdGhlIHNhbWUgc2hhcmVkIERGQSBvYmplY3QuIFRoaXMgaXMgYmVjYXVzZSBsb3RzIG9mXG4vLyB0aHJlYWRzIHdpbGwgYmUgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgREZBIGF0IG9uY2UuIFRoZVxuLy8ge0BsaW5rIC8vYWRkREZBU3RhdGV9IG1ldGhvZCBhbHNvIGxvY2tzIGluc2lkZSB0aGUgREZBIGxvY2tcbi8vIGJ1dCB0aGlzIHRpbWUgb24gdGhlIHNoYXJlZCBjb250ZXh0IGNhY2hlIHdoZW4gaXQgcmVidWlsZHMgdGhlXG4vLyBjb25maWd1cmF0aW9ucycge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RzIHVzaW5nIGNhY2hlZFxuLy8gc3ViZ3JhcGhzL25vZGVzLiBObyBvdGhlciBsb2NraW5nIG9jY3VycywgZXZlbiBkdXJpbmcgREZBIHNpbXVsYXRpb24uIFRoaXMgaXNcbi8vIHNhZmUgYXMgbG9uZyBhcyB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHRocmVhZHMgcmVmZXJlbmNpbmdcbi8vIHtAY29kZSBzLmVkZ2VbdF19IGdldCB0aGUgc2FtZSBwaHlzaWNhbCB0YXJnZXQge0BsaW5rIERGQVN0YXRlfSwgb3Jcbi8vIHtAY29kZSBudWxsfS4gT25jZSBpbnRvIHRoZSBERkEsIHRoZSBERkEgc2ltdWxhdGlvbiBkb2VzIG5vdCByZWZlcmVuY2UgdGhlXG4vLyB7QGxpbmsgREZBLy9zdGF0ZXN9IG1hcC4gSXQgZm9sbG93cyB0aGUge0BsaW5rIERGQVN0YXRlLy9lZGdlc30gZmllbGQgdG8gbmV3XG4vLyB0YXJnZXRzLiBUaGUgREZBIHNpbXVsYXRvciB3aWxsIGVpdGhlciBmaW5kIHtAbGluayBERkFTdGF0ZS8vZWRnZXN9IHRvIGJlXG4vLyB7QGNvZGUgbnVsbH0sIHRvIGJlIG5vbi17QGNvZGUgbnVsbH0gYW5kIHtAY29kZSBkZmEuZWRnZXNbdF19IG51bGwsIG9yXG4vLyB7QGNvZGUgZGZhLmVkZ2VzW3RdfSB0byBiZSBub24tbnVsbC4gVGhlXG4vLyB7QGxpbmsgLy9hZGRERkFFZGdlfSBtZXRob2QgY291bGQgYmUgcmFjaW5nIHRvIHNldCB0aGUgZmllbGRcbi8vIGJ1dCBpbiBlaXRoZXIgY2FzZSB0aGUgREZBIHNpbXVsYXRvciB3b3JrczsgaWYge0Bjb2RlIG51bGx9LCBhbmQgcmVxdWVzdHMgQVROXG4vLyBzaW11bGF0aW9uLiBJdCBjb3VsZCBhbHNvIHJhY2UgdHJ5aW5nIHRvIGdldCB7QGNvZGUgZGZhLmVkZ2VzW3RdfSwgYnV0IGVpdGhlclxuLy8gd2F5IGl0IHdpbGwgd29yayBiZWNhdXNlIGl0J3Mgbm90IGRvaW5nIGEgdGVzdCBhbmQgc2V0IG9wZXJhdGlvbi48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPlN0YXJ0aW5nIHdpdGggU0xMIHRoZW4gZmFpbGluZyB0byBjb21iaW5lZCBTTEwvTEwgKFR3by1TdGFnZVxuLy8gUGFyc2luZyk8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+XG4vLyBTYW0gcG9pbnRlZCBvdXQgdGhhdCBpZiBTTEwgZG9lcyBub3QgZ2l2ZSBhIHN5bnRheCBlcnJvciwgdGhlbiB0aGVyZSBpcyBub1xuLy8gcG9pbnQgaW4gZG9pbmcgZnVsbCBMTCwgd2hpY2ggaXMgc2xvd2VyLiBXZSBvbmx5IGhhdmUgdG8gdHJ5IExMIGlmIHdlIGdldCBhXG4vLyBzeW50YXggZXJyb3IuIEZvciBtYXhpbXVtIHNwZWVkLCBTYW0gc3RhcnRzIHRoZSBwYXJzZXIgc2V0IHRvIHB1cmUgU0xMXG4vLyBtb2RlIHdpdGggdGhlIHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX06PC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBwYXJzZXIue0BsaW5rIFBhcnNlci8vZ2V0SW50ZXJwcmV0ZXIoKSBnZXRJbnRlcnByZXRlcigpfS57QGxpbmsgLy9zZXRQcmVkaWN0aW9uTW9kZSBzZXRQcmVkaWN0aW9uTW9kZX17QGNvZGUgKH17QGxpbmsgUHJlZGljdGlvbk1vZGUvL1NMTH17QGNvZGUgKX07XG4vLyBwYXJzZXIue0BsaW5rIFBhcnNlci8vc2V0RXJyb3JIYW5kbGVyIHNldEVycm9ySGFuZGxlcn0obmV3IHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX0oKSk7XG4vLyA8L3ByZT5cbi8vXG4vLyA8cD5cbi8vIElmIGl0IGRvZXMgbm90IGdldCBhIHN5bnRheCBlcnJvciwgdGhlbiB3ZSdyZSBkb25lLiBJZiBpdCBkb2VzIGdldCBhIHN5bnRheFxuLy8gZXJyb3IsIHdlIG5lZWQgdG8gcmV0cnkgd2l0aCB0aGUgY29tYmluZWQgU0xML0xMIHN0cmF0ZWd5LjwvcD5cbi8vXG4vLyA8cD5cbi8vIFRoZSByZWFzb24gdGhpcyB3b3JrcyBpcyBhcyBmb2xsb3dzLiBJZiB0aGVyZSBhcmUgbm8gU0xMIGNvbmZsaWN0cywgdGhlbiB0aGVcbi8vIGdyYW1tYXIgaXMgU0xMIChhdCBsZWFzdCBmb3IgdGhhdCBpbnB1dCBzZXQpLiBJZiB0aGVyZSBpcyBhbiBTTEwgY29uZmxpY3QsXG4vLyB0aGUgZnVsbCBMTCBhbmFseXNpcyBtdXN0IHlpZWxkIGEgc2V0IG9mIHZpYWJsZSBhbHRlcm5hdGl2ZXMgd2hpY2ggaXMgYVxuLy8gc3Vic2V0IG9mIHRoZSBhbHRlcm5hdGl2ZXMgcmVwb3J0ZWQgYnkgU0xMLiBJZiB0aGUgTEwgc2V0IGlzIGEgc2luZ2xldG9uLFxuLy8gdGhlbiB0aGUgZ3JhbW1hciBpcyBMTCBidXQgbm90IFNMTC4gSWYgdGhlIExMIHNldCBpcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBTTExcbi8vIHNldCwgdGhlIGRlY2lzaW9uIGlzIFNMTC4gSWYgdGhlIExMIHNldCBoYXMgc2l6ZSAmZ3Q7IDEsIHRoZW4gdGhhdCBkZWNpc2lvblxuLy8gaXMgdHJ1bHkgYW1iaWd1b3VzIG9uIHRoZSBjdXJyZW50IGlucHV0LiBJZiB0aGUgTEwgc2V0IGlzIHNtYWxsZXIsIHRoZW4gdGhlXG4vLyBTTEwgY29uZmxpY3QgcmVzb2x1dGlvbiBtaWdodCBjaG9vc2UgYW4gYWx0ZXJuYXRpdmUgdGhhdCB0aGUgZnVsbCBMTCB3b3VsZFxuLy8gcnVsZSBvdXQgYXMgYSBwb3NzaWJpbGl0eSBiYXNlZCB1cG9uIGJldHRlciBjb250ZXh0IGluZm9ybWF0aW9uLiBJZiB0aGF0J3Ncbi8vIHRoZSBjYXNlLCB0aGVuIHRoZSBTTEwgcGFyc2Ugd2lsbCBkZWZpbml0ZWx5IGdldCBhbiBlcnJvciBiZWNhdXNlIHRoZSBmdWxsIExMXG4vLyBhbmFseXNpcyBzYXlzIGl0J3Mgbm90IHZpYWJsZS4gSWYgU0xMIGNvbmZsaWN0IHJlc29sdXRpb24gY2hvb3NlcyBhblxuLy8gYWx0ZXJuYXRpdmUgd2l0aGluIHRoZSBMTCBzZXQsIHRoZW0gYm90aCBTTEwgYW5kIExMIHdvdWxkIGNob29zZSB0aGUgc2FtZVxuLy8gYWx0ZXJuYXRpdmUgYmVjYXVzZSB0aGV5IGJvdGggY2hvb3NlIHRoZSBtaW5pbXVtIG9mIG11bHRpcGxlIGNvbmZsaWN0aW5nXG4vLyBhbHRlcm5hdGl2ZXMuPC9wPlxuLy9cbi8vIDxwPlxuLy8gTGV0J3Mgc2F5IHdlIGhhdmUgYSBzZXQgb2YgU0xMIGNvbmZsaWN0aW5nIGFsdGVybmF0aXZlcyB7QGNvZGUgezEsIDIsIDN9fSBhbmRcbi8vIGEgc21hbGxlciBMTCBzZXQgY2FsbGVkIDxlbT5zPC9lbT4uIElmIDxlbT5zPC9lbT4gaXMge0Bjb2RlIHsyLCAzfX0sIHRoZW4gU0xMXG4vLyBwYXJzaW5nIHdpbGwgZ2V0IGFuIGVycm9yIGJlY2F1c2UgU0xMIHdpbGwgcHVyc3VlIGFsdGVybmF0aXZlIDEuIElmXG4vLyA8ZW0+czwvZW0+IGlzIHtAY29kZSB7MSwgMn19IG9yIHtAY29kZSB7MSwgM319IHRoZW4gYm90aCBTTEwgYW5kIExMIHdpbGxcbi8vIGNob29zZSB0aGUgc2FtZSBhbHRlcm5hdGl2ZSBiZWNhdXNlIGFsdGVybmF0aXZlIG9uZSBpcyB0aGUgbWluaW11bSBvZiBlaXRoZXJcbi8vIHNldC4gSWYgPGVtPnM8L2VtPiBpcyB7QGNvZGUgezJ9fSBvciB7QGNvZGUgezN9fSB0aGVuIFNMTCB3aWxsIGdldCBhIHN5bnRheFxuLy8gZXJyb3IuIElmIDxlbT5zPC9lbT4gaXMge0Bjb2RlIHsxfX0gdGhlbiBTTEwgd2lsbCBzdWNjZWVkLjwvcD5cbi8vXG4vLyA8cD5cbi8vIE9mIGNvdXJzZSwgaWYgdGhlIGlucHV0IGlzIGludmFsaWQsIHRoZW4gd2Ugd2lsbCBnZXQgYW4gZXJyb3IgZm9yIHN1cmUgaW5cbi8vIGJvdGggU0xMIGFuZCBMTCBwYXJzaW5nLiBFcnJvbmVvdXMgaW5wdXQgd2lsbCB0aGVyZWZvcmUgcmVxdWlyZSAyIHBhc3NlcyBvdmVyXG4vLyB0aGUgaW5wdXQuPC9wPlxuLy9cblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi8uLi9VdGlscycpO1xudmFyIFNldCA9IFV0aWxzLlNldDtcbnZhciBCaXRTZXQgPSBVdGlscy5CaXRTZXQ7XG52YXIgRG91YmxlRGljdCA9IFV0aWxzLkRvdWJsZURpY3Q7XG52YXIgQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG52YXIgQVROU3RhdGUgPSByZXF1aXJlKCcuL0FUTlN0YXRlJykuQVROU3RhdGU7XG52YXIgQVROQ29uZmlnID0gcmVxdWlyZSgnLi9BVE5Db25maWcnKS5BVE5Db25maWc7XG52YXIgQVROQ29uZmlnU2V0ID0gcmVxdWlyZSgnLi9BVE5Db25maWdTZXQnKS5BVE5Db25maWdTZXQ7XG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLy4uL1Rva2VuJykuVG9rZW47XG52YXIgREZBU3RhdGUgPSByZXF1aXJlKCcuLy4uL2RmYS9ERkFTdGF0ZScpLkRGQVN0YXRlO1xudmFyIFByZWRQcmVkaWN0aW9uID0gcmVxdWlyZSgnLi8uLi9kZmEvREZBU3RhdGUnKS5QcmVkUHJlZGljdGlvbjtcbnZhciBBVE5TaW11bGF0b3IgPSByZXF1aXJlKCcuL0FUTlNpbXVsYXRvcicpLkFUTlNpbXVsYXRvcjtcbnZhciBQcmVkaWN0aW9uTW9kZSA9IHJlcXVpcmUoJy4vUHJlZGljdGlvbk1vZGUnKS5QcmVkaWN0aW9uTW9kZTtcbnZhciBSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUnVsZUNvbnRleHQnKS5SdWxlQ29udGV4dDtcbnZhciBQYXJzZXJSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUGFyc2VyUnVsZUNvbnRleHQnKS5QYXJzZXJSdWxlQ29udGV4dDtcbnZhciBTZW1hbnRpY0NvbnRleHQgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlNlbWFudGljQ29udGV4dDtcbnZhciBTdGFyTG9vcEVudHJ5U3RhdGUgPSByZXF1aXJlKCcuL0FUTlN0YXRlJykuU3Rhckxvb3BFbnRyeVN0YXRlO1xudmFyIFJ1bGVTdG9wU3RhdGUgPSByZXF1aXJlKCcuL0FUTlN0YXRlJykuUnVsZVN0b3BTdGF0ZTtcbnZhciBQcmVkaWN0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5QcmVkaWN0aW9uQ29udGV4dDtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcbnZhciBUcmFuc2l0aW9ucyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbicpO1xudmFyIFRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5UcmFuc2l0aW9uO1xudmFyIFNldFRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5TZXRUcmFuc2l0aW9uO1xudmFyIE5vdFNldFRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5Ob3RTZXRUcmFuc2l0aW9uO1xudmFyIFJ1bGVUcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuUnVsZVRyYW5zaXRpb247XG52YXIgQWN0aW9uVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLkFjdGlvblRyYW5zaXRpb247XG52YXIgTm9WaWFibGVBbHRFeGNlcHRpb24gPSByZXF1aXJlKCcuLy4uL2Vycm9yL0Vycm9ycycpLk5vVmlhYmxlQWx0RXhjZXB0aW9uO1xuXG52YXIgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLy4uL1ByZWRpY3Rpb25Db250ZXh0JykuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQ7XG52YXIgcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQgPSByZXF1aXJlKCcuLy4uL1ByZWRpY3Rpb25Db250ZXh0JykucHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQ7XG5cbmZ1bmN0aW9uIFBhcnNlckFUTlNpbXVsYXRvcihwYXJzZXIsIGF0biwgZGVjaXNpb25Ub0RGQSwgc2hhcmVkQ29udGV4dENhY2hlKSB7XG5cdEFUTlNpbXVsYXRvci5jYWxsKHRoaXMsIGF0biwgc2hhcmVkQ29udGV4dENhY2hlKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmRlY2lzaW9uVG9ERkEgPSBkZWNpc2lvblRvREZBO1xuICAgIC8vIFNMTCwgTEwsIG9yIExMICsgZXhhY3QgYW1iaWcgZGV0ZWN0aW9uPy8vXG4gICAgdGhpcy5wcmVkaWN0aW9uTW9kZSA9IFByZWRpY3Rpb25Nb2RlLkxMO1xuICAgIC8vIExBTUUgZ2xvYmFscyB0byBhdm9pZCBwYXJhbWV0ZXJzISEhISEgSSBuZWVkIHRoZXNlIGRvd24gZGVlcCBpbiBwcmVkVHJhbnNpdGlvblxuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydEluZGV4ID0gMDtcbiAgICB0aGlzLl9vdXRlckNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX2RmYSA9IG51bGw7XG4gICAgLy8gRWFjaCBwcmVkaWN0aW9uIG9wZXJhdGlvbiB1c2VzIGEgY2FjaGUgZm9yIG1lcmdlIG9mIHByZWRpY3Rpb24gY29udGV4dHMuXG4gICAgLy8gIERvbid0IGtlZXAgYXJvdW5kIGFzIGl0IHdhc3RlcyBodWdlIGFtb3VudHMgb2YgbWVtb3J5LiBEb3VibGVLZXlNYXBcbiAgICAvLyAgaXNuJ3Qgc3luY2hyb25pemVkIGJ1dCB3ZSdyZSBvayBzaW5jZSB0d28gdGhyZWFkcyBzaG91bGRuJ3QgcmV1c2Ugc2FtZVxuICAgIC8vICBwYXJzZXIvYXRuc2ltIG9iamVjdCBiZWNhdXNlIGl0IGNhbiBvbmx5IGhhbmRsZSBvbmUgaW5wdXQgYXQgYSB0aW1lLlxuICAgIC8vICBUaGlzIG1hcHMgZ3JhcGhzIGEgYW5kIGIgdG8gbWVyZ2VkIHJlc3VsdCBjLiAoYSxiKSZyYXJyO2MuIFdlIGNhbiBhdm9pZFxuICAgIC8vICB0aGUgbWVyZ2UgaWYgd2UgZXZlciBzZWUgYSBhbmQgYiBhZ2Fpbi4gIE5vdGUgdGhhdCAoYixhKSZyYXJyO2Mgc2hvdWxkXG4gICAgLy8gIGFsc28gYmUgZXhhbWluZWQgZHVyaW5nIGNhY2hlIGxvb2t1cC5cbiAgICAvL1xuICAgIHRoaXMubWVyZ2VDYWNoZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlNpbXVsYXRvci5wcm90b3R5cGUpO1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNlckFUTlNpbXVsYXRvcjtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kZWJ1ZyA9IGZhbHNlO1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kZWJ1Z19jbG9zdXJlID0gZmFsc2U7XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmRlYnVnX2FkZCA9IGZhbHNlO1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMgPSBmYWxzZTtcblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZGZhX2RlYnVnID0gZmFsc2U7XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJldHJ5X2RlYnVnID0gZmFsc2U7XG5cblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5hZGFwdGl2ZVByZWRpY3QgPSBmdW5jdGlvbihpbnB1dCwgZGVjaXNpb24sIG91dGVyQ29udGV4dCkge1xuICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWRhcHRpdmVQcmVkaWN0IGRlY2lzaW9uIFwiICsgZGVjaXNpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGV4ZWMgTEEoMSk9PVwiICsgdGhpcy5nZXRMb29rYWhlYWROYW1lKGlucHV0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbGluZSBcIiArIGlucHV0LkxUKDEpLmxpbmUgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuTFQoMSkuY29sdW1uKTtcbiAgICB9XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLl9zdGFydEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgdGhpcy5fb3V0ZXJDb250ZXh0ID0gb3V0ZXJDb250ZXh0O1xuXG4gICAgdmFyIGRmYSA9IHRoaXMuZGVjaXNpb25Ub0RGQVtkZWNpc2lvbl07XG4gICAgdGhpcy5fZGZhID0gZGZhO1xuICAgIHZhciBtID0gaW5wdXQubWFyaygpO1xuICAgIHZhciBpbmRleCA9IGlucHV0LmluZGV4O1xuXG4gICAgLy8gTm93IHdlIGFyZSBjZXJ0YWluIHRvIGhhdmUgYSBzcGVjaWZpYyBkZWNpc2lvbidzIERGQVxuICAgIC8vIEJ1dCwgZG8gd2Ugc3RpbGwgbmVlZCBhbiBpbml0aWFsIHN0YXRlP1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBzMDtcbiAgICAgICAgaWYgKGRmYS5wcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgcHJlY2VkZW5jZSBERkEgZGVwZW5kcyBvbiB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gcGFyc2VyIHByZWNlZGVuY2UsIGFuZCBpcyBwcm92aWRlZCBieSBhIERGQSBtZXRob2QuXG4gICAgICAgICAgICBzMCA9IGRmYS5nZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSh0aGlzLnBhcnNlci5nZXRQcmVjZWRlbmNlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IHN0YXRlIGZvciBhIFwicmVndWxhclwiIERGQSBpcyBqdXN0IHMwXG4gICAgICAgICAgICBzMCA9IGRmYS5zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczA9PT1udWxsKSB7XG4gICAgICAgICAgICBpZiAob3V0ZXJDb250ZXh0PT09bnVsbCkge1xuICAgICAgICAgICAgICAgIG91dGVyQ29udGV4dCA9IFJ1bGVDb250ZXh0LkVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZWRpY3RBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0LnRvU3RyaW5nKHRoaXMucGFyc2VyLnJ1bGVOYW1lcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnVsbEN0eCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHMwX2Nsb3N1cmUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlLCBSdWxlQ29udGV4dC5FTVBUWSwgZnVsbEN0eCk7XG5cbiAgICAgICAgICAgIGlmKCBkZmEucHJlY2VkZW5jZURmYSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmVjZWRlbmNlIERGQSwgd2UgdXNlIGFwcGx5UHJlY2VkZW5jZUZpbHRlclxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbnZlcnQgdGhlIGNvbXB1dGVkIHN0YXJ0IHN0YXRlIHRvIGEgcHJlY2VkZW5jZSBzdGFydFxuICAgICAgICAgICAgICAgIC8vIHN0YXRlLiBXZSB0aGVuIHVzZSBERkEuc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUgdG8gc2V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFwcHJvcHJpYXRlIHN0YXJ0IHN0YXRlIGZvciB0aGUgcHJlY2VkZW5jZSBsZXZlbCByYXRoZXJcbiAgICAgICAgICAgICAgICAvLyB0aGFuIHNpbXBseSBzZXR0aW5nIERGQS5zMC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGRmYS5zMC5jb25maWdzID0gczBfY2xvc3VyZTsgLy8gbm90IHVzZWQgZm9yIHByZWRpY3Rpb24gYnV0IHVzZWZ1bCB0byBrbm93IHN0YXJ0IGNvbmZpZ3MgYW55d2F5XG4gICAgICAgICAgICAgICAgczBfY2xvc3VyZSA9IHRoaXMuYXBwbHlQcmVjZWRlbmNlRmlsdGVyKHMwX2Nsb3N1cmUpO1xuICAgICAgICAgICAgICAgIHMwID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIG5ldyBERkFTdGF0ZShudWxsLCBzMF9jbG9zdXJlKSk7XG4gICAgICAgICAgICAgICAgZGZhLnNldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMucGFyc2VyLmdldFByZWNlZGVuY2UoKSwgczApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBuZXcgREZBU3RhdGUobnVsbCwgczBfY2xvc3VyZSkpO1xuICAgICAgICAgICAgICAgIGRmYS5zMCA9IHMwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhbHQgPSB0aGlzLmV4ZWNBVE4oZGZhLCBzMCwgaW5wdXQsIGluZGV4LCBvdXRlckNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJERkEgYWZ0ZXIgcHJlZGljdEFUTjogXCIgKyBkZmEudG9TdHJpbmcodGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9kZmEgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlQ2FjaGUgPSBudWxsOyAvLyB3YWNrIGNhY2hlIGFmdGVyIGVhY2ggcHJlZGljdGlvblxuICAgICAgICBpbnB1dC5zZWVrKGluZGV4KTtcbiAgICAgICAgaW5wdXQucmVsZWFzZShtKTtcbiAgICB9XG59O1xuLy8gUGVyZm9ybXMgQVROIHNpbXVsYXRpb24gdG8gY29tcHV0ZSBhIHByZWRpY3RlZCBhbHRlcm5hdGl2ZSBiYXNlZFxuLy8gIHVwb24gdGhlIHJlbWFpbmluZyBpbnB1dCwgYnV0IGFsc28gdXBkYXRlcyB0aGUgREZBIGNhY2hlIHRvIGF2b2lkXG4vLyAgaGF2aW5nIHRvIHRyYXZlcnNlIHRoZSBBVE4gYWdhaW4gZm9yIHRoZSBzYW1lIGlucHV0IHNlcXVlbmNlLlxuXG4vLyBUaGVyZSBhcmUgc29tZSBrZXkgY29uZGl0aW9ucyB3ZSdyZSBsb29raW5nIGZvciBhZnRlciBjb21wdXRpbmcgYSBuZXdcbi8vIHNldCBvZiBBVE4gY29uZmlncyAocHJvcG9zZWQgREZBIHN0YXRlKTpcbiAgICAgIC8vIGlmIHRoZSBzZXQgaXMgZW1wdHksIHRoZXJlIGlzIG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBmb3IgY3VycmVudCBzeW1ib2xcbiAgICAgIC8vIGRvZXMgdGhlIHN0YXRlIHVuaXF1ZWx5IHByZWRpY3QgYW4gYWx0ZXJuYXRpdmU/XG4gICAgICAvLyBkb2VzIHRoZSBzdGF0ZSBoYXZlIGEgY29uZmxpY3QgdGhhdCB3b3VsZCBwcmV2ZW50IHVzIGZyb21cbiAgICAgIC8vICAgcHV0dGluZyBpdCBvbiB0aGUgd29yayBsaXN0P1xuXG4vLyBXZSBhbHNvIGhhdmUgc29tZSBrZXkgb3BlcmF0aW9ucyB0byBkbzpcbiAgICAgIC8vIGFkZCBhbiBlZGdlIGZyb20gcHJldmlvdXMgREZBIHN0YXRlIHRvIHBvdGVudGlhbGx5IG5ldyBERkEgc3RhdGUsIEQsXG4gICAgICAvLyAgIHVwb24gY3VycmVudCBzeW1ib2wgYnV0IG9ubHkgaWYgYWRkaW5nIHRvIHdvcmsgbGlzdCwgd2hpY2ggbWVhbnMgaW4gYWxsXG4gICAgICAvLyAgIGNhc2VzIGV4Y2VwdCBubyB2aWFibGUgYWx0ZXJuYXRpdmUgKGFuZCBwb3NzaWJseSBub24tZ3JlZWR5IGRlY2lzaW9ucz8pXG4gICAgICAvLyBjb2xsZWN0aW5nIHByZWRpY2F0ZXMgYW5kIGFkZGluZyBzZW1hbnRpYyBjb250ZXh0IHRvIERGQSBhY2NlcHQgc3RhdGVzXG4gICAgICAvLyBhZGRpbmcgcnVsZSBjb250ZXh0IHRvIGNvbnRleHQtc2Vuc2l0aXZlIERGQSBhY2NlcHQgc3RhdGVzXG4gICAgICAvLyBjb25zdW1pbmcgYW4gaW5wdXQgc3ltYm9sXG4gICAgICAvLyByZXBvcnRpbmcgYSBjb25mbGljdFxuICAgICAgLy8gcmVwb3J0aW5nIGFuIGFtYmlndWl0eVxuICAgICAgLy8gcmVwb3J0aW5nIGEgY29udGV4dCBzZW5zaXRpdml0eVxuICAgICAgLy8gcmVwb3J0aW5nIGluc3VmZmljaWVudCBwcmVkaWNhdGVzXG5cbi8vIGNvdmVyIHRoZXNlIGNhc2VzOlxuLy8gICAgZGVhZCBlbmRcbi8vICAgIHNpbmdsZSBhbHRcbi8vICAgIHNpbmdsZSBhbHQgKyBwcmVkc1xuLy8gICAgY29uZmxpY3Rcbi8vICAgIGNvbmZsaWN0ICsgcHJlZHNcbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmV4ZWNBVE4gPSBmdW5jdGlvbihkZmEsIHMwLCBpbnB1dCwgc3RhcnRJbmRleCwgb3V0ZXJDb250ZXh0ICkge1xuICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY0FUTiBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXG4gICAgICAgICAgICAgICAgXCIgZXhlYyBMQSgxKT09XCIgKyB0aGlzLmdldExvb2thaGVhZE5hbWUoaW5wdXQpICtcbiAgICAgICAgICAgICAgICBcIiBsaW5lIFwiICsgaW5wdXQuTFQoMSkubGluZSArIFwiOlwiICsgaW5wdXQuTFQoMSkuY29sdW1uKTtcbiAgICB9XG4gICAgdmFyIGFsdDtcbiAgICB2YXIgcHJldmlvdXNEID0gczA7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInMwID0gXCIgKyBzMCk7XG4gICAgfVxuICAgIHZhciB0ID0gaW5wdXQuTEEoMSk7XG4gICAgd2hpbGUodHJ1ZSkgeyAvLyB3aGlsZSBtb3JlIHdvcmtcbiAgICAgICAgdmFyIEQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocHJldmlvdXNELCB0KTtcbiAgICAgICAgaWYoRD09PW51bGwpIHtcbiAgICAgICAgICAgIEQgPSB0aGlzLmNvbXB1dGVUYXJnZXRTdGF0ZShkZmEsIHByZXZpb3VzRCwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoRD09PUFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICAgICAgLy8gaWYgYW55IGNvbmZpZ3MgaW4gcHJldmlvdXMgZGlwcGVkIGludG8gb3V0ZXIgY29udGV4dCwgdGhhdFxuICAgICAgICAgICAgLy8gbWVhbnMgdGhhdCBpbnB1dCB1cCB0byB0IGFjdHVhbGx5IGZpbmlzaGVkIGVudHJ5IHJ1bGVcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IGZvciBTTEwgZGVjaXNpb24uIEZ1bGwgTEwgZG9lc24ndCBkaXAgaW50byBvdXRlclxuICAgICAgICAgICAgLy8gc28gZG9uJ3QgbmVlZCBzcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIGdldCBhbiBlcnJvciBubyBtYXR0ZXIgd2hhdCBzbyBkZWxheSB1bnRpbCBhZnRlclxuICAgICAgICAgICAgLy8gZGVjaXNpb247IGJldHRlciBlcnJvciBtZXNzYWdlLiBBbHNvLCBubyByZWFjaGFibGUgdGFyZ2V0XG4gICAgICAgICAgICAvLyBBVE4gc3RhdGVzIGluIFNMTCBpbXBsaWVzIExMIHdpbGwgYWxzbyBnZXQgbm93aGVyZS5cbiAgICAgICAgICAgIC8vIElmIGNvbmZsaWN0IGluIHN0YXRlcyB0aGF0IGRpcCBvdXQsIGNob29zZSBtaW4gc2luY2Ugd2VcbiAgICAgICAgICAgIC8vIHdpbGwgZ2V0IGVycm9yIG5vIG1hdHRlciB3aGF0LlxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm5vVmlhYmxlQWx0KGlucHV0LCBvdXRlckNvbnRleHQsIHByZXZpb3VzRC5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBhbHQgPSB0aGlzLmdldFN5blZhbGlkT3JTZW1JbnZhbGlkQWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUocHJldmlvdXNELmNvbmZpZ3MsIG91dGVyQ29udGV4dCk7XG4gICAgICAgICAgICBpZihhbHQhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihELnJlcXVpcmVzRnVsbENvbnRleHQgJiYgdGhpcy5wcmVkaWN0aW9uTW9kZSAhPT0gUHJlZGljdGlvbk1vZGUuU0xMKSB7XG4gICAgICAgICAgICAvLyBJRiBQUkVEUywgTUlHSFQgUkVTT0xWRSBUTyBTSU5HTEUgQUxUID0+IFNMTCAob3Igc3ludGF4IGVycm9yKVxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0aW5nQWx0cyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoRC5wcmVkaWNhdGVzIT09bnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREZBIHN0YXRlIGhhcyBwcmVkcyBpbiBERkEgc2ltIExMIGZhaWxvdmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RJbmRleCA9IGlucHV0LmluZGV4O1xuICAgICAgICAgICAgICAgIGlmKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmxpY3RpbmdBbHRzID0gdGhpcy5ldmFsU2VtYW50aWNDb250ZXh0KEQucHJlZGljYXRlcywgb3V0ZXJDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3RpbmdBbHRzLmxlbmd0aD09PTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGdWxsIExMIGF2b2lkZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZsaWN0aW5nQWx0cy5taW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBpbmRleCBzbyByZXBvcnRpbmcgdGhlIGZhbGxiYWNrIHRvIGZ1bGxcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCBvY2N1cnMgd2l0aCB0aGUgaW5kZXggYXQgdGhlIGNvcnJlY3Qgc3BvdFxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZWVrKGNvbmZsaWN0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRmYV9kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3R4IHNlbnNpdGl2ZSBzdGF0ZSBcIiArIG91dGVyQ29udGV4dCArXCIgaW4gXCIgKyBEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmdWxsQ3R4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzMF9jbG9zdXJlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShkZmEuYXRuU3RhcnRTdGF0ZSwgb3V0ZXJDb250ZXh0LCBmdWxsQ3R4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBELmNvbmZpZ3MsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcbiAgICAgICAgICAgIGFsdCA9IHRoaXMuZXhlY0FUTldpdGhGdWxsQ29udGV4dChkZmEsIEQsIHMwX2Nsb3N1cmUsIGlucHV0LCBzdGFydEluZGV4LCBvdXRlckNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRC5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoRC5wcmVkaWNhdGVzPT09bnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBELnByZWRpY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RvcEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIGFsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQoRC5wcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGFsdHMubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgRC5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0cy5sZW5ndGg9PT0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdHMubWluVmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwb3J0IGFtYmlndWl0eSBhZnRlciBwcmVkaWNhdGUgZXZhbHVhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGNvcnJlY3Qgc2V0IG9mIGFtYmlnIGFsdHMgaXMgcmVwb3J0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRBbWJpZ3VpdHkoZGZhLCBELCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGZhbHNlLCBhbHRzLCBELmNvbmZpZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHRzLm1pblZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNEID0gRDtcblxuICAgICAgICBpZiAodCAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICBpbnB1dC5jb25zdW1lKCk7XG4gICAgICAgICAgICB0ID0gaW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy9cbi8vIEdldCBhbiBleGlzdGluZyB0YXJnZXQgc3RhdGUgZm9yIGFuIGVkZ2UgaW4gdGhlIERGQS4gSWYgdGhlIHRhcmdldCBzdGF0ZVxuLy8gZm9yIHRoZSBlZGdlIGhhcyBub3QgeWV0IGJlZW4gY29tcHV0ZWQgb3IgaXMgb3RoZXJ3aXNlIG5vdCBhdmFpbGFibGUsXG4vLyB0aGlzIG1ldGhvZCByZXR1cm5zIHtAY29kZSBudWxsfS5cbi8vXG4vLyBAcGFyYW0gcHJldmlvdXNEIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxuLy8gQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXG4vLyBAcmV0dXJuIFRoZSBleGlzdGluZyB0YXJnZXQgREZBIHN0YXRlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc3ltYm9sXG4vLyB7QGNvZGUgdH0sIG9yIHtAY29kZSBudWxsfSBpZiB0aGUgdGFyZ2V0IHN0YXRlIGZvciB0aGlzIGVkZ2UgaXMgbm90XG4vLyBhbHJlYWR5IGNhY2hlZFxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uKHByZXZpb3VzRCwgdCkge1xuICAgIHZhciBlZGdlcyA9IHByZXZpb3VzRC5lZGdlcztcbiAgICBpZiAoZWRnZXM9PT1udWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlZGdlc1t0ICsgMV0gfHwgbnVsbDtcbiAgICB9XG59O1xuLy9cbi8vIENvbXB1dGUgYSB0YXJnZXQgc3RhdGUgZm9yIGFuIGVkZ2UgaW4gdGhlIERGQSwgYW5kIGF0dGVtcHQgdG8gYWRkIHRoZVxuLy8gY29tcHV0ZWQgc3RhdGUgYW5kIGNvcnJlc3BvbmRpbmcgZWRnZSB0byB0aGUgREZBLlxuLy9cbi8vIEBwYXJhbSBkZmEgVGhlIERGQVxuLy8gQHBhcmFtIHByZXZpb3VzRCBUaGUgY3VycmVudCBERkEgc3RhdGVcbi8vIEBwYXJhbSB0IFRoZSBuZXh0IGlucHV0IHN5bWJvbFxuLy9cbi8vIEByZXR1cm4gVGhlIGNvbXB1dGVkIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcbi8vIHtAY29kZSB0fS4gSWYge0Bjb2RlIHR9IGRvZXMgbm90IGxlYWQgdG8gYSB2YWxpZCBERkEgc3RhdGUsIHRoaXMgbWV0aG9kXG4vLyByZXR1cm5zIHtAbGluayAvL0VSUk9SfS5cbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbXB1dGVUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uKGRmYSwgcHJldmlvdXNELCB0KSB7XG4gICB2YXIgcmVhY2ggPSB0aGlzLmNvbXB1dGVSZWFjaFNldChwcmV2aW91c0QuY29uZmlncywgdCwgZmFsc2UpO1xuICAgIGlmKHJlYWNoPT09bnVsbCkge1xuICAgICAgICB0aGlzLmFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHQsIEFUTlNpbXVsYXRvci5FUlJPUik7XG4gICAgICAgIHJldHVybiBBVE5TaW11bGF0b3IuRVJST1I7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBuZXcgdGFyZ2V0IHN0YXRlOyB3ZSdsbCBhZGQgdG8gREZBIGFmdGVyIGl0J3MgY29tcGxldGVcbiAgICB2YXIgRCA9IG5ldyBERkFTdGF0ZShudWxsLCByZWFjaCk7XG5cbiAgICB2YXIgcHJlZGljdGVkQWx0ID0gdGhpcy5nZXRVbmlxdWVBbHQocmVhY2gpO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgdmFyIGFsdFN1YlNldHMgPSBQcmVkaWN0aW9uTW9kZS5nZXRDb25mbGljdGluZ0FsdFN1YnNldHMocmVhY2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNMTCBhbHRTdWJTZXRzPVwiICsgVXRpbHMuYXJyYXlUb1N0cmluZyhhbHRTdWJTZXRzKSArXG4gICAgICAgICAgICAgICAgICAgIFwiLCBwcmV2aW91cz1cIiArIHByZXZpb3VzRC5jb25maWdzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIGNvbmZpZ3M9XCIgKyByZWFjaCArXG4gICAgICAgICAgICAgICAgICAgIFwiLCBwcmVkaWN0PVwiICsgcHJlZGljdGVkQWx0ICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIGFsbFN1YnNldHNDb25mbGljdD1cIiArXG4gICAgICAgICAgICAgICAgICAgIFByZWRpY3Rpb25Nb2RlLmFsbFN1YnNldHNDb25mbGljdChhbHRTdWJTZXRzKSArIFwiLCBjb25mbGljdGluZ0FsdHM9XCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbmZsaWN0aW5nQWx0cyhyZWFjaCkpO1xuICAgIH1cbiAgICBpZiAocHJlZGljdGVkQWx0IT09QVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAvLyBOTyBDT05GTElDVCwgVU5JUVVFTFkgUFJFRElDVEVEIEFMVFxuICAgICAgICBELmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuICAgICAgICBELmNvbmZpZ3MudW5pcXVlQWx0ID0gcHJlZGljdGVkQWx0O1xuICAgICAgICBELnByZWRpY3Rpb24gPSBwcmVkaWN0ZWRBbHQ7XG4gICAgfSBlbHNlIGlmIChQcmVkaWN0aW9uTW9kZS5oYXNTTExDb25mbGljdFRlcm1pbmF0aW5nUHJlZGljdGlvbih0aGlzLnByZWRpY3Rpb25Nb2RlLCByZWFjaCkpIHtcbiAgICAgICAgLy8gTU9SRSBUSEFOIE9ORSBWSUFCTEUgQUxURVJOQVRJVkVcbiAgICAgICAgRC5jb25maWdzLmNvbmZsaWN0aW5nQWx0cyA9IHRoaXMuZ2V0Q29uZmxpY3RpbmdBbHRzKHJlYWNoKTtcbiAgICAgICAgRC5yZXF1aXJlc0Z1bGxDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgLy8gaW4gU0xMLW9ubHkgbW9kZSwgd2Ugd2lsbCBzdG9wIGF0IHRoaXMgc3RhdGUgYW5kIHJldHVybiB0aGUgbWluaW11bSBhbHRcbiAgICAgICAgRC5pc0FjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgRC5wcmVkaWN0aW9uID0gRC5jb25maWdzLmNvbmZsaWN0aW5nQWx0cy5taW5WYWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoRC5pc0FjY2VwdFN0YXRlICYmIEQuY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVERkFTdGF0ZShELCB0aGlzLmF0bi5nZXREZWNpc2lvblN0YXRlKGRmYS5kZWNpc2lvbikpO1xuICAgICAgICBpZiggRC5wcmVkaWNhdGVzIT09bnVsbCkge1xuICAgICAgICAgICAgRC5wcmVkaWN0aW9uID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhbGwgYWRkcyB0byBkZmEgYXJlIGRvbmUgYWZ0ZXIgd2UndmUgY3JlYXRlZCBmdWxsIEQgc3RhdGVcbiAgICBEID0gdGhpcy5hZGRERkFFZGdlKGRmYSwgcHJldmlvdXNELCB0LCBEKTtcbiAgICByZXR1cm4gRDtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucHJlZGljYXRlREZBU3RhdGUgPSBmdW5jdGlvbihkZmFTdGF0ZSwgZGVjaXNpb25TdGF0ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gdGVzdCBhbGwgcHJlZGljYXRlcywgZXZlbiBpbiBERkEgc3RhdGVzIHRoYXRcbiAgICAvLyB1bmlxdWVseSBwcmVkaWN0IGFsdGVybmF0aXZlLlxuICAgIHZhciBuYWx0cyA9IGRlY2lzaW9uU3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgIC8vIFVwZGF0ZSBERkEgc28gcmVhY2ggYmVjb21lcyBhY2NlcHQgc3RhdGUgd2l0aCAocHJlZGljYXRlLGFsdClcbiAgICAvLyBwYWlycyBpZiBwcmVkcyBmb3VuZCBmb3IgY29uZmxpY3RpbmcgYWx0c1xuICAgIHZhciBhbHRzVG9Db2xsZWN0UHJlZHNGcm9tID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHNPclVuaXF1ZUFsdChkZmFTdGF0ZS5jb25maWdzKTtcbiAgICB2YXIgYWx0VG9QcmVkID0gdGhpcy5nZXRQcmVkc0ZvckFtYmlnQWx0cyhhbHRzVG9Db2xsZWN0UHJlZHNGcm9tLCBkZmFTdGF0ZS5jb25maWdzLCBuYWx0cyk7XG4gICAgaWYgKGFsdFRvUHJlZCE9PW51bGwpIHtcbiAgICAgICAgZGZhU3RhdGUucHJlZGljYXRlcyA9IHRoaXMuZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYWx0c1RvQ29sbGVjdFByZWRzRnJvbSwgYWx0VG9QcmVkKTtcbiAgICAgICAgZGZhU3RhdGUucHJlZGljdGlvbiA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7IC8vIG1ha2Ugc3VyZSB3ZSB1c2UgcHJlZHNcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBhcmUgcHJlZHMgaW4gY29uZmlncyBidXQgdGhleSBtaWdodCBnbyBhd2F5XG4gICAgICAgIC8vIHdoZW4gT1InZCB0b2dldGhlciBsaWtlIHtwfT8gfHwgTk9ORSA9PSBOT05FLiBJZiBuZWl0aGVyXG4gICAgICAgIC8vIGFsdCBoYXMgcHJlZHMsIHJlc29sdmUgdG8gbWluIGFsdFxuICAgICAgICBkZmFTdGF0ZS5wcmVkaWN0aW9uID0gYWx0c1RvQ29sbGVjdFByZWRzRnJvbS5taW5WYWx1ZSgpO1xuICAgIH1cbn07XG5cbi8vIGNvbWVzIGJhY2sgd2l0aCByZWFjaC51bmlxdWVBbHQgc2V0IHRvIGEgdmFsaWQgYWx0XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmV4ZWNBVE5XaXRoRnVsbENvbnRleHQgPSBmdW5jdGlvbihkZmEsIEQsIC8vIGhvdyBmYXIgd2UgZ290IGJlZm9yZSBmYWlsaW5nIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ29udGV4dCkge1xuICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY0FUTldpdGhGdWxsQ29udGV4dCBcIitzMCk7XG4gICAgfVxuICAgIHZhciBmdWxsQ3R4ID0gdHJ1ZTtcbiAgICB2YXIgZm91bmRFeGFjdEFtYmlnID0gZmFsc2U7XG4gICAgdmFyIHJlYWNoID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSBzMDtcbiAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgIHZhciB0ID0gaW5wdXQuTEEoMSk7XG4gICAgdmFyIHByZWRpY3RlZEFsdCA9IC0xO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIHdoaWxlIG1vcmUgd29ya1xuICAgICAgICByZWFjaCA9IHRoaXMuY29tcHV0ZVJlYWNoU2V0KHByZXZpb3VzLCB0LCBmdWxsQ3R4KTtcbiAgICAgICAgaWYgKHJlYWNoPT09bnVsbCkge1xuICAgICAgICAgICAgLy8gaWYgYW55IGNvbmZpZ3MgaW4gcHJldmlvdXMgZGlwcGVkIGludG8gb3V0ZXIgY29udGV4dCwgdGhhdFxuICAgICAgICAgICAgLy8gbWVhbnMgdGhhdCBpbnB1dCB1cCB0byB0IGFjdHVhbGx5IGZpbmlzaGVkIGVudHJ5IHJ1bGVcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IGZvciBMTCBkZWNpc2lvbi4gRnVsbCBMTCBkb2Vzbid0IGRpcCBpbnRvIG91dGVyXG4gICAgICAgICAgICAvLyBzbyBkb24ndCBuZWVkIHNwZWNpYWwgY2FzZS5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgZ2V0IGFuIGVycm9yIG5vIG1hdHRlciB3aGF0IHNvIGRlbGF5IHVudGlsIGFmdGVyXG4gICAgICAgICAgICAvLyBkZWNpc2lvbjsgYmV0dGVyIGVycm9yIG1lc3NhZ2UuIEFsc28sIG5vIHJlYWNoYWJsZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIEFUTiBzdGF0ZXMgaW4gU0xMIGltcGxpZXMgTEwgd2lsbCBhbHNvIGdldCBub3doZXJlLlxuICAgICAgICAgICAgLy8gSWYgY29uZmxpY3QgaW4gc3RhdGVzIHRoYXQgZGlwIG91dCwgY2hvb3NlIG1pbiBzaW5jZSB3ZVxuICAgICAgICAgICAgLy8gd2lsbCBnZXQgZXJyb3Igbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgcHJldmlvdXMsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICAgIHZhciBhbHQgPSB0aGlzLmdldFN5blZhbGlkT3JTZW1JbnZhbGlkQWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUocHJldmlvdXMsIG91dGVyQ29udGV4dCk7XG4gICAgICAgICAgICBpZihhbHQhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYWx0U3ViU2V0cyA9IFByZWRpY3Rpb25Nb2RlLmdldENvbmZsaWN0aW5nQWx0U3Vic2V0cyhyZWFjaCk7XG4gICAgICAgIGlmKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTEwgYWx0U3ViU2V0cz1cIiArIGFsdFN1YlNldHMgKyBcIiwgcHJlZGljdD1cIiArXG4gICAgICAgICAgICAgICAgICBQcmVkaWN0aW9uTW9kZS5nZXRVbmlxdWVBbHQoYWx0U3ViU2V0cykgKyBcIiwgcmVzb2x2ZXNUb0p1c3RPbmVWaWFibGVBbHQ9XCIgK1xuICAgICAgICAgICAgICAgICAgUHJlZGljdGlvbk1vZGUucmVzb2x2ZXNUb0p1c3RPbmVWaWFibGVBbHQoYWx0U3ViU2V0cykpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWNoLnVuaXF1ZUFsdCA9IHRoaXMuZ2V0VW5pcXVlQWx0KHJlYWNoKTtcbiAgICAgICAgLy8gdW5pcXVlIHByZWRpY3Rpb24/XG4gICAgICAgIGlmKHJlYWNoLnVuaXF1ZUFsdCE9PUFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICAgIHByZWRpY3RlZEFsdCA9IHJlYWNoLnVuaXF1ZUFsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJlZGljdGlvbk1vZGUgIT09IFByZWRpY3Rpb25Nb2RlLkxMX0VYQUNUX0FNQklHX0RFVEVDVElPTikge1xuICAgICAgICAgICAgcHJlZGljdGVkQWx0ID0gUHJlZGljdGlvbk1vZGUucmVzb2x2ZXNUb0p1c3RPbmVWaWFibGVBbHQoYWx0U3ViU2V0cyk7XG4gICAgICAgICAgICBpZihwcmVkaWN0ZWRBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGV4YWN0IGFtYmlndWl0eSBtb2RlLCB3ZSBuZXZlciB0cnkgdG8gdGVybWluYXRlIGVhcmx5LlxuICAgICAgICAgICAgLy8gSnVzdCBrZWVwcyBzY2FyZmluZyB1bnRpbCB3ZSBrbm93IHdoYXQgdGhlIGNvbmZsaWN0IGlzXG4gICAgICAgICAgICBpZiAoUHJlZGljdGlvbk1vZGUuYWxsU3Vic2V0c0NvbmZsaWN0KGFsdFN1YlNldHMpICYmIFByZWRpY3Rpb25Nb2RlLmFsbFN1YnNldHNFcXVhbChhbHRTdWJTZXRzKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kRXhhY3RBbWJpZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkQWx0ID0gUHJlZGljdGlvbk1vZGUuZ2V0U2luZ2xlVmlhYmxlQWx0KGFsdFN1YlNldHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSB0aGVyZSBhcmUgbXVsdGlwbGUgbm9uLWNvbmZsaWN0aW5nIHN1YnNldHMgb3JcbiAgICAgICAgICAgIC8vIHdlJ3JlIG5vdCBzdXJlIHdoYXQgdGhlIGFtYmlndWl0eSBpcyB5ZXQuXG4gICAgICAgICAgICAvLyBTbywga2VlcCBnb2luZy5cbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IHJlYWNoO1xuICAgICAgICBpZiggdCAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICBpbnB1dC5jb25zdW1lKCk7XG4gICAgICAgICAgICB0ID0gaW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHVuaXF1ZWx5IHByZWRpY3RzIGFuIGFsdGVybmF0aXZlLFxuICAgIC8vIHdpdGhvdXQgY29uZmxpY3QsIHRoZW4gd2Uga25vdyB0aGF0IGl0J3MgYSBmdWxsIExMIGRlY2lzaW9uXG4gICAgLy8gbm90IFNMTC5cbiAgICBpZiAocmVhY2gudW5pcXVlQWx0ICE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSICkge1xuICAgICAgICB0aGlzLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3RlZEFsdCwgcmVhY2gsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHByZWRpY3RlZEFsdDtcbiAgICB9XG4gICAgLy8gV2UgZG8gbm90IGNoZWNrIHByZWRpY2F0ZXMgaGVyZSBiZWNhdXNlIHdlIGhhdmUgY2hlY2tlZCB0aGVtXG4gICAgLy8gb24tdGhlLWZseSB3aGVuIGRvaW5nIGZ1bGwgY29udGV4dCBwcmVkaWN0aW9uLlxuXG4gICAgLy9cbiAgICAvLyBJbiBub24tZXhhY3QgYW1iaWd1aXR5IGRldGVjdGlvbiBtb2RlLCB3ZSBtaWdodFx0YWN0dWFsbHkgYmUgYWJsZSB0b1xuICAgIC8vIGRldGVjdCBhbiBleGFjdCBhbWJpZ3VpdHksIGJ1dCBJJ20gbm90IGdvaW5nIHRvIHNwZW5kIHRoZSBjeWNsZXNcbiAgICAvLyBuZWVkZWQgdG8gY2hlY2suIFdlIG9ubHkgZW1pdCBhbWJpZ3VpdHkgd2FybmluZ3MgaW4gZXhhY3QgYW1iaWd1aXR5XG4gICAgLy8gbW9kZS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB3ZSBtaWdodCBrbm93IHRoYXQgd2UgaGF2ZSBjb25mbGljdGluZyBjb25maWd1cmF0aW9ucy5cbiAgICAvLyBCdXQsIHRoYXQgZG9lcyBub3QgbWVhbiB0aGF0IHRoZXJlIGlzIG5vIHdheSBmb3J3YXJkIHdpdGhvdXQgYVxuICAgIC8vIGNvbmZsaWN0LiBJdCdzIHBvc3NpYmxlIHRvIGhhdmUgbm9uY29uZmxpY3RpbmcgYWx0IHN1YnNldHMgYXMgaW46XG5cbiAgICAvLyBhbHRTdWJTZXRzPVt7MSwgMn0sIHsxLCAyfSwgezF9LCB7MSwgMn1dXG5cbiAgICAvLyBmcm9tXG4gICAgLy9cbiAgICAvLyAgICBbKDE3LDEsWzUgJF0pLCAoMTMsMSxbNSAxMCAkXSksICgyMSwxLFs1IDEwICRdKSwgKDExLDEsWyRdKSxcbiAgICAvLyAgICAgKDEzLDIsWzUgMTAgJF0pLCAoMjEsMixbNSAxMCAkXSksICgxMSwyLFskXSldXG4gICAgLy9cbiAgICAvLyBJbiB0aGlzIGNhc2UsICgxNywxLFs1ICRdKSBpbmRpY2F0ZXMgdGhlcmUgaXMgc29tZSBuZXh0IHNlcXVlbmNlIHRoYXRcbiAgICAvLyB3b3VsZCByZXNvbHZlIHRoaXMgd2l0aG91dCBjb25mbGljdCB0byBhbHRlcm5hdGl2ZSAxLiBBbnkgb3RoZXIgdmlhYmxlXG4gICAgLy8gbmV4dCBzZXF1ZW5jZSwgaG93ZXZlciwgaXMgYXNzb2NpYXRlZCB3aXRoIGEgY29uZmxpY3QuICBXZSBzdG9wXG4gICAgLy8gbG9va2luZyBmb3IgaW5wdXQgYmVjYXVzZSBubyBhbW91bnQgb2YgZnVydGhlciBsb29rYWhlYWQgd2lsbCBhbHRlclxuICAgIC8vIHRoZSBmYWN0IHRoYXQgd2Ugc2hvdWxkIHByZWRpY3QgYWx0ZXJuYXRpdmUgMS4gIFdlIGp1c3QgY2FuJ3Qgc2F5IGZvclxuICAgIC8vIHN1cmUgdGhhdCB0aGVyZSBpcyBhbiBhbWJpZ3VpdHkgd2l0aG91dCBsb29raW5nIGZ1cnRoZXIuXG5cbiAgICB0aGlzLnJlcG9ydEFtYmlndWl0eShkZmEsIEQsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4LCBmb3VuZEV4YWN0QW1iaWcsIG51bGwsIHJlYWNoKTtcblxuICAgIHJldHVybiBwcmVkaWN0ZWRBbHQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbXB1dGVSZWFjaFNldCA9IGZ1bmN0aW9uKGNsb3N1cmUsIHQsIGZ1bGxDdHgpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImluIGNvbXB1dGVSZWFjaFNldCwgc3RhcnRpbmcgY2xvc3VyZTogXCIgKyBjbG9zdXJlKTtcbiAgICB9XG4gICAgaWYoIHRoaXMubWVyZ2VDYWNoZT09PW51bGwpIHtcbiAgICAgICAgdGhpcy5tZXJnZUNhY2hlID0gbmV3IERvdWJsZURpY3QoKTtcbiAgICB9XG4gICAgdmFyIGludGVybWVkaWF0ZSA9IG5ldyBBVE5Db25maWdTZXQoZnVsbEN0eCk7XG5cbiAgICAvLyBDb25maWd1cmF0aW9ucyBhbHJlYWR5IGluIGEgcnVsZSBzdG9wIHN0YXRlIGluZGljYXRlIHJlYWNoaW5nIHRoZSBlbmRcbiAgICAvLyBvZiB0aGUgZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHRoZSBzdGFydCBydWxlIChmdWxsXG4gICAgLy8gY29udGV4dCkuIE9uY2UgcmVhY2hlZCwgdGhlc2UgY29uZmlndXJhdGlvbnMgYXJlIG5ldmVyIHVwZGF0ZWQgYnkgYVxuICAgIC8vIGNsb3N1cmUgb3BlcmF0aW9uLCBzbyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgZm9yIHRoZSBwZXJmb3JtYW5jZVxuICAgIC8vIGFkdmFudGFnZSBvZiBoYXZpbmcgYSBzbWFsbGVyIGludGVybWVkaWF0ZSBzZXQgd2hlbiBjYWxsaW5nIGNsb3N1cmUuXG4gICAgLy9cbiAgICAvLyBGb3IgZnVsbC1jb250ZXh0IHJlYWNoIG9wZXJhdGlvbnMsIHNlcGFyYXRlIGhhbmRsaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIGFsdGVybmF0aXZlIG1hdGNoaW5nIHRoZSBsb25nZXN0IG92ZXJhbGwgc2VxdWVuY2UgaXNcbiAgICAvLyBjaG9zZW4gd2hlbiBtdWx0aXBsZSBzdWNoIGNvbmZpZ3VyYXRpb25zIGNhbiBtYXRjaCB0aGUgaW5wdXQuXG5cbiAgICB2YXIgc2tpcHBlZFN0b3BTdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gRmlyc3QgZmlndXJlIG91dCB3aGVyZSB3ZSBjYW4gcmVhY2ggb24gaW5wdXQgdFxuICAgIGZvciAodmFyIGk9MDsgaTxjbG9zdXJlLml0ZW1zLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjbG9zdXJlLml0ZW1zW2ldO1xuICAgICAgICBpZih0aGlzLmRlYnVnX2FkZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZXN0aW5nIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodCkgKyBcIiBhdCBcIiArIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGZ1bGxDdHggfHwgdCA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzPT09bnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkU3RvcFN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwcGVkU3RvcFN0YXRlcy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVidWdfYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkZWQgXCIgKyBjICsgXCIgdG8gc2tpcHBlZFN0b3BTdGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBqPTA7ajxjLnN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IGMuc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRSZWFjaGFibGVUYXJnZXQodHJhbnMsIHQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCE9PW51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ZnID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6dGFyZ2V0fSwgYyk7XG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlLmFkZChjZmcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kZWJ1Z19hZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZGRlZCBcIiArIGNmZyArIFwiIHRvIGludGVybWVkaWF0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93IGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHJlYWNoIG9wZXJhdGlvbiBjYW4gdGFrZSB1cy4uLlxuICAgIHZhciByZWFjaCA9IG51bGw7XG5cbiAgICAvLyBUaGlzIGJsb2NrIG9wdGltaXplcyB0aGUgcmVhY2ggb3BlcmF0aW9uIGZvciBpbnRlcm1lZGlhdGUgc2V0cyB3aGljaFxuICAgIC8vIHRyaXZpYWxseSBpbmRpY2F0ZSBhIHRlcm1pbmF0aW9uIHN0YXRlIGZvciB0aGUgb3ZlcmFsbFxuICAgIC8vIGFkYXB0aXZlUHJlZGljdCBvcGVyYXRpb24uXG4gICAgLy9cbiAgICAvLyBUaGUgY29uZGl0aW9ucyBhc3N1bWUgdGhhdCBpbnRlcm1lZGlhdGVcbiAgICAvLyBjb250YWlucyBhbGwgY29uZmlndXJhdGlvbnMgcmVsZXZhbnQgdG8gdGhlIHJlYWNoIHNldCwgYnV0IHRoaXNcbiAgICAvLyBjb25kaXRpb24gaXMgbm90IHRydWUgd2hlbiBvbmUgb3IgbW9yZSBjb25maWd1cmF0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyB3aXRoaGVsZCBpbiBza2lwcGVkU3RvcFN0YXRlcywgb3Igd2hlbiB0aGUgY3VycmVudCBzeW1ib2wgaXMgRU9GLlxuICAgIC8vXG4gICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzPT09bnVsbCAmJiB0IT09VG9rZW4uRU9GKSB7XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGUuaXRlbXMubGVuZ3RoPT09MSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcHVyc3VlIHRoZSBjbG9zdXJlIGlmIHRoZXJlIGlzIGp1c3Qgb25lIHN0YXRlLlxuICAgICAgICAgICAgLy8gSXQgY2FuIG9ubHkgaGF2ZSBvbmUgYWx0ZXJuYXRpdmU7IGp1c3QgYWRkIHRvIHJlc3VsdFxuICAgICAgICAgICAgLy8gQWxzbyBkb24ndCBwdXJzdWUgdGhlIGNsb3N1cmUgaWYgdGhlcmUgaXMgdW5pcXVlIGFsdGVybmF0aXZlXG4gICAgICAgICAgICAvLyBhbW9uZyB0aGUgY29uZmlndXJhdGlvbnMuXG4gICAgICAgICAgICByZWFjaCA9IGludGVybWVkaWF0ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdldFVuaXF1ZUFsdChpbnRlcm1lZGlhdGUpIT09QVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgLy8gQWxzbyBkb24ndCBwdXJzdWUgdGhlIGNsb3N1cmUgaWYgdGhlcmUgaXMgdW5pcXVlIGFsdGVybmF0aXZlXG4gICAgICAgICAgICAvLyBhbW9uZyB0aGUgY29uZmlndXJhdGlvbnMuXG4gICAgICAgICAgICByZWFjaCA9IGludGVybWVkaWF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgcmVhY2ggc2V0IGNvdWxkIG5vdCBiZSB0cml2aWFsbHkgZGV0ZXJtaW5lZCwgcGVyZm9ybSBhIGNsb3N1cmVcbiAgICAvLyBvcGVyYXRpb24gb24gdGhlIGludGVybWVkaWF0ZSBzZXQgdG8gY29tcHV0ZSBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAgICAvL1xuICAgIGlmIChyZWFjaD09PW51bGwpIHtcbiAgICAgICAgcmVhY2ggPSBuZXcgQVROQ29uZmlnU2V0KGZ1bGxDdHgpO1xuICAgICAgICB2YXIgY2xvc3VyZUJ1c3kgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciB0cmVhdEVvZkFzRXBzaWxvbiA9IHQgPT09IFRva2VuLkVPRjtcbiAgICAgICAgZm9yICh2YXIgaz0wOyBrPGludGVybWVkaWF0ZS5pdGVtcy5sZW5ndGg7aysrKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3N1cmUoaW50ZXJtZWRpYXRlLml0ZW1zW2tdLCByZWFjaCwgY2xvc3VyZUJ1c3ksIGZhbHNlLCBmdWxsQ3R4LCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IFRva2VuLkVPRikge1xuICAgICAgICAvLyBBZnRlciBjb25zdW1pbmcgRU9GIG5vIGFkZGl0aW9uYWwgaW5wdXQgaXMgcG9zc2libGUsIHNvIHdlIGFyZVxuICAgICAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gY29uZmlndXJhdGlvbnMgd2hpY2ggcmVhY2hlZCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBkZWNpc2lvbiBydWxlIChsb2NhbCBjb250ZXh0KSBvciBlbmQgb2YgdGhlIHN0YXJ0IHJ1bGUgKGZ1bGxcbiAgICAgICAgLy8gY29udGV4dCkuIFVwZGF0ZSByZWFjaCB0byBjb250YWluIG9ubHkgdGhlc2UgY29uZmlndXJhdGlvbnMuIFRoaXNcbiAgICAgICAgLy8gaGFuZGxlcyBib3RoIGV4cGxpY2l0IEVPRiB0cmFuc2l0aW9ucyBpbiB0aGUgZ3JhbW1hciBhbmQgaW1wbGljaXRcbiAgICAgICAgLy8gRU9GIHRyYW5zaXRpb25zIGZvbGxvd2luZyB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvbiBvciBzdGFydCBydWxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGVuIHJlYWNoPT1pbnRlcm1lZGlhdGUsIG5vIGNsb3N1cmUgb3BlcmF0aW9uIHdhcyBwZXJmb3JtZWQuIEluXG4gICAgICAgIC8vIHRoaXMgY2FzZSwgcmVtb3ZlQWxsQ29uZmlnc05vdEluUnVsZVN0b3BTdGF0ZSBuZWVkcyB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gcmVhY2hhYmxlIHJ1bGUgc3RvcCBzdGF0ZXMgYXMgd2VsbCBhcyBjb25maWd1cmF0aW9ucyBhbHJlYWR5IGluXG4gICAgICAgIC8vIGEgcnVsZSBzdG9wIHN0YXRlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGlzIGhhbmRsZWQgYmVmb3JlIHRoZSBjb25maWd1cmF0aW9ucyBpbiBza2lwcGVkU3RvcFN0YXRlcyxcbiAgICAgICAgLy8gYmVjYXVzZSBhbnkgY29uZmlndXJhdGlvbnMgcG90ZW50aWFsbHkgYWRkZWQgZnJvbSB0aGF0IGxpc3QgYXJlXG4gICAgICAgIC8vIGFscmVhZHkgZ3VhcmFudGVlZCB0byBtZWV0IHRoaXMgY29uZGl0aW9uIHdoZXRoZXIgb3Igbm90IGl0J3NcbiAgICAgICAgLy8gcmVxdWlyZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJlYWNoID0gdGhpcy5yZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlKHJlYWNoLCByZWFjaCA9PT0gaW50ZXJtZWRpYXRlKTtcbiAgICB9XG4gICAgLy8gSWYgc2tpcHBlZFN0b3BTdGF0ZXMhPT1udWxsLCB0aGVuIGl0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNvbmZpZ3VyYXRpb24uIEZvciBmdWxsLWNvbnRleHQgcmVhY2ggb3BlcmF0aW9ucywgdGhlc2VcbiAgICAvLyBjb25maWd1cmF0aW9ucyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0YXJ0IHJ1bGUsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyBvbmx5IGFkZCB0aGVtIGJhY2sgdG8gcmVhY2ggaWYgbm8gY29uZmlndXJhdGlvbiBkdXJpbmcgdGhlIGN1cnJlbnRcbiAgICAvLyBjbG9zdXJlIG9wZXJhdGlvbiByZWFjaGVkIHN1Y2ggYSBzdGF0ZS4gVGhpcyBlbnN1cmVzIGFkYXB0aXZlUHJlZGljdFxuICAgIC8vIGNob29zZXMgYW4gYWx0ZXJuYXRpdmUgbWF0Y2hpbmcgdGhlIGxvbmdlc3Qgb3ZlcmFsbCBzZXF1ZW5jZSB3aGVuXG4gICAgLy8gbXVsdGlwbGUgYWx0ZXJuYXRpdmVzIGFyZSB2aWFibGUuXG4gICAgLy9cbiAgICBpZiAoc2tpcHBlZFN0b3BTdGF0ZXMhPT1udWxsICYmICggKCEgZnVsbEN0eCkgfHwgKCEgUHJlZGljdGlvbk1vZGUuaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlKHJlYWNoKSkpKSB7XG4gICAgICAgIGZvciAodmFyIGw9MDsgbDxza2lwcGVkU3RvcFN0YXRlcy5sZW5ndGg7bCsrKSB7XG4gICAgICAgICAgICByZWFjaC5hZGQoc2tpcHBlZFN0b3BTdGF0ZXNbbF0sIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlYWNoLml0ZW1zLmxlbmd0aD09PTApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlYWNoO1xuICAgIH1cbn07XG4vL1xuLy8gUmV0dXJuIGEgY29uZmlndXJhdGlvbiBzZXQgY29udGFpbmluZyBvbmx5IHRoZSBjb25maWd1cmF0aW9ucyBmcm9tXG4vLyB7QGNvZGUgY29uZmlnc30gd2hpY2ggYXJlIGluIGEge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LiBJZiBhbGxcbi8vIGNvbmZpZ3VyYXRpb25zIGluIHtAY29kZSBjb25maWdzfSBhcmUgYWxyZWFkeSBpbiBhIHJ1bGUgc3RvcCBzdGF0ZSwgdGhpc1xuLy8gbWV0aG9kIHNpbXBseSByZXR1cm5zIHtAY29kZSBjb25maWdzfS5cbi8vXG4vLyA8cD5XaGVuIHtAY29kZSBsb29rVG9FbmRPZlJ1bGV9IGlzIHRydWUsIHRoaXMgbWV0aG9kIHVzZXNcbi8vIHtAbGluayBBVE4vL25leHRUb2tlbnN9IGZvciBlYWNoIGNvbmZpZ3VyYXRpb24gaW4ge0Bjb2RlIGNvbmZpZ3N9IHdoaWNoIGlzXG4vLyBub3QgYWxyZWFkeSBpbiBhIHJ1bGUgc3RvcCBzdGF0ZSB0byBzZWUgaWYgYSBydWxlIHN0b3Agc3RhdGUgaXMgcmVhY2hhYmxlXG4vLyBmcm9tIHRoZSBjb25maWd1cmF0aW9uIHZpYSBlcHNpbG9uLW9ubHkgdHJhbnNpdGlvbnMuPC9wPlxuLy9cbi8vIEBwYXJhbSBjb25maWdzIHRoZSBjb25maWd1cmF0aW9uIHNldCB0byB1cGRhdGVcbi8vIEBwYXJhbSBsb29rVG9FbmRPZlJ1bGUgd2hlbiB0cnVlLCB0aGlzIG1ldGhvZCBjaGVja3MgZm9yIHJ1bGUgc3RvcCBzdGF0ZXNcbi8vIHJlYWNoYWJsZSBieSBlcHNpbG9uLW9ubHkgdHJhbnNpdGlvbnMgZnJvbSBlYWNoIGNvbmZpZ3VyYXRpb24gaW5cbi8vIHtAY29kZSBjb25maWdzfS5cbi8vXG4vLyBAcmV0dXJuIHtAY29kZSBjb25maWdzfSBpZiBhbGwgY29uZmlndXJhdGlvbnMgaW4ge0Bjb2RlIGNvbmZpZ3N9IGFyZSBpbiBhXG4vLyBydWxlIHN0b3Agc3RhdGUsIG90aGVyd2lzZSByZXR1cm4gYSBuZXcgY29uZmlndXJhdGlvbiBzZXQgY29udGFpbmluZyBvbmx5XG4vLyB0aGUgY29uZmlndXJhdGlvbnMgZnJvbSB7QGNvZGUgY29uZmlnc30gd2hpY2ggYXJlIGluIGEgcnVsZSBzdG9wIHN0YXRlXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5yZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlID0gZnVuY3Rpb24oY29uZmlncywgbG9va1RvRW5kT2ZSdWxlKSB7XG4gICAgaWYgKFByZWRpY3Rpb25Nb2RlLmFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzKGNvbmZpZ3MpKSB7XG4gICAgICAgIHJldHVybiBjb25maWdzO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgIGZvcih2YXIgaT0wOyBpPGNvbmZpZ3MuaXRlbXMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgY29uZmlnID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoY29uZmlnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tUb0VuZE9mUnVsZSAmJiBjb25maWcuc3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIG5leHRUb2tlbnMgPSB0aGlzLmF0bi5uZXh0VG9rZW5zKGNvbmZpZy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZlJ1bGVTdGF0ZSA9IHRoaXMuYXRuLnJ1bGVUb1N0b3BTdGF0ZVtjb25maWcuc3RhdGUucnVsZUluZGV4XTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKG5ldyBBVE5Db25maWcoe3N0YXRlOmVuZE9mUnVsZVN0YXRlfSwgY29uZmlnKSwgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jb21wdXRlU3RhcnRTdGF0ZSA9IGZ1bmN0aW9uKHAsIGN0eCwgZnVsbEN0eCkge1xuICAgIC8vIGFsd2F5cyBhdCBsZWFzdCB0aGUgaW1wbGljaXQgY2FsbCB0byBzdGFydCBydWxlXG4gICAgdmFyIGluaXRpYWxDb250ZXh0ID0gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQodGhpcy5hdG4sIGN0eCk7XG4gICAgdmFyIGNvbmZpZ3MgPSBuZXcgQVROQ29uZmlnU2V0KGZ1bGxDdHgpO1xuICAgIGZvcih2YXIgaT0wO2k8cC50cmFuc2l0aW9ucy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwLnRyYW5zaXRpb25zW2ldLnRhcmdldDtcbiAgICAgICAgdmFyIGMgPSBuZXcgQVROQ29uZmlnKHsgc3RhdGU6dGFyZ2V0LCBhbHQ6aSsxLCBjb250ZXh0OmluaXRpYWxDb250ZXh0IH0sIG51bGwpO1xuICAgICAgICB2YXIgY2xvc3VyZUJ1c3kgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY2xvc3VyZShjLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgdHJ1ZSwgZnVsbEN0eCwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlncztcbn07XG5cbi8vXG4vLyBUaGlzIG1ldGhvZCB0cmFuc2Zvcm1zIHRoZSBzdGFydCBzdGF0ZSBjb21wdXRlZCBieVxuLy8ge0BsaW5rIC8vY29tcHV0ZVN0YXJ0U3RhdGV9IHRvIHRoZSBzcGVjaWFsIHN0YXJ0IHN0YXRlIHVzZWQgYnkgYVxuLy8gcHJlY2VkZW5jZSBERkEgZm9yIGEgcGFydGljdWxhciBwcmVjZWRlbmNlIHZhbHVlLiBUaGUgdHJhbnNmb3JtYXRpb25cbi8vIHByb2Nlc3MgYXBwbGllcyB0aGUgZm9sbG93aW5nIGNoYW5nZXMgdG8gdGhlIHN0YXJ0IHN0YXRlJ3MgY29uZmlndXJhdGlvblxuLy8gc2V0LlxuLy9cbi8vIDxvbD5cbi8vIDxsaT5FdmFsdWF0ZSB0aGUgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGZvciBlYWNoIGNvbmZpZ3VyYXRpb24gdXNpbmdcbi8vIHtAbGluayBTZW1hbnRpY0NvbnRleHQvL2V2YWxQcmVjZWRlbmNlfS48L2xpPlxuLy8gPGxpPlJlbW92ZSBhbGwgY29uZmlndXJhdGlvbnMgd2hpY2ggcHJlZGljdCBhbiBhbHRlcm5hdGl2ZSBncmVhdGVyIHRoYW5cbi8vIDEsIGZvciB3aGljaCBhbm90aGVyIGNvbmZpZ3VyYXRpb24gdGhhdCBwcmVkaWN0cyBhbHRlcm5hdGl2ZSAxIGlzIGluIHRoZVxuLy8gc2FtZSBBVE4gc3RhdGUgd2l0aCB0aGUgc2FtZSBwcmVkaWN0aW9uIGNvbnRleHQuIFRoaXMgdHJhbnNmb3JtYXRpb24gaXNcbi8vIHZhbGlkIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XG4vLyA8dWw+XG4vLyA8bGk+VGhlIGNsb3N1cmUgYmxvY2sgY2Fubm90IGNvbnRhaW4gYW55IGVwc2lsb24gdHJhbnNpdGlvbnMgd2hpY2ggYnlwYXNzXG4vLyB0aGUgYm9keSBvZiB0aGUgY2xvc3VyZSwgc28gYWxsIHN0YXRlcyByZWFjaGFibGUgdmlhIGFsdGVybmF0aXZlIDEgYXJlXG4vLyBwYXJ0IG9mIHRoZSBwcmVjZWRlbmNlIGFsdGVybmF0aXZlcyBvZiB0aGUgdHJhbnNmb3JtZWQgbGVmdC1yZWN1cnNpdmVcbi8vIHJ1bGUuPC9saT5cbi8vIDxsaT5UaGUgXCJwcmltYXJ5XCIgcG9ydGlvbiBvZiBhIGxlZnQgcmVjdXJzaXZlIHJ1bGUgY2Fubm90IGNvbnRhaW4gYW5cbi8vIGVwc2lsb24gdHJhbnNpdGlvbiwgc28gdGhlIG9ubHkgd2F5IGFuIGFsdGVybmF0aXZlIG90aGVyIHRoYW4gMSBjYW4gZXhpc3Rcbi8vIGluIGEgc3RhdGUgdGhhdCBpcyBhbHNvIHJlYWNoYWJsZSB2aWEgYWx0ZXJuYXRpdmUgMSBpcyBieSBuZXN0aW5nIGNhbGxzXG4vLyB0byB0aGUgbGVmdC1yZWN1cnNpdmUgcnVsZSwgd2l0aCB0aGUgb3V0ZXIgY2FsbHMgbm90IGJlaW5nIGF0IHRoZVxuLy8gcHJlZmVycmVkIHByZWNlZGVuY2UgbGV2ZWwuPC9saT5cbi8vIDwvdWw+XG4vLyA8L2xpPlxuLy8gPC9vbD5cbi8vXG4vLyA8cD5cbi8vIFRoZSBwcmVkaWN0aW9uIGNvbnRleHQgbXVzdCBiZSBjb25zaWRlcmVkIGJ5IHRoaXMgZmlsdGVyIHRvIGFkZHJlc3Ncbi8vIHNpdHVhdGlvbnMgbGlrZSB0aGUgZm9sbG93aW5nLlxuLy8gPC9wPlxuLy8gPGNvZGU+XG4vLyA8cHJlPlxuLy8gZ3JhbW1hciBUQTtcbi8vIHByb2c6IHN0YXRlbWVudCogRU9GO1xuLy8gc3RhdGVtZW50OiBsZXR0ZXJBIHwgc3RhdGVtZW50IGxldHRlckEgJ2InIDtcbi8vIGxldHRlckE6ICdhJztcbi8vIDwvcHJlPlxuLy8gPC9jb2RlPlxuLy8gPHA+XG4vLyBJZiB0aGUgYWJvdmUgZ3JhbW1hciwgdGhlIEFUTiBzdGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHRva2VuXG4vLyByZWZlcmVuY2Uge0Bjb2RlICdhJ30gaW4ge0Bjb2RlIGxldHRlckF9IGlzIHJlYWNoYWJsZSBmcm9tIHRoZSBsZWZ0IGVkZ2Vcbi8vIG9mIGJvdGggdGhlIHByaW1hcnkgYW5kIGNsb3N1cmUgYmxvY2tzIG9mIHRoZSBsZWZ0LXJlY3Vyc2l2ZSBydWxlXG4vLyB7QGNvZGUgc3RhdGVtZW50fS4gVGhlIHByZWRpY3Rpb24gY29udGV4dCBhc3NvY2lhdGVkIHdpdGggZWFjaCBvZiB0aGVzZVxuLy8gY29uZmlndXJhdGlvbnMgZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIHRoZW0sIGFuZCBwcmV2ZW50cyB0aGUgYWx0ZXJuYXRpdmVcbi8vIHdoaWNoIHN0ZXBwZWQgb3V0IHRvIHtAY29kZSBwcm9nfSAoYW5kIHRoZW4gYmFjayBpbiB0byB7QGNvZGUgc3RhdGVtZW50fVxuLy8gZnJvbSBiZWluZyBlbGltaW5hdGVkIGJ5IHRoZSBmaWx0ZXIuXG4vLyA8L3A+XG4vL1xuLy8gQHBhcmFtIGNvbmZpZ3MgVGhlIGNvbmZpZ3VyYXRpb24gc2V0IGNvbXB1dGVkIGJ5XG4vLyB7QGxpbmsgLy9jb21wdXRlU3RhcnRTdGF0ZX0gYXMgdGhlIHN0YXJ0IHN0YXRlIGZvciB0aGUgREZBLlxuLy8gQHJldHVybiBUaGUgdHJhbnNmb3JtZWQgY29uZmlndXJhdGlvbiBzZXQgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBzdGF0ZVxuLy8gZm9yIGEgcHJlY2VkZW5jZSBERkEgYXQgYSBwYXJ0aWN1bGFyIHByZWNlZGVuY2UgbGV2ZWwgKGRldGVybWluZWQgYnlcbi8vIGNhbGxpbmcge0BsaW5rIFBhcnNlci8vZ2V0UHJlY2VkZW5jZX0pLlxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuYXBwbHlQcmVjZWRlbmNlRmlsdGVyID0gZnVuY3Rpb24oY29uZmlncykge1xuXHR2YXIgY29uZmlnO1xuXHR2YXIgc3RhdGVzRnJvbUFsdDEgPSBbXTtcbiAgICB2YXIgY29uZmlnU2V0ID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgIGZvcih2YXIgaT0wOyBpPGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgLy8gaGFuZGxlIGFsdCAxIGZpcnN0XG4gICAgICAgIGlmIChjb25maWcuYWx0ICE9PSAxKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlZENvbnRleHQgPSBjb25maWcuc2VtYW50aWNDb250ZXh0LmV2YWxQcmVjZWRlbmNlKHRoaXMucGFyc2VyLCB0aGlzLl9vdXRlckNvbnRleHQpO1xuICAgICAgICBpZiAodXBkYXRlZENvbnRleHQ9PT1udWxsKSB7XG4gICAgICAgICAgICAvLyB0aGUgY29uZmlndXJhdGlvbiB3YXMgZWxpbWluYXRlZFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVzRnJvbUFsdDFbY29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyXSA9IGNvbmZpZy5jb250ZXh0O1xuICAgICAgICBpZiAodXBkYXRlZENvbnRleHQgIT09IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbmZpZ1NldC5hZGQobmV3IEFUTkNvbmZpZyh7c2VtYW50aWNDb250ZXh0OnVwZGF0ZWRDb250ZXh0fSwgY29uZmlnKSwgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ1NldC5hZGQoY29uZmlnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPTA7IGk8Y29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25maWcgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoY29uZmlnLmFsdCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgZnV0dXJlLCB0aGlzIGVsaW1pbmF0aW9uIHN0ZXAgY291bGQgYmUgdXBkYXRlZCB0byBhbHNvXG4gICAgICAgIC8vIGZpbHRlciB0aGUgcHJlZGljdGlvbiBjb250ZXh0IGZvciBhbHRlcm5hdGl2ZXMgcHJlZGljdGluZyBhbHQ+MVxuICAgICAgICAvLyAoYmFzaWNhbGx5IGEgZ3JhcGggc3VidHJhY3Rpb24gYWxnb3JpdGhtKS5cblx0XHRpZiAoIWNvbmZpZy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzdGF0ZXNGcm9tQWx0MVtjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJdIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAoY29udGV4dCE9PW51bGwgJiYgY29udGV4dC5lcXVhbHMoY29uZmlnLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZWxpbWluYXRlZFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXHRcdH1cbiAgICAgICAgY29uZmlnU2V0LmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdTZXQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFJlYWNoYWJsZVRhcmdldCA9IGZ1bmN0aW9uKHRyYW5zLCB0dHlwZSkge1xuICAgIGlmICh0cmFucy5tYXRjaGVzKHR0eXBlLCAwLCB0aGlzLmF0bi5tYXhUb2tlblR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cmFucy50YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRQcmVkc0ZvckFtYmlnQWx0cyA9IGZ1bmN0aW9uKGFtYmlnQWx0cywgY29uZmlncywgbmFsdHMpIHtcbiAgICAvLyBSRUFDSD1bMXwxfFtdfDA6MCwgMXwyfFtdfDA6MV1cbiAgICAvLyBhbHRUb1ByZWQgc3RhcnRzIGFzIGFuIGFycmF5IG9mIGFsbCBudWxsIGNvbnRleHRzLiBUaGUgZW50cnkgYXQgaW5kZXggaVxuICAgIC8vIGNvcnJlc3BvbmRzIHRvIGFsdGVybmF0aXZlIGkuIGFsdFRvUHJlZFtpXSBtYXkgaGF2ZSBvbmUgb2YgdGhyZWUgdmFsdWVzOlxuICAgIC8vICAgMS4gbnVsbDogbm8gQVROQ29uZmlnIGMgaXMgZm91bmQgc3VjaCB0aGF0IGMuYWx0PT1pXG4gICAgLy8gICAyLiBTZW1hbnRpY0NvbnRleHQuTk9ORTogQXQgbGVhc3Qgb25lIEFUTkNvbmZpZyBjIGV4aXN0cyBzdWNoIHRoYXRcbiAgICAvLyAgICAgIGMuYWx0PT1pIGFuZCBjLnNlbWFudGljQ29udGV4dD09U2VtYW50aWNDb250ZXh0Lk5PTkUuIEluIG90aGVyIHdvcmRzLFxuICAgIC8vICAgICAgYWx0IGkgaGFzIGF0IGxlYXN0IG9uZSB1bnByZWRpY2F0ZWQgY29uZmlnLlxuICAgIC8vICAgMy4gTm9uLU5PTkUgU2VtYW50aWMgQ29udGV4dDogVGhlcmUgZXhpc3RzIGF0IGxlYXN0IG9uZSwgYW5kIGZvciBhbGxcbiAgICAvLyAgICAgIEFUTkNvbmZpZyBjIHN1Y2ggdGhhdCBjLmFsdD09aSwgYy5zZW1hbnRpY0NvbnRleHQhPVNlbWFudGljQ29udGV4dC5OT05FLlxuICAgIC8vXG4gICAgLy8gRnJvbSB0aGlzLCBpdCBpcyBjbGVhciB0aGF0IE5PTkV8fGFueXRoaW5nPT1OT05FLlxuICAgIC8vXG4gICAgdmFyIGFsdFRvUHJlZCA9IFtdO1xuICAgIGZvcih2YXIgaT0wO2k8Y29uZmlncy5pdGVtcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYoYW1iaWdBbHRzLmNvbnRhaW5zKCBjLmFsdCApKSB7XG4gICAgICAgICAgICBhbHRUb1ByZWRbYy5hbHRdID0gU2VtYW50aWNDb250ZXh0Lm9yQ29udGV4dChhbHRUb1ByZWRbYy5hbHRdIHx8IG51bGwsIGMuc2VtYW50aWNDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgblByZWRBbHRzID0gMDtcbiAgICBmb3IgKGkgPTE7aTwgbmFsdHMrMTtpKyspIHtcbiAgICAgICAgdmFyIHByZWQgPSBhbHRUb1ByZWRbaV0gfHwgbnVsbDtcbiAgICAgICAgaWYgKHByZWQ9PT1udWxsKSB7XG4gICAgICAgICAgICBhbHRUb1ByZWRbaV0gPSBTZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVkICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgICAgblByZWRBbHRzICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbm9uYW1iaWcgYWx0cyBhcmUgbnVsbCBpbiBhbHRUb1ByZWRcbiAgICBpZiAoblByZWRBbHRzPT09MCkge1xuICAgICAgICBhbHRUb1ByZWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImdldFByZWRzRm9yQW1iaWdBbHRzIHJlc3VsdCBcIiArIFV0aWxzLmFycmF5VG9TdHJpbmcoYWx0VG9QcmVkKSk7XG4gICAgfVxuICAgIHJldHVybiBhbHRUb1ByZWQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFByZWRpY2F0ZVByZWRpY3Rpb25zID0gZnVuY3Rpb24oYW1iaWdBbHRzLCBhbHRUb1ByZWQpIHtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICB2YXIgY29udGFpbnNQcmVkaWNhdGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpPTE7IGk8YWx0VG9QcmVkLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIHByZWQgPSBhbHRUb1ByZWRbaV07XG4gICAgICAgIC8vIHVucHJlZGljYXRlZCBpcyBpbmRpY2F0ZWQgYnkgU2VtYW50aWNDb250ZXh0Lk5PTkVcbiAgICAgICAgaWYoIGFtYmlnQWx0cyE9PW51bGwgJiYgYW1iaWdBbHRzLmNvbnRhaW5zKCBpICkpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2gobmV3IFByZWRQcmVkaWN0aW9uKHByZWQsIGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgICAgIGNvbnRhaW5zUHJlZGljYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoISBjb250YWluc1ByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufTtcblxuLy9cbi8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gaW1wcm92ZSB0aGUgbG9jYWxpemF0aW9uIG9mIGVycm9yIG1lc3NhZ2VzIGJ5XG4vLyBjaG9vc2luZyBhbiBhbHRlcm5hdGl2ZSByYXRoZXIgdGhhbiB0aHJvd2luZyBhXG4vLyB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259IGluIHBhcnRpY3VsYXIgcHJlZGljdGlvbiBzY2VuYXJpb3Mgd2hlcmUgdGhlXG4vLyB7QGxpbmsgLy9FUlJPUn0gc3RhdGUgd2FzIHJlYWNoZWQgZHVyaW5nIEFUTiBzaW11bGF0aW9uLlxuLy9cbi8vIDxwPlxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgdXNlcyB0aGUgZm9sbG93aW5nXG4vLyBhbGdvcml0aG0gdG8gaWRlbnRpZnkgYW4gQVROIGNvbmZpZ3VyYXRpb24gd2hpY2ggc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGVcbi8vIGRlY2lzaW9uIGVudHJ5IHJ1bGUuIENob29zaW5nIHN1Y2ggYW4gYWx0ZXJuYXRpdmUgZW5zdXJlcyB0aGF0IHRoZVxuLy8ge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSByZXR1cm5lZCBieSB0aGUgY2FsbGluZyBydWxlIHdpbGwgYmUgY29tcGxldGVcbi8vIGFuZCB2YWxpZCwgYW5kIHRoZSBzeW50YXggZXJyb3Igd2lsbCBiZSByZXBvcnRlZCBsYXRlciBhdCBhIG1vcmVcbi8vIGxvY2FsaXplZCBsb2NhdGlvbi48L3A+XG4vL1xuLy8gPHVsPlxuLy8gPGxpPklmIGEgc3ludGFjdGljYWxseSB2YWxpZCBwYXRoIG9yIHBhdGhzIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUgYW5kXG4vLyB0aGV5IGFyZSBzZW1hbnRpY2FsbHkgdmFsaWQgaWYgcHJlZGljYXRlZCwgcmV0dXJuIHRoZSBtaW4gYXNzb2NpYXRlZCBhbHQuPC9saT5cbi8vIDxsaT5FbHNlLCBpZiBhIHNlbWFudGljYWxseSBpbnZhbGlkIGJ1dCBzeW50YWN0aWNhbGx5IHZhbGlkIHBhdGggZXhpc3Rcbi8vIG9yIHBhdGhzIGV4aXN0LCByZXR1cm4gdGhlIG1pbmltdW0gYXNzb2NpYXRlZCBhbHQuXG4vLyA8L2xpPlxuLy8gPGxpPk90aGVyd2lzZSwgcmV0dXJuIHtAbGluayBBVE4vL0lOVkFMSURfQUxUX05VTUJFUn0uPC9saT5cbi8vIDwvdWw+XG4vL1xuLy8gPHA+XG4vLyBJbiBzb21lIHNjZW5hcmlvcywgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgYWJvdmUgY291bGQgcHJlZGljdCBhblxuLy8gYWx0ZXJuYXRpdmUgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufSBpblxuLy8gdGhlIHBhcnNlci4gU3BlY2lmaWNhbGx5LCB0aGlzIGNvdWxkIG9jY3VyIGlmIHRoZSA8ZW0+b25seTwvZW0+IGNvbmZpZ3VyYXRpb25cbi8vIGNhcGFibGUgb2Ygc3VjY2Vzc2Z1bGx5IHBhcnNpbmcgdG8gdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSBpc1xuLy8gYmxvY2tlZCBieSBhIHNlbWFudGljIHByZWRpY2F0ZS4gQnkgY2hvb3NpbmcgdGhpcyBhbHRlcm5hdGl2ZSB3aXRoaW5cbi8vIHtAbGluayAvL2FkYXB0aXZlUHJlZGljdH0gaW5zdGVhZCBvZiB0aHJvd2luZyBhXG4vLyB7QGxpbmsgTm9WaWFibGVBbHRFeGNlcHRpb259LCB0aGUgcmVzdWx0aW5nXG4vLyB7QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufSBpbiB0aGUgcGFyc2VyIHdpbGwgaWRlbnRpZnkgdGhlIHNwZWNpZmljXG4vLyBwcmVkaWNhdGUgd2hpY2ggaXMgcHJldmVudGluZyB0aGUgcGFyc2VyIGZyb20gc3VjY2Vzc2Z1bGx5IHBhcnNpbmcgdGhlXG4vLyBkZWNpc2lvbiBydWxlLCB3aGljaCBoZWxwcyBkZXZlbG9wZXJzIGlkZW50aWZ5IGFuZCBjb3JyZWN0IGxvZ2ljIGVycm9yc1xuLy8gaW4gc2VtYW50aWMgcHJlZGljYXRlcy5cbi8vIDwvcD5cbi8vXG4vLyBAcGFyYW0gY29uZmlncyBUaGUgQVROIGNvbmZpZ3VyYXRpb25zIHdoaWNoIHdlcmUgdmFsaWQgaW1tZWRpYXRlbHkgYmVmb3JlXG4vLyB0aGUge0BsaW5rIC8vRVJST1J9IHN0YXRlIHdhcyByZWFjaGVkXG4vLyBAcGFyYW0gb3V0ZXJDb250ZXh0IFRoZSBpcyB0aGUgXFxnYW1tYV8wIGluaXRpYWwgcGFyc2VyIGNvbnRleHQgZnJvbSB0aGUgcGFwZXJcbi8vIG9yIHRoZSBwYXJzZXIgc3RhY2sgYXQgdGhlIGluc3RhbnQgYmVmb3JlIHByZWRpY3Rpb24gY29tbWVuY2VzLlxuLy9cbi8vIEByZXR1cm4gVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHtAbGluayAvL2FkYXB0aXZlUHJlZGljdH0sIG9yXG4vLyB7QGxpbmsgQVROLy9JTlZBTElEX0FMVF9OVU1CRVJ9IGlmIGEgc3VpdGFibGUgYWx0ZXJuYXRpdmUgd2FzIG5vdFxuLy8gaWRlbnRpZmllZCBhbmQge0BsaW5rIC8vYWRhcHRpdmVQcmVkaWN0fSBzaG91bGQgcmVwb3J0IGFuIGVycm9yIGluc3RlYWQuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRTeW5WYWxpZE9yU2VtSW52YWxpZEFsdFRoYXRGaW5pc2hlZERlY2lzaW9uRW50cnlSdWxlID0gZnVuY3Rpb24oY29uZmlncywgb3V0ZXJDb250ZXh0KSB7XG4gICAgdmFyIGNmZ3MgPSB0aGlzLnNwbGl0QWNjb3JkaW5nVG9TZW1hbnRpY1ZhbGlkaXR5KGNvbmZpZ3MsIG91dGVyQ29udGV4dCk7XG4gICAgdmFyIHNlbVZhbGlkQ29uZmlncyA9IGNmZ3NbMF07XG4gICAgdmFyIHNlbUludmFsaWRDb25maWdzID0gY2Znc1sxXTtcbiAgICB2YXIgYWx0ID0gdGhpcy5nZXRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShzZW1WYWxpZENvbmZpZ3MpO1xuICAgIGlmIChhbHQhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7IC8vIHNlbWFudGljYWxseS9zeW50YWN0aWNhbGx5IHZpYWJsZSBwYXRoIGV4aXN0c1xuICAgICAgICByZXR1cm4gYWx0O1xuICAgIH1cbiAgICAvLyBJcyB0aGVyZSBhIHN5bnRhY3RpY2FsbHkgdmFsaWQgcGF0aCB3aXRoIGEgZmFpbGVkIHByZWQ/XG4gICAgaWYgKHNlbUludmFsaWRDb25maWdzLml0ZW1zLmxlbmd0aD4wKSB7XG4gICAgICAgIGFsdCA9IHRoaXMuZ2V0QWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUoc2VtSW52YWxpZENvbmZpZ3MpO1xuICAgICAgICBpZiAoYWx0IT09QVROLklOVkFMSURfQUxUX05VTUJFUikgeyAvLyBzeW50YWN0aWNhbGx5IHZpYWJsZSBwYXRoIGV4aXN0c1xuICAgICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQVROLklOVkFMSURfQUxUX05VTUJFUjtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0QWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUgPSBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIGFsdHMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDtpPGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoYy5yZWFjaGVzSW50b091dGVyQ29udGV4dD4wIHx8ICgoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpICYmIGMuY29udGV4dC5oYXNFbXB0eVBhdGgoKSkpIHtcbiAgICAgICAgICAgIGlmKGFsdHMuaW5kZXhPZihjLmFsdCk8MCkge1xuICAgICAgICAgICAgICAgIGFsdHMucHVzaChjLmFsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdHMubGVuZ3RoPT09MCkge1xuICAgICAgICByZXR1cm4gQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgYWx0cyk7XG4gICAgfVxufTtcbi8vIFdhbGsgdGhlIGxpc3Qgb2YgY29uZmlndXJhdGlvbnMgYW5kIHNwbGl0IHRoZW0gYWNjb3JkaW5nIHRvXG4vLyAgdGhvc2UgdGhhdCBoYXZlIHByZWRzIGV2YWx1YXRpbmcgdG8gdHJ1ZS9mYWxzZS4gIElmIG5vIHByZWQsIGFzc3VtZVxuLy8gIHRydWUgcHJlZCBhbmQgaW5jbHVkZSBpbiBzdWNjZWVkZWQgc2V0LiAgUmV0dXJucyBQYWlyIG9mIHNldHMuXG4vL1xuLy8gIENyZWF0ZSBhIG5ldyBzZXQgc28gYXMgbm90IHRvIGFsdGVyIHRoZSBpbmNvbWluZyBwYXJhbWV0ZXIuXG4vL1xuLy8gIEFzc3VtcHRpb246IHRoZSBpbnB1dCBzdHJlYW0gaGFzIGJlZW4gcmVzdG9yZWQgdG8gdGhlIHN0YXJ0aW5nIHBvaW50XG4vLyAgcHJlZGljdGlvbiwgd2hpY2ggaXMgd2hlcmUgcHJlZGljYXRlcyBuZWVkIHRvIGV2YWx1YXRlLlxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuc3BsaXRBY2NvcmRpbmdUb1NlbWFudGljVmFsaWRpdHkgPSBmdW5jdGlvbiggY29uZmlncywgb3V0ZXJDb250ZXh0KSB7XG4gICAgdmFyIHN1Y2NlZWRlZCA9IG5ldyBBVE5Db25maWdTZXQoY29uZmlncy5mdWxsQ3R4KTtcbiAgICB2YXIgZmFpbGVkID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgIGZvcih2YXIgaT0wO2k8Y29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgIGlmIChjLnNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0ID0gYy5zZW1hbnRpY0NvbnRleHQuZXZhbHVhdGUodGhpcy5wYXJzZXIsIG91dGVyQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHN1Y2NlZWRlZC5hZGQoYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhaWxlZC5hZGQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQuYWRkKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3VjY2VlZGVkLCBmYWlsZWRdO1xufTtcblxuLy8gTG9vayB0aHJvdWdoIGEgbGlzdCBvZiBwcmVkaWNhdGUvYWx0IHBhaXJzLCByZXR1cm5pbmcgYWx0cyBmb3IgdGhlXG4vLyAgcGFpcnMgdGhhdCB3aW4uIEEge0Bjb2RlIE5PTkV9IHByZWRpY2F0ZSBpbmRpY2F0ZXMgYW4gYWx0IGNvbnRhaW5pbmcgYW5cbi8vICB1bnByZWRpY2F0ZWQgY29uZmlnIHdoaWNoIGJlaGF2ZXMgYXMgXCJhbHdheXMgdHJ1ZS5cIiBJZiAhY29tcGxldGVcbi8vICB0aGVuIHdlIHN0b3AgYXQgdGhlIGZpcnN0IHByZWRpY2F0ZSB0aGF0IGV2YWx1YXRlcyB0byB0cnVlLiBUaGlzXG4vLyAgaW5jbHVkZXMgcGFpcnMgd2l0aCBudWxsIHByZWRpY2F0ZXMuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5ldmFsU2VtYW50aWNDb250ZXh0ID0gZnVuY3Rpb24ocHJlZFByZWRpY3Rpb25zLCBvdXRlckNvbnRleHQsIGNvbXBsZXRlKSB7XG4gICAgdmFyIHByZWRpY3Rpb25zID0gbmV3IEJpdFNldCgpO1xuICAgIGZvcih2YXIgaT0wO2k8cHJlZFByZWRpY3Rpb25zLmxlbmd0aDtpKyspIHtcbiAgICBcdHZhciBwYWlyID0gcHJlZFByZWRpY3Rpb25zW2ldO1xuICAgICAgICBpZiAocGFpci5wcmVkID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgICAgcHJlZGljdGlvbnMuYWRkKHBhaXIuYWx0KTtcbiAgICAgICAgICAgIGlmICghIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCA9IHBhaXIucHJlZC5ldmFsdWF0ZSh0aGlzLnBhcnNlciwgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZmFfZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXZhbCBwcmVkIFwiICsgcGFpciArIFwiPVwiICsgcHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWRpY2F0ZUV2YWx1YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQUkVESUNUIFwiICsgcGFpci5hbHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZGljdGlvbnMuYWRkKHBhaXIuYWx0KTtcbiAgICAgICAgICAgIGlmICghIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWRpY3Rpb25zO1xufTtcblxuLy8gVE9ETzogSWYgd2UgYXJlIGRvaW5nIHByZWRpY2F0ZXMsIHRoZXJlIGlzIG5vIHBvaW50IGluIHB1cnN1aW5nXG4vLyAgICAgY2xvc3VyZSBvcGVyYXRpb25zIGlmIHdlIHJlYWNoIGEgREZBIHN0YXRlIHRoYXQgdW5pcXVlbHkgcHJlZGljdHNcbi8vICAgICBhbHRlcm5hdGl2ZS4gV2Ugd2lsbCBub3QgYmUgY2FjaGluZyB0aGF0IERGQSBzdGF0ZSBhbmQgaXQgaXMgYVxuLy8gICAgIHdhc3RlIHRvIHB1cnN1ZSB0aGUgY2xvc3VyZS4gTWlnaHQgaGF2ZSB0byBhZHZhbmNlIHdoZW4gd2UgZG9cbi8vICAgICBhbWJpZyBkZXRlY3Rpb24gdGhvdWdodCA6KFxuLy9cblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jbG9zdXJlID0gZnVuY3Rpb24oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgdmFyIGluaXRpYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5jbG9zdXJlQ2hlY2tpbmdTdG9wU3RhdGUoY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxDdHgsIGluaXRpYWxEZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xufTtcblxuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNsb3N1cmVDaGVja2luZ1N0b3BTdGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBkZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLmRlYnVnX2Nsb3N1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjbG9zdXJlKFwiICsgY29uZmlnLnRvU3RyaW5nKHRoaXMucGFyc2VyLHRydWUpICsgXCIpXCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNvbmZpZ3MoXCIgKyBjb25maWdzLnRvU3RyaW5nKCkgKyBcIilcIik7XG4gICAgICAgIGlmKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dD41MCkge1xuICAgICAgICAgICAgdGhyb3cgXCJwcm9ibGVtXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgLy8gV2UgaGl0IHJ1bGUgZW5kLiBJZiB3ZSBoYXZlIGNvbnRleHQgaW5mbywgdXNlIGl0XG4gICAgICAgIC8vIHJ1biB0aHJ1IGFsbCBwb3NzaWJsZSBzdGFjayB0b3BzIGluIGN0eFxuICAgICAgICBpZiAoISBjb25maWcuY29udGV4dC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0wOyBpPGNvbmZpZy5jb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0LmdldFJldHVyblN0YXRlKGkpID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuYWRkKG5ldyBBVE5Db25maWcoe3N0YXRlOmNvbmZpZy5zdGF0ZSwgY29udGV4dDpQcmVkaWN0aW9uQ29udGV4dC5FTVBUWX0sIGNvbmZpZyksIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgbm8gY29udGV4dCBpbmZvLCBqdXN0IGNoYXNlIGZvbGxvdyBsaW5rcyAoaWYgZ3JlZWR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZBTExJTkcgb2ZmIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKGNvbmZpZy5zdGF0ZS5ydWxlSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc3VyZV8oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsQ3R4LCBkZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSldO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0UGFyZW50KGkpOyAvLyBcInBvcFwiIHJldHVybiBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBwYXJtcyA9IHtzdGF0ZTpyZXR1cm5TdGF0ZSwgYWx0OmNvbmZpZy5hbHQsIGNvbnRleHQ6bmV3Q29udGV4dCwgc2VtYW50aWNDb250ZXh0OmNvbmZpZy5zZW1hbnRpY0NvbnRleHR9O1xuICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IEFUTkNvbmZpZyhwYXJtcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSBjb250ZXh0IHRvIHBvcCBiYWNrIGZyb20sIHdlIG1heSBoYXZlXG4gICAgICAgICAgICAgICAgLy8gZ290dGVuIHRoYXQgY29udGV4dCBBRlRFUiBoYXZpbmcgZmFsbGluZyBvZmYgYSBydWxlLlxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmFjayB0aGF0IHdlIGFyZSBub3cgb3V0IG9mIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgYy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3N1cmVDaGVja2luZ1N0b3BTdGF0ZShjLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoIC0gMSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYoIGZ1bGxDdHgpIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIG9mIHN0YXJ0IHJ1bGVcbiAgICAgICAgICAgIGNvbmZpZ3MuYWRkKGNvbmZpZywgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UgaWYgd2UgaGF2ZSBubyBjb250ZXh0IGluZm8sIGp1c3QgY2hhc2UgZm9sbG93IGxpbmtzIChpZiBncmVlZHkpXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRkFMTElORyBvZmYgcnVsZSBcIiArIHRoaXMuZ2V0UnVsZU5hbWUoY29uZmlnLnN0YXRlLnJ1bGVJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xvc3VyZV8oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG59O1xuXG5cbi8vIERvIHRoZSBhY3R1YWwgd29yayBvZiB3YWxraW5nIGVwc2lsb24gZWRnZXMvL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jbG9zdXJlXyA9IGZ1bmN0aW9uKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBkZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICB2YXIgcCA9IGNvbmZpZy5zdGF0ZTtcbiAgICAvLyBvcHRpbWl6YXRpb25cbiAgICBpZiAoISBwLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMpIHtcbiAgICAgICAgY29uZmlncy5hZGQoY29uZmlnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gbm90IHJldHVybiBoZXJlLCBiZWNhdXNlIEVPRiB0cmFuc2l0aW9ucyBjYW4gYWN0IGFzXG4gICAgICAgIC8vIGJvdGggZXBzaWxvbiB0cmFuc2l0aW9ucyBhbmQgbm9uLWVwc2lsb24gdHJhbnNpdGlvbnMuXG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7aTxwLnRyYW5zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGk9PTAgJiYgdGhpcy5jYW5Ecm9wTG9vcEVudHJ5RWRnZUluTGVmdFJlY3Vyc2l2ZVJ1bGUoY29uZmlnKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB0ID0gcC50cmFuc2l0aW9uc1tpXTtcbiAgICAgICAgdmFyIGNvbnRpbnVlQ29sbGVjdGluZyA9IGNvbGxlY3RQcmVkaWNhdGVzICYmICEodCBpbnN0YW5jZW9mIEFjdGlvblRyYW5zaXRpb24pO1xuICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHQsIGNvbnRpbnVlQ29sbGVjdGluZywgZGVwdGggPT09IDAsIGZ1bGxDdHgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgaWYgKGMhPT1udWxsKSB7XG5cdFx0XHRpZiAoIXQuaXNFcHNpbG9uICYmIGNsb3N1cmVCdXN5LmFkZChjKSE9PWMpe1xuXHRcdFx0XHQvLyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb24gZm9yIEVPRiogYW5kIEVPRitcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG4gICAgICAgICAgICB2YXIgbmV3RGVwdGggPSBkZXB0aDtcbiAgICAgICAgICAgIGlmICggY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBmZWxsIG9mZiBlbmQgb2YgcnVsZTsgbWFyayByZXN1bHRpbmcgYyBhcyBoYXZpbmcgZGlwcGVkIGludG8gb3V0ZXIgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGdldCBoZXJlIGlmIGluY29taW5nIGNvbmZpZyB3YXMgcnVsZSBzdG9wIGFuZCB3ZSBoYWQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIHRyYWNrIGhvdyBmYXIgd2UgZGlwIGludG8gb3V0ZXIgY29udGV4dC4gIE1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gY29tZSBpbiBoYW5keSBhbmQgd2UgYXZvaWQgZXZhbHVhdGluZyBjb250ZXh0IGRlcGVuZGVudFxuICAgICAgICAgICAgICAgIC8vIHByZWRzIGlmIHRoaXMgaXMgPiAwLlxuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3N1cmVCdXN5LmFkZChjKSE9PWMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uIGZvciByaWdodC1yZWN1cnNpdmUgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdGlmICh0aGlzLl9kZmEgIT09IG51bGwgJiYgdGhpcy5fZGZhLnByZWNlZGVuY2VEZmEpIHtcblx0XHRcdFx0XHRpZiAodC5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID09PSB0aGlzLl9kZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXgpIHtcblx0XHRcdFx0XHRcdGMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG4gICAgICAgICAgICAgICAgYy5yZWFjaGVzSW50b091dGVyQ29udGV4dCArPSAxO1xuICAgICAgICAgICAgICAgIGNvbmZpZ3MuZGlwc0ludG9PdXRlckNvbnRleHQgPSB0cnVlOyAvLyBUT0RPOiBjYW4gcmVtb3ZlPyBvbmx5IGNhcmUgd2hlbiB3ZSBhZGQgdG8gc2V0IHBlciBtaWRkbGUgb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICBuZXdEZXB0aCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGlwcyBpbnRvIG91dGVyIGN0eDogXCIgKyBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGxhdGNoIHdoZW4gbmV3RGVwdGggZ29lcyBuZWdhdGl2ZSAtIG9uY2Ugd2Ugc3RlcCBvdXQgb2YgdGhlIGVudHJ5IGNvbnRleHQgd2UgY2FuJ3QgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RlcHRoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVwdGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3N1cmVDaGVja2luZ1N0b3BTdGF0ZShjLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29udGludWVDb2xsZWN0aW5nLCBmdWxsQ3R4LCBuZXdEZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNhbkRyb3BMb29wRW50cnlFZGdlSW5MZWZ0UmVjdXJzaXZlUnVsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIC8vIHJldHVybiBGYWxzZVxuICAgIHZhciBwID0gY29uZmlnLnN0YXRlO1xuICAgIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gU3Rhckxvb3BFbnRyeVN0YXRlIGdlbmVyYXRlZCBkdXJpbmdcbiAgICAvLyBsZWZ0LXJlY3Vyc2lvbiBlbGltaW5hdGlvbi4gRm9yIGVmZmljaWVuY3ksIGFsc28gY2hlY2sgaWZcbiAgICAvLyB0aGUgY29udGV4dCBoYXMgYW4gZW1wdHkgc3RhY2sgY2FzZS4gSWYgc28sIGl0IHdvdWxkIG1lYW5cbiAgICAvLyBnbG9iYWwgRk9MTE9XIHNvIHdlIGNhbid0IHBlcmZvcm0gb3B0aW1pemF0aW9uXG4gICAgLy8gQXJlIHdlIHRoZSBzcGVjaWFsIGxvb3AgZW50cnkvZXhpdCBzdGF0ZT8gb3IgU0xMIHdpbGRjYXJkXG4gICAgaWYocC5zdGF0ZVR5cGUgIT0gQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYocC5zdGF0ZVR5cGUgIT0gQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZIHx8ICFwLmlzUHJlY2VkZW5jZURlY2lzaW9uIHx8XG4gICAgICAgICAgIGNvbmZpZy5jb250ZXh0LmlzRW1wdHkoKSB8fCBjb25maWcuY29udGV4dC5oYXNFbXB0eVBhdGgoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gUmVxdWlyZSBhbGwgcmV0dXJuIHN0YXRlcyB0byByZXR1cm4gYmFjayB0byB0aGUgc2FtZSBydWxlIHRoYXQgcCBpcyBpbi5cbiAgICB2YXIgbnVtQ3R4cyA9IGNvbmZpZy5jb250ZXh0Lmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaTxudW1DdHhzOyBpKyspIHsgLy8gZm9yIGVhY2ggc3RhY2sgY29udGV4dFxuICAgICAgICB2YXIgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSldO1xuICAgICAgICBpZiAocmV0dXJuU3RhdGUucnVsZUluZGV4ICE9IHAucnVsZUluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkZWNpc2lvblN0YXJ0U3RhdGUgPSBwLnRyYW5zaXRpb25zWzBdLnRhcmdldDtcbiAgICB2YXIgYmxvY2tFbmRTdGF0ZU51bSA9IGRlY2lzaW9uU3RhcnRTdGF0ZS5lbmRTdGF0ZS5zdGF0ZU51bWJlcjtcbiAgICB2YXIgYmxvY2tFbmRTdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tibG9ja0VuZFN0YXRlTnVtXTtcblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSB0b3Agb2YgZWFjaCBzdGFjayBjb250ZXh0IGxlYWRzIHRvIGxvb3AgZW50cnkvZXhpdFxuICAgIC8vIHN0YXRlIHRocm91Z2ggZXBzaWxvbiBlZGdlcyBhbmQgdy9vIGxlYXZpbmcgcnVsZS5cbiAgICBmb3IodmFyIGk9MDsgaTxudW1DdHhzOyBpKyspIHsgLy8gZm9yIGVhY2ggc3RhY2sgY29udGV4dFxuICAgICAgICB2YXIgcmV0dXJuU3RhdGVOdW1iZXIgPSBjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKTtcbiAgICAgICAgdmFyIHJldHVyblN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW3JldHVyblN0YXRlTnVtYmVyXTtcbiAgICAgICAgLy8gYWxsIHN0YXRlcyBtdXN0IGhhdmUgc2luZ2xlIG91dGdvaW5nIGVwc2lsb24gZWRnZVxuICAgICAgICBpZiAocmV0dXJuU3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoICE9IDEgfHwgIXJldHVyblN0YXRlLnRyYW5zaXRpb25zWzBdLmlzRXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBMb29rIGZvciBwcmVmaXggb3AgY2FzZSBsaWtlICdub3QgZXhwcicsICgnIHR5cGUgJyknIGV4cHJcbiAgICAgICAgdmFyIHJldHVyblN0YXRlVGFyZ2V0ID0gcmV0dXJuU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAoIHJldHVyblN0YXRlLnN0YXRlVHlwZSA9PSBBVE5TdGF0ZS5CTE9DS19FTkQgJiYgcmV0dXJuU3RhdGVUYXJnZXQgPT0gcCApXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBMb29rIGZvciAnZXhwciBvcCBleHByJyBvciBjYXNlIHdoZXJlIGV4cHIncyByZXR1cm4gc3RhdGUgaXMgYmxvY2sgZW5kXG4gICAgICAgIC8vIG9mICguLi4pKiBpbnRlcm5hbCBibG9jazsgdGhlIGJsb2NrIGVuZCBwb2ludHMgdG8gbG9vcCBiYWNrXG4gICAgICAgIC8vIHdoaWNoIHBvaW50cyB0byBwIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoYXRcbiAgICAgICAgaWYgKCByZXR1cm5TdGF0ZSA9PSBibG9ja0VuZFN0YXRlIClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIHRlcm5hcnkgZXhwciA/IGV4cHIgOiBleHByLiBUaGUgcmV0dXJuIHN0YXRlIHBvaW50cyBhdCBibG9jayBlbmQsXG4gICAgICAgIC8vIHdoaWNoIHBvaW50cyBhdCBsb29wIGVudHJ5IHN0YXRlXG4gICAgICAgIGlmICggcmV0dXJuU3RhdGVUYXJnZXQgPT0gYmxvY2tFbmRTdGF0ZSApXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBMb29rIGZvciBjb21wbGV4IHByZWZpeCAnYmV0d2VlbiBleHByIGFuZCBleHByJyBjYXNlIHdoZXJlIDJuZCBleHByJ3NcbiAgICAgICAgLy8gcmV0dXJuIHN0YXRlIHBvaW50cyBhdCBibG9jayBlbmQgc3RhdGUgb2YgKC4uLikqIGludGVybmFsIGJsb2NrXG4gICAgICAgIGlmIChyZXR1cm5TdGF0ZVRhcmdldC5zdGF0ZVR5cGUgPT0gQVROU3RhdGUuQkxPQ0tfRU5EICYmIHJldHVyblN0YXRlVGFyZ2V0LnRyYW5zaXRpb25zLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAgICAgJiYgcmV0dXJuU3RhdGVUYXJnZXQudHJhbnNpdGlvbnNbMF0uaXNFcHNpbG9uICYmIHJldHVyblN0YXRlVGFyZ2V0LnRyYW5zaXRpb25zWzBdLnRhcmdldCA9PSBwKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBhaW4ndCBjb25mb3JtaW5nXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0UnVsZU5hbWUgPSBmdW5jdGlvbiggaW5kZXgpIHtcbiAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsICYmIGluZGV4Pj0wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5ydWxlTmFtZXNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIjxydWxlIFwiICsgaW5kZXggKyBcIj5cIjtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldEVwc2lsb25UYXJnZXQgPSBmdW5jdGlvbihjb25maWcsIHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgc3dpdGNoKHQuc2VyaWFsaXphdGlvblR5cGUpIHtcbiAgICBjYXNlIFRyYW5zaXRpb24uUlVMRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZVRyYW5zaXRpb24oY29uZmlnLCB0KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uUFJFQ0VERU5DRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZVRyYW5zaXRpb24oY29uZmlnLCB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uUFJFRElDQVRFOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVkVHJhbnNpdGlvbihjb25maWcsIHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5BQ1RJT046XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvblRyYW5zaXRpb24oY29uZmlnLCB0KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uRVBTSUxPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBBVE5Db25maWcoe3N0YXRlOnQudGFyZ2V0fSwgY29uZmlnKTtcbiAgICBjYXNlIFRyYW5zaXRpb24uQVRPTTpcbiAgICBjYXNlIFRyYW5zaXRpb24uUkFOR0U6XG4gICAgY2FzZSBUcmFuc2l0aW9uLlNFVDpcbiAgICAgICAgLy8gRU9GIHRyYW5zaXRpb25zIGFjdCBsaWtlIGVwc2lsb24gdHJhbnNpdGlvbnMgYWZ0ZXIgdGhlIGZpcnN0IEVPRlxuICAgICAgICAvLyB0cmFuc2l0aW9uIGlzIHRyYXZlcnNlZFxuICAgICAgICBpZiAodHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgICAgICAgIGlmICh0Lm1hdGNoZXMoVG9rZW4uRU9GLCAwLCAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTogdC50YXJnZXR9LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgXHRyZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFjdGlvblRyYW5zaXRpb24gPSBmdW5jdGlvbihjb25maWcsIHQpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICB2YXIgaW5kZXggPSB0LmFjdGlvbkluZGV4PT0tMSA/IDY1NTM1IDogdC5hY3Rpb25JbmRleDtcbiAgICAgICAgY29uc29sZS5sb2coXCJBQ1RJT04gZWRnZSBcIiArIHQucnVsZUluZGV4ICsgXCI6XCIgKyBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTp0LnRhcmdldH0sIGNvbmZpZyk7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnByZWNlZGVuY2VUcmFuc2l0aW9uID0gZnVuY3Rpb24oY29uZmlnLCBwdCwgIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlBSRUQgKGNvbGxlY3RQcmVkaWNhdGVzPVwiICsgY29sbGVjdFByZWRpY2F0ZXMgKyBcIikgXCIgK1xuICAgICAgICAgICAgICAgIHB0LnByZWNlZGVuY2UgKyBcIj49X3AsIGN0eCBkZXBlbmRlbnQ9dHJ1ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VyIT09bnVsbCkge1xuICAgICAgICBcdGNvbnNvbGUubG9nKFwiY29udGV4dCBzdXJyb3VuZGluZyBwcmVkIGlzIFwiICsgVXRpbHMuYXJyYXlUb1N0cmluZyh0aGlzLnBhcnNlci5nZXRSdWxlSW52b2NhdGlvblN0YWNrKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYyA9IG51bGw7XG4gICAgaWYgKGNvbGxlY3RQcmVkaWNhdGVzICYmIGluQ29udGV4dCkge1xuICAgICAgICBpZiAoZnVsbEN0eCkge1xuICAgICAgICAgICAgLy8gSW4gZnVsbCBjb250ZXh0IG1vZGUsIHdlIGNhbiBldmFsdWF0ZSBwcmVkaWNhdGVzIG9uLXRoZS1mbHlcbiAgICAgICAgICAgIC8vIGR1cmluZyBjbG9zdXJlLCB3aGljaCBkcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgc2l6ZSBvZlxuICAgICAgICAgICAgLy8gdGhlIGNvbmZpZyBzZXRzLiBJdCBhbHNvIG9idmlhdGVzIHRoZSBuZWVkIHRvIHRlc3QgcHJlZGljYXRlc1xuICAgICAgICAgICAgLy8gbGF0ZXIgZHVyaW5nIGNvbmZsaWN0IHJlc29sdXRpb24uXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gdGhpcy5faW5wdXQuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC5zZWVrKHRoaXMuX3N0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIHByZWRTdWNjZWVkcyA9IHB0LmdldFByZWRpY2F0ZSgpLmV2YWx1YXRlKHRoaXMucGFyc2VyLCB0aGlzLl9vdXRlckNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuc2VlayhjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHByZWRTdWNjZWVkcykge1xuICAgICAgICAgICAgICAgIGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTpwdC50YXJnZXR9LCBjb25maWcpOyAvLyBubyBwcmVkIGNvbnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdTZW1DdHggPSBTZW1hbnRpY0NvbnRleHQuYW5kQ29udGV4dChjb25maWcuc2VtYW50aWNDb250ZXh0LCBwdC5nZXRQcmVkaWNhdGUoKSk7XG4gICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0LCBzZW1hbnRpY0NvbnRleHQ6bmV3U2VtQ3R4fSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTpwdC50YXJnZXR9LCBjb25maWcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpZyBmcm9tIHByZWQgdHJhbnNpdGlvbj1cIiArIGMpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucHJlZFRyYW5zaXRpb24gPSBmdW5jdGlvbihjb25maWcsIHB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJQUkVEIChjb2xsZWN0UHJlZGljYXRlcz1cIiArIGNvbGxlY3RQcmVkaWNhdGVzICsgXCIpIFwiICsgcHQucnVsZUluZGV4ICtcbiAgICAgICAgICAgICAgICBcIjpcIiArIHB0LnByZWRJbmRleCArIFwiLCBjdHggZGVwZW5kZW50PVwiICsgcHQuaXNDdHhEZXBlbmRlbnQpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQgc3Vycm91bmRpbmcgcHJlZCBpcyBcIiArIFV0aWxzLmFycmF5VG9TdHJpbmcodGhpcy5wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIGlmIChjb2xsZWN0UHJlZGljYXRlcyAmJiAoKHB0LmlzQ3R4RGVwZW5kZW50ICYmIGluQ29udGV4dCkgfHwgISBwdC5pc0N0eERlcGVuZGVudCkpIHtcbiAgICAgICAgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICAgIC8vIEluIGZ1bGwgY29udGV4dCBtb2RlLCB3ZSBjYW4gZXZhbHVhdGUgcHJlZGljYXRlcyBvbi10aGUtZmx5XG4gICAgICAgICAgICAvLyBkdXJpbmcgY2xvc3VyZSwgd2hpY2ggZHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIHNpemUgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBjb25maWcgc2V0cy4gSXQgYWxzbyBvYnZpYXRlcyB0aGUgbmVlZCB0byB0ZXN0IHByZWRpY2F0ZXNcbiAgICAgICAgICAgIC8vIGxhdGVyIGR1cmluZyBjb25mbGljdCByZXNvbHV0aW9uLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuc2Vlayh0aGlzLl9zdGFydEluZGV4KTtcbiAgICAgICAgICAgIHZhciBwcmVkU3VjY2VlZHMgPSBwdC5nZXRQcmVkaWNhdGUoKS5ldmFsdWF0ZSh0aGlzLnBhcnNlciwgdGhpcy5fb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnNlZWsoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcmVkU3VjY2VlZHMpIHtcbiAgICAgICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0fSwgY29uZmlnKTsgLy8gbm8gcHJlZCBjb250ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3U2VtQ3R4ID0gU2VtYW50aWNDb250ZXh0LmFuZENvbnRleHQoY29uZmlnLnNlbWFudGljQ29udGV4dCwgcHQuZ2V0UHJlZGljYXRlKCkpO1xuICAgICAgICAgICAgYyA9IG5ldyBBVE5Db25maWcoe3N0YXRlOnB0LnRhcmdldCwgc2VtYW50aWNDb250ZXh0Om5ld1NlbUN0eH0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0fSwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25maWcgZnJvbSBwcmVkIHRyYW5zaXRpb249XCIgKyBjKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJ1bGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oY29uZmlnLCB0KSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDQUxMIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKHQudGFyZ2V0LnJ1bGVJbmRleCkgKyBcIiwgY3R4PVwiICsgY29uZmlnLmNvbnRleHQpO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuU3RhdGUgPSB0LmZvbGxvd1N0YXRlO1xuICAgIHZhciBuZXdDb250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKGNvbmZpZy5jb250ZXh0LCByZXR1cm5TdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgcmV0dXJuIG5ldyBBVE5Db25maWcoe3N0YXRlOnQudGFyZ2V0LCBjb250ZXh0Om5ld0NvbnRleHR9LCBjb25maWcgKTtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0Q29uZmxpY3RpbmdBbHRzID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciBhbHRzZXRzID0gUHJlZGljdGlvbk1vZGUuZ2V0Q29uZmxpY3RpbmdBbHRTdWJzZXRzKGNvbmZpZ3MpO1xuICAgIHJldHVybiBQcmVkaWN0aW9uTW9kZS5nZXRBbHRzKGFsdHNldHMpO1xufTtcblxuIC8vIFNhbSBwb2ludGVkIG91dCBhIHByb2JsZW0gd2l0aCB0aGUgcHJldmlvdXMgZGVmaW5pdGlvbiwgdjMsIG9mXG4gLy8gYW1iaWd1b3VzIHN0YXRlcy4gSWYgd2UgaGF2ZSBhbm90aGVyIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCBjb25mbGljdGluZ1xuIC8vIGFsdGVybmF0aXZlcywgd2Ugc2hvdWxkIGtlZXAgZ29pbmcuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGdyYW1tYXJcbiAvL1xuIC8vIHMgOiAoSUQgfCBJRCBJRD8pICc7JyA7XG4gLy9cbiAvLyBXaGVuIHRoZSBBVE4gc2ltdWxhdGlvbiByZWFjaGVzIHRoZSBzdGF0ZSBiZWZvcmUgJzsnLCBpdCBoYXMgYSBERkFcbiAvLyBzdGF0ZSB0aGF0IGxvb2tzIGxpa2U6IFsxMnwxfFtdLCA2fDJ8W10sIDEyfDJ8W11dLiBOYXR1cmFsbHlcbiAvLyAxMnwxfFtdIGFuZCAxMnwyfFtdIGNvbmZsaWN0LCBidXQgd2UgY2Fubm90IHN0b3AgcHJvY2Vzc2luZyB0aGlzIG5vZGVcbiAvLyBiZWNhdXNlIGFsdGVybmF0aXZlIHRvIGhhcyBhbm90aGVyIHdheSB0byBjb250aW51ZSwgdmlhIFs2fDJ8W11dLlxuIC8vIFRoZSBrZXkgaXMgdGhhdCB3ZSBoYXZlIGEgc2luZ2xlIHN0YXRlIHRoYXQgaGFzIGNvbmZpZydzIG9ubHkgYXNzb2NpYXRlZFxuIC8vIHdpdGggYSBzaW5nbGUgYWx0ZXJuYXRpdmUsIDIsIGFuZCBjcnVjaWFsbHkgdGhlIHN0YXRlIHRyYW5zaXRpb25zXG4gLy8gYW1vbmcgdGhlIGNvbmZpZ3VyYXRpb25zIGFyZSBhbGwgbm9uLWVwc2lsb24gdHJhbnNpdGlvbnMuIFRoYXQgbWVhbnNcbiAvLyB3ZSBkb24ndCBjb25zaWRlciBhbnkgY29uZmxpY3RzIHRoYXQgaW5jbHVkZSBhbHRlcm5hdGl2ZSAyLiBTbywgd2VcbiAvLyBpZ25vcmUgdGhlIGNvbmZsaWN0IGJldHdlZW4gYWx0cyAxIGFuZCAyLiBXZSBpZ25vcmUgYSBzZXQgb2ZcbiAvLyBjb25mbGljdGluZyBhbHRzIHdoZW4gdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uIHdpdGggYW4gYWx0ZXJuYXRpdmVcbiAvLyBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgYWx0IHN0YXRlIGluIHRoZSBzdGF0ZSZyYXJyO2NvbmZpZy1saXN0IG1hcC5cbiAvL1xuIC8vIEl0J3MgYWxzbyB0aGUgY2FzZSB0aGF0IHdlIG1pZ2h0IGhhdmUgdHdvIGNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb25zIGJ1dFxuIC8vIGFsc28gYSAzcmQgbm9uY29uZmxpY3RpbmcgY29uZmlndXJhdGlvbiBmb3IgYSBkaWZmZXJlbnQgYWx0ZXJuYXRpdmU6XG4gLy8gWzF8MXxbXSwgMXwyfFtdLCA4fDN8W11dLiBUaGlzIGNhbiBjb21lIGFib3V0IGZyb20gZ3JhbW1hcjpcbiAvL1xuIC8vIGEgOiBBIHwgQSB8IEEgQiA7XG4gLy9cbiAvLyBBZnRlciBtYXRjaGluZyBpbnB1dCBBLCB3ZSByZWFjaCB0aGUgc3RvcCBzdGF0ZSBmb3IgcnVsZSBBLCBzdGF0ZSAxLlxuIC8vIFN0YXRlIDggaXMgdGhlIHN0YXRlIHJpZ2h0IGJlZm9yZSBCLiBDbGVhcmx5IGFsdGVybmF0aXZlcyAxIGFuZCAyXG4gLy8gY29uZmxpY3QgYW5kIG5vIGFtb3VudCBvZiBmdXJ0aGVyIGxvb2thaGVhZCB3aWxsIHNlcGFyYXRlIHRoZSB0d28uXG4gLy8gSG93ZXZlciwgYWx0ZXJuYXRpdmUgMyB3aWxsIGJlIGFibGUgdG8gY29udGludWUgYW5kIHNvIHdlIGRvIG5vdFxuIC8vIHN0b3Agd29ya2luZyBvbiB0aGlzIHN0YXRlLiBJbiB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UncmUgY29uY2VybmVkXG4gLy8gd2l0aCBzdGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBhbHRlcm5hdGl2ZXMuIEhlcmUgYWx0XG4gLy8gMyBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBjb25maWdzLCBidXQgc2luY2Ugd2UgY2FuIGNvbnRpbnVlXG4gLy8gbG9va2luZyBmb3IgaW5wdXQgcmVhc29uYWJseSwgSSBkb24ndCBkZWNsYXJlIHRoZSBzdGF0ZSBkb25lLiBXZVxuIC8vIGlnbm9yZSBhIHNldCBvZiBjb25mbGljdGluZyBhbHRzIHdoZW4gd2UgaGF2ZSBhbiBhbHRlcm5hdGl2ZVxuIC8vIHRoYXQgd2Ugc3RpbGwgbmVlZCB0byBwdXJzdWUuXG4vL1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldENvbmZsaWN0aW5nQWx0c09yVW5pcXVlQWx0ID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciBjb25mbGljdGluZ0FsdHMgPSBudWxsO1xuICAgIGlmIChjb25maWdzLnVuaXF1ZUFsdCE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIGNvbmZsaWN0aW5nQWx0cyA9IG5ldyBCaXRTZXQoKTtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzLmFkZChjb25maWdzLnVuaXF1ZUFsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgfVxuICAgIHJldHVybiBjb25mbGljdGluZ0FsdHM7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFRva2VuTmFtZSA9IGZ1bmN0aW9uKCB0KSB7XG4gICAgaWYgKHQ9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgfVxuICAgIGlmKCB0aGlzLnBhcnNlciE9PW51bGwgJiYgdGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzIT09bnVsbCkge1xuICAgICAgICBpZiAodCA+PSB0aGlzLnBhcnNlci5saXRlcmFsTmFtZXMubGVuZ3RoICYmIHQgPj0gdGhpcy5wYXJzZXIuc3ltYm9saWNOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXCIgKyB0ICsgXCIgdHR5cGUgb3V0IG9mIHJhbmdlOiBcIiArIHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlwiICsgdGhpcy5wYXJzZXIuZ2V0SW5wdXRTdHJlYW0oKS5nZXRUb2tlbnMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lc1t0XSB8fCB0aGlzLnBhcnNlci5zeW1ib2xpY05hbWVzW3RdO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIjxcIiArIHQgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIHQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldExvb2thaGVhZE5hbWUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmdldFRva2VuTmFtZShpbnB1dC5MQSgxKSk7XG59O1xuXG4vLyBVc2VkIGZvciBkZWJ1Z2dpbmcgaW4gYWRhcHRpdmVQcmVkaWN0IGFyb3VuZCBleGVjQVROIGJ1dCBJIGN1dFxuLy8gIGl0IG91dCBmb3IgY2xhcml0eSBub3cgdGhhdCBhbGcuIHdvcmtzIHdlbGwuIFdlIGNhbiBsZWF2ZSB0aGlzXG4vLyAgXCJkZWFkXCIgY29kZSBmb3IgYSBiaXQuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kdW1wRGVhZEVuZENvbmZpZ3MgPSBmdW5jdGlvbihudmFlKSB7XG4gICAgY29uc29sZS5sb2coXCJkZWFkIGVuZCBjb25maWdzOiBcIik7XG4gICAgdmFyIGRlY3MgPSBudmFlLmdldERlYWRFbmRDb25maWdzKCk7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGVjcy5sZW5ndGg7IGkrKykge1xuICAgIFx0dmFyIGMgPSBkZWNzW2ldO1xuICAgICAgICB2YXIgdHJhbnMgPSBcIm5vIGVkZ2VzXCI7XG4gICAgICAgIGlmIChjLnN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGMuc3RhdGUudHJhbnNpdGlvbnNbMF07XG4gICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnMgPSBcIkF0b20gXCIrIHRoaXMuZ2V0VG9rZW5OYW1lKHQubGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgU2V0VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBuZWcgPSAodCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zID0gKG5lZyA/IFwiflwiIDogXCJcIikgKyBcIlNldCBcIiArIHQuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYy50b1N0cmluZyh0aGlzLnBhcnNlciwgdHJ1ZSkgKyBcIjpcIiArIHRyYW5zKTtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLm5vVmlhYmxlQWx0ID0gZnVuY3Rpb24oaW5wdXQsIG91dGVyQ29udGV4dCwgY29uZmlncywgc3RhcnRJbmRleCkge1xuICAgIHJldHVybiBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5wYXJzZXIsIGlucHV0LCBpbnB1dC5nZXQoc3RhcnRJbmRleCksIGlucHV0LkxUKDEpLCBjb25maWdzLCBvdXRlckNvbnRleHQpO1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRVbmlxdWVBbHQgPSBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIGFsdCA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgZm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDtpKyspIHtcbiAgICBcdHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGFsdCA9PT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgYWx0ID0gYy5hbHQgLy8gZm91bmQgZmlyc3QgYWx0XG4gICAgICAgIH0gZWxzZSBpZiggYy5hbHQhPT1hbHQpIHtcbiAgICAgICAgICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbHQ7XG59O1xuXG4vL1xuLy8gQWRkIGFuIGVkZ2UgdG8gdGhlIERGQSwgaWYgcG9zc2libGUuIFRoaXMgbWV0aG9kIGNhbGxzXG4vLyB7QGxpbmsgLy9hZGRERkFTdGF0ZX0gdG8gZW5zdXJlIHRoZSB7QGNvZGUgdG99IHN0YXRlIGlzIHByZXNlbnQgaW4gdGhlXG4vLyBERkEuIElmIHtAY29kZSBmcm9tfSBpcyB7QGNvZGUgbnVsbH0sIG9yIGlmIHtAY29kZSB0fSBpcyBvdXRzaWRlIHRoZVxuLy8gcmFuZ2Ugb2YgZWRnZXMgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gdGhlIERGQSB0YWJsZXMsIHRoaXMgbWV0aG9kXG4vLyByZXR1cm5zIHdpdGhvdXQgYWRkaW5nIHRoZSBlZGdlIHRvIHRoZSBERkEuXG4vL1xuLy8gPHA+SWYge0Bjb2RlIHRvfSBpcyB7QGNvZGUgbnVsbH0sIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9LlxuLy8gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB7QGxpbmsgREZBU3RhdGV9IHJldHVybmVkIGJ5IGNhbGxpbmdcbi8vIHtAbGluayAvL2FkZERGQVN0YXRlfSBmb3IgdGhlIHtAY29kZSB0b30gc3RhdGUuPC9wPlxuLy9cbi8vIEBwYXJhbSBkZmEgVGhlIERGQVxuLy8gQHBhcmFtIGZyb20gVGhlIHNvdXJjZSBzdGF0ZSBmb3IgdGhlIGVkZ2Vcbi8vIEBwYXJhbSB0IFRoZSBpbnB1dCBzeW1ib2xcbi8vIEBwYXJhbSB0byBUaGUgdGFyZ2V0IHN0YXRlIGZvciB0aGUgZWRnZVxuLy9cbi8vIEByZXR1cm4gSWYge0Bjb2RlIHRvfSBpcyB7QGNvZGUgbnVsbH0sIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9O1xuLy8gb3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHtAbGluayAvL2FkZERGQVN0YXRlfVxuLy8gb24ge0Bjb2RlIHRvfVxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuYWRkREZBRWRnZSA9IGZ1bmN0aW9uKGRmYSwgZnJvbV8sIHQsIHRvKSB7XG4gICAgaWYoIHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFREdFIFwiICsgZnJvbV8gKyBcIiAtPiBcIiArIHRvICsgXCIgdXBvbiBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQpKTtcbiAgICB9XG4gICAgaWYgKHRvPT09bnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG8gPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgdG8pOyAvLyB1c2VkIGV4aXN0aW5nIGlmIHBvc3NpYmxlIG5vdCBpbmNvbWluZ1xuICAgIGlmIChmcm9tXz09PW51bGwgfHwgdCA8IC0xIHx8IHQgPiB0aGlzLmF0bi5tYXhUb2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBpZiAoZnJvbV8uZWRnZXM9PT1udWxsKSB7XG4gICAgICAgIGZyb21fLmVkZ2VzID0gW107XG4gICAgfVxuICAgIGZyb21fLmVkZ2VzW3QrMV0gPSB0bzsgLy8gY29ubmVjdFxuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgdmFyIGxpdGVyYWxOYW1lcyA9IHRoaXMucGFyc2VyPT09bnVsbCA/IG51bGwgOiB0aGlzLnBhcnNlci5saXRlcmFsTmFtZXM7XG4gICAgICAgIHZhciBzeW1ib2xpY05hbWVzID0gdGhpcy5wYXJzZXI9PT1udWxsID8gbnVsbCA6IHRoaXMucGFyc2VyLnN5bWJvbGljTmFtZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREZBPVxcblwiICsgZGZhLnRvU3RyaW5nKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG87XG59O1xuLy9cbi8vIEFkZCBzdGF0ZSB7QGNvZGUgRH0gdG8gdGhlIERGQSBpZiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50LCBhbmQgcmV0dXJuXG4vLyB0aGUgYWN0dWFsIGluc3RhbmNlIHN0b3JlZCBpbiB0aGUgREZBLiBJZiBhIHN0YXRlIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIER9XG4vLyBpcyBhbHJlYWR5IGluIHRoZSBERkEsIHRoZSBleGlzdGluZyBzdGF0ZSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoaXNcbi8vIG1ldGhvZCByZXR1cm5zIHtAY29kZSBEfSBhZnRlciBhZGRpbmcgaXQgdG8gdGhlIERGQS5cbi8vXG4vLyA8cD5JZiB7QGNvZGUgRH0gaXMge0BsaW5rIC8vRVJST1J9LCB0aGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayAvL0VSUk9SfSBhbmRcbi8vIGRvZXMgbm90IGNoYW5nZSB0aGUgREZBLjwvcD5cbi8vXG4vLyBAcGFyYW0gZGZhIFRoZSBkZmFcbi8vIEBwYXJhbSBEIFRoZSBERkEgc3RhdGUgdG8gYWRkXG4vLyBAcmV0dXJuIFRoZSBzdGF0ZSBzdG9yZWQgaW4gdGhlIERGQS4gVGhpcyB3aWxsIGJlIGVpdGhlciB0aGUgZXhpc3Rpbmdcbi8vIHN0YXRlIGlmIHtAY29kZSBEfSBpcyBhbHJlYWR5IGluIHRoZSBERkEsIG9yIHtAY29kZSBEfSBpdHNlbGYgaWYgdGhlXG4vLyBzdGF0ZSB3YXMgbm90IGFscmVhZHkgcHJlc2VudC5cbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFkZERGQVN0YXRlID0gZnVuY3Rpb24oZGZhLCBEKSB7XG4gICAgaWYgKEQgPT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XG4gICAgICAgIHJldHVybiBEO1xuICAgIH1cbiAgICB2YXIgZXhpc3RpbmcgPSBkZmEuc3RhdGVzLmdldChEKTtcbiAgICBpZihleGlzdGluZyE9PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICBELnN0YXRlTnVtYmVyID0gZGZhLnN0YXRlcy5sZW5ndGg7XG4gICAgaWYgKCEgRC5jb25maWdzLnJlYWRPbmx5KSB7XG4gICAgICAgIEQuY29uZmlncy5vcHRpbWl6ZUNvbmZpZ3ModGhpcyk7XG4gICAgICAgIEQuY29uZmlncy5zZXRSZWFkb25seSh0cnVlKTtcbiAgICB9XG4gICAgZGZhLnN0YXRlcy5hZGQoRCk7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGRpbmcgbmV3IERGQSBzdGF0ZTogXCIgKyBEKTtcbiAgICB9XG4gICAgcmV0dXJuIEQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCA9IGZ1bmN0aW9uKGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpIHtcbiAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXggKyAxKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZGVjaXNpb249XCIgKyBkZmEuZGVjaXNpb24gKyBcIjpcIiArIGNvbmZpZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGlucHV0PVwiICsgdGhpcy5wYXJzZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlciE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCkucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KHRoaXMucGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKTtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSA9IGZ1bmN0aW9uKGRmYSwgcHJlZGljdGlvbiwgY29uZmlncywgc3RhcnRJbmRleCwgc3RvcEluZGV4KSB7XG4gICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5yZXRyeV9kZWJ1Zykge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnRJbmRleCwgc3RvcEluZGV4ICsgMSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGRlY2lzaW9uPVwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIgKyBjb25maWdzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBpbnB1dD1cIiArIHRoaXMucGFyc2VyLmdldFRva2VuU3RyZWFtKCkuZ2V0VGV4dChpbnRlcnZhbCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSh0aGlzLnBhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpO1xuICAgIH1cbn07XG5cbi8vIElmIGNvbnRleHQgc2Vuc2l0aXZlIHBhcnNpbmcsIHdlIGtub3cgaXQncyBhbWJpZ3VpdHkgbm90IGNvbmZsaWN0Ly9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucmVwb3J0QW1iaWd1aXR5ID0gZnVuY3Rpb24oZGZhLCBELCBzdGFydEluZGV4LCBzdG9wSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyApIHtcbiAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXggKyAxKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXBvcnRBbWJpZ3VpdHkgXCIgKyBhbWJpZ0FsdHMgKyBcIjpcIiArIGNvbmZpZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGlucHV0PVwiICsgdGhpcy5wYXJzZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlciE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCkucmVwb3J0QW1iaWd1aXR5KHRoaXMucGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5QYXJzZXJBVE5TaW11bGF0b3IgPSBQYXJzZXJBVE5TaW11bGF0b3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9QYXJzZXJBVE5TaW11bGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuZXhwb3J0cy5ERkEgPSByZXF1aXJlKCcuL0RGQScpLkRGQTtcbmV4cG9ydHMuREZBU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vREZBU2VyaWFsaXplcicpLkRGQVNlcmlhbGl6ZXI7XG5leHBvcnRzLkxleGVyREZBU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vREZBU2VyaWFsaXplcicpLkxleGVyREZBU2VyaWFsaXplcjtcbmV4cG9ydHMuUHJlZFByZWRpY3Rpb24gPSByZXF1aXJlKCcuL0RGQVN0YXRlJykuUHJlZFByZWRpY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvZGZhL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG52YXIgU2V0ID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpLlNldDtcbnZhciBERkFTdGF0ZSA9IHJlcXVpcmUoJy4vREZBU3RhdGUnKS5ERkFTdGF0ZTtcbnZhciBTdGFyTG9vcEVudHJ5U3RhdGUgPSByZXF1aXJlKCcuLi9hdG4vQVROU3RhdGUnKS5TdGFyTG9vcEVudHJ5U3RhdGU7XG52YXIgQVROQ29uZmlnU2V0ID0gcmVxdWlyZSgnLi8uLi9hdG4vQVROQ29uZmlnU2V0JykuQVROQ29uZmlnU2V0O1xudmFyIERGQVNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL0RGQVNlcmlhbGl6ZXInKS5ERkFTZXJpYWxpemVyO1xudmFyIExleGVyREZBU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vREZBU2VyaWFsaXplcicpLkxleGVyREZBU2VyaWFsaXplcjtcblxuXG5cbmZ1bmN0aW9uIERGQShhdG5TdGFydFN0YXRlLCBkZWNpc2lvbikge1xuXHRpZiAoZGVjaXNpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdGRlY2lzaW9uID0gMDtcblx0fVxuXHQvLyBGcm9tIHdoaWNoIEFUTiBzdGF0ZSBkaWQgd2UgY3JlYXRlIHRoaXMgREZBP1xuXHR0aGlzLmF0blN0YXJ0U3RhdGUgPSBhdG5TdGFydFN0YXRlO1xuXHR0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XG5cdC8vIEEgc2V0IG9mIGFsbCBERkEgc3RhdGVzLiBVc2Uge0BsaW5rIE1hcH0gc28gd2UgY2FuIGdldCBvbGQgc3RhdGUgYmFja1xuXHQvLyAoe0BsaW5rIFNldH0gb25seSBhbGxvd3MgeW91IHRvIHNlZSBpZiBpdCdzIHRoZXJlKS5cblx0dGhpcy5fc3RhdGVzID0gbmV3IFNldCgpO1xuXHR0aGlzLnMwID0gbnVsbDtcblx0Ly8ge0Bjb2RlIHRydWV9IGlmIHRoaXMgREZBIGlzIGZvciBhIHByZWNlZGVuY2UgZGVjaXNpb247IG90aGVyd2lzZSxcblx0Ly8ge0Bjb2RlIGZhbHNlfS4gVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rIC8vaXNQcmVjZWRlbmNlRGZhfSxcblx0Ly8ge0BsaW5rIC8vc2V0UHJlY2VkZW5jZURmYX0uXG5cdHRoaXMucHJlY2VkZW5jZURmYSA9IGZhbHNlO1xuICAgIGlmIChhdG5TdGFydFN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKVxuICAgIHtcbiAgICAgICAgaWYgKGF0blN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlRGVjaXNpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZURmYSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJlY2VkZW5jZVN0YXRlID0gbmV3IERGQVN0YXRlKG51bGwsIG5ldyBBVE5Db25maWdTZXQoKSk7XG4gICAgICAgICAgICBwcmVjZWRlbmNlU3RhdGUuZWRnZXMgPSBbXTtcbiAgICAgICAgICAgIHByZWNlZGVuY2VTdGF0ZS5pc0FjY2VwdFN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBwcmVjZWRlbmNlU3RhdGUucmVxdWlyZXNGdWxsQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zMCA9IHByZWNlZGVuY2VTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEdldCB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJlY2VkZW5jZSB2YWx1ZS5cbi8vXG4vLyBAcGFyYW0gcHJlY2VkZW5jZSBUaGUgY3VycmVudCBwcmVjZWRlbmNlLlxuLy8gQHJldHVybiBUaGUgc3RhcnQgc3RhdGUgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIHByZWNlZGVuY2UsIG9yXG4vLyB7QGNvZGUgbnVsbH0gaWYgbm8gc3RhcnQgc3RhdGUgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByZWNlZGVuY2UuXG4vL1xuLy8gQHRocm93cyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24gaWYgdGhpcyBpcyBub3QgYSBwcmVjZWRlbmNlIERGQS5cbi8vIEBzZWUgLy9pc1ByZWNlZGVuY2VEZmEoKVxuXG5ERkEucHJvdG90eXBlLmdldFByZWNlZGVuY2VTdGFydFN0YXRlID0gZnVuY3Rpb24ocHJlY2VkZW5jZSkge1xuXHRpZiAoISh0aGlzLnByZWNlZGVuY2VEZmEpKSB7XG5cdFx0dGhyb3cgKFwiT25seSBwcmVjZWRlbmNlIERGQXMgbWF5IGNvbnRhaW4gYSBwcmVjZWRlbmNlIHN0YXJ0IHN0YXRlLlwiKTtcblx0fVxuXHQvLyBzMC5lZGdlcyBpcyBuZXZlciBudWxsIGZvciBhIHByZWNlZGVuY2UgREZBXG5cdGlmIChwcmVjZWRlbmNlIDwgMCB8fCBwcmVjZWRlbmNlID49IHRoaXMuczAuZWRnZXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMuczAuZWRnZXNbcHJlY2VkZW5jZV0gfHwgbnVsbDtcbn07XG5cbi8vIFNldCB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJlY2VkZW5jZSB2YWx1ZS5cbi8vXG4vLyBAcGFyYW0gcHJlY2VkZW5jZSBUaGUgY3VycmVudCBwcmVjZWRlbmNlLlxuLy8gQHBhcmFtIHN0YXJ0U3RhdGUgVGhlIHN0YXJ0IHN0YXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZFxuLy8gcHJlY2VkZW5jZS5cbi8vXG4vLyBAdGhyb3dzIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiBpZiB0aGlzIGlzIG5vdCBhIHByZWNlZGVuY2UgREZBLlxuLy8gQHNlZSAvL2lzUHJlY2VkZW5jZURmYSgpXG4vL1xuREZBLnByb3RvdHlwZS5zZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSA9IGZ1bmN0aW9uKHByZWNlZGVuY2UsIHN0YXJ0U3RhdGUpIHtcblx0aWYgKCEodGhpcy5wcmVjZWRlbmNlRGZhKSkge1xuXHRcdHRocm93IChcIk9ubHkgcHJlY2VkZW5jZSBERkFzIG1heSBjb250YWluIGEgcHJlY2VkZW5jZSBzdGFydCBzdGF0ZS5cIik7XG5cdH1cblx0aWYgKHByZWNlZGVuY2UgPCAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gc3luY2hyb25pemF0aW9uIG9uIHMwIGhlcmUgaXMgb2suIHdoZW4gdGhlIERGQSBpcyB0dXJuZWQgaW50byBhXG5cdC8vIHByZWNlZGVuY2UgREZBLCBzMCB3aWxsIGJlIGluaXRpYWxpemVkIG9uY2UgYW5kIG5vdCB1cGRhdGVkIGFnYWluXG5cdC8vIHMwLmVkZ2VzIGlzIG5ldmVyIG51bGwgZm9yIGEgcHJlY2VkZW5jZSBERkFcblx0dGhpcy5zMC5lZGdlc1twcmVjZWRlbmNlXSA9IHN0YXJ0U3RhdGU7XG59O1xuXG4vL1xuLy8gU2V0cyB3aGV0aGVyIHRoaXMgaXMgYSBwcmVjZWRlbmNlIERGQS4gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkaWZmZXJzXG4vLyBmcm9tIHRoZSBjdXJyZW50IERGQSBjb25maWd1cmF0aW9uLCB0aGUgZm9sbG93aW5nIGFjdGlvbnMgYXJlIHRha2VuO1xuLy8gb3RoZXJ3aXNlIG5vIGNoYW5nZXMgYXJlIG1hZGUgdG8gdGhlIGN1cnJlbnQgREZBLlxuLy9cbi8vIDx1bD5cbi8vIDxsaT5UaGUge0BsaW5rIC8vc3RhdGVzfSBtYXAgaXMgY2xlYXJlZDwvbGk+XG4vLyA8bGk+SWYge0Bjb2RlIHByZWNlZGVuY2VEZmF9IGlzIHtAY29kZSBmYWxzZX0sIHRoZSBpbml0aWFsIHN0YXRlXG4vLyB7QGxpbmsgLy9zMH0gaXMgc2V0IHRvIHtAY29kZSBudWxsfTsgb3RoZXJ3aXNlLCBpdCBpcyBpbml0aWFsaXplZCB0byBhIG5ld1xuLy8ge0BsaW5rIERGQVN0YXRlfSB3aXRoIGFuIGVtcHR5IG91dGdvaW5nIHtAbGluayBERkFTdGF0ZS8vZWRnZXN9IGFycmF5IHRvXG4vLyBzdG9yZSB0aGUgc3RhcnQgc3RhdGVzIGZvciBpbmRpdmlkdWFsIHByZWNlZGVuY2UgdmFsdWVzLjwvbGk+XG4vLyA8bGk+VGhlIHtAbGluayAvL3ByZWNlZGVuY2VEZmF9IGZpZWxkIGlzIHVwZGF0ZWQ8L2xpPlxuLy8gPC91bD5cbi8vXG4vLyBAcGFyYW0gcHJlY2VkZW5jZURmYSB7QGNvZGUgdHJ1ZX0gaWYgdGhpcyBpcyBhIHByZWNlZGVuY2UgREZBOyBvdGhlcndpc2UsXG4vLyB7QGNvZGUgZmFsc2V9XG5cbkRGQS5wcm90b3R5cGUuc2V0UHJlY2VkZW5jZURmYSA9IGZ1bmN0aW9uKHByZWNlZGVuY2VEZmEpIHtcblx0aWYgKHRoaXMucHJlY2VkZW5jZURmYSE9PXByZWNlZGVuY2VEZmEpIHtcblx0XHR0aGlzLl9zdGF0ZXMgPSBuZXcgREZBU3RhdGVzU2V0KCk7XG5cdFx0aWYgKHByZWNlZGVuY2VEZmEpIHtcblx0XHRcdHZhciBwcmVjZWRlbmNlU3RhdGUgPSBuZXcgREZBU3RhdGUobnVsbCwgbmV3IEFUTkNvbmZpZ1NldCgpKTtcblx0XHRcdHByZWNlZGVuY2VTdGF0ZS5lZGdlcyA9IFtdO1xuXHRcdFx0cHJlY2VkZW5jZVN0YXRlLmlzQWNjZXB0U3RhdGUgPSBmYWxzZTtcblx0XHRcdHByZWNlZGVuY2VTdGF0ZS5yZXF1aXJlc0Z1bGxDb250ZXh0ID0gZmFsc2U7XG5cdFx0XHR0aGlzLnMwID0gcHJlY2VkZW5jZVN0YXRlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnMwID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5wcmVjZWRlbmNlRGZhID0gcHJlY2VkZW5jZURmYTtcblx0fVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERGQS5wcm90b3R5cGUsIFwic3RhdGVzXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlcztcblx0fVxufSk7XG5cbi8vIFJldHVybiBhIGxpc3Qgb2YgYWxsIHN0YXRlcyBpbiB0aGlzIERGQSwgb3JkZXJlZCBieSBzdGF0ZSBudW1iZXIuXG5ERkEucHJvdG90eXBlLnNvcnRlZFN0YXRlcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbGlzdCA9IHRoaXMuX3N0YXRlcy52YWx1ZXMoKTtcblx0cmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0cmV0dXJuIGEuc3RhdGVOdW1iZXIgLSBiLnN0YXRlTnVtYmVyO1xuXHR9KTtcbn07XG5cbkRGQS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpIHtcblx0bGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzIHx8IG51bGw7XG5cdHN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzIHx8IG51bGw7XG5cdGlmICh0aGlzLnMwID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblx0dmFyIHNlcmlhbGl6ZXIgPSBuZXcgREZBU2VyaWFsaXplcih0aGlzLCBsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpO1xuXHRyZXR1cm4gc2VyaWFsaXplci50b1N0cmluZygpO1xufTtcblxuREZBLnByb3RvdHlwZS50b0xleGVyU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnMwID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblx0dmFyIHNlcmlhbGl6ZXIgPSBuZXcgTGV4ZXJERkFTZXJpYWxpemVyKHRoaXMpO1xuXHRyZXR1cm4gc2VyaWFsaXplci50b1N0cmluZygpO1xufTtcblxuZXhwb3J0cy5ERkEgPSBERkE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvZGZhL0RGQS5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG52YXIgVHJlZSA9IHJlcXVpcmUoJy4vVHJlZScpO1xuZXhwb3J0cy5UcmVlcyA9IHJlcXVpcmUoJy4vVHJlZXMnKS5UcmVlcztcbmV4cG9ydHMuUnVsZU5vZGUgPSBUcmVlLlJ1bGVOb2RlO1xuZXhwb3J0cy5QYXJzZVRyZWVMaXN0ZW5lciA9IFRyZWUuUGFyc2VUcmVlTGlzdGVuZXI7XG5leHBvcnRzLlBhcnNlVHJlZVZpc2l0b3IgPSBUcmVlLlBhcnNlVHJlZVZpc2l0b3I7XG5leHBvcnRzLlBhcnNlVHJlZVdhbGtlciA9IFRyZWUuUGFyc2VUcmVlV2Fsa2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L3RyZWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuZXhwb3J0cy5SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuUmVjb2duaXRpb25FeGNlcHRpb247XG5leHBvcnRzLk5vVmlhYmxlQWx0RXhjZXB0aW9uID0gcmVxdWlyZSgnLi9FcnJvcnMnKS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbjtcbmV4cG9ydHMuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9FcnJvcnMnKS5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb247XG5leHBvcnRzLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyID0gcmVxdWlyZSgnLi9EaWFnbm9zdGljRXJyb3JMaXN0ZW5lcicpLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyO1xuZXhwb3J0cy5CYWlsRXJyb3JTdHJhdGVneSA9IHJlcXVpcmUoJy4vRXJyb3JTdHJhdGVneScpLkJhaWxFcnJvclN0cmF0ZWd5O1xuZXhwb3J0cy5FcnJvckxpc3RlbmVyID0gcmVxdWlyZSgnLi9FcnJvckxpc3RlbmVyJykuRXJyb3JMaXN0ZW5lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FudGxyNC9lcnJvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbi8vXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBBTlRMUkVycm9yTGlzdGVuZXJ9IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5XG4vLyBjZXJ0YWluIHBvdGVudGlhbCBjb3JyZWN0bmVzcyBhbmQgcGVyZm9ybWFuY2UgcHJvYmxlbXMgaW4gZ3JhbW1hcnMuIFwiUmVwb3J0c1wiXG4vLyBhcmUgbWFkZSBieSBjYWxsaW5nIHtAbGluayBQYXJzZXIvL25vdGlmeUVycm9yTGlzdGVuZXJzfSB3aXRoIHRoZSBhcHByb3ByaWF0ZVxuLy8gbWVzc2FnZS5cbi8vXG4vLyA8dWw+XG4vLyA8bGk+PGI+QW1iaWd1aXRpZXM8L2I+OiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgbW9yZSB0aGFuIG9uZSBwYXRoIHRocm91Z2ggdGhlXG4vLyBncmFtbWFyIGNhbiBtYXRjaCB0aGUgaW5wdXQuPC9saT5cbi8vIDxsaT48Yj5XZWFrIGNvbnRleHQgc2Vuc2l0aXZpdHk8L2I+OiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgZnVsbC1jb250ZXh0XG4vLyBwcmVkaWN0aW9uIHJlc29sdmVkIGFuIFNMTCBjb25mbGljdCB0byBhIHVuaXF1ZSBhbHRlcm5hdGl2ZSB3aGljaCBlcXVhbGVkIHRoZVxuLy8gbWluaW11bSBhbHRlcm5hdGl2ZSBvZiB0aGUgU0xMIGNvbmZsaWN0LjwvbGk+XG4vLyA8bGk+PGI+U3Ryb25nIChmb3JjZWQpIGNvbnRleHQgc2Vuc2l0aXZpdHk8L2I+OiBUaGVzZSBhcmUgY2FzZXMgd2hlcmUgdGhlXG4vLyBmdWxsLWNvbnRleHQgcHJlZGljdGlvbiByZXNvbHZlZCBhbiBTTEwgY29uZmxpY3QgdG8gYSB1bmlxdWUgYWx0ZXJuYXRpdmUsXG4vLyA8ZW0+YW5kPC9lbT4gdGhlIG1pbmltdW0gYWx0ZXJuYXRpdmUgb2YgdGhlIFNMTCBjb25mbGljdCB3YXMgZm91bmQgdG8gbm90IGJlXG4vLyBhIHRydWx5IHZpYWJsZSBhbHRlcm5hdGl2ZS4gVHdvLXN0YWdlIHBhcnNpbmcgY2Fubm90IGJlIHVzZWQgZm9yIGlucHV0cyB3aGVyZVxuLy8gdGhpcyBzaXR1YXRpb24gb2NjdXJzLjwvbGk+XG4vLyA8L3VsPlxuXG52YXIgQml0U2V0ID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLkJpdFNldDtcbnZhciBFcnJvckxpc3RlbmVyID0gcmVxdWlyZSgnLi9FcnJvckxpc3RlbmVyJykuRXJyb3JMaXN0ZW5lcjtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcblxuZnVuY3Rpb24gRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIoZXhhY3RPbmx5KSB7XG5cdEVycm9yTGlzdGVuZXIuY2FsbCh0aGlzKTtcblx0ZXhhY3RPbmx5ID0gZXhhY3RPbmx5IHx8IHRydWU7XG5cdC8vIHdoZXRoZXIgYWxsIGFtYmlndWl0aWVzIG9yIG9ubHkgZXhhY3QgYW1iaWd1aXRpZXMgYXJlIHJlcG9ydGVkLlxuXHR0aGlzLmV4YWN0T25seSA9IGV4YWN0T25seTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkRpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUpO1xuRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXI7XG5cbkRpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBbWJpZ3VpdHkgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsXG5cdFx0c3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKSB7XG5cdGlmICh0aGlzLmV4YWN0T25seSAmJiAhZXhhY3QpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIG1zZyA9IFwicmVwb3J0QW1iaWd1aXR5IGQ9XCIgK1xuXHRcdFx0dGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSkgK1xuXHRcdFx0XCI6IGFtYmlnQWx0cz1cIiArXG5cdFx0XHR0aGlzLmdldENvbmZsaWN0aW5nQWx0cyhhbWJpZ0FsdHMsIGNvbmZpZ3MpICtcblx0XHRcdFwiLCBpbnB1dD0nXCIgK1xuXHRcdFx0cmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLmdldFRleHQobmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpICsgXCInXCI7XG5cdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnKTtcbn07XG5cbkRpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgPSBmdW5jdGlvbihcblx0XHRyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKSB7XG5cdHZhciBtc2cgPSBcInJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCBkPVwiICtcblx0XHRcdHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpICtcblx0XHRcdFwiLCBpbnB1dD0nXCIgK1xuXHRcdFx0cmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLmdldFRleHQobmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpICsgXCInXCI7XG5cdHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnKTtcbn07XG5cbkRpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgPSBmdW5jdGlvbihcblx0XHRyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgY29uZmlncykge1xuXHR2YXIgbXNnID0gXCJyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgZD1cIiArXG5cdFx0XHR0aGlzLmdldERlY2lzaW9uRGVzY3JpcHRpb24ocmVjb2duaXplciwgZGZhKSArXG5cdFx0XHRcIiwgaW5wdXQ9J1wiICtcblx0XHRcdHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXgpKSArIFwiJ1wiO1xuXHRyZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZyk7XG59O1xuXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGRmYSkge1xuXHR2YXIgZGVjaXNpb24gPSBkZmEuZGVjaXNpb247XG5cdHZhciBydWxlSW5kZXggPSBkZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXg7XG5cblx0dmFyIHJ1bGVOYW1lcyA9IHJlY29nbml6ZXIucnVsZU5hbWVzO1xuXHRpZiAocnVsZUluZGV4IDwgMCB8fCBydWxlSW5kZXggPj0gcnVsZU5hbWVzLmxlbmd0aCkge1xuXHRcdHJldHVybiBcIlwiICsgZGVjaXNpb247XG5cdH1cblx0dmFyIHJ1bGVOYW1lID0gcnVsZU5hbWVzW3J1bGVJbmRleF0gfHwgbnVsbDtcblx0aWYgKHJ1bGVOYW1lID09PSBudWxsIHx8IHJ1bGVOYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBcIlwiICsgZGVjaXNpb247XG5cdH1cblx0cmV0dXJuIFwiXCIgKyBkZWNpc2lvbiArIFwiIChcIiArIHJ1bGVOYW1lICsgXCIpXCI7XG59O1xuXG4vL1xuLy8gQ29tcHV0ZXMgdGhlIHNldCBvZiBjb25mbGljdGluZyBvciBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzIGZyb20gYVxuLy8gY29uZmlndXJhdGlvbiBzZXQsIGlmIHRoYXQgaW5mb3JtYXRpb24gd2FzIG5vdCBhbHJlYWR5IHByb3ZpZGVkIGJ5IHRoZVxuLy8gcGFyc2VyLlxuLy9cbi8vIEBwYXJhbSByZXBvcnRlZEFsdHMgVGhlIHNldCBvZiBjb25mbGljdGluZyBvciBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzLCBhc1xuLy8gcmVwb3J0ZWQgYnkgdGhlIHBhcnNlci5cbi8vIEBwYXJhbSBjb25maWdzIFRoZSBjb25mbGljdGluZyBvciBhbWJpZ3VvdXMgY29uZmlndXJhdGlvbiBzZXQuXG4vLyBAcmV0dXJuIFJldHVybnMge0Bjb2RlIHJlcG9ydGVkQWx0c30gaWYgaXQgaXMgbm90IHtAY29kZSBudWxsfSwgb3RoZXJ3aXNlXG4vLyByZXR1cm5zIHRoZSBzZXQgb2YgYWx0ZXJuYXRpdmVzIHJlcHJlc2VudGVkIGluIHtAY29kZSBjb25maWdzfS5cbi8vXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUuZ2V0Q29uZmxpY3RpbmdBbHRzID0gZnVuY3Rpb24ocmVwb3J0ZWRBbHRzLCBjb25maWdzKSB7XG5cdGlmIChyZXBvcnRlZEFsdHMgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gcmVwb3J0ZWRBbHRzO1xuXHR9XG5cdHZhciByZXN1bHQgPSBuZXcgQml0U2V0KCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdHJlc3VsdC5hZGQoY29uZmlncy5pdGVtc1tpXS5hbHQpO1xuXHR9XG5cdHJldHVybiBcIntcIiArIHJlc3VsdC52YWx1ZXMoKS5qb2luKFwiLCBcIikgKyBcIn1cIjtcbn07XG5cbmV4cG9ydHMuRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIgPSBEaWFnbm9zdGljRXJyb3JMaXN0ZW5lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbnRscjQvZXJyb3IvRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG52YXIgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJykuSW5wdXRTdHJlYW07XG5cbnZhciBpc05vZGVKcyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAndW5kZWZpbmVkJztcbnZhciBmcyA9IGlzTm9kZUpzID8gcmVxdWlyZShcImZzXCIpIDogbnVsbDtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgdG8gY3JlYXRlIElucHV0U3RyZWFtcyBmcm9tIHZhcmlvdXMgc291cmNlcy5cbi8vXG4vLyBBbGwgcmV0dXJuZWQgSW5wdXRTdHJlYW1zIHN1cHBvcnQgdGhlIGZ1bGwgcmFuZ2Ugb2YgVW5pY29kZVxuLy8gdXAgdG8gVSsxMEZGRkYgKHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIElucHV0U3RyZWFtIG9ubHkgc3VwcG9ydHNcbi8vIGNvZGUgcG9pbnRzIHVwIHRvIFUrRkZGRikuXG52YXIgQ2hhclN0cmVhbXMgPSB7XG4gIC8vIENyZWF0ZXMgYW4gSW5wdXRTdHJlYW0gZnJvbSBhIHN0cmluZy5cbiAgZnJvbVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFN0cmVhbShzdHIsIHRydWUpO1xuICB9LFxuXG4gIC8vIEFzeW5jaHJvbm91c2x5IGNyZWF0ZXMgYW4gSW5wdXRTdHJlYW0gZnJvbSBhIGJsb2IgZ2l2ZW4gdGhlXG4gIC8vIGVuY29kaW5nIG9mIHRoZSBieXRlcyBpbiB0aGF0IGJsb2IgKGRlZmF1bHRzIHRvICd1dGY4JyBpZlxuICAvLyBlbmNvZGluZyBpcyBudWxsKS5cbiAgLy9cbiAgLy8gSW52b2tlcyBvbkxvYWQocmVzdWx0KSBvbiBzdWNjZXNzLCBvbkVycm9yKGVycm9yKSBvblxuICAvLyBmYWlsdXJlLlxuICBmcm9tQmxvYjogZnVuY3Rpb24oYmxvYiwgZW5jb2RpbmcsIG9uTG9hZCwgb25FcnJvcikge1xuICAgIHZhciByZWFkZXIgPSBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpcyA9IG5ldyBJbnB1dFN0cmVhbShlLnRhcmdldC5yZXN1bHQsIHRydWUpO1xuICAgICAgb25Mb2FkKGlzKTtcbiAgICB9O1xuICAgIHJlYWRlci5vbmVycm9yID0gb25FcnJvcjtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XG4gIH0sXG5cbiAgLy8gQ3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBmcm9tIGEgQnVmZmVyIGdpdmVuIHRoZVxuICAvLyBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBidWZmZXIgKGRlZmF1bHRzIHRvICd1dGY4JyBpZlxuICAvLyBlbmNvZGluZyBpcyBudWxsKS5cbiAgZnJvbUJ1ZmZlcjogZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRTdHJlYW0oYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKSwgdHJ1ZSk7XG4gIH0sXG5cbiAgLy8gQXN5bmNocm9ub3VzbHkgY3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBmcm9tIGEgZmlsZSBvbiBkaXNrIGdpdmVuXG4gIC8vIHRoZSBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBmaWxlIChkZWZhdWx0cyB0byAndXRmOCcgaWZcbiAgLy8gZW5jb2RpbmcgaXMgbnVsbCkuXG4gIC8vXG4gIC8vIEludm9rZXMgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkgb24gY29tcGxldGlvbi5cbiAgZnJvbVBhdGg6IGZ1bmN0aW9uKHBhdGgsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGZzLnJlYWRGaWxlKHBhdGgsIGVuY29kaW5nLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIHZhciBpcyA9IG51bGw7XG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpcyA9IG5ldyBJbnB1dFN0cmVhbShkYXRhLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgaXMpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFN5bmNocm9ub3VzbHkgY3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBnaXZlbiBhIHBhdGggdG8gYSBmaWxlXG4gIC8vIG9uIGRpc2sgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBmaWxlIChkZWZhdWx0cyB0b1xuICAvLyAndXRmOCcgaWYgZW5jb2RpbmcgaXMgbnVsbCkuXG4gIGZyb21QYXRoU3luYzogZnVuY3Rpb24ocGF0aCwgZW5jb2RpbmcpIHtcbiAgICB2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCBlbmNvZGluZyk7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFN0cmVhbShkYXRhLCB0cnVlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5DaGFyU3RyZWFtcyA9IENoYXJTdHJlYW1zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0NoYXJTdHJlYW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy9cbi8vICBUaGlzIGlzIGFuIElucHV0U3RyZWFtIHRoYXQgaXMgbG9hZGVkIGZyb20gYSBmaWxlIGFsbCBhdCBvbmNlXG4vLyAgd2hlbiB5b3UgY29uc3RydWN0IHRoZSBvYmplY3QuXG4vL1xudmFyIElucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpLklucHV0U3RyZWFtO1xudmFyIGlzTm9kZUpzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICd1bmRlZmluZWQnO1xudmFyIGZzID0gaXNOb2RlSnMgPyByZXF1aXJlKFwiZnNcIikgOiBudWxsO1xuXG5mdW5jdGlvbiBGaWxlU3RyZWFtKGZpbGVOYW1lLCBkZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzKSB7XG5cdHZhciBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGZpbGVOYW1lLCBcInV0ZjhcIik7XG5cdElucHV0U3RyZWFtLmNhbGwodGhpcywgZGF0YSwgZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cyk7XG5cdHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnB1dFN0cmVhbS5wcm90b3R5cGUpO1xuRmlsZVN0cmVhbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWxlU3RyZWFtO1xuXG5leHBvcnRzLkZpbGVTdHJlYW0gPSBGaWxlU3RyZWFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0ZpbGVTdHJlYW0uanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy9cbi8vIFRoaXMgY2xhc3MgZXh0ZW5kcyB7QGxpbmsgQnVmZmVyZWRUb2tlblN0cmVhbX0gd2l0aCBmdW5jdGlvbmFsaXR5IHRvIGZpbHRlclxuLy8gdG9rZW4gc3RyZWFtcyB0byB0b2tlbnMgb24gYSBwYXJ0aWN1bGFyIGNoYW5uZWwgKHRva2VucyB3aGVyZVxuLy8ge0BsaW5rIFRva2VuLy9nZXRDaGFubmVsfSByZXR1cm5zIGEgcGFydGljdWxhciB2YWx1ZSkuXG4vL1xuLy8gPHA+XG4vLyBUaGlzIHRva2VuIHN0cmVhbSBwcm92aWRlcyBhY2Nlc3MgdG8gYWxsIHRva2VucyBieSBpbmRleCBvciB3aGVuIGNhbGxpbmdcbi8vIG1ldGhvZHMgbGlrZSB7QGxpbmsgLy9nZXRUZXh0fS4gVGhlIGNoYW5uZWwgZmlsdGVyaW5nIGlzIG9ubHkgdXNlZCBmb3IgY29kZVxuLy8gYWNjZXNzaW5nIHRva2VucyB2aWEgdGhlIGxvb2thaGVhZCBtZXRob2RzIHtAbGluayAvL0xBfSwge0BsaW5rIC8vTFR9LCBhbmRcbi8vIHtAbGluayAvL0xCfS48L3A+XG4vL1xuLy8gPHA+XG4vLyBCeSBkZWZhdWx0LCB0b2tlbnMgYXJlIHBsYWNlZCBvbiB0aGUgZGVmYXVsdCBjaGFubmVsXG4vLyAoe0BsaW5rIFRva2VuLy9ERUZBVUxUX0NIQU5ORUx9KSwgYnV0IG1heSBiZSByZWFzc2lnbmVkIGJ5IHVzaW5nIHRoZVxuLy8ge0Bjb2RlIC0+Y2hhbm5lbChISURERU4pfSBsZXhlciBjb21tYW5kLCBvciBieSB1c2luZyBhbiBlbWJlZGRlZCBhY3Rpb24gdG9cbi8vIGNhbGwge0BsaW5rIExleGVyLy9zZXRDaGFubmVsfS5cbi8vIDwvcD5cbi8vXG4vLyA8cD5cbi8vIE5vdGU6IGxleGVyIHJ1bGVzIHdoaWNoIHVzZSB0aGUge0Bjb2RlIC0+c2tpcH0gbGV4ZXIgY29tbWFuZCBvciBjYWxsXG4vLyB7QGxpbmsgTGV4ZXIvL3NraXB9IGRvIG5vdCBwcm9kdWNlIHRva2VucyBhdCBhbGwsIHNvIGlucHV0IHRleHQgbWF0Y2hlZCBieVxuLy8gc3VjaCBhIHJ1bGUgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFzIHBhcnQgb2YgdGhlIHRva2VuIHN0cmVhbSwgcmVnYXJkbGVzcyBvZlxuLy8gY2hhbm5lbC48L3A+XG4vLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xudmFyIEJ1ZmZlcmVkVG9rZW5TdHJlYW0gPSByZXF1aXJlKCcuL0J1ZmZlcmVkVG9rZW5TdHJlYW0nKS5CdWZmZXJlZFRva2VuU3RyZWFtO1xuXG5mdW5jdGlvbiBDb21tb25Ub2tlblN0cmVhbShsZXhlciwgY2hhbm5lbCkge1xuXHRCdWZmZXJlZFRva2VuU3RyZWFtLmNhbGwodGhpcywgbGV4ZXIpO1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw9PT11bmRlZmluZWQgPyBUb2tlbi5ERUZBVUxUX0NIQU5ORUwgOiBjaGFubmVsO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5Db21tb25Ub2tlblN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlKTtcbkNvbW1vblRva2VuU3RyZWFtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbW1vblRva2VuU3RyZWFtO1xuXG5Db21tb25Ub2tlblN0cmVhbS5wcm90b3R5cGUuYWRqdXN0U2Vla0luZGV4ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbChpLCB0aGlzLmNoYW5uZWwpO1xufTtcblxuQ29tbW9uVG9rZW5TdHJlYW0ucHJvdG90eXBlLkxCID0gZnVuY3Rpb24oaykge1xuICAgIGlmIChrPT09MCB8fCB0aGlzLmluZGV4LWs8MCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmluZGV4O1xuICAgIHZhciBuID0gMTtcbiAgICAvLyBmaW5kIGsgZ29vZCB0b2tlbnMgbG9va2luZyBiYWNrd2FyZHNcbiAgICB3aGlsZSAobiA8PSBrKSB7XG4gICAgICAgIC8vIHNraXAgb2ZmLWNoYW5uZWwgdG9rZW5zXG4gICAgICAgIGkgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwoaSAtIDEsIHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIG4gKz0gMTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbnNbaV07XG59O1xuXG5Db21tb25Ub2tlblN0cmVhbS5wcm90b3R5cGUuTFQgPSBmdW5jdGlvbihrKSB7XG4gICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoayA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTEIoLWspO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuaW5kZXg7XG4gICAgdmFyIG4gPSAxOyAvLyB3ZSBrbm93IHRva2Vuc1twb3NdIGlzIGEgZ29vZCBvbmVcbiAgICAvLyBmaW5kIGsgZ29vZCB0b2tlbnNcbiAgICB3aGlsZSAobiA8IGspIHtcbiAgICAgICAgLy8gc2tpcCBvZmYtY2hhbm5lbCB0b2tlbnMsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGxvb2sgcGFzdCBFT0ZcbiAgICAgICAgaWYgKHRoaXMuc3luYyhpICsgMSkpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbChpICsgMSwgdGhpcy5jaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2Vuc1tpXTtcbn07XG5cbi8vIENvdW50IEVPRiBqdXN0IG9uY2UuLy8vXG5Db21tb25Ub2tlblN0cmVhbS5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZPbkNoYW5uZWxUb2tlbnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdGhpcy5maWxsKCk7XG4gICAgZm9yICh2YXIgaSA9MDsgaTwgdGhpcy50b2tlbnMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiggdC5jaGFubmVsPT09dGhpcy5jaGFubmVsKSB7XG4gICAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIHQudHlwZT09PVRva2VuLkVPRikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuXG5leHBvcnRzLkNvbW1vblRva2VuU3RyZWFtID0gQ29tbW9uVG9rZW5TdHJlYW07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0NvbW1vblRva2VuU3RyZWFtLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBUb2tlblN0cmVhbX0gbG9hZHMgdG9rZW5zIGZyb20gYVxuLy8ge0BsaW5rIFRva2VuU291cmNlfSBvbi1kZW1hbmQsIGFuZCBwbGFjZXMgdGhlIHRva2VucyBpbiBhIGJ1ZmZlciB0byBwcm92aWRlXG4vLyBhY2Nlc3MgdG8gYW55IHByZXZpb3VzIHRva2VuIGJ5IGluZGV4LlxuLy9cbi8vIDxwPlxuLy8gVGhpcyB0b2tlbiBzdHJlYW0gaWdub3JlcyB0aGUgdmFsdWUgb2Yge0BsaW5rIFRva2VuLy9nZXRDaGFubmVsfS4gSWYgeW91clxuLy8gcGFyc2VyIHJlcXVpcmVzIHRoZSB0b2tlbiBzdHJlYW0gZmlsdGVyIHRva2VucyB0byBvbmx5IHRob3NlIG9uIGEgcGFydGljdWxhclxuLy8gY2hhbm5lbCwgc3VjaCBhcyB7QGxpbmsgVG9rZW4vL0RFRkFVTFRfQ0hBTk5FTH0gb3Jcbi8vIHtAbGluayBUb2tlbi8vSElEREVOX0NIQU5ORUx9LCB1c2UgYSBmaWx0ZXJpbmcgdG9rZW4gc3RyZWFtIHN1Y2ggYVxuLy8ge0BsaW5rIENvbW1vblRva2VuU3RyZWFtfS48L3A+XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBMZXhlciA9IHJlcXVpcmUoJy4vTGV4ZXInKS5MZXhlcjtcbnZhciBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbDtcblxuLy8gdGhpcyBpcyBqdXN0IHRvIGtlZXAgbWVhbmluZ2Z1bCBwYXJhbWV0ZXIgdHlwZXMgdG8gUGFyc2VyXG5mdW5jdGlvbiBUb2tlblN0cmVhbSgpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkVG9rZW5TdHJlYW0odG9rZW5Tb3VyY2UpIHtcblxuXHRUb2tlblN0cmVhbS5jYWxsKHRoaXMpO1xuXHQvLyBUaGUge0BsaW5rIFRva2VuU291cmNlfSBmcm9tIHdoaWNoIHRva2VucyBmb3IgdGhpcyBzdHJlYW0gYXJlIGZldGNoZWQuXG5cdHRoaXMudG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcblxuXHQvLyBBIGNvbGxlY3Rpb24gb2YgYWxsIHRva2VucyBmZXRjaGVkIGZyb20gdGhlIHRva2VuIHNvdXJjZS4gVGhlIGxpc3QgaXNcblx0Ly8gY29uc2lkZXJlZCBhIGNvbXBsZXRlIHZpZXcgb2YgdGhlIGlucHV0IG9uY2Uge0BsaW5rIC8vZmV0Y2hlZEVPRn0gaXMgc2V0XG5cdC8vIHRvIHtAY29kZSB0cnVlfS5cblx0dGhpcy50b2tlbnMgPSBbXTtcblxuXHQvLyBUaGUgaW5kZXggaW50byB7QGxpbmsgLy90b2tlbnN9IG9mIHRoZSBjdXJyZW50IHRva2VuIChuZXh0IHRva2VuIHRvXG5cdC8vIHtAbGluayAvL2NvbnN1bWV9KS4ge0BsaW5rIC8vdG9rZW5zfXtAY29kZSBbfXtAbGluayAvL3B9e0Bjb2RlIF19IHNob3VsZFxuXHQvLyBiZVxuXHQvLyB7QGxpbmsgLy9MVCBMVCgxKX0uXG5cdC8vXG5cdC8vIDxwPlRoaXMgZmllbGQgaXMgc2V0IHRvIC0xIHdoZW4gdGhlIHN0cmVhbSBpcyBmaXJzdCBjb25zdHJ1Y3RlZCBvciB3aGVuXG5cdC8vIHtAbGluayAvL3NldFRva2VuU291cmNlfSBpcyBjYWxsZWQsIGluZGljYXRpbmcgdGhhdCB0aGUgZmlyc3QgdG9rZW4gaGFzXG5cdC8vIG5vdCB5ZXQgYmVlbiBmZXRjaGVkIGZyb20gdGhlIHRva2VuIHNvdXJjZS4gRm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24sXG5cdC8vIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiB7QGxpbmsgSW50U3RyZWFtfSBmb3IgYSBkZXNjcmlwdGlvbiBvZlxuXHQvLyBJbml0aWFsaXppbmcgTWV0aG9kcy48L3A+XG5cdHRoaXMuaW5kZXggPSAtMTtcblxuXHQvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUge0BsaW5rIFRva2VuLy9FT0Z9IHRva2VuIGhhcyBiZWVuIGZldGNoZWQgZnJvbVxuXHQvLyB7QGxpbmsgLy90b2tlblNvdXJjZX0gYW5kIGFkZGVkIHRvIHtAbGluayAvL3Rva2Vuc30uIFRoaXMgZmllbGQgaW1wcm92ZXNcblx0Ly8gcGVyZm9ybWFuY2UgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vXG5cdC8vIDx1bD5cblx0Ly8gPGxpPntAbGluayAvL2NvbnN1bWV9OiBUaGUgbG9va2FoZWFkIGNoZWNrIGluIHtAbGluayAvL2NvbnN1bWV9IHRvXG5cdC8vIHByZXZlbnRcblx0Ly8gY29uc3VtaW5nIHRoZSBFT0Ygc3ltYm9sIGlzIG9wdGltaXplZCBieSBjaGVja2luZyB0aGUgdmFsdWVzIG9mXG5cdC8vIHtAbGluayAvL2ZldGNoZWRFT0Z9IGFuZCB7QGxpbmsgLy9wfSBpbnN0ZWFkIG9mIGNhbGxpbmcge0BsaW5rXG5cdC8vIC8vTEF9LjwvbGk+XG5cdC8vIDxsaT57QGxpbmsgLy9mZXRjaH06IFRoZSBjaGVjayB0byBwcmV2ZW50IGFkZGluZyBtdWx0aXBsZSBFT0Ygc3ltYm9sc1xuXHQvLyBpbnRvXG5cdC8vIHtAbGluayAvL3Rva2Vuc30gaXMgdHJpdmlhbCB3aXRoIHRoaXMgZmllbGQuPC9saT5cblx0Ly8gPHVsPlxuXHR0aGlzLmZldGNoZWRFT0YgPSBmYWxzZTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUb2tlblN0cmVhbS5wcm90b3R5cGUpO1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCdWZmZXJlZFRva2VuU3RyZWFtO1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAwO1xufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG1hcmtlcikge1xuXHQvLyBubyByZXNvdXJjZXMgdG8gcmVsZWFzZVxufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5zZWVrKDApO1xufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHRoaXMubGF6eUluaXQoKTtcblx0dGhpcy5pbmRleCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KGluZGV4KTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHRoaXMubGF6eUluaXQoKTtcblx0cmV0dXJuIHRoaXMudG9rZW5zW2luZGV4XTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNraXBFb2ZDaGVjayA9IGZhbHNlO1xuXHRpZiAodGhpcy5pbmRleCA+PSAwKSB7XG5cdFx0aWYgKHRoaXMuZmV0Y2hlZEVPRikge1xuXHRcdFx0Ly8gdGhlIGxhc3QgdG9rZW4gaW4gdG9rZW5zIGlzIEVPRi4gc2tpcCBjaGVjayBpZiBwIGluZGV4ZXMgYW55XG5cdFx0XHQvLyBmZXRjaGVkIHRva2VuIGV4Y2VwdCB0aGUgbGFzdC5cblx0XHRcdHNraXBFb2ZDaGVjayA9IHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBubyBFT0YgdG9rZW4gaW4gdG9rZW5zLiBza2lwIGNoZWNrIGlmIHAgaW5kZXhlcyBhIGZldGNoZWQgdG9rZW4uXG5cdFx0XHRza2lwRW9mQ2hlY2sgPSB0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBub3QgeWV0IGluaXRpYWxpemVkXG5cdFx0c2tpcEVvZkNoZWNrID0gZmFsc2U7XG5cdH1cblx0aWYgKCFza2lwRW9mQ2hlY2sgJiYgdGhpcy5MQSgxKSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0dGhyb3cgXCJjYW5ub3QgY29uc3VtZSBFT0ZcIjtcblx0fVxuXHRpZiAodGhpcy5zeW5jKHRoaXMuaW5kZXggKyAxKSkge1xuXHRcdHRoaXMuaW5kZXggPSB0aGlzLmFkanVzdFNlZWtJbmRleCh0aGlzLmluZGV4ICsgMSk7XG5cdH1cbn07XG5cbi8vIE1ha2Ugc3VyZSBpbmRleCB7QGNvZGUgaX0gaW4gdG9rZW5zIGhhcyBhIHRva2VuLlxuLy9cbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGEgdG9rZW4gaXMgbG9jYXRlZCBhdCBpbmRleCB7QGNvZGUgaX0sIG90aGVyd2lzZVxuLy8ge0Bjb2RlIGZhbHNlfS5cbi8vIEBzZWUgLy9nZXQoaW50IGkpXG4vLyAvXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24oaSkge1xuXHR2YXIgbiA9IGkgLSB0aGlzLnRva2Vucy5sZW5ndGggKyAxOyAvLyBob3cgbWFueSBtb3JlIGVsZW1lbnRzIHdlIG5lZWQ/XG5cdGlmIChuID4gMCkge1xuXHRcdHZhciBmZXRjaGVkID0gdGhpcy5mZXRjaChuKTtcblx0XHRyZXR1cm4gZmV0Y2hlZCA+PSBuO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcblxuLy8gQWRkIHtAY29kZSBufSBlbGVtZW50cyB0byBidWZmZXIuXG4vL1xuLy8gQHJldHVybiBUaGUgYWN0dWFsIG51bWJlciBvZiBlbGVtZW50cyBhZGRlZCB0byB0aGUgYnVmZmVyLlxuLy8gL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihuKSB7XG5cdGlmICh0aGlzLmZldGNoZWRFT0YpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdHZhciB0ID0gdGhpcy50b2tlblNvdXJjZS5uZXh0VG9rZW4oKTtcblx0XHR0LnRva2VuSW5kZXggPSB0aGlzLnRva2Vucy5sZW5ndGg7XG5cdFx0dGhpcy50b2tlbnMucHVzaCh0KTtcblx0XHRpZiAodC50eXBlID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdHRoaXMuZmV0Y2hlZEVPRiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gaSArIDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBuO1xufTtcblxuLy8gR2V0IGFsbCB0b2tlbnMgZnJvbSBzdGFydC4uc3RvcCBpbmNsdXNpdmVseS8vL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuZ2V0VG9rZW5zID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHR5cGVzKSB7XG5cdGlmICh0eXBlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dHlwZXMgPSBudWxsO1xuXHR9XG5cdGlmIChzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0aGlzLmxhenlJbml0KCk7XG5cdHZhciBzdWJzZXQgPSBbXTtcblx0aWYgKHN0b3AgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG5cdFx0c3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG5cdH1cblx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSsrKSB7XG5cdFx0dmFyIHQgPSB0aGlzLnRva2Vuc1tpXTtcblx0XHRpZiAodC50eXBlID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAodHlwZXMgPT09IG51bGwgfHwgdHlwZXMuY29udGFpbnModC50eXBlKSkge1xuXHRcdFx0c3Vic2V0LnB1c2godCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJzZXQ7XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5MQSA9IGZ1bmN0aW9uKGkpIHtcblx0cmV0dXJuIHRoaXMuTFQoaSkudHlwZTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLkxCID0gZnVuY3Rpb24oaykge1xuXHRpZiAodGhpcy5pbmRleCAtIGsgPCAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggLSBrXTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLkxUID0gZnVuY3Rpb24oaykge1xuXHR0aGlzLmxhenlJbml0KCk7XG5cdGlmIChrID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKGsgPCAwKSB7XG5cdFx0cmV0dXJuIHRoaXMuTEIoLWspO1xuXHR9XG5cdHZhciBpID0gdGhpcy5pbmRleCArIGsgLSAxO1xuXHR0aGlzLnN5bmMoaSk7XG5cdGlmIChpID49IHRoaXMudG9rZW5zLmxlbmd0aCkgeyAvLyByZXR1cm4gRU9GIHRva2VuXG5cdFx0Ly8gRU9GIG11c3QgYmUgbGFzdCB0b2tlblxuXHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcblx0fVxuXHRyZXR1cm4gdGhpcy50b2tlbnNbaV07XG59O1xuXG4vLyBBbGxvd2VkIGRlcml2ZWQgY2xhc3NlcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIG9wZXJhdGlvbnMgd2hpY2ggY2hhbmdlXG4vLyB0aGUgY3VycmVudCBzdHJlYW0gcG9zaXRpb24gYnkgYWRqdXN0aW5nIHRoZSB0YXJnZXQgdG9rZW4gaW5kZXggb2YgYSBzZWVrXG4vLyBvcGVyYXRpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSByZXR1cm5zIHtAY29kZSBpfS4gSWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gaW4gdGhpcyBtZXRob2QsIHRoZSBjdXJyZW50IHN0cmVhbSBpbmRleCBzaG91bGQgbm90IGJlXG4vLyBjaGFuZ2VkLlxuLy9cbi8vIDxwPkZvciBleGFtcGxlLCB7QGxpbmsgQ29tbW9uVG9rZW5TdHJlYW19IG92ZXJyaWRlcyB0aGlzIG1ldGhvZCB0byBlbnN1cmVcbi8vIHRoYXRcbi8vIHRoZSBzZWVrIHRhcmdldCBpcyBhbHdheXMgYW4gb24tY2hhbm5lbCB0b2tlbi48L3A+XG4vL1xuLy8gQHBhcmFtIGkgVGhlIHRhcmdldCB0b2tlbiBpbmRleC5cbi8vIEByZXR1cm4gVGhlIGFkanVzdGVkIHRhcmdldCB0b2tlbiBpbmRleC5cblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuYWRqdXN0U2Vla0luZGV4ID0gZnVuY3Rpb24oaSkge1xuXHRyZXR1cm4gaTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmxhenlJbml0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmluZGV4ID09PSAtMSkge1xuXHRcdHRoaXMuc2V0dXAoKTtcblx0fVxufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5zeW5jKDApO1xuXHR0aGlzLmluZGV4ID0gdGhpcy5hZGp1c3RTZWVrSW5kZXgoMCk7XG59O1xuXG4vLyBSZXNldCB0aGlzIHRva2VuIHN0cmVhbSBieSBzZXR0aW5nIGl0cyB0b2tlbiBzb3VyY2UuLy8vXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5zZXRUb2tlblNvdXJjZSA9IGZ1bmN0aW9uKHRva2VuU291cmNlKSB7XG5cdHRoaXMudG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcblx0dGhpcy50b2tlbnMgPSBbXTtcblx0dGhpcy5pbmRleCA9IC0xO1xuXHR0aGlzLmZldGNoZWRFT0YgPSBmYWxzZTtcbn07XG5cblxuLy8gR2l2ZW4gYSBzdGFydGluZyBpbmRleCwgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbmV4dCB0b2tlbiBvbiBjaGFubmVsLlxuLy8gUmV0dXJuIGkgaWYgdG9rZW5zW2ldIGlzIG9uIGNoYW5uZWwuIFJldHVybiAtMSBpZiB0aGVyZSBhcmUgbm8gdG9rZW5zXG4vLyBvbiBjaGFubmVsIGJldHdlZW4gaSBhbmQgRU9GLlxuLy8gL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUubmV4dFRva2VuT25DaGFubmVsID0gZnVuY3Rpb24oaSwgY2hhbm5lbCkge1xuXHR0aGlzLnN5bmMoaSk7XG5cdGlmIChpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHRcdHJldHVybiAtMTtcblx0fVxuXHR2YXIgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcblx0d2hpbGUgKHRva2VuLmNoYW5uZWwgIT09IHRoaXMuY2hhbm5lbCkge1xuXHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aSArPSAxO1xuXHRcdHRoaXMuc3luYyhpKTtcblx0XHR0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuXHR9XG5cdHJldHVybiBpO1xufTtcblxuLy8gR2l2ZW4gYSBzdGFydGluZyBpbmRleCwgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXMgdG9rZW4gb24gY2hhbm5lbC5cbi8vIFJldHVybiBpIGlmIHRva2Vuc1tpXSBpcyBvbiBjaGFubmVsLiBSZXR1cm4gLTEgaWYgdGhlcmUgYXJlIG5vIHRva2Vuc1xuLy8gb24gY2hhbm5lbCBiZXR3ZWVuIGkgYW5kIDAuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5wcmV2aW91c1Rva2VuT25DaGFubmVsID0gZnVuY3Rpb24oaSwgY2hhbm5lbCkge1xuXHR3aGlsZSAoaSA+PSAwICYmIHRoaXMudG9rZW5zW2ldLmNoYW5uZWwgIT09IGNoYW5uZWwpIHtcblx0XHRpIC09IDE7XG5cdH1cblx0cmV0dXJuIGk7XG59O1xuXG4vLyBDb2xsZWN0IGFsbCB0b2tlbnMgb24gc3BlY2lmaWVkIGNoYW5uZWwgdG8gdGhlIHJpZ2h0IG9mXG4vLyB0aGUgY3VycmVudCB0b2tlbiB1cCB1bnRpbCB3ZSBzZWUgYSB0b2tlbiBvbiBERUZBVUxUX1RPS0VOX0NIQU5ORUwgb3Jcbi8vIEVPRi4gSWYgY2hhbm5lbCBpcyAtMSwgZmluZCBhbnkgbm9uIGRlZmF1bHQgY2hhbm5lbCB0b2tlbi5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmdldEhpZGRlblRva2Vuc1RvUmlnaHQgPSBmdW5jdGlvbih0b2tlbkluZGV4LFxuXHRcdGNoYW5uZWwpIHtcblx0aWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNoYW5uZWwgPSAtMTtcblx0fVxuXHR0aGlzLmxhenlJbml0KCk7XG5cdGlmICh0b2tlbkluZGV4IDwgMCB8fCB0b2tlbkluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHRcdHRocm93IFwiXCIgKyB0b2tlbkluZGV4ICsgXCIgbm90IGluIDAuLlwiICsgdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcblx0fVxuXHR2YXIgbmV4dE9uQ2hhbm5lbCA9IHRoaXMubmV4dFRva2VuT25DaGFubmVsKHRva2VuSW5kZXggKyAxLCBMZXhlci5ERUZBVUxUX1RPS0VOX0NIQU5ORUwpO1xuXHR2YXIgZnJvbV8gPSB0b2tlbkluZGV4ICsgMTtcblx0Ly8gaWYgbm9uZSBvbmNoYW5uZWwgdG8gcmlnaHQsIG5leHRPbkNoYW5uZWw9LTEgc28gc2V0IHRvID0gbGFzdCB0b2tlblxuXHR2YXIgdG8gPSBuZXh0T25DaGFubmVsID09PSAtMSA/IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgOiBuZXh0T25DaGFubmVsO1xuXHRyZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb21fLCB0bywgY2hhbm5lbCk7XG59O1xuXG4vLyBDb2xsZWN0IGFsbCB0b2tlbnMgb24gc3BlY2lmaWVkIGNoYW5uZWwgdG8gdGhlIGxlZnQgb2Zcbi8vIHRoZSBjdXJyZW50IHRva2VuIHVwIHVudGlsIHdlIHNlZSBhIHRva2VuIG9uIERFRkFVTFRfVE9LRU5fQ0hBTk5FTC5cbi8vIElmIGNoYW5uZWwgaXMgLTEsIGZpbmQgYW55IG5vbiBkZWZhdWx0IGNoYW5uZWwgdG9rZW4uXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5nZXRIaWRkZW5Ub2tlbnNUb0xlZnQgPSBmdW5jdGlvbih0b2tlbkluZGV4LFxuXHRcdGNoYW5uZWwpIHtcblx0aWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNoYW5uZWwgPSAtMTtcblx0fVxuXHR0aGlzLmxhenlJbml0KCk7XG5cdGlmICh0b2tlbkluZGV4IDwgMCB8fCB0b2tlbkluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHRcdHRocm93IFwiXCIgKyB0b2tlbkluZGV4ICsgXCIgbm90IGluIDAuLlwiICsgdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcblx0fVxuXHR2YXIgcHJldk9uQ2hhbm5lbCA9IHRoaXMucHJldmlvdXNUb2tlbk9uQ2hhbm5lbCh0b2tlbkluZGV4IC0gMSwgTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcblx0aWYgKHByZXZPbkNoYW5uZWwgPT09IHRva2VuSW5kZXggLSAxKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Ly8gaWYgbm9uZSBvbiBjaGFubmVsIHRvIGxlZnQsIHByZXZPbkNoYW5uZWw9LTEgdGhlbiBmcm9tPTBcblx0dmFyIGZyb21fID0gcHJldk9uQ2hhbm5lbCArIDE7XG5cdHZhciB0byA9IHRva2VuSW5kZXggLSAxO1xuXHRyZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb21fLCB0bywgY2hhbm5lbCk7XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5maWx0ZXJGb3JDaGFubmVsID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGNoYW5uZWwpIHtcblx0dmFyIGhpZGRlbiA9IFtdO1xuXHRmb3IgKHZhciBpID0gbGVmdDsgaSA8IHJpZ2h0ICsgMTsgaSsrKSB7XG5cdFx0dmFyIHQgPSB0aGlzLnRva2Vuc1tpXTtcblx0XHRpZiAoY2hhbm5lbCA9PT0gLTEpIHtcblx0XHRcdGlmICh0LmNoYW5uZWwgIT09IExleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCkge1xuXHRcdFx0XHRoaWRkZW4ucHVzaCh0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHQuY2hhbm5lbCA9PT0gY2hhbm5lbCkge1xuXHRcdFx0aGlkZGVuLnB1c2godCk7XG5cdFx0fVxuXHR9XG5cdGlmIChoaWRkZW4ubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIGhpZGRlbjtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmdldFNvdXJjZU5hbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudG9rZW5Tb3VyY2UuZ2V0U291cmNlTmFtZSgpO1xufTtcblxuLy8gR2V0IHRoZSB0ZXh0IG9mIGFsbCB0b2tlbnMgaW4gdGhpcyBidWZmZXIuLy8vXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0dGhpcy5sYXp5SW5pdCgpO1xuXHR0aGlzLmZpbGwoKTtcblx0aWYgKGludGVydmFsID09PSB1bmRlZmluZWQgfHwgaW50ZXJ2YWwgPT09IG51bGwpIHtcblx0XHRpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbCgwLCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKTtcblx0fVxuXHR2YXIgc3RhcnQgPSBpbnRlcnZhbC5zdGFydDtcblx0aWYgKHN0YXJ0IGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRzdGFydCA9IHN0YXJ0LnRva2VuSW5kZXg7XG5cdH1cblx0dmFyIHN0b3AgPSBpbnRlcnZhbC5zdG9wO1xuXHRpZiAoc3RvcCBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0c3RvcCA9IHN0b3AudG9rZW5JbmRleDtcblx0fVxuXHRpZiAoc3RhcnQgPT09IG51bGwgfHwgc3RvcCA9PT0gbnVsbCB8fCBzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXHRpZiAoc3RvcCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcblx0XHRzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcblx0fVxuXHR2YXIgcyA9IFwiXCI7XG5cdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0b3AgKyAxOyBpKyspIHtcblx0XHR2YXIgdCA9IHRoaXMudG9rZW5zW2ldO1xuXHRcdGlmICh0LnR5cGUgPT09IFRva2VuLkVPRikge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHMgPSBzICsgdC50ZXh0O1xuXHR9XG5cdHJldHVybiBzO1xufTtcblxuLy8gR2V0IGFsbCB0b2tlbnMgZnJvbSBsZXhlciB1bnRpbCBFT0YvLy9cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5sYXp5SW5pdCgpO1xuXHR3aGlsZSAodGhpcy5mZXRjaCgxMDAwKSA9PT0gMTAwMCkge1xuXHRcdGNvbnRpbnVlO1xuXHR9XG59O1xuXG5leHBvcnRzLkJ1ZmZlcmVkVG9rZW5TdHJlYW0gPSBCdWZmZXJlZFRva2VuU3RyZWFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L0J1ZmZlcmVkVG9rZW5TdHJlYW0uanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xudmFyIFBhcnNlVHJlZUxpc3RlbmVyID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKS5QYXJzZVRyZWVMaXN0ZW5lcjtcbnZhciBSZWNvZ25pemVyID0gcmVxdWlyZSgnLi9SZWNvZ25pemVyJykuUmVjb2duaXplcjtcbnZhciBEZWZhdWx0RXJyb3JTdHJhdGVneSA9IHJlcXVpcmUoJy4vZXJyb3IvRXJyb3JTdHJhdGVneScpLkRlZmF1bHRFcnJvclN0cmF0ZWd5O1xudmFyIEFUTkRlc2VyaWFsaXplciA9IHJlcXVpcmUoJy4vYXRuL0FUTkRlc2VyaWFsaXplcicpLkFUTkRlc2VyaWFsaXplcjtcbnZhciBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zID0gcmVxdWlyZSgnLi9hdG4vQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucycpLkFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XG52YXIgVGVybWluYWxOb2RlID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKS5UZXJtaW5hbE5vZGU7XG52YXIgRXJyb3JOb2RlID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKS5FcnJvck5vZGU7XG5cbmZ1bmN0aW9uIFRyYWNlTGlzdGVuZXIocGFyc2VyKSB7XG5cdFBhcnNlVHJlZUxpc3RlbmVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdHJldHVybiB0aGlzO1xufVxuXG5UcmFjZUxpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlKTtcblRyYWNlTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhY2VMaXN0ZW5lcjtcblxuVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUuZW50ZXJFdmVyeVJ1bGUgPSBmdW5jdGlvbihjdHgpIHtcblx0Y29uc29sZS5sb2coXCJlbnRlciAgIFwiICsgdGhpcy5wYXJzZXIucnVsZU5hbWVzW2N0eC5ydWxlSW5kZXhdICsgXCIsIExUKDEpPVwiICsgdGhpcy5wYXJzZXIuX2lucHV0LkxUKDEpLnRleHQpO1xufTtcblxuVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUudmlzaXRUZXJtaW5hbCA9IGZ1bmN0aW9uKCBub2RlKSB7XG5cdGNvbnNvbGUubG9nKFwiY29uc3VtZSBcIiArIG5vZGUuc3ltYm9sICsgXCIgcnVsZSBcIiArIHRoaXMucGFyc2VyLnJ1bGVOYW1lc1t0aGlzLnBhcnNlci5fY3R4LnJ1bGVJbmRleF0pO1xufTtcblxuVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUuZXhpdEV2ZXJ5UnVsZSA9IGZ1bmN0aW9uKGN0eCkge1xuXHRjb25zb2xlLmxvZyhcImV4aXQgICAgXCIgKyB0aGlzLnBhcnNlci5ydWxlTmFtZXNbY3R4LnJ1bGVJbmRleF0gKyBcIiwgTFQoMSk9XCIgKyB0aGlzLnBhcnNlci5faW5wdXQuTFQoMSkudGV4dCk7XG59O1xuXG4vLyB0aGlzIGlzIGFsbCB0aGUgcGFyc2luZyBzdXBwb3J0IGNvZGUgZXNzZW50aWFsbHk7IG1vc3Qgb2YgaXQgaXMgZXJyb3Jcbi8vIHJlY292ZXJ5IHN0dWZmLi8vXG5mdW5jdGlvbiBQYXJzZXIoaW5wdXQpIHtcblx0UmVjb2duaXplci5jYWxsKHRoaXMpO1xuXHQvLyBUaGUgaW5wdXQgc3RyZWFtLlxuXHR0aGlzLl9pbnB1dCA9IG51bGw7XG5cdC8vIFRoZSBlcnJvciBoYW5kbGluZyBzdHJhdGVneSBmb3IgdGhlIHBhcnNlci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBuZXdcblx0Ly8gaW5zdGFuY2Ugb2Yge0BsaW5rIERlZmF1bHRFcnJvclN0cmF0ZWd5fS5cblx0dGhpcy5fZXJySGFuZGxlciA9IG5ldyBEZWZhdWx0RXJyb3JTdHJhdGVneSgpO1xuXHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sgPSBbXTtcblx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLnB1c2goMCk7XG5cdC8vIFRoZSB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHR9IG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcnVsZS5cblx0Ly8gdGhpcyBpcyBhbHdheXMgbm9uLW51bGwgZHVyaW5nIHRoZSBwYXJzaW5nIHByb2Nlc3MuXG5cdHRoaXMuX2N0eCA9IG51bGw7XG5cdC8vIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGUgcGFyc2VyIHNob3VsZCBjb25zdHJ1Y3QgYSBwYXJzZSB0cmVlIGR1cmluZ1xuXHQvLyB0aGUgcGFyc2luZyBwcm9jZXNzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB7QGNvZGUgdHJ1ZX0uXG5cdHRoaXMuYnVpbGRQYXJzZVRyZWVzID0gdHJ1ZTtcblx0Ly8gV2hlbiB7QGxpbmsgLy9zZXRUcmFjZX17QGNvZGUgKHRydWUpfSBpcyBjYWxsZWQsIGEgcmVmZXJlbmNlIHRvIHRoZVxuXHQvLyB7QGxpbmsgVHJhY2VMaXN0ZW5lcn0gaXMgc3RvcmVkIGhlcmUgc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGluIGFcblx0Ly8gbGF0ZXIgY2FsbCB0byB7QGxpbmsgLy9zZXRUcmFjZX17QGNvZGUgKGZhbHNlKX0uIFRoZSBsaXN0ZW5lciBpdHNlbGYgaXNcblx0Ly8gaW1wbGVtZW50ZWQgYXMgYSBwYXJzZXIgbGlzdGVuZXIgc28gdGhpcyBmaWVsZCBpcyBub3QgZGlyZWN0bHkgdXNlZCBieVxuXHQvLyBvdGhlciBwYXJzZXIgbWV0aG9kcy5cblx0dGhpcy5fdHJhY2VyID0gbnVsbDtcblx0Ly8gVGhlIGxpc3Qgb2Yge0BsaW5rIFBhcnNlVHJlZUxpc3RlbmVyfSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCB0byByZWNlaXZlXG5cdC8vIGV2ZW50cyBkdXJpbmcgdGhlIHBhcnNlLlxuXHR0aGlzLl9wYXJzZUxpc3RlbmVycyA9IG51bGw7XG5cdC8vIFRoZSBudW1iZXIgb2Ygc3ludGF4IGVycm9ycyByZXBvcnRlZCBkdXJpbmcgcGFyc2luZy4gdGhpcyB2YWx1ZSBpc1xuXHQvLyBpbmNyZW1lbnRlZCBlYWNoIHRpbWUge0BsaW5rIC8vbm90aWZ5RXJyb3JMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cblx0dGhpcy5fc3ludGF4RXJyb3JzID0gMDtcblx0dGhpcy5zZXRJbnB1dFN0cmVhbShpbnB1dCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5QYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvZ25pemVyLnByb3RvdHlwZSk7XG5QYXJzZXIucHJvdG90eXBlLmNvbnRydWN0b3IgPSBQYXJzZXI7XG5cbi8vIHRoaXMgZmllbGQgbWFwcyBmcm9tIHRoZSBzZXJpYWxpemVkIEFUTiBzdHJpbmcgdG8gdGhlIGRlc2VyaWFsaXplZCB7QGxpbmtcbi8vIEFUTn0gd2l0aFxuLy8gYnlwYXNzIGFsdGVybmF0aXZlcy5cbi8vXG4vLyBAc2VlIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMvL2lzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMoKVxuLy9cblBhcnNlci5ieXBhc3NBbHRzQXRuQ2FjaGUgPSB7fTtcblxuLy8gcmVzZXQgdGhlIHBhcnNlcidzIHN0YXRlLy9cblBhcnNlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2lucHV0ICE9PSBudWxsKSB7XG5cdFx0dGhpcy5faW5wdXQuc2VlaygwKTtcblx0fVxuXHR0aGlzLl9lcnJIYW5kbGVyLnJlc2V0KHRoaXMpO1xuXHR0aGlzLl9jdHggPSBudWxsO1xuXHR0aGlzLl9zeW50YXhFcnJvcnMgPSAwO1xuXHR0aGlzLnNldFRyYWNlKGZhbHNlKTtcblx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrID0gW107XG5cdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKDApO1xuXHRpZiAodGhpcy5faW50ZXJwICE9PSBudWxsKSB7XG5cdFx0dGhpcy5faW50ZXJwLnJlc2V0KCk7XG5cdH1cbn07XG5cbi8vIE1hdGNoIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGFnYWluc3Qge0Bjb2RlIHR0eXBlfS4gSWYgdGhlIHN5bWJvbCB0eXBlXG4vLyBtYXRjaGVzLCB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5Ly9yZXBvcnRNYXRjaH0gYW5kIHtAbGluayAvL2NvbnN1bWV9IGFyZVxuLy8gY2FsbGVkIHRvIGNvbXBsZXRlIHRoZSBtYXRjaCBwcm9jZXNzLlxuLy9cbi8vIDxwPklmIHRoZSBzeW1ib2wgdHlwZSBkb2VzIG5vdCBtYXRjaCxcbi8vIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kvL3JlY292ZXJJbmxpbmV9IGlzIGNhbGxlZCBvbiB0aGUgY3VycmVudCBlcnJvclxuLy8gc3RyYXRlZ3kgdG8gYXR0ZW1wdCByZWNvdmVyeS4gSWYge0BsaW5rIC8vZ2V0QnVpbGRQYXJzZVRyZWV9IGlzXG4vLyB7QGNvZGUgdHJ1ZX0gYW5kIHRoZSB0b2tlbiBpbmRleCBvZiB0aGUgc3ltYm9sIHJldHVybmVkIGJ5XG4vLyB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5Ly9yZWNvdmVySW5saW5lfSBpcyAtMSwgdGhlIHN5bWJvbCBpcyBhZGRlZCB0b1xuLy8gdGhlIHBhcnNlIHRyZWUgYnkgY2FsbGluZyB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQvL2FkZEVycm9yTm9kZX0uPC9wPlxuLy9cbi8vIEBwYXJhbSB0dHlwZSB0aGUgdG9rZW4gdHlwZSB0byBtYXRjaFxuLy8gQHJldHVybiB0aGUgbWF0Y2hlZCBzeW1ib2xcbi8vIEB0aHJvd3MgUmVjb2duaXRpb25FeGNlcHRpb24gaWYgdGhlIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGRpZCBub3QgbWF0Y2hcbi8vIHtAY29kZSB0dHlwZX0gYW5kIHRoZSBlcnJvciBzdHJhdGVneSBjb3VsZCBub3QgcmVjb3ZlciBmcm9tIHRoZVxuLy8gbWlzbWF0Y2hlZCBzeW1ib2xcblxuUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHR0eXBlKSB7XG5cdHZhciB0ID0gdGhpcy5nZXRDdXJyZW50VG9rZW4oKTtcblx0aWYgKHQudHlwZSA9PT0gdHR5cGUpIHtcblx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHRcdHRoaXMuY29uc3VtZSgpO1xuXHR9IGVsc2Uge1xuXHRcdHQgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdFx0aWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcblx0XHRcdC8vIHdlIG11c3QgaGF2ZSBjb25qdXJlZCB1cCBhIG5ldyB0b2tlbiBkdXJpbmcgc2luZ2xlIHRva2VuXG5cdFx0XHQvLyBpbnNlcnRpb25cblx0XHRcdC8vIGlmIGl0J3Mgbm90IHRoZSBjdXJyZW50IHN5bWJvbFxuXHRcdFx0dGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHQ7XG59O1xuLy8gTWF0Y2ggY3VycmVudCBpbnB1dCBzeW1ib2wgYXMgYSB3aWxkY2FyZC4gSWYgdGhlIHN5bWJvbCB0eXBlIG1hdGNoZXNcbi8vIChpLmUuIGhhcyBhIHZhbHVlIGdyZWF0ZXIgdGhhbiAwKSwge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneS8vcmVwb3J0TWF0Y2h9XG4vLyBhbmQge0BsaW5rIC8vY29uc3VtZX0gYXJlIGNhbGxlZCB0byBjb21wbGV0ZSB0aGUgbWF0Y2ggcHJvY2Vzcy5cbi8vXG4vLyA8cD5JZiB0aGUgc3ltYm9sIHR5cGUgZG9lcyBub3QgbWF0Y2gsXG4vLyB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5Ly9yZWNvdmVySW5saW5lfSBpcyBjYWxsZWQgb24gdGhlIGN1cnJlbnQgZXJyb3Jcbi8vIHN0cmF0ZWd5IHRvIGF0dGVtcHQgcmVjb3ZlcnkuIElmIHtAbGluayAvL2dldEJ1aWxkUGFyc2VUcmVlfSBpc1xuLy8ge0Bjb2RlIHRydWV9IGFuZCB0aGUgdG9rZW4gaW5kZXggb2YgdGhlIHN5bWJvbCByZXR1cm5lZCBieVxuLy8ge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneS8vcmVjb3ZlcklubGluZX0gaXMgLTEsIHRoZSBzeW1ib2wgaXMgYWRkZWQgdG9cbi8vIHRoZSBwYXJzZSB0cmVlIGJ5IGNhbGxpbmcge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0Ly9hZGRFcnJvck5vZGV9LjwvcD5cbi8vXG4vLyBAcmV0dXJuIHRoZSBtYXRjaGVkIHN5bWJvbFxuLy8gQHRocm93cyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiBpZiB0aGUgY3VycmVudCBpbnB1dCBzeW1ib2wgZGlkIG5vdCBtYXRjaFxuLy8gYSB3aWxkY2FyZCBhbmQgdGhlIGVycm9yIHN0cmF0ZWd5IGNvdWxkIG5vdCByZWNvdmVyIGZyb20gdGhlIG1pc21hdGNoZWRcbi8vIHN5bWJvbFxuXG5QYXJzZXIucHJvdG90eXBlLm1hdGNoV2lsZGNhcmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIHQgPSB0aGlzLmdldEN1cnJlbnRUb2tlbigpO1xuXHRpZiAodC50eXBlID4gMCkge1xuXHRcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG5cdFx0dGhpcy5jb25zdW1lKCk7XG5cdH0gZWxzZSB7XG5cdFx0dCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcblx0XHRpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcblx0XHRcdC8vIHdlIG11c3QgaGF2ZSBjb25qdXJlZCB1cCBhIG5ldyB0b2tlbiBkdXJpbmcgc2luZ2xlIHRva2VuXG5cdFx0XHQvLyBpbnNlcnRpb25cblx0XHRcdC8vIGlmIGl0J3Mgbm90IHRoZSBjdXJyZW50IHN5bWJvbFxuXHRcdFx0dGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHQ7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmdldFBhcnNlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9wYXJzZUxpc3RlbmVycyB8fCBbXTtcbn07XG5cbi8vIFJlZ2lzdGVycyB7QGNvZGUgbGlzdGVuZXJ9IHRvIHJlY2VpdmUgZXZlbnRzIGR1cmluZyB0aGUgcGFyc2luZyBwcm9jZXNzLlxuLy9cbi8vIDxwPlRvIHN1cHBvcnQgb3V0cHV0LXByZXNlcnZpbmcgZ3JhbW1hciB0cmFuc2Zvcm1hdGlvbnMgKGluY2x1ZGluZyBidXQgbm90XG4vLyBsaW1pdGVkIHRvIGxlZnQtcmVjdXJzaW9uIHJlbW92YWwsIGF1dG9tYXRlZCBsZWZ0LWZhY3RvcmluZywgYW5kXG4vLyBvcHRpbWl6ZWQgY29kZSBnZW5lcmF0aW9uKSwgY2FsbHMgdG8gbGlzdGVuZXIgbWV0aG9kcyBkdXJpbmcgdGhlIHBhcnNlXG4vLyBtYXkgZGlmZmVyIHN1YnN0YW50aWFsbHkgZnJvbSBjYWxscyBtYWRlIGJ5XG4vLyB7QGxpbmsgUGFyc2VUcmVlV2Fsa2VyLy9ERUZBVUxUfSB1c2VkIGFmdGVyIHRoZSBwYXJzZSBpcyBjb21wbGV0ZS4gSW5cbi8vIHBhcnRpY3VsYXIsIHJ1bGUgZW50cnkgYW5kIGV4aXQgZXZlbnRzIG1heSBvY2N1ciBpbiBhIGRpZmZlcmVudCBvcmRlclxuLy8gZHVyaW5nIHRoZSBwYXJzZSB0aGFuIGFmdGVyIHRoZSBwYXJzZXIuIEluIGFkZGl0aW9uLCBjYWxscyB0byBjZXJ0YWluXG4vLyBydWxlIGVudHJ5IG1ldGhvZHMgbWF5IGJlIG9taXR0ZWQuPC9wPlxuLy9cbi8vIDxwPldpdGggdGhlIGZvbGxvd2luZyBzcGVjaWZpYyBleGNlcHRpb25zLCBjYWxscyB0byBsaXN0ZW5lciBldmVudHMgYXJlXG4vLyA8ZW0+ZGV0ZXJtaW5pc3RpYzwvZW0+LCBpLmUuIGZvciBpZGVudGljYWwgaW5wdXQgdGhlIGNhbGxzIHRvIGxpc3RlbmVyXG4vLyBtZXRob2RzIHdpbGwgYmUgdGhlIHNhbWUuPC9wPlxuLy9cbi8vIDx1bD5cbi8vIDxsaT5BbHRlcmF0aW9ucyB0byB0aGUgZ3JhbW1hciB1c2VkIHRvIGdlbmVyYXRlIGNvZGUgbWF5IGNoYW5nZSB0aGVcbi8vIGJlaGF2aW9yIG9mIHRoZSBsaXN0ZW5lciBjYWxscy48L2xpPlxuLy8gPGxpPkFsdGVyYXRpb25zIHRvIHRoZSBjb21tYW5kIGxpbmUgb3B0aW9ucyBwYXNzZWQgdG8gQU5UTFIgNCB3aGVuXG4vLyBnZW5lcmF0aW5nIHRoZSBwYXJzZXIgbWF5IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGxpc3RlbmVyIGNhbGxzLjwvbGk+XG4vLyA8bGk+Q2hhbmdpbmcgdGhlIHZlcnNpb24gb2YgdGhlIEFOVExSIFRvb2wgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcGFyc2VyXG4vLyBtYXkgY2hhbmdlIHRoZSBiZWhhdmlvciBvZiB0aGUgbGlzdGVuZXIgY2FsbHMuPC9saT5cbi8vIDwvdWw+XG4vL1xuLy8gQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBhZGRcbi8vXG4vLyBAdGhyb3dzIE51bGxQb2ludGVyRXhjZXB0aW9uIGlmIHtAY29kZX0gbGlzdGVuZXIgaXMge0Bjb2RlIG51bGx9XG4vL1xuUGFyc2VyLnByb3RvdHlwZS5hZGRQYXJzZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0aWYgKGxpc3RlbmVyID09PSBudWxsKSB7XG5cdFx0dGhyb3cgXCJsaXN0ZW5lclwiO1xuXHR9XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyA9PT0gbnVsbCkge1xuXHRcdHRoaXMuX3BhcnNlTGlzdGVuZXJzID0gW107XG5cdH1cblx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59O1xuXG4vL1xuLy8gUmVtb3ZlIHtAY29kZSBsaXN0ZW5lcn0gZnJvbSB0aGUgbGlzdCBvZiBwYXJzZSBsaXN0ZW5lcnMuXG4vL1xuLy8gPHA+SWYge0Bjb2RlIGxpc3RlbmVyfSBpcyB7QGNvZGUgbnVsbH0gb3IgaGFzIG5vdCBiZWVuIGFkZGVkIGFzIGEgcGFyc2Vcbi8vIGxpc3RlbmVyLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuPC9wPlxuLy8gQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byByZW1vdmVcbi8vXG5QYXJzZXIucHJvdG90eXBlLnJlbW92ZVBhcnNlTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgIT09IG51bGwpIHtcblx0XHR2YXIgaWR4ID0gdGhpcy5fcGFyc2VMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH1cblx0fVxufTtcblxuLy8gUmVtb3ZlIGFsbCBwYXJzZSBsaXN0ZW5lcnMuXG5QYXJzZXIucHJvdG90eXBlLnJlbW92ZVBhcnNlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3BhcnNlTGlzdGVuZXJzID0gbnVsbDtcbn07XG5cbi8vIE5vdGlmeSBhbnkgcGFyc2UgbGlzdGVuZXJzIG9mIGFuIGVudGVyIHJ1bGUgZXZlbnQuXG5QYXJzZXIucHJvdG90eXBlLnRyaWdnZXJFbnRlclJ1bGVFdmVudCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5tYXAoZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKGN0eCk7XG5cdFx0XHRjdHguZW50ZXJSdWxlKGxpc3RlbmVyKTtcblx0XHR9KTtcblx0fVxufTtcblxuLy9cbi8vIE5vdGlmeSBhbnkgcGFyc2UgbGlzdGVuZXJzIG9mIGFuIGV4aXQgcnVsZSBldmVudC5cbi8vXG4vLyBAc2VlIC8vYWRkUGFyc2VMaXN0ZW5lclxuLy9cblBhcnNlci5wcm90b3R5cGUudHJpZ2dlckV4aXRSdWxlRXZlbnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0Ly8gcmV2ZXJzZSBvcmRlciB3YWxrIG9mIGxpc3RlbmVyc1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHRcdHRoaXMuX3BhcnNlTGlzdGVuZXJzLnNsaWNlKDApLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdGN0eC5leGl0UnVsZShsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lci5leGl0RXZlcnlSdWxlKGN0eCk7XG5cdFx0fSk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5GYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9pbnB1dC50b2tlblNvdXJjZS5fZmFjdG9yeTtcbn07XG5cbi8vIFRlbGwgb3VyIHRva2VuIHNvdXJjZSBhbmQgZXJyb3Igc3RyYXRlZ3kgYWJvdXQgYSBuZXcgd2F5IHRvIGNyZWF0ZSB0b2tlbnMuLy9cblBhcnNlci5wcm90b3R5cGUuc2V0VG9rZW5GYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuXHR0aGlzLl9pbnB1dC50b2tlblNvdXJjZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG59O1xuXG4vLyBUaGUgQVROIHdpdGggYnlwYXNzIGFsdGVybmF0aXZlcyBpcyBleHBlbnNpdmUgdG8gY3JlYXRlIHNvIHdlIGNyZWF0ZSBpdFxuLy8gbGF6aWx5LlxuLy9cbi8vIEB0aHJvd3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gaWYgdGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90XG4vLyBpbXBsZW1lbnQgdGhlIHtAbGluayAvL2dldFNlcmlhbGl6ZWRBVE4oKX0gbWV0aG9kLlxuLy9cblBhcnNlci5wcm90b3R5cGUuZ2V0QVROV2l0aEJ5cGFzc0FsdHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlcmlhbGl6ZWRBdG4gPSB0aGlzLmdldFNlcmlhbGl6ZWRBVE4oKTtcblx0aWYgKHNlcmlhbGl6ZWRBdG4gPT09IG51bGwpIHtcblx0XHR0aHJvdyBcIlRoZSBjdXJyZW50IHBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IGFuIEFUTiB3aXRoIGJ5cGFzcyBhbHRlcm5hdGl2ZXMuXCI7XG5cdH1cblx0dmFyIHJlc3VsdCA9IHRoaXMuYnlwYXNzQWx0c0F0bkNhY2hlW3NlcmlhbGl6ZWRBdG5dO1xuXHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0dmFyIGRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBuZXcgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucygpO1xuXHRcdGRlc2VyaWFsaXphdGlvbk9wdGlvbnMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSB0cnVlO1xuXHRcdHJlc3VsdCA9IG5ldyBBVE5EZXNlcmlhbGl6ZXIoZGVzZXJpYWxpemF0aW9uT3B0aW9ucylcblx0XHRcdFx0LmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRBdG4pO1xuXHRcdHRoaXMuYnlwYXNzQWx0c0F0bkNhY2hlW3NlcmlhbGl6ZWRBdG5dID0gcmVzdWx0O1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUaGUgcHJlZmVycmVkIG1ldGhvZCBvZiBnZXR0aW5nIGEgdHJlZSBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgaGVyZSdzIGFcbi8vIHNhbXBsZSB1c2U6XG4vL1xuLy8gPHByZT5cbi8vIFBhcnNlVHJlZSB0ID0gcGFyc2VyLmV4cHIoKTtcbi8vIFBhcnNlVHJlZVBhdHRlcm4gcCA9IHBhcnNlci5jb21waWxlUGFyc2VUcmVlUGF0dGVybihcIiZsdDtJRCZndDsrMFwiLFxuLy8gTXlQYXJzZXIuUlVMRV9leHByKTtcbi8vIFBhcnNlVHJlZU1hdGNoIG0gPSBwLm1hdGNoKHQpO1xuLy8gU3RyaW5nIGlkID0gbS5nZXQoXCJJRFwiKTtcbi8vIDwvcHJlPlxuXG52YXIgTGV4ZXIgPSByZXF1aXJlKCcuL0xleGVyJykuTGV4ZXI7XG5cblBhcnNlci5wcm90b3R5cGUuY29tcGlsZVBhcnNlVHJlZVBhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4LCBsZXhlcikge1xuXHRsZXhlciA9IGxleGVyIHx8IG51bGw7XG5cdGlmIChsZXhlciA9PT0gbnVsbCkge1xuXHRcdGlmICh0aGlzLmdldFRva2VuU3RyZWFtKCkgIT09IG51bGwpIHtcblx0XHRcdHZhciB0b2tlblNvdXJjZSA9IHRoaXMuZ2V0VG9rZW5TdHJlYW0oKS50b2tlblNvdXJjZTtcblx0XHRcdGlmICh0b2tlblNvdXJjZSBpbnN0YW5jZW9mIExleGVyKSB7XG5cdFx0XHRcdGxleGVyID0gdG9rZW5Tb3VyY2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChsZXhlciA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwiUGFyc2VyIGNhbid0IGRpc2NvdmVyIGEgbGV4ZXIgdG8gdXNlXCI7XG5cdH1cblx0dmFyIG0gPSBuZXcgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIobGV4ZXIsIHRoaXMpO1xuXHRyZXR1cm4gbS5jb21waWxlKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5nZXRJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5nZXRUb2tlblN0cmVhbSgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5zZXRJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHRoaXMuc2V0VG9rZW5TdHJlYW0oaW5wdXQpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5nZXRUb2tlblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5faW5wdXQ7XG59O1xuXG4vLyBTZXQgdGhlIHRva2VuIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHBhcnNlci4vL1xuUGFyc2VyLnByb3RvdHlwZS5zZXRUb2tlblN0cmVhbSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHRoaXMuX2lucHV0ID0gbnVsbDtcblx0dGhpcy5yZXNldCgpO1xuXHR0aGlzLl9pbnB1dCA9IGlucHV0O1xufTtcblxuLy8gTWF0Y2ggbmVlZHMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IGlucHV0IHN5bWJvbCwgd2hpY2ggZ2V0cyBwdXRcbi8vIGludG8gdGhlIGxhYmVsIGZvciB0aGUgYXNzb2NpYXRlZCB0b2tlbiByZWY7IGUuZy4sIHg9SUQuXG4vL1xuUGFyc2VyLnByb3RvdHlwZS5nZXRDdXJyZW50VG9rZW4gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2lucHV0LkxUKDEpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5ub3RpZnlFcnJvckxpc3RlbmVycyA9IGZ1bmN0aW9uKG1zZywgb2ZmZW5kaW5nVG9rZW4sIGVycikge1xuXHRvZmZlbmRpbmdUb2tlbiA9IG9mZmVuZGluZ1Rva2VuIHx8IG51bGw7XG5cdGVyciA9IGVyciB8fCBudWxsO1xuXHRpZiAob2ZmZW5kaW5nVG9rZW4gPT09IG51bGwpIHtcblx0XHRvZmZlbmRpbmdUb2tlbiA9IHRoaXMuZ2V0Q3VycmVudFRva2VuKCk7XG5cdH1cblx0dGhpcy5fc3ludGF4RXJyb3JzICs9IDE7XG5cdHZhciBsaW5lID0gb2ZmZW5kaW5nVG9rZW4ubGluZTtcblx0dmFyIGNvbHVtbiA9IG9mZmVuZGluZ1Rva2VuLmNvbHVtbjtcblx0dmFyIGxpc3RlbmVyID0gdGhpcy5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcblx0bGlzdGVuZXIuc3ludGF4RXJyb3IodGhpcywgb2ZmZW5kaW5nVG9rZW4sIGxpbmUsIGNvbHVtbiwgbXNnLCBlcnIpO1xufTtcblxuLy9cbi8vIENvbnN1bWUgYW5kIHJldHVybiB0aGUge0BsaW5rcGxhaW4gLy9nZXRDdXJyZW50VG9rZW4gY3VycmVudCBzeW1ib2x9LlxuLy9cbi8vIDxwPkUuZy4sIGdpdmVuIHRoZSBmb2xsb3dpbmcgaW5wdXQgd2l0aCB7QGNvZGUgQX0gYmVpbmcgdGhlIGN1cnJlbnRcbi8vIGxvb2thaGVhZCBzeW1ib2wsIHRoaXMgZnVuY3Rpb24gbW92ZXMgdGhlIGN1cnNvciB0byB7QGNvZGUgQn0gYW5kIHJldHVybnNcbi8vIHtAY29kZSBBfS48L3A+XG4vL1xuLy8gPHByZT5cbi8vIEEgQlxuLy8gXlxuLy8gPC9wcmU+XG4vL1xuLy8gSWYgdGhlIHBhcnNlciBpcyBub3QgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZSwgdGhlIGNvbnN1bWVkIHN5bWJvbCBpcyBhZGRlZFxuLy8gdG8gdGhlIHBhcnNlIHRyZWUgdXNpbmcge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0Ly9hZGRDaGlsZChUb2tlbil9LCBhbmRcbi8vIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lci8vdmlzaXRUZXJtaW5hbH0gaXMgY2FsbGVkIG9uIGFueSBwYXJzZSBsaXN0ZW5lcnMuXG4vLyBJZiB0aGUgcGFyc2VyIDxlbT5pczwvZW0+IGluIGVycm9yIHJlY292ZXJ5IG1vZGUsIHRoZSBjb25zdW1lZCBzeW1ib2wgaXNcbi8vIGFkZGVkIHRvIHRoZSBwYXJzZSB0cmVlIHVzaW5nXG4vLyB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQvL2FkZEVycm9yTm9kZShUb2tlbil9LCBhbmRcbi8vIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lci8vdmlzaXRFcnJvck5vZGV9IGlzIGNhbGxlZCBvbiBhbnkgcGFyc2Vcbi8vIGxpc3RlbmVycy5cbi8vXG5QYXJzZXIucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbigpIHtcblx0dmFyIG8gPSB0aGlzLmdldEN1cnJlbnRUb2tlbigpO1xuXHRpZiAoby50eXBlICE9PSBUb2tlbi5FT0YpIHtcblx0XHR0aGlzLmdldElucHV0U3RyZWFtKCkuY29uc3VtZSgpO1xuXHR9XG5cdHZhciBoYXNMaXN0ZW5lciA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsICYmIHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCA+IDA7XG5cdGlmICh0aGlzLmJ1aWxkUGFyc2VUcmVlcyB8fCBoYXNMaXN0ZW5lcikge1xuXHRcdHZhciBub2RlO1xuXHRcdGlmICh0aGlzLl9lcnJIYW5kbGVyLmluRXJyb3JSZWNvdmVyeU1vZGUodGhpcykpIHtcblx0XHRcdG5vZGUgPSB0aGlzLl9jdHguYWRkRXJyb3JOb2RlKG8pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy5fY3R4LmFkZFRva2VuTm9kZShvKTtcblx0XHR9XG4gICAgICAgIG5vZGUuaW52b2tpbmdTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cdFx0aWYgKGhhc0xpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5tYXAoZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBFcnJvck5vZGUgfHwgKG5vZGUuaXNFcnJvck5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlzRXJyb3JOb2RlKCkpKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXIudmlzaXRFcnJvck5vZGUobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyLnZpc2l0VGVybWluYWwobm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbztcbn07XG5cblBhcnNlci5wcm90b3R5cGUuYWRkQ29udGV4dFRvUGFyc2VUcmVlID0gZnVuY3Rpb24oKSB7XG5cdC8vIGFkZCBjdXJyZW50IGNvbnRleHQgdG8gcGFyZW50IGlmIHdlIGhhdmUgYSBwYXJlbnRcblx0aWYgKHRoaXMuX2N0eC5wYXJlbnRDdHggIT09IG51bGwpIHtcblx0XHR0aGlzLl9jdHgucGFyZW50Q3R4LmFkZENoaWxkKHRoaXMuX2N0eCk7XG5cdH1cbn07XG5cbi8vIEFsd2F5cyBjYWxsZWQgYnkgZ2VuZXJhdGVkIHBhcnNlcnMgdXBvbiBlbnRyeSB0byBhIHJ1bGUuIEFjY2VzcyBmaWVsZFxuLy8ge0BsaW5rIC8vX2N0eH0gZ2V0IHRoZSBjdXJyZW50IGNvbnRleHQuXG5cblBhcnNlci5wcm90b3R5cGUuZW50ZXJSdWxlID0gZnVuY3Rpb24obG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgpIHtcblx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcblx0dGhpcy5fY3R4LnN0YXJ0ID0gdGhpcy5faW5wdXQuTFQoMSk7XG5cdGlmICh0aGlzLmJ1aWxkUGFyc2VUcmVlcykge1xuXHRcdHRoaXMuYWRkQ29udGV4dFRvUGFyc2VUcmVlKCk7XG5cdH1cblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5leGl0UnVsZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcblx0Ly8gdHJpZ2dlciBldmVudCBvbiBfY3R4LCBiZWZvcmUgaXQgcmV2ZXJ0cyB0byBwYXJlbnRcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xuXHR9XG5cdHRoaXMuc3RhdGUgPSB0aGlzLl9jdHguaW52b2tpbmdTdGF0ZTtcblx0dGhpcy5fY3R4ID0gdGhpcy5fY3R4LnBhcmVudEN0eDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuZW50ZXJPdXRlckFsdCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBhbHROdW0pIHtcbiAgIFx0bG9jYWxjdHguc2V0QWx0TnVtYmVyKGFsdE51bSk7XG5cdC8vIGlmIHdlIGhhdmUgbmV3IGxvY2FsY3R4LCBtYWtlIHN1cmUgd2UgcmVwbGFjZSBleGlzdGluZyBjdHhcblx0Ly8gdGhhdCBpcyBwcmV2aW91cyBjaGlsZCBvZiBwYXJzZSB0cmVlXG5cdGlmICh0aGlzLmJ1aWxkUGFyc2VUcmVlcyAmJiB0aGlzLl9jdHggIT09IGxvY2FsY3R4KSB7XG5cdFx0aWYgKHRoaXMuX2N0eC5wYXJlbnRDdHggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2N0eC5wYXJlbnRDdHgucmVtb3ZlTGFzdENoaWxkKCk7XG5cdFx0XHR0aGlzLl9jdHgucGFyZW50Q3R4LmFkZENoaWxkKGxvY2FsY3R4KTtcblx0XHR9XG5cdH1cblx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XG59O1xuXG4vLyBHZXQgdGhlIHByZWNlZGVuY2UgbGV2ZWwgZm9yIHRoZSB0b3AtbW9zdCBwcmVjZWRlbmNlIHJ1bGUuXG4vL1xuLy8gQHJldHVybiBUaGUgcHJlY2VkZW5jZSBsZXZlbCBmb3IgdGhlIHRvcC1tb3N0IHByZWNlZGVuY2UgcnVsZSwgb3IgLTEgaWZcbi8vIHRoZSBwYXJzZXIgY29udGV4dCBpcyBub3QgbmVzdGVkIHdpdGhpbiBhIHByZWNlZGVuY2UgcnVsZS5cblxuUGFyc2VyLnByb3RvdHlwZS5nZXRQcmVjZWRlbmNlID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9wcmVjZWRlbmNlU3RhY2subGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLl9wcmVjZWRlbmNlU3RhY2tbdGhpcy5fcHJlY2VkZW5jZVN0YWNrLmxlbmd0aC0xXTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5lbnRlclJlY3Vyc2lvblJ1bGUgPSBmdW5jdGlvbihsb2NhbGN0eCwgc3RhdGUsIHJ1bGVJbmRleCxcblx0XHRwcmVjZWRlbmNlKSB7XG5cdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrLnB1c2gocHJlY2VkZW5jZSk7XG5cdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuXHR0aGlzLl9jdHguc3RhcnQgPSB0aGlzLl9pbnB1dC5MVCgxKTtcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTsgLy8gc2ltdWxhdGVzIHJ1bGUgZW50cnkgZm9yXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGxlZnQtcmVjdXJzaXZlIHJ1bGVzXG5cdH1cbn07XG5cbi8vXG4vLyBMaWtlIHtAbGluayAvL2VudGVyUnVsZX0gYnV0IGZvciByZWN1cnNpdmUgcnVsZXMuXG5cblBhcnNlci5wcm90b3R5cGUucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQgPSBmdW5jdGlvbihsb2NhbGN0eCwgc3RhdGUsIHJ1bGVJbmRleCkge1xuXHR2YXIgcHJldmlvdXMgPSB0aGlzLl9jdHg7XG5cdHByZXZpb3VzLnBhcmVudEN0eCA9IGxvY2FsY3R4O1xuXHRwcmV2aW91cy5pbnZva2luZ1N0YXRlID0gc3RhdGU7XG5cdHByZXZpb3VzLnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XG5cblx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XG5cdHRoaXMuX2N0eC5zdGFydCA9IHByZXZpb3VzLnN0YXJ0O1xuXHRpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMpIHtcblx0XHR0aGlzLl9jdHguYWRkQ2hpbGQocHJldmlvdXMpO1xuXHR9XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7IC8vIHNpbXVsYXRlcyBydWxlIGVudHJ5IGZvclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBsZWZ0LXJlY3Vyc2l2ZSBydWxlc1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzID0gZnVuY3Rpb24ocGFyZW50Q3R4KSB7XG5cdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wb3AoKTtcblx0dGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XG5cdHZhciByZXRDdHggPSB0aGlzLl9jdHg7IC8vIHNhdmUgY3VycmVudCBjdHggKHJldHVybiB2YWx1ZSlcblx0Ly8gdW5yb2xsIHNvIF9jdHggaXMgYXMgaXQgd2FzIGJlZm9yZSBjYWxsIHRvIHJlY3Vyc2l2ZSBtZXRob2Rcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0d2hpbGUgKHRoaXMuX2N0eCAhPT0gcGFyZW50Q3R4KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XG5cdFx0XHR0aGlzLl9jdHggPSB0aGlzLl9jdHgucGFyZW50Q3R4O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aGlzLl9jdHggPSBwYXJlbnRDdHg7XG5cdH1cblx0Ly8gaG9vayBpbnRvIHRyZWVcblx0cmV0Q3R4LnBhcmVudEN0eCA9IHBhcmVudEN0eDtcblx0aWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzICYmIHBhcmVudEN0eCAhPT0gbnVsbCkge1xuXHRcdC8vIGFkZCByZXR1cm4gY3R4IGludG8gaW52b2tpbmcgcnVsZSdzIHRyZWVcblx0XHRwYXJlbnRDdHguYWRkQ2hpbGQocmV0Q3R4KTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5nZXRJbnZva2luZ0NvbnRleHQgPSBmdW5jdGlvbihydWxlSW5kZXgpIHtcblx0dmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0d2hpbGUgKGN0eCAhPT0gbnVsbCkge1xuXHRcdGlmIChjdHgucnVsZUluZGV4ID09PSBydWxlSW5kZXgpIHtcblx0XHRcdHJldHVybiBjdHg7XG5cdFx0fVxuXHRcdGN0eCA9IGN0eC5wYXJlbnRDdHg7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnByZWNwcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWNlZGVuY2UpIHtcblx0cmV0dXJuIHByZWNlZGVuY2UgPj0gdGhpcy5fcHJlY2VkZW5jZVN0YWNrW3RoaXMuX3ByZWNlZGVuY2VTdGFjay5sZW5ndGgtMV07XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmluQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Ly8gVE9ETzogdXNlZnVsIGluIHBhcnNlcj9cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLy9cbi8vIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB7QGNvZGUgc3ltYm9sfSBjYW4gZm9sbG93IHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZVxuLy8gQVROLiBUaGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nLCBidXQgaXNcbi8vIGltcGxlbWVudGVkIHN1Y2ggdGhhdCB0aGUgY29tcGxldGUgY29udGV4dC1zZW5zaXRpdmUgZm9sbG93IHNldCBkb2VzIG5vdFxuLy8gbmVlZCB0byBiZSBleHBsaWNpdGx5IGNvbnN0cnVjdGVkLlxuLy9cbi8vIDxwcmU+XG4vLyByZXR1cm4gZ2V0RXhwZWN0ZWRUb2tlbnMoKS5jb250YWlucyhzeW1ib2wpO1xuLy8gPC9wcmU+XG4vL1xuLy8gQHBhcmFtIHN5bWJvbCB0aGUgc3ltYm9sIHR5cGUgdG8gY2hlY2tcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIHtAY29kZSBzeW1ib2x9IGNhbiBmb2xsb3cgdGhlIGN1cnJlbnQgc3RhdGUgaW5cbi8vIHRoZSBBVE4sIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9LlxuXG5QYXJzZXIucHJvdG90eXBlLmlzRXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHR2YXIgYXRuID0gdGhpcy5faW50ZXJwLmF0bjtcblx0dmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0dmFyIHMgPSBhdG4uc3RhdGVzW3RoaXMuc3RhdGVdO1xuXHR2YXIgZm9sbG93aW5nID0gYXRuLm5leHRUb2tlbnMocyk7XG5cdGlmIChmb2xsb3dpbmcuY29udGFpbnMoc3ltYm9sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHdoaWxlIChjdHggIT09IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCAmJiBmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikpIHtcblx0XHR2YXIgaW52b2tpbmdTdGF0ZSA9IGF0bi5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xuXHRcdHZhciBydCA9IGludm9raW5nU3RhdGUudHJhbnNpdGlvbnNbMF07XG5cdFx0Zm9sbG93aW5nID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xuXHRcdGlmIChmb2xsb3dpbmcuY29udGFpbnMoc3ltYm9sKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGN0eCA9IGN0eC5wYXJlbnRDdHg7XG5cdH1cblx0aWYgKGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSAmJiBzeW1ib2wgPT09IFRva2VuLkVPRikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHNldCBvZiBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyB0aGUgY3VycmVudCBwYXJzZXJcbi8vIHN0YXRlIGFuZCBjb250ZXh0LCBhcyBnaXZlbiBieSB7QGxpbmsgLy9nZXRTdGF0ZX0gYW5kIHtAbGluayAvL2dldENvbnRleHR9LFxuLy8gcmVzcGVjdGl2ZWx5LlxuLy9cbi8vIEBzZWUgQVROLy9nZXRFeHBlY3RlZFRva2VucyhpbnQsIFJ1bGVDb250ZXh0KVxuLy9cblBhcnNlci5wcm90b3R5cGUuZ2V0RXhwZWN0ZWRUb2tlbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2ludGVycC5hdG4uZ2V0RXhwZWN0ZWRUb2tlbnModGhpcy5zdGF0ZSwgdGhpcy5fY3R4KTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuZ2V0RXhwZWN0ZWRUb2tlbnNXaXRoaW5DdXJyZW50UnVsZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYXRuID0gdGhpcy5faW50ZXJwLmF0bjtcblx0dmFyIHMgPSBhdG4uc3RhdGVzW3RoaXMuc3RhdGVdO1xuXHRyZXR1cm4gYXRuLm5leHRUb2tlbnMocyk7XG59O1xuXG4vLyBHZXQgYSBydWxlJ3MgaW5kZXggKGkuZS4sIHtAY29kZSBSVUxFX3J1bGVOYW1lfSBmaWVsZCkgb3IgLTEgaWYgbm90IGZvdW5kLi8vXG5QYXJzZXIucHJvdG90eXBlLmdldFJ1bGVJbmRleCA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG5cdHZhciBydWxlSW5kZXggPSB0aGlzLmdldFJ1bGVJbmRleE1hcCgpW3J1bGVOYW1lXTtcblx0aWYgKHJ1bGVJbmRleCAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBydWxlSW5kZXg7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG59O1xuXG4vLyBSZXR1cm4gTGlzdCZsdDtTdHJpbmcmZ3Q7IG9mIHRoZSBydWxlIG5hbWVzIGluIHlvdXIgcGFyc2VyIGluc3RhbmNlXG4vLyBsZWFkaW5nIHVwIHRvIGEgY2FsbCB0byB0aGUgY3VycmVudCBydWxlLiBZb3UgY291bGQgb3ZlcnJpZGUgaWZcbi8vIHlvdSB3YW50IG1vcmUgZGV0YWlscyBzdWNoIGFzIHRoZSBmaWxlL2xpbmUgaW5mbyBvZiB3aGVyZVxuLy8gaW4gdGhlIEFUTiBhIHJ1bGUgaXMgaW52b2tlZC5cbi8vXG4vLyB0aGlzIGlzIHZlcnkgdXNlZnVsIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vXG5QYXJzZXIucHJvdG90eXBlLmdldFJ1bGVJbnZvY2F0aW9uU3RhY2sgPSBmdW5jdGlvbihwKSB7XG5cdHAgPSBwIHx8IG51bGw7XG5cdGlmIChwID09PSBudWxsKSB7XG5cdFx0cCA9IHRoaXMuX2N0eDtcblx0fVxuXHR2YXIgc3RhY2sgPSBbXTtcblx0d2hpbGUgKHAgIT09IG51bGwpIHtcblx0XHQvLyBjb21wdXRlIHdoYXQgZm9sbG93cyB3aG8gaW52b2tlZCB1c1xuXHRcdHZhciBydWxlSW5kZXggPSBwLnJ1bGVJbmRleDtcblx0XHRpZiAocnVsZUluZGV4IDwgMCkge1xuXHRcdFx0c3RhY2sucHVzaChcIm4vYVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhY2sucHVzaCh0aGlzLnJ1bGVOYW1lc1tydWxlSW5kZXhdKTtcblx0XHR9XG5cdFx0cCA9IHAucGFyZW50Q3R4O1xuXHR9XG5cdHJldHVybiBzdGFjaztcbn07XG5cbi8vIEZvciBkZWJ1Z2dpbmcgYW5kIG90aGVyIHB1cnBvc2VzLi8vXG5QYXJzZXIucHJvdG90eXBlLmdldERGQVN0cmluZ3MgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2ludGVycC5kZWNpc2lvblRvREZBLnRvU3RyaW5nKCk7XG59O1xuLy8gRm9yIGRlYnVnZ2luZyBhbmQgb3RoZXIgcHVycG9zZXMuLy9cblBhcnNlci5wcm90b3R5cGUuZHVtcERGQSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2Vlbk9uZSA9IGZhbHNlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludGVycC5kZWNpc2lvblRvREZBLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGRmYSA9IHRoaXMuX2ludGVycC5kZWNpc2lvblRvREZBW2ldO1xuXHRcdGlmIChkZmEuc3RhdGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChzZWVuT25lKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByaW50ZXIucHJpbnRsbihcIkRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIpO1xuXHRcdFx0dGhpcy5wcmludGVyLnByaW50KGRmYS50b1N0cmluZyh0aGlzLmxpdGVyYWxOYW1lcywgdGhpcy5zeW1ib2xpY05hbWVzKSk7XG5cdFx0XHRzZWVuT25lID0gdHJ1ZTtcblx0XHR9XG5cdH1cbn07XG5cbi8qXG5cIlx0XHRcdHByaW50ZXIgPSBmdW5jdGlvbigpIHtcXHJcXG5cIiArXG5cIlx0XHRcdFx0dGhpcy5wcmludGxuID0gZnVuY3Rpb24ocykgeyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3V0cHV0JykgKz0gcyArICdcXFxcbic7IH1cXHJcXG5cIiArXG5cIlx0XHRcdFx0dGhpcy5wcmludCA9IGZ1bmN0aW9uKHMpIHsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpICs9IHM7IH1cXHJcXG5cIiArXG5cIlx0XHRcdH07XFxyXFxuXCIgK1xuKi9cblxuUGFyc2VyLnByb3RvdHlwZS5nZXRTb3VyY2VOYW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9pbnB1dC5zb3VyY2VOYW1lO1xufTtcblxuLy8gRHVyaW5nIGEgcGFyc2UgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBsaXN0ZW4gaW4gb24gdGhlIHJ1bGUgZW50cnkgYW5kIGV4aXRcbi8vIGV2ZW50cyBhcyB3ZWxsIGFzIHRva2VuIG1hdGNoZXMuIHRoaXMgaXMgZm9yIHF1aWNrIGFuZCBkaXJ0eSBkZWJ1Z2dpbmcuXG4vL1xuUGFyc2VyLnByb3RvdHlwZS5zZXRUcmFjZSA9IGZ1bmN0aW9uKHRyYWNlKSB7XG5cdGlmICghdHJhY2UpIHtcblx0XHR0aGlzLnJlbW92ZVBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcblx0XHR0aGlzLl90cmFjZXIgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0aGlzLl90cmFjZXIgIT09IG51bGwpIHtcblx0XHRcdHRoaXMucmVtb3ZlUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xuXHRcdH1cblx0XHR0aGlzLl90cmFjZXIgPSBuZXcgVHJhY2VMaXN0ZW5lcih0aGlzKTtcblx0XHR0aGlzLmFkZFBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcblx0fVxufTtcblxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW50bHI0L1BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIiwiLy8gR2VuZXJhdGVkIGZyb20gQy5nNCBieSBBTlRMUiA0LjcuMVxyXG4vLyBqc2hpbnQgaWdub3JlOiBzdGFydFxyXG52YXIgYW50bHI0ID0gcmVxdWlyZSgnYW50bHI0L2luZGV4Jyk7XHJcblxyXG5cclxudmFyIHNlcmlhbGl6ZWRBVE4gPSBbXCJcXHUwMDAzXFx1NjA4YlxcdWE3MmFcXHU4MTMzXFx1YjllZFxcdTQxN2NcXHUzYmU3XFx1Nzc4NlxcdTU5NjRcIixcclxuICAgIFwiXFx1MDAwMndcXHUwNTM4XFxiXFx1MDAwMVxcdTAwMDRcXHUwMDAyXFx0XFx1MDAwMlxcdTAwMDRcXHUwMDAzXFx0XFx1MDAwM1xcdTAwMDRcIixcclxuICAgIFwiXFx1MDAwNFxcdFxcdTAwMDRcXHUwMDA0XFx1MDAwNVxcdFxcdTAwMDVcXHUwMDA0XFx1MDAwNlxcdFxcdTAwMDZcXHUwMDA0XFx1MDAwN1xcdFwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAwNFxcYlxcdFxcYlxcdTAwMDRcXHRcXHRcXHRcXHUwMDA0XFxuXFx0XFxuXFx1MDAwNFxcdTAwMGJcXHRcXHUwMDBiXFx1MDAwNFwiLFxyXG4gICAgXCJcXGZcXHRcXGZcXHUwMDA0XFxyXFx0XFxyXFx1MDAwNFxcdTAwMGVcXHRcXHUwMDBlXFx1MDAwNFxcdTAwMGZcXHRcXHUwMDBmXFx1MDAwNFxcdTAwMTBcIixcclxuICAgIFwiXFx0XFx1MDAxMFxcdTAwMDRcXHUwMDExXFx0XFx1MDAxMVxcdTAwMDRcXHUwMDEyXFx0XFx1MDAxMlxcdTAwMDRcXHUwMDEzXFx0XFx1MDAxM1wiLFxyXG4gICAgXCJcXHUwMDA0XFx1MDAxNFxcdFxcdTAwMTRcXHUwMDA0XFx1MDAxNVxcdFxcdTAwMTVcXHUwMDA0XFx1MDAxNlxcdFxcdTAwMTZcXHUwMDA0XFx1MDAxN1wiLFxyXG4gICAgXCJcXHRcXHUwMDE3XFx1MDAwNFxcdTAwMThcXHRcXHUwMDE4XFx1MDAwNFxcdTAwMTlcXHRcXHUwMDE5XFx1MDAwNFxcdTAwMWFcXHRcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMDRcXHUwMDFiXFx0XFx1MDAxYlxcdTAwMDRcXHUwMDFjXFx0XFx1MDAxY1xcdTAwMDRcXHUwMDFkXFx0XFx1MDAxZFxcdTAwMDRcXHUwMDFlXCIsXHJcbiAgICBcIlxcdFxcdTAwMWVcXHUwMDA0XFx1MDAxZlxcdFxcdTAwMWZcXHUwMDA0IFxcdCBcXHUwMDA0IVxcdCFcXHUwMDA0XFxcIlxcdFxcXCJcXHUwMDA0I1wiLFxyXG4gICAgXCJcXHQjXFx1MDAwNCRcXHQkXFx1MDAwNCVcXHQlXFx1MDAwNCZcXHQmXFx1MDAwNFxcJ1xcdFxcJ1xcdTAwMDQoXFx0KFxcdTAwMDQpXFx0KVxcdTAwMDRcIixcclxuICAgIFwiKlxcdCpcXHUwMDA0K1xcdCtcXHUwMDA0LFxcdCxcXHUwMDA0LVxcdC1cXHUwMDA0LlxcdC5cXHUwMDA0L1xcdC9cXHUwMDA0MFxcdDBcXHUwMDA0XCIsXHJcbiAgICBcIjFcXHQxXFx1MDAwNDJcXHQyXFx1MDAwNDNcXHQzXFx1MDAwNDRcXHQ0XFx1MDAwNDVcXHQ1XFx1MDAwNDZcXHQ2XFx1MDAwNDdcXHQ3XFx1MDAwNFwiLFxyXG4gICAgXCI4XFx0OFxcdTAwMDQ5XFx0OVxcdTAwMDQ6XFx0OlxcdTAwMDQ7XFx0O1xcdTAwMDQ8XFx0PFxcdTAwMDQ9XFx0PVxcdTAwMDQ+XFx0PlxcdTAwMDRcIixcclxuICAgIFwiP1xcdD9cXHUwMDA0QFxcdEBcXHUwMDA0QVxcdEFcXHUwMDA0QlxcdEJcXHUwMDA0Q1xcdENcXHUwMDA0RFxcdERcXHUwMDA0RVxcdEVcXHUwMDA0XCIsXHJcbiAgICBcIkZcXHRGXFx1MDAwNEdcXHRHXFx1MDAwNEhcXHRIXFx1MDAwNElcXHRJXFx1MDAwNEpcXHRKXFx1MDAwNEtcXHRLXFx1MDAwNExcXHRMXFx1MDAwNFwiLFxyXG4gICAgXCJNXFx0TVxcdTAwMDROXFx0TlxcdTAwMDRPXFx0T1xcdTAwMDRQXFx0UFxcdTAwMDRRXFx0UVxcdTAwMDRSXFx0UlxcdTAwMDRTXFx0U1xcdTAwMDRcIixcclxuICAgIFwiVFxcdFRcXHUwMDA0VVxcdFVcXHUwMDA0VlxcdFZcXHUwMDA0V1xcdFdcXHUwMDA0WFxcdFhcXHUwMDA0WVxcdFlcXHUwMDA0WlxcdFpcXHUwMDA0XCIsXHJcbiAgICBcIltcXHRbXFx1MDAwNFxcXFxcXHRcXFxcXFx1MDAwNF1cXHRdXFx1MDAwNF5cXHReXFx1MDAwNF9cXHRfXFx1MDAwNGBcXHRgXFx1MDAwNGFcXHRhXFx1MDAwNFwiLFxyXG4gICAgXCJiXFx0YlxcdTAwMDRjXFx0Y1xcdTAwMDRkXFx0ZFxcdTAwMDRlXFx0ZVxcdTAwMDRmXFx0ZlxcdTAwMDRnXFx0Z1xcdTAwMDRoXFx0aFxcdTAwMDRcIixcclxuICAgIFwiaVxcdGlcXHUwMDA0alxcdGpcXHUwMDA0a1xcdGtcXHUwMDA0bFxcdGxcXHUwMDA0bVxcdG1cXHUwMDA0blxcdG5cXHUwMDA0b1xcdG9cXHUwMDA0XCIsXHJcbiAgICBcInBcXHRwXFx1MDAwNHFcXHRxXFx1MDAwNHJcXHRyXFx1MDAwNHNcXHRzXFx1MDAwNHRcXHR0XFx1MDAwNHVcXHR1XFx1MDAwNHZcXHR2XFx1MDAwNFwiLFxyXG4gICAgXCJ3XFx0d1xcdTAwMDR4XFx0eFxcdTAwMDR5XFx0eVxcdTAwMDR6XFx0elxcdTAwMDR7XFx0e1xcdTAwMDR8XFx0fFxcdTAwMDR9XFx0fVxcdTAwMDRcIixcclxuICAgIFwiflxcdH5cXHUwMDA0XFx1MDA3ZlxcdFxcdTAwN2ZcXHUwMDA0XFx1MDA4MFxcdFxcdTAwODBcXHUwMDA0XFx1MDA4MVxcdFxcdTAwODFcXHUwMDA0XCIsXHJcbiAgICBcIlxcdTAwODJcXHRcXHUwMDgyXFx1MDAwNFxcdTAwODNcXHRcXHUwMDgzXFx1MDAwNFxcdTAwODRcXHRcXHUwMDg0XFx1MDAwNFxcdTAwODVcXHRcIixcclxuICAgIFwiXFx1MDA4NVxcdTAwMDRcXHUwMDg2XFx0XFx1MDA4NlxcdTAwMDRcXHUwMDg3XFx0XFx1MDA4N1xcdTAwMDRcXHUwMDg4XFx0XFx1MDA4OFxcdTAwMDRcIixcclxuICAgIFwiXFx1MDA4OVxcdFxcdTAwODlcXHUwMDA0XFx1MDA4YVxcdFxcdTAwOGFcXHUwMDA0XFx1MDA4YlxcdFxcdTAwOGJcXHUwMDA0XFx1MDA4Y1xcdFwiLFxyXG4gICAgXCJcXHUwMDhjXFx1MDAwNFxcdTAwOGRcXHRcXHUwMDhkXFx1MDAwNFxcdTAwOGVcXHRcXHUwMDhlXFx1MDAwNFxcdTAwOGZcXHRcXHUwMDhmXFx1MDAwNFwiLFxyXG4gICAgXCJcXHUwMDkwXFx0XFx1MDA5MFxcdTAwMDRcXHUwMDkxXFx0XFx1MDA5MVxcdTAwMDRcXHUwMDkyXFx0XFx1MDA5MlxcdTAwMDRcXHUwMDkzXFx0XCIsXHJcbiAgICBcIlxcdTAwOTNcXHUwMDA0XFx1MDA5NFxcdFxcdTAwOTRcXHUwMDA0XFx1MDA5NVxcdFxcdTAwOTVcXHUwMDA0XFx1MDA5NlxcdFxcdTAwOTZcXHUwMDA0XCIsXHJcbiAgICBcIlxcdTAwOTdcXHRcXHUwMDk3XFx1MDAwNFxcdTAwOThcXHRcXHUwMDk4XFx1MDAwNFxcdTAwOTlcXHRcXHUwMDk5XFx1MDAwNFxcdTAwOWFcXHRcIixcclxuICAgIFwiXFx1MDA5YVxcdTAwMDRcXHUwMDliXFx0XFx1MDA5YlxcdTAwMDRcXHUwMDljXFx0XFx1MDA5Y1xcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwNFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDVcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA3XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcYlwiLFxyXG4gICAgXCJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcIixcclxuICAgIFwiXFxiXFx1MDAwM1xcYlxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXHRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdFxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1wiLFxyXG4gICAgXCJcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXFxmXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcZlxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMGZcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXFx1MDAxMVxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXFx1MDAxMVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTJcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTNcXHUwMDAzXFx1MDAxM1xcdTAwMDNcXHUwMDEzXFx1MDAwM1xcdTAwMTNcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTVcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxOFxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMThcXHUwMDAzXFx1MDAxOVxcdTAwMDNcXHUwMDE5XFx1MDAwM1xcdTAwMTlcXHUwMDAzXFx1MDAxOVxcdTAwMDNcXHUwMDE5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDFhXFx1MDAwM1xcdTAwMWFcXHUwMDAzXFx1MDAxYVxcdTAwMDNcXHUwMDFhXFx1MDAwM1xcdTAwMWFcXHUwMDAzXFx1MDAxYlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxYlxcdTAwMDNcXHUwMDFiXFx1MDAwM1xcdTAwMWJcXHUwMDAzXFx1MDAxYlxcdTAwMDNcXHUwMDFiXFx1MDAwM1xcdTAwMWJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWNcXHUwMDAzXFx1MDAxY1xcdTAwMDNcXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDAzXFx1MDAxY1xcdTAwMDNcXHUwMDFjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDFkXFx1MDAwM1xcdTAwMWRcXHUwMDAzXFx1MDAxZFxcdTAwMDNcXHUwMDFkXFx1MDAwM1xcdTAwMWVcXHUwMDAzXFx1MDAxZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxZVxcdTAwMDNcXHUwMDFlXFx1MDAwM1xcdTAwMWVcXHUwMDAzXFx1MDAxZlxcdTAwMDNcXHUwMDFmXFx1MDAwM1xcdTAwMWZcXHUwMDAzXCIsXHJcbiAgICBcIiBcXHUwMDAzIFxcdTAwMDMgXFx1MDAwMyBcXHUwMDAzIFxcdTAwMDMgXFx1MDAwMyBcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzXCIsXHJcbiAgICBcIiFcXHUwMDAzXFxcIlxcdTAwMDNcXFwiXFx1MDAwM1xcXCJcXHUwMDAzXFxcIlxcdTAwMDNcXFwiXFx1MDAwMyNcXHUwMDAzI1xcdTAwMDMjXFx1MDAwM1wiLFxyXG4gICAgXCIjXFx1MDAwMyNcXHUwMDAzI1xcdTAwMDMjXFx1MDAwMyNcXHUwMDAzI1xcdTAwMDMkXFx1MDAwMyRcXHUwMDAzJFxcdTAwMDMkXFx1MDAwM1wiLFxyXG4gICAgXCIkXFx1MDAwMyRcXHUwMDAzJFxcdTAwMDMkXFx1MDAwMyRcXHUwMDAzJVxcdTAwMDMlXFx1MDAwMyVcXHUwMDAzJVxcdTAwMDMlXFx1MDAwM1wiLFxyXG4gICAgXCIlXFx1MDAwMyVcXHUwMDAzJlxcdTAwMDMmXFx1MDAwMyZcXHUwMDAzJlxcdTAwMDMmXFx1MDAwMyZcXHUwMDAzXFwnXFx1MDAwM1xcJ1xcdTAwMDNcIixcclxuICAgIFwiXFwnXFx1MDAwM1xcJ1xcdTAwMDNcXCdcXHUwMDAzXFwnXFx1MDAwM1xcJ1xcdTAwMDMoXFx1MDAwMyhcXHUwMDAzKFxcdTAwMDMoXFx1MDAwM1wiLFxyXG4gICAgXCIoXFx1MDAwMyhcXHUwMDAzKFxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwM1wiLFxyXG4gICAgXCIqXFx1MDAwMypcXHUwMDAzKlxcdTAwMDMqXFx1MDAwMypcXHUwMDAzKlxcdTAwMDMqXFx1MDAwMytcXHUwMDAzK1xcdTAwMDMrXFx1MDAwM1wiLFxyXG4gICAgXCIrXFx1MDAwMytcXHUwMDAzK1xcdTAwMDMrXFx1MDAwMyxcXHUwMDAzLFxcdTAwMDMsXFx1MDAwMyxcXHUwMDAzLFxcdTAwMDMsXFx1MDAwM1wiLFxyXG4gICAgXCIsXFx1MDAwMyxcXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy1cXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy1cXHUwMDAzLlxcdTAwMDMuXFx1MDAwM1wiLFxyXG4gICAgXCIuXFx1MDAwMy5cXHUwMDAzLlxcdTAwMDMuXFx1MDAwMy5cXHUwMDAzLlxcdTAwMDMuXFx1MDAwMy9cXHUwMDAzL1xcdTAwMDMvXFx1MDAwM1wiLFxyXG4gICAgXCIvXFx1MDAwMy9cXHUwMDAzMFxcdTAwMDMwXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDMwXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDMwXFx1MDAwM1wiLFxyXG4gICAgXCIwXFx1MDAwMzFcXHUwMDAzMVxcdTAwMDMxXFx1MDAwMzFcXHUwMDAzMVxcdTAwMDMxXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwM1wiLFxyXG4gICAgXCIyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMzXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDMzXFx1MDAwM1wiLFxyXG4gICAgXCIzXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDMzXFx1MDAwMzNcXHUwMDAzNFxcdTAwMDM0XFx1MDAwMzRcXHUwMDAzNFxcdTAwMDM0XFx1MDAwM1wiLFxyXG4gICAgXCI0XFx1MDAwMzRcXHUwMDAzNFxcdTAwMDM1XFx1MDAwMzVcXHUwMDAzNVxcdTAwMDM1XFx1MDAwMzVcXHUwMDAzNVxcdTAwMDM2XFx1MDAwM1wiLFxyXG4gICAgXCI2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzN1xcdTAwMDM3XFx1MDAwM1wiLFxyXG4gICAgXCI3XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwM1wiLFxyXG4gICAgXCI4XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDAzOVxcdTAwMDM5XFx1MDAwM1wiLFxyXG4gICAgXCI5XFx1MDAwMzlcXHUwMDAzOVxcdTAwMDM5XFx1MDAwMzlcXHUwMDAzOVxcdTAwMDM5XFx1MDAwMzlcXHUwMDAzOlxcdTAwMDM6XFx1MDAwM1wiLFxyXG4gICAgXCI6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwM1wiLFxyXG4gICAgXCI6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM7XFx1MDAwMztcXHUwMDAzO1xcdTAwMDM7XFx1MDAwMztcXHUwMDAzO1xcdTAwMDM7XFx1MDAwM1wiLFxyXG4gICAgXCI7XFx1MDAwMztcXHUwMDAzO1xcdTAwMDM7XFx1MDAwMztcXHUwMDAzO1xcdTAwMDM7XFx1MDAwMzxcXHUwMDAzPFxcdTAwMDM9XFx1MDAwM1wiLFxyXG4gICAgXCI9XFx1MDAwMz5cXHUwMDAzPlxcdTAwMDM/XFx1MDAwMz9cXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0FcXHUwMDAzQVxcdTAwMDNCXFx1MDAwM1wiLFxyXG4gICAgXCJCXFx1MDAwM0NcXHUwMDAzQ1xcdTAwMDNDXFx1MDAwM0RcXHUwMDAzRFxcdTAwMDNFXFx1MDAwM0VcXHUwMDAzRVxcdTAwMDNGXFx1MDAwM1wiLFxyXG4gICAgXCJGXFx1MDAwM0ZcXHUwMDAzR1xcdTAwMDNHXFx1MDAwM0dcXHUwMDAzSFxcdTAwMDNIXFx1MDAwM0lcXHUwMDAzSVxcdTAwMDNJXFx1MDAwM1wiLFxyXG4gICAgXCJKXFx1MDAwM0pcXHUwMDAzS1xcdTAwMDNLXFx1MDAwM0tcXHUwMDAzTFxcdTAwMDNMXFx1MDAwM01cXHUwMDAzTVxcdTAwMDNOXFx1MDAwM1wiLFxyXG4gICAgXCJOXFx1MDAwM09cXHUwMDAzT1xcdTAwMDNQXFx1MDAwM1BcXHUwMDAzUVxcdTAwMDNRXFx1MDAwM1FcXHUwMDAzUlxcdTAwMDNSXFx1MDAwM1wiLFxyXG4gICAgXCJSXFx1MDAwM1NcXHUwMDAzU1xcdTAwMDNUXFx1MDAwM1RcXHUwMDAzVVxcdTAwMDNVXFx1MDAwM1ZcXHUwMDAzVlxcdTAwMDNXXFx1MDAwM1wiLFxyXG4gICAgXCJXXFx1MDAwM1hcXHUwMDAzWFxcdTAwMDNZXFx1MDAwM1lcXHUwMDAzWlxcdTAwMDNaXFx1MDAwM1tcXHUwMDAzW1xcdTAwMDNbXFx1MDAwM1wiLFxyXG4gICAgXCJcXFxcXFx1MDAwM1xcXFxcXHUwMDAzXFxcXFxcdTAwMDNdXFx1MDAwM11cXHUwMDAzXVxcdTAwMDNeXFx1MDAwM15cXHUwMDAzXlxcdTAwMDNfXCIsXHJcbiAgICBcIlxcdTAwMDNfXFx1MDAwM19cXHUwMDAzYFxcdTAwMDNgXFx1MDAwM2BcXHUwMDAzYFxcdTAwMDNhXFx1MDAwM2FcXHUwMDAzYVxcdTAwMDNcIixcclxuICAgIFwiYVxcdTAwMDNiXFx1MDAwM2JcXHUwMDAzYlxcdTAwMDNjXFx1MDAwM2NcXHUwMDAzY1xcdTAwMDNkXFx1MDAwM2RcXHUwMDAzZFxcdTAwMDNcIixcclxuICAgIFwiZVxcdTAwMDNlXFx1MDAwM2VcXHUwMDAzZlxcdTAwMDNmXFx1MDAwM2ZcXHUwMDAzZ1xcdTAwMDNnXFx1MDAwM2dcXHUwMDAzaFxcdTAwMDNcIixcclxuICAgIFwiaFxcdTAwMDNpXFx1MDAwM2lcXHUwMDAzaVxcdTAwMDNpXFx1MDAwM2pcXHUwMDAzalxcdTAwMDNqXFx1MDAwN2pcXHUwMzg5XFxualxcZlwiLFxyXG4gICAgXCJqXFx1MDAwZWpcXHUwMzhjXFx1MDAwYmpcXHUwMDAza1xcdTAwMDNrXFx1MDAwNWtcXHUwMzkwXFxua1xcdTAwMDNsXFx1MDAwM2xcXHUwMDAzXCIsXHJcbiAgICBcIm1cXHUwMDAzbVxcdTAwMDNuXFx1MDAwM25cXHUwMDAzblxcdTAwMDNuXFx1MDAwM25cXHUwMDAzblxcdTAwMDNuXFx1MDAwM25cXHUwMDAzXCIsXHJcbiAgICBcIm5cXHUwMDAzblxcdTAwMDVuXFx1MDNhMFxcbm5cXHUwMDAzb1xcdTAwMDNvXFx1MDAwM29cXHUwMDAzb1xcdTAwMDNvXFx1MDAwM3BcXHUwMDAzXCIsXHJcbiAgICBcInBcXHUwMDAzcFxcdTAwMDVwXFx1MDNhYVxcbnBcXHUwMDAzcVxcdTAwMDNxXFx1MDAwNXFcXHUwM2FlXFxucVxcdTAwMDNxXFx1MDAwM1wiLFxyXG4gICAgXCJxXFx1MDAwNXFcXHUwM2IyXFxucVxcdTAwMDNxXFx1MDAwM3FcXHUwMDA1cVxcdTAzYjZcXG5xXFx1MDAwM3FcXHUwMDA1cVxcdTAzYjlcIixcclxuICAgIFwiXFxucVxcdTAwMDNyXFx1MDAwM3JcXHUwMDAzclxcdTAwMDZyXFx1MDNiZVxcbnJcXHJyXFx1MDAwZXJcXHUwM2JmXFx1MDAwM3NcXHUwMDAzXCIsXHJcbiAgICBcInNcXHUwMDA3c1xcdTAzYzRcXG5zXFxmc1xcdTAwMGVzXFx1MDNjN1xcdTAwMGJzXFx1MDAwM3RcXHUwMDAzdFxcdTAwMDd0XFx1MDNjYlwiLFxyXG4gICAgXCJcXG50XFxmdFxcdTAwMGV0XFx1MDNjZVxcdTAwMGJ0XFx1MDAwM3VcXHUwMDAzdVxcdTAwMDZ1XFx1MDNkMlxcbnVcXHJ1XFx1MDAwZXVcXHUwM2QzXCIsXHJcbiAgICBcIlxcdTAwMDN2XFx1MDAwM3ZcXHUwMDAzdlxcdTAwMDN3XFx1MDAwM3dcXHUwMDAzeFxcdTAwMDN4XFx1MDAwM3lcXHUwMDAzeVxcdTAwMDNcIixcclxuICAgIFwielxcdTAwMDN6XFx1MDAwNXpcXHUwM2UxXFxuelxcdTAwMDN6XFx1MDAwM3pcXHUwMDAzelxcdTAwMDN6XFx1MDAwM3pcXHUwMDA1elxcdTAzZThcIixcclxuICAgIFwiXFxuelxcdTAwMDN6XFx1MDAwM3pcXHUwMDA1elxcdTAzZWNcXG56XFx1MDAwNXpcXHUwM2VlXFxuelxcdTAwMDN7XFx1MDAwM3tcXHUwMDAzXCIsXHJcbiAgICBcInxcXHUwMDAzfFxcdTAwMDN9XFx1MDAwM31cXHUwMDAzfVxcdTAwMDN9XFx1MDAwNX1cXHUwM2Y4XFxufVxcdTAwMDN+XFx1MDAwM35cXHUwMDA1XCIsXHJcbiAgICBcIn5cXHUwM2ZjXFxuflxcdTAwMDNcXHUwMDdmXFx1MDAwM1xcdTAwN2ZcXHUwMDA1XFx1MDA3ZlxcdTA0MDBcXG5cXHUwMDdmXFx1MDAwM1xcdTAwN2ZcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwN2ZcXHUwNDAzXFxuXFx1MDA3ZlxcdTAwMDNcXHUwMDdmXFx1MDAwM1xcdTAwN2ZcXHUwMDAzXFx1MDA3ZlxcdTAwMDVcIixcclxuICAgIFwiXFx1MDA3ZlxcdTA0MDhcXG5cXHUwMDdmXFx1MDAwNVxcdTAwN2ZcXHUwNDBhXFxuXFx1MDA3ZlxcdTAwMDNcXHUwMDgwXFx1MDAwM1xcdTAwODBcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwODBcXHUwMDAzXFx1MDA4MFxcdTAwMDVcXHUwMDgwXFx1MDQxMFxcblxcdTAwODBcXHUwMDAzXFx1MDA4MFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA4MFxcdTAwMDNcXHUwMDgwXFx1MDAwM1xcdTAwODBcXHUwMDA1XFx1MDA4MFxcdTA0MTZcXG5cXHUwMDgwXFx1MDAwNVxcdTAwODBcIixcclxuICAgIFwiXFx1MDQxOFxcblxcdTAwODBcXHUwMDAzXFx1MDA4MVxcdTAwMDVcXHUwMDgxXFx1MDQxYlxcblxcdTAwODFcXHUwMDAzXFx1MDA4MVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA4MVxcdTAwMDNcXHUwMDgxXFx1MDAwM1xcdTAwODFcXHUwMDAzXFx1MDA4MVxcdTAwMDVcXHUwMDgxXFx1MDQyMlxcblxcdTAwODFcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwODJcXHUwMDAzXFx1MDA4MlxcdTAwMDVcXHUwMDgyXFx1MDQyNlxcblxcdTAwODJcXHUwMDAzXFx1MDA4MlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA4MlxcdTAwMDNcXHUwMDgyXFx1MDAwNVxcdTAwODJcXHUwNDJiXFxuXFx1MDA4MlxcdTAwMDNcXHUwMDgyXFx1MDAwNVxcdTAwODJcIixcclxuICAgIFwiXFx1MDQyZVxcblxcdTAwODJcXHUwMDAzXFx1MDA4M1xcdTAwMDNcXHUwMDgzXFx1MDAwM1xcdTAwODRcXHUwMDA2XFx1MDA4NFxcdTA0MzNcIixcclxuICAgIFwiXFxuXFx1MDA4NFxcclxcdTAwODRcXHUwMDBlXFx1MDA4NFxcdTA0MzRcXHUwMDAzXFx1MDA4NVxcdTAwMDVcXHUwMDg1XFx1MDQzOFxcblxcdTAwODVcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwODVcXHUwMDAzXFx1MDA4NVxcdTAwMDNcXHUwMDg1XFx1MDAwM1xcdTAwODVcXHUwMDAzXFx1MDA4NVxcdTAwMDVcXHUwMDg1XCIsXHJcbiAgICBcIlxcdTA0M2ZcXG5cXHUwMDg1XFx1MDAwM1xcdTAwODZcXHUwMDAzXFx1MDA4NlxcdTAwMDVcXHUwMDg2XFx1MDQ0M1xcblxcdTAwODZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwODZcXHUwMDAzXFx1MDA4NlxcdTAwMDNcXHUwMDg2XFx1MDAwNVxcdTAwODZcXHUwNDQ4XFxuXFx1MDA4NlxcdTAwMDNcXHUwMDg2XCIsXHJcbiAgICBcIlxcdTAwMDVcXHUwMDg2XFx1MDQ0YlxcblxcdTAwODZcXHUwMDAzXFx1MDA4N1xcdTAwMDZcXHUwMDg3XFx1MDQ0ZVxcblxcdTAwODdcXHJcXHUwMDg3XCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDg3XFx1MDQ0ZlxcdTAwMDNcXHUwMDg4XFx1MDAwM1xcdTAwODhcXHUwMDAzXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDAzXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDAzXFx1MDA4OVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDAzXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwODlcXHUwMDAzXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDAzXFx1MDA4OVxcdTAwMDNcXHUwMDg5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDg5XFx1MDAwM1xcdTAwODlcXHUwMDA1XFx1MDA4OVxcdTA0NmFcXG5cXHUwMDg5XFx1MDAwM1xcdTAwOGFcXHUwMDA2XFx1MDA4YVwiLFxyXG4gICAgXCJcXHUwNDZkXFxuXFx1MDA4YVxcclxcdTAwOGFcXHUwMDBlXFx1MDA4YVxcdTA0NmVcXHUwMDAzXFx1MDA4YlxcdTAwMDNcXHUwMDhiXFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMDhiXFx1MDQ3M1xcblxcdTAwOGJcXHUwMDAzXFx1MDA4Y1xcdTAwMDNcXHUwMDhjXFx1MDAwM1xcdTAwOGNcXHUwMDAzXFx1MDA4Y1wiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDA4Y1xcdTA0NzlcXG5cXHUwMDhjXFx1MDAwM1xcdTAwOGRcXHUwMDAzXFx1MDA4ZFxcdTAwMDNcXHUwMDhkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDhlXFx1MDAwM1xcdTAwOGVcXHUwMDAzXFx1MDA4ZVxcdTAwMDNcXHUwMDhlXFx1MDAwM1xcdTAwOGVcXHUwMDAzXFx1MDA4ZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA4ZVxcdTAwMDNcXHUwMDhlXFx1MDAwM1xcdTAwOGVcXHUwMDAzXFx1MDA4ZVxcdTAwMDNcXHUwMDhlXFx1MDAwNVxcdTAwOGVcXHUwNDg5XCIsXHJcbiAgICBcIlxcblxcdTAwOGVcXHUwMDAzXFx1MDA4ZlxcdTAwMDNcXHUwMDhmXFx1MDAwM1xcdTAwOGZcXHUwMDAzXFx1MDA4ZlxcdTAwMDZcXHUwMDhmXCIsXHJcbiAgICBcIlxcdTA0OGZcXG5cXHUwMDhmXFxyXFx1MDA4ZlxcdTAwMGVcXHUwMDhmXFx1MDQ5MFxcdTAwMDNcXHUwMDkwXFx1MDAwNVxcdTAwOTBcXHUwNDk0XCIsXHJcbiAgICBcIlxcblxcdTAwOTBcXHUwMDAzXFx1MDA5MFxcdTAwMDNcXHUwMDkwXFx1MDAwNVxcdTAwOTBcXHUwNDk4XFxuXFx1MDA5MFxcdTAwMDNcXHUwMDkwXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDkwXFx1MDAwM1xcdTAwOTFcXHUwMDAzXFx1MDA5MVxcdTAwMDNcXHUwMDkxXFx1MDAwNVxcdTAwOTFcXHUwNDlmXFxuXCIsXHJcbiAgICBcIlxcdTAwOTFcXHUwMDAzXFx1MDA5MlxcdTAwMDZcXHUwMDkyXFx1MDRhMlxcblxcdTAwOTJcXHJcXHUwMDkyXFx1MDAwZVxcdTAwOTJcXHUwNGEzXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDkzXFx1MDAwM1xcdTAwOTNcXHUwMDAzXFx1MDA5M1xcdTAwMDNcXHUwMDkzXFx1MDAwM1xcdTAwOTNcXHUwMDAzXFx1MDA5M1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDA5M1xcdTAwMDVcXHUwMDkzXFx1MDRhZFxcblxcdTAwOTNcXHUwMDAzXFx1MDA5NFxcdTAwMDNcXHUwMDk0XFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMDk0XFx1MDRiMVxcblxcdTAwOTRcXHUwMDAzXFx1MDA5NFxcdTAwMDNcXHUwMDk0XFx1MDAwM1xcdTAwOTRcXHUwMDAzXFx1MDA5NFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDA5NFxcdTAwMDNcXHUwMDk0XFx1MDAwM1xcdTAwOTRcXHUwMDAzXFx1MDA5NFxcdTAwMDdcXHUwMDk0XFx1MDRiYlxcblwiLFxyXG4gICAgXCJcXHUwMDk0XFxmXFx1MDA5NFxcdTAwMGVcXHUwMDk0XFx1MDRiZVxcdTAwMGJcXHUwMDk0XFx1MDAwM1xcdTAwOTRcXHUwMDAzXFx1MDA5NFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDA5NVxcdTAwMDNcXHUwMDk1XFx1MDAwM1xcdTAwOTVcXHUwMDAzXFx1MDA5NVxcdTAwMDNcXHUwMDk1XFx1MDAwN1xcdTAwOTVcIixcclxuICAgIFwiXFx1MDRjN1xcblxcdTAwOTVcXGZcXHUwMDk1XFx1MDAwZVxcdTAwOTVcXHUwNGNhXFx1MDAwYlxcdTAwOTVcXHUwMDAzXFx1MDA5NVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDA5NVxcdTAwMDdcXHUwMDk1XFx1MDRjZVxcblxcdTAwOTVcXGZcXHUwMDk1XFx1MDAwZVxcdTAwOTVcXHUwNGQxXFx1MDAwYlxcdTAwOTVcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwOTVcXHUwMDAzXFx1MDA5NVxcdTAwMDNcXHUwMDk1XFx1MDAwM1xcdTAwOTVcXHUwMDAzXFx1MDA5NlxcdTAwMDNcXHUwMDk2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDk2XFx1MDAwM1xcdTAwOTZcXHUwMDAzXFx1MDA5NlxcdTAwMDNcXHUwMDk2XFx1MDAwM1xcdTAwOTZcXHUwMDA3XFx1MDA5NlwiLFxyXG4gICAgXCJcXHUwNGRlXFxuXFx1MDA5NlxcZlxcdTAwOTZcXHUwMDBlXFx1MDA5NlxcdTA0ZTFcXHUwMDBiXFx1MDA5NlxcdTAwMDNcXHUwMDk2XFx1MDAwN1wiLFxyXG4gICAgXCJcXHUwMDk2XFx1MDRlNFxcblxcdTAwOTZcXGZcXHUwMDk2XFx1MDAwZVxcdTAwOTZcXHUwNGU3XFx1MDAwYlxcdTAwOTZcXHUwMDAzXFx1MDA5NlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDA5NlxcdTAwMDNcXHUwMDk3XFx1MDAwM1xcdTAwOTdcXHUwMDA1XFx1MDA5N1xcdTA0ZWRcXG5cXHUwMDk3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDk3XFx1MDAwM1xcdTAwOTdcXHUwMDA1XFx1MDA5N1xcdTA0ZjFcXG5cXHUwMDk3XFx1MDAwM1xcdTAwOTdcXHUwMDAzXFx1MDA5N1wiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDA5N1xcdTA0ZjVcXG5cXHUwMDk3XFxmXFx1MDA5N1xcdTAwMGVcXHUwMDk3XFx1MDRmOFxcdTAwMGJcXHUwMDk3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDk3XFx1MDAwM1xcdTAwOTdcXHUwMDAzXFx1MDA5OFxcdTAwMDNcXHUwMDk4XFx1MDAwNVxcdTAwOThcXHUwNGZlXFxuXFx1MDA5OFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDA5OFxcdTAwMDNcXHUwMDk4XFx1MDAwM1xcdTAwOThcXHUwMDAzXFx1MDA5OFxcdTAwMDNcXHUwMDk4XFx1MDAwM1xcdTAwOThcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwOThcXHUwMDAzXFx1MDA5OFxcdTAwMDNcXHUwMDk4XFx1MDAwN1xcdTAwOThcXHUwNTA5XFxuXFx1MDA5OFxcZlxcdTAwOThcIixcclxuICAgIFwiXFx1MDAwZVxcdTAwOThcXHUwNTBjXFx1MDAwYlxcdTAwOThcXHUwMDAzXFx1MDA5OFxcdTAwMDNcXHUwMDk4XFx1MDAwM1xcdTAwOTlcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwOTlcXHUwNTExXFxuXFx1MDA5OVxcclxcdTAwOTlcXHUwMDBlXFx1MDA5OVxcdTA1MTJcXHUwMDAzXFx1MDA5OVxcdTAwMDNcXHUwMDk5XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDlhXFx1MDAwM1xcdTAwOWFcXHUwMDA1XFx1MDA5YVxcdTA1MTlcXG5cXHUwMDlhXFx1MDAwM1xcdTAwOWFcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwOWFcXHUwNTFjXFxuXFx1MDA5YVxcdTAwMDNcXHUwMDlhXFx1MDAwM1xcdTAwOWFcXHUwMDAzXFx1MDA5YlxcdTAwMDNcXHUwMDliXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDliXFx1MDAwM1xcdTAwOWJcXHUwMDA3XFx1MDA5YlxcdTA1MjRcXG5cXHUwMDliXFxmXFx1MDA5YlxcdTAwMGVcXHUwMDliXCIsXHJcbiAgICBcIlxcdTA1MjdcXHUwMDBiXFx1MDA5YlxcdTAwMDNcXHUwMDliXFx1MDAwM1xcdTAwOWJcXHUwMDAzXFx1MDA5YlxcdTAwMDNcXHUwMDliXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDliXFx1MDAwM1xcdTAwOWNcXHUwMDAzXFx1MDA5Y1xcdTAwMDNcXHUwMDljXFx1MDAwM1xcdTAwOWNcXHUwMDA3XFx1MDA5Y1xcdTA1MzJcIixcclxuICAgIFwiXFxuXFx1MDA5Y1xcZlxcdTAwOWNcXHUwMDBlXFx1MDA5Y1xcdTA1MzVcXHUwMDBiXFx1MDA5Y1xcdTAwMDNcXHUwMDljXFx1MDAwM1xcdTAwOWNcIixcclxuICAgIFwiXFx1MDAwM1xcdTA1MjVcXHUwMDAyXFx1MDA5ZFxcdTAwMDNcXHUwMDAzXFx1MDAwNVxcdTAwMDRcXHUwMDA3XFx1MDAwNVxcdFxcdTAwMDZcIixcclxuICAgIFwiXFx1MDAwYlxcdTAwMDdcXHJcXGJcXHUwMDBmXFx0XFx1MDAxMVxcblxcdTAwMTNcXHUwMDBiXFx1MDAxNVxcZlxcdTAwMTdcXHJcXHUwMDE5XFx1MDAwZVwiLFxyXG4gICAgXCJcXHUwMDFiXFx1MDAwZlxcdTAwMWRcXHUwMDEwXFx1MDAxZlxcdTAwMTEhXFx1MDAxMiNcXHUwMDEzJVxcdTAwMTRcXCdcXHUwMDE1KVxcdTAwMTZcIixcclxuICAgIFwiK1xcdTAwMTctXFx1MDAxOC9cXHUwMDE5MVxcdTAwMWEzXFx1MDAxYjVcXHUwMDFjN1xcdTAwMWQ5XFx1MDAxZTtcXHUwMDFmPSA/IVwiLFxyXG4gICAgXCJBXFxcIkMjRSRHJUkmS1xcJ00oTylRKlMrVSxXLVkuWy9dMF8xYTJjM2U0ZzVpNms3bThvOXE6czt1PHc9eT57P31AXFx1MDA3ZlwiLFxyXG4gICAgXCJBXFx1MDA4MUJcXHUwMDgzQ1xcdTAwODVEXFx1MDA4N0VcXHUwMDg5RlxcdTAwOGJHXFx1MDA4ZEhcXHUwMDhmSVxcdTAwOTFKXFx1MDA5M1wiLFxyXG4gICAgXCJLXFx1MDA5NUxcXHUwMDk3TVxcdTAwOTlOXFx1MDA5Yk9cXHUwMDlkUFxcdTAwOWZRXFx1MDBhMVJcXHUwMGEzU1xcdTAwYTVUXFx1MDBhN1wiLFxyXG4gICAgXCJVXFx1MDBhOVZcXHUwMGFiV1xcdTAwYWRYXFx1MDBhZllcXHUwMGIxWlxcdTAwYjNbXFx1MDBiNVxcXFxcXHUwMGI3XVxcdTAwYjleXFx1MDBiYlwiLFxyXG4gICAgXCJfXFx1MDBiZGBcXHUwMGJmYVxcdTAwYzFiXFx1MDBjM2NcXHUwMGM1ZFxcdTAwYzdlXFx1MDBjOWZcXHUwMGNiZ1xcdTAwY2RoXFx1MDBjZlwiLFxyXG4gICAgXCJpXFx1MDBkMWpcXHUwMGQza1xcdTAwZDVcXHUwMDAyXFx1MDBkN1xcdTAwMDJcXHUwMGQ5XFx1MDAwMlxcdTAwZGJcXHUwMDAyXFx1MDBkZFwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBkZmxcXHUwMGUxXFx1MDAwMlxcdTAwZTNcXHUwMDAyXFx1MDBlNVxcdTAwMDJcXHUwMGU3XFx1MDAwMlxcdTAwZTlcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwZWJcXHUwMDAyXFx1MDBlZFxcdTAwMDJcXHUwMGVmXFx1MDAwMlxcdTAwZjFcXHUwMDAyXFx1MDBmM1xcdTAwMDJcXHUwMGY1XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGY3XFx1MDAwMlxcdTAwZjlcXHUwMDAyXFx1MDBmYlxcdTAwMDJcXHUwMGZkXFx1MDAwMlxcdTAwZmZcXHUwMDAyXFx1MDEwMVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEwM1xcdTAwMDJcXHUwMTA1XFx1MDAwMlxcdTAxMDdtXFx1MDEwOVxcdTAwMDJcXHUwMTBiXFx1MDAwMlxcdTAxMGRcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMGZcXHUwMDAyXFx1MDExMVxcdTAwMDJcXHUwMTEzXFx1MDAwMlxcdTAxMTVcXHUwMDAyXFx1MDExN1xcdTAwMDJcXHUwMTE5XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTFiXFx1MDAwMlxcdTAxMWRcXHUwMDAyXFx1MDExZm5cXHUwMTIxXFx1MDAwMlxcdTAxMjNcXHUwMDAyXFx1MDEyNVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEyN29cXHUwMTI5cFxcdTAxMmJxXFx1MDEyZHJcXHUwMTJmc1xcdTAxMzF0XFx1MDEzM3VcXHUwMTM1dlxcdTAxMzdcIixcclxuICAgIFwid1xcdTAwMDNcXHUwMDAyXFx1MDAxN1xcdTAwMDVcXHUwMDAyQ1xcXFxhYWN8XFx1MDAwM1xcdTAwMDIyO1xcdTAwMDRcXHUwMDAyRERkXCIsXHJcbiAgICBcImRcXHUwMDAzXFx1MDAwMjIzXFx1MDAwNFxcdTAwMDJaWnp6XFx1MDAwM1xcdTAwMDIzO1xcdTAwMDNcXHUwMDAyMjlcXHUwMDA1XFx1MDAwMlwiLFxyXG4gICAgXCIyO0NIY2hcXHUwMDA0XFx1MDAwMldXd3dcXHUwMDA0XFx1MDAwMk5Obm5cXHUwMDA0XFx1MDAwMi0tLy9cXHUwMDA2XFx1MDAwMkhcIixcclxuICAgIFwiSE5OaGhublxcdTAwMDZcXHUwMDAyXFxmXFxmXFx1MDAwZlxcdTAwMGYpKV5eXFxmXFx1MDAwMiQkKSlBQV5eY2RoaHBwdHR2dnh4XCIsXHJcbiAgICBcIlxcdTAwMDVcXHUwMDAyTk5XV3d3XFx1MDAwNlxcdTAwMDJcXGZcXGZcXHUwMDBmXFx1MDAwZiQkXl5cXHUwMDAzXFx1MDAwMiUlXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyfX1cXHUwMDAzXFx1MDAwMlxcdTAwN2ZcXHUwMDdmXFx1MDAwNFxcdTAwMDJcXGZcXGZcXHUwMDBmXFx1MDAwZlxcdTAwMDRcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMGJcXHUwMDBiXFxcIlxcXCJcXHUwMDAyXFx1MDU1ZVxcdTAwMDJcXHUwMDAzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcclxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDE1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAxOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCIhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIlXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFwnXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIpXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyK1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyLVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMi9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyO1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMj1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMj9cXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJBXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJDXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyRVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyR1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMklcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMktcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJNXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJPXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJRXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyU1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyVVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMldcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMllcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJbXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJdXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyX1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcImNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMmdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJpXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJrXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAybVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyb1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMnFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMnNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJ1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJ3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwieVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAye1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyfVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwN2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDgzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDg1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4OVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOGRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDkxXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5NVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDliXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDlkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhMVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYTVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGE3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGE5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhZFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGI1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYmRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGMxXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBjM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBjNVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYzlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGNkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBjZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkMVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTA3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTFmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTMxXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzNVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwM1xcdTAxMzlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDVcXHUwMTQ3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDdcXHUwMTU4XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHRcXHUwMTZiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMGJcXHUwMTcyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHJcXHUwMTdhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMGZcXHUwMTgyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDExXFx1MDE4ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDEzXFx1MDE5OFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxNVxcdTAxYTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxN1xcdTAxYWRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTlcXHUwMWIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWJcXHUwMWMxXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFkXFx1MDFjOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFmXFx1MDFkNlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyIVxcdTAxZGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyI1xcdTAxZTFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMiVcXHUwMWU2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcJ1xcdTAxZWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMilcXHUwMWYxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMitcXHUwMWZhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCItXFx1MDIwMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIvXFx1MDIwNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIxXFx1MDIwY1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyM1xcdTAyMTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyNVxcdTAyMTZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMjdcXHUwMjFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjlcXHUwMjIzXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDI7XFx1MDIyN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI9XFx1MDIyY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyP1xcdTAyMmZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyQVxcdTAyMzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIkNcXHUwMjNhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkVcXHUwMjNmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkdcXHUwMjQ4XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJJXFx1MDI1MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJLXFx1MDI1OFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyTVxcdTAyNWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyT1xcdTAyNjVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlFcXHUwMjZjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlNcXHUwMjczXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJVXFx1MDI3YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJXXFx1MDI4MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiWVxcdTAyODlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyW1xcdTAyOGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXVxcdTAyOThcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMl9cXHUwMjlkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmFcXHUwMmE2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJjXFx1MDJhY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJlXFx1MDJiNVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyZ1xcdTAyYmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyaVxcdTAyYzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMmtcXHUwMmNjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMm1cXHUwMmQ1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJvXFx1MDJkZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJxXFx1MDJlOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJzXFx1MDJmM1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAydVxcdTAzMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyd1xcdTAzMTBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMnlcXHUwMzEyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMntcXHUwMzE0XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJ9XFx1MDMxNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDdmXFx1MDMxOFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDA4MVxcdTAzMWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4M1xcdTAzMWNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwODVcXHUwMzFlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODdcXHUwMzIxXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDg5XFx1MDMyM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhiXFx1MDMyNlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDA4ZFxcdTAzMjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4ZlxcdTAzMmNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwOTFcXHUwMzJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTNcXHUwMzMxXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDk1XFx1MDMzM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk3XFx1MDMzNlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDA5OVxcdTAzMzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5YlxcdTAzM2FcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwOWRcXHUwMzNjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOWZcXHUwMzNlXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGExXFx1MDM0MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGEzXFx1MDM0M1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBhNVxcdTAzNDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhN1xcdTAzNDhcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYTlcXHUwMzRhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYWJcXHUwMzRjXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGFkXFx1MDM0ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGFmXFx1MDM1MFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiMVxcdTAzNTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiM1xcdTAzNTRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYjVcXHUwMzU2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjdcXHUwMzU5XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGI5XFx1MDM1Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJiXFx1MDM1ZlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiZFxcdTAzNjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiZlxcdTAzNjVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYzFcXHUwMzY5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYzNcXHUwMzZkXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGM1XFx1MDM3MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGM3XFx1MDM3M1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBjOVxcdTAzNzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBjYlxcdTAzNzlcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwY2RcXHUwMzdjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwY2ZcXHUwMzdmXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGQxXFx1MDM4MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGQzXFx1MDM4NVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBkNVxcdTAzOGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkN1xcdTAzOTFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZDlcXHUwMzkzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGJcXHUwMzlmXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGRkXFx1MDNhMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGRmXFx1MDNhOVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBlMVxcdTAzYjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlM1xcdTAzYmFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZTVcXHUwM2MxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTdcXHUwM2M4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGU5XFx1MDNjZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGViXFx1MDNkNVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBlZFxcdTAzZDhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlZlxcdTAzZGFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZjFcXHUwM2RjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjNcXHUwM2VkXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGY1XFx1MDNlZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGY3XFx1MDNmMVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBmOVxcdTAzZjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBmYlxcdTAzZmJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZmRcXHUwNDA5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZmZcXHUwNDE3XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTAxXFx1MDQyMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTAzXFx1MDQyZFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDEwNVxcdTA0MmZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwN1xcdTA0MzJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxMDlcXHUwNDNlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMGJcXHUwNDRhXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTBkXFx1MDQ0ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTBmXFx1MDQ1MVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDExMVxcdTA0NjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExM1xcdTA0NmNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxMTVcXHUwNDcyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTdcXHUwNDc4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTE5XFx1MDQ3YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTFiXFx1MDQ4OFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDExZFxcdTA0OGFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExZlxcdTA0OTNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxMjFcXHUwNDllXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjNcXHUwNGExXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTI1XFx1MDRhY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTI3XFx1MDRhZVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDEyOVxcdTA0YzFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyYlxcdTA0ZDZcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxMmRcXHUwNGVhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmZcXHUwNGZiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTMxXFx1MDUxMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTMzXFx1MDUxYlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDEzNVxcdTA1MWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzN1xcdTA1MmRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxMzlcXHUwMTNhXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxM2FcXHUwMTNiXFx1MDAwN2FcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTNiXFx1MDEzY1xcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMTNjXFx1MDEzZFxcdTAwMDd6XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEzZFxcdTAxM2VcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDEzZVxcdTAxM2ZcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDEzZlwiLFxyXG4gICAgXCJcXHUwMTQwXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAxNDBcXHUwMTQxXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAxNDFcXHUwMTQyXCIsXHJcbiAgICBcIlxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMTQyXFx1MDE0M1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMTQzXFx1MDE0NFxcdTAwMDdcIixcclxuICAgIFwicFxcdTAwMDJcXHUwMDAyXFx1MDE0NFxcdTAxNDVcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDE0NVxcdTAxNDZcXHUwMDA3YVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNDZcXHUwMDA0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDdcXHUwMTQ4XFx1MDAwN2FcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTQ4XFx1MDE0OVxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMTQ5XFx1MDE0YVxcdTAwMDdkXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE0YVxcdTAxNGJcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXFx1MDE0YlxcdTAxNGNcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDE0Y1wiLFxyXG4gICAgXCJcXHUwMTRkXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAxNGRcXHUwMTRlXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxNGVcXHUwMTRmXCIsXHJcbiAgICBcIlxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMTRmXFx1MDE1MFxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMTUwXFx1MDE1MVxcdTAwMDdcIixcclxuICAgIFwiYVxcdTAwMDJcXHUwMDAyXFx1MDE1MVxcdTAxNTJcXHUwMDA3eFxcdTAwMDJcXHUwMDAyXFx1MDE1MlxcdTAxNTNcXHUwMDA3Y1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNTNcXHUwMTU0XFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxNTRcXHUwMTU1XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTU1XFx1MDE1NlxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMTU2XFx1MDE1N1xcdTAwMDdpXFx1MDAwMlxcdTAwMDJcXHUwMTU3XCIsXHJcbiAgICBcIlxcdTAwMDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE1OFxcdTAxNTlcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDE1OVwiLFxyXG4gICAgXCJcXHUwMTVhXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxNWFcXHUwMTViXFx1MDAwN2RcXHUwMDAyXFx1MDAwMlxcdTAxNWJcXHUwMTVjXCIsXHJcbiAgICBcIlxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMTVjXFx1MDE1ZFxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMTVkXFx1MDE1ZVxcdTAwMDdcIixcclxuICAgIFwiblxcdTAwMDJcXHUwMDAyXFx1MDE1ZVxcdTAxNWZcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDE1ZlxcdTAxNjBcXHUwMDA3a1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNjBcXHUwMTYxXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAxNjFcXHUwMTYyXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTYyXFx1MDE2M1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMTYzXFx1MDE2NFxcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwMTY0XCIsXHJcbiAgICBcIlxcdTAxNjVcXHUwMDA3aFxcdTAwMDJcXHUwMDAyXFx1MDE2NVxcdTAxNjZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDE2NlxcdTAxNjdcIixcclxuICAgIFwiXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxNjdcXHUwMTY4XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxNjhcXHUwMTY5XFx1MDAwN1wiLFxyXG4gICAgXCJxXFx1MDAwMlxcdTAwMDJcXHUwMTY5XFx1MDE2YVxcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwMTZhXFxiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTZiXFx1MDE2Y1xcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMTZjXFx1MDE2ZFxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE2ZFxcdTAxNmVcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXFx1MDE2ZVxcdTAxNmZcXHUwMDA3M1xcdTAwMDJcXHUwMDAyXFx1MDE2ZlwiLFxyXG4gICAgXCJcXHUwMTcwXFx1MDAwNzRcXHUwMDAyXFx1MDAwMlxcdTAxNzBcXHUwMTcxXFx1MDAwNzpcXHUwMDAyXFx1MDAwMlxcdTAxNzFcXG5cXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNzJcXHUwMTczXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxNzNcXHUwMTc0XFx1MDAwN1wiLFxyXG4gICAgXCJhXFx1MDAwMlxcdTAwMDJcXHUwMTc0XFx1MDE3NVxcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMTc1XFx1MDE3NlxcdTAwMDczXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE3NlxcdTAxNzdcXHUwMDA3NFxcdTAwMDJcXHUwMDAyXFx1MDE3N1xcdTAxNzhcXHUwMDA3OlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNzhcXHUwMTc5XFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAxNzlcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE3YVwiLFxyXG4gICAgXCJcXHUwMTdiXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxN2JcXHUwMTdjXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxN2NcXHUwMTdkXCIsXHJcbiAgICBcIlxcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMTdkXFx1MDE3ZVxcdTAwMDczXFx1MDAwMlxcdTAwMDJcXHUwMTdlXFx1MDE3ZlxcdTAwMDdcIixcclxuICAgIFwiNFxcdTAwMDJcXHUwMDAyXFx1MDE3ZlxcdTAxODBcXHUwMDA3OlxcdTAwMDJcXHUwMDAyXFx1MDE4MFxcdTAxODFcXHUwMDA3a1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxODFcXHUwMDBlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODJcXHUwMTgzXFx1MDAwN2FcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTgzXFx1MDE4NFxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMTg0XFx1MDE4NVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE4NVxcdTAxODZcXHUwMDA3e1xcdTAwMDJcXHUwMDAyXFx1MDE4NlxcdTAxODdcXHUwMDA3clxcdTAwMDJcXHUwMDAyXFx1MDE4N1wiLFxyXG4gICAgXCJcXHUwMTg4XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxODhcXHUwMTg5XFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAxODlcXHUwMThhXCIsXHJcbiAgICBcIlxcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwMThhXFx1MDE4YlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMThiXFx1MDE4Y1xcdTAwMDdcIixcclxuICAgIFwiYVxcdTAwMDJcXHUwMDAyXFx1MDE4Y1xcdTAwMTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4ZFxcdTAxOGVcXHUwMDA3XCIsXHJcbiAgICBcImFcXHUwMDAyXFx1MDAwMlxcdTAxOGVcXHUwMThmXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxOGZcXHUwMTkwXFx1MDAwN2tcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTkwXFx1MDE5MVxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMTkxXFx1MDE5MlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE5MlxcdTAxOTNcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDE5M1xcdTAxOTRcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDE5NFwiLFxyXG4gICAgXCJcXHUwMTk1XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAxOTVcXHUwMTk2XFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxOTZcXHUwMTk3XCIsXHJcbiAgICBcIlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMTk3XFx1MDAxMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTk4XFx1MDE5OVwiLFxyXG4gICAgXCJcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDE5OVxcdTAxOWFcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDE5YVxcdTAxOWJcXHUwMDA3XCIsXHJcbiAgICBcInVcXHUwMDAyXFx1MDAwMlxcdTAxOWJcXHUwMTljXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxOWNcXHUwMTlkXFx1MDAwN2ZcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTlkXFx1MDE5ZVxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMTllXFx1MDE5ZlxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE5ZlxcdTAxYTBcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDFhMFxcdTAxYTFcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDFhMVwiLFxyXG4gICAgXCJcXHUwMDE0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYTJcXHUwMWEzXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxYTNcIixcclxuICAgIFwiXFx1MDFhNFxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMWE0XFx1MDFhNVxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMWE1XFx1MDFhNlwiLFxyXG4gICAgXCJcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDFhNlxcdTAxYTdcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDFhN1xcdTAxYThcXHUwMDA3XCIsXHJcbiAgICBcIm5cXHUwMDAyXFx1MDAwMlxcdTAxYThcXHUwMWE5XFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAxYTlcXHUwMWFhXFx1MDAwN3JcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMWFhXFx1MDFhYlxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMWFiXFx1MDFhY1xcdTAwMDdlXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDFhY1xcdTAwMTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhZFxcdTAxYWVcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxYWVcXHUwMWFmXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxYWZcXHUwMWIwXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxYjBcIixcclxuICAgIFwiXFx1MDFiMVxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMWIxXFx1MDFiMlxcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMWIyXFx1MDAxOFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiM1xcdTAxYjRcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDFiNFxcdTAxYjVcIixcclxuICAgIFwiXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxYjVcXHUwMWI2XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxYjZcXHUwMWI3XFx1MDAwN1wiLFxyXG4gICAgXCJ2XFx1MDAwMlxcdTAwMDJcXHUwMWI3XFx1MDFiOFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMWI4XFx1MDFiOVxcdTAwMDd0XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFiOVxcdTAxYmFcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDFiYVxcdTAxYmJcXHUwMDA3ZFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxYmJcXHUwMWJjXFx1MDAwN3dcXHUwMDAyXFx1MDAwMlxcdTAxYmNcXHUwMWJkXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxYmRcIixcclxuICAgIFwiXFx1MDFiZVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMWJlXFx1MDFiZlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMWJmXFx1MDFjMFwiLFxyXG4gICAgXCJcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDFjMFxcdTAwMWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjMVxcdTAxYzJcIixcclxuICAgIFwiXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxYzJcXHUwMWMzXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAxYzNcXHUwMWM0XFx1MDAwN1wiLFxyXG4gICAgXCJjXFx1MDAwMlxcdTAwMDJcXHUwMWM0XFx1MDFjNVxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMWM1XFx1MDFjNlxcdTAwMDdvXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFjNlxcdTAxYzdcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDFjN1xcdTAxYzhcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxYzhcXHUwMDFjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzlcXHUwMWNhXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWNhXFx1MDFjYlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMWNiXFx1MDFjY1xcdTAwMDd4XFx1MDAwMlxcdTAwMDJcXHUwMWNjXCIsXHJcbiAgICBcIlxcdTAxY2RcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDFjZFxcdTAxY2VcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDFjZVxcdTAxY2ZcIixcclxuICAgIFwiXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxY2ZcXHUwMWQwXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxZDBcXHUwMWQxXFx1MDAwN1wiLFxyXG4gICAgXCJrXFx1MDAwMlxcdTAwMDJcXHUwMWQxXFx1MDFkMlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMWQyXFx1MDFkM1xcdTAwMDdnXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFkM1xcdTAxZDRcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDFkNFxcdTAxZDVcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxZDVcXHUwMDFlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDZcXHUwMWQ3XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWQ3XFx1MDFkOFxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMWQ4XFx1MDFkOVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMWQ5XCIsXHJcbiAgICBcIlxcdTAxZGFcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDFkYSBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkYlxcdTAxZGNcIixcclxuICAgIFwiXFx1MDAwN2RcXHUwMDAyXFx1MDAwMlxcdTAxZGNcXHUwMWRkXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAxZGRcXHUwMWRlXFx1MDAwN1wiLFxyXG4gICAgXCJnXFx1MDAwMlxcdTAwMDJcXHUwMWRlXFx1MDFkZlxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMWRmXFx1MDFlMFxcdTAwMDdtXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFlMFxcXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFlMVxcdTAxZTJcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxZTJcXHUwMWUzXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxZTNcXHUwMWU0XFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAxZTRcIixcclxuICAgIFwiXFx1MDFlNVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMWU1JFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU2XFx1MDFlN1wiLFxyXG4gICAgXCJcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDFlN1xcdTAxZThcXHUwMDA3alxcdTAwMDJcXHUwMDAyXFx1MDFlOFxcdTAxZTlcXHUwMDA3XCIsXHJcbiAgICBcImNcXHUwMDAyXFx1MDAwMlxcdTAxZTlcXHUwMWVhXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAxZWEmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMWViXFx1MDFlY1xcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMWVjXFx1MDFlZFxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDFlZFxcdTAxZWVcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDFlZVxcdTAxZWZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDFlZlwiLFxyXG4gICAgXCJcXHUwMWYwXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAxZjAoXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjFcXHUwMWYyXCIsXHJcbiAgICBcIlxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMWYyXFx1MDFmM1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMWYzXFx1MDFmNFxcdTAwMDdcIixcclxuICAgIFwicFxcdTAwMDJcXHUwMDAyXFx1MDFmNFxcdTAxZjVcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDFmNVxcdTAxZjZcXHUwMDA3a1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxZjZcXHUwMWY3XFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAxZjdcXHUwMWY4XFx1MDAwN3dcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWY4XFx1MDFmOVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMWY5KlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWZhXCIsXHJcbiAgICBcIlxcdTAxZmJcXHUwMDA3ZlxcdTAwMDJcXHUwMDAyXFx1MDFmYlxcdTAxZmNcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDFmY1xcdTAxZmRcIixcclxuICAgIFwiXFx1MDAwN2hcXHUwMDAyXFx1MDAwMlxcdTAxZmRcXHUwMWZlXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAxZmVcXHUwMWZmXFx1MDAwN1wiLFxyXG4gICAgXCJ3XFx1MDAwMlxcdTAwMDJcXHUwMWZmXFx1MDIwMFxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMjAwXFx1MDIwMVxcdTAwMDd2XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDIwMSxcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIwMlxcdTAyMDNcXHUwMDA3ZlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyMDNcXHUwMjA0XFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAyMDQuXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMDVcIixcclxuICAgIFwiXFx1MDIwNlxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMjA2XFx1MDIwN1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMjA3XFx1MDIwOFwiLFxyXG4gICAgXCJcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXFx1MDIwOFxcdTAyMDlcXHUwMDA3ZFxcdTAwMDJcXHUwMDAyXFx1MDIwOVxcdTAyMGFcXHUwMDA3XCIsXHJcbiAgICBcIm5cXHUwMDAyXFx1MDAwMlxcdTAyMGFcXHUwMjBiXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyMGIwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjBjXFx1MDIwZFxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMjBkXFx1MDIwZVxcdTAwMDduXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDIwZVxcdTAyMGZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDIwZlxcdTAyMTBcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDIxMFwiLFxyXG4gICAgXCIyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMTFcXHUwMjEyXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyMTJcXHUwMjEzXCIsXHJcbiAgICBcIlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMjEzXFx1MDIxNFxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMjE0XFx1MDIxNVxcdTAwMDdcIixcclxuICAgIFwib1xcdTAwMDJcXHUwMDAyXFx1MDIxNTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxNlxcdTAyMTdcXHUwMDA3Z1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyMTdcXHUwMjE4XFx1MDAwN3pcXHUwMDAyXFx1MDAwMlxcdTAyMThcXHUwMjE5XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjE5XFx1MDIxYVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMjFhXFx1MDIxYlxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMjFiXCIsXHJcbiAgICBcIlxcdTAyMWNcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDIxYzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxZFxcdTAyMWVcIixcclxuICAgIFwiXFx1MDAwN2hcXHUwMDAyXFx1MDAwMlxcdTAyMWVcXHUwMjFmXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAyMWZcXHUwMjIwXFx1MDAwN1wiLFxyXG4gICAgXCJxXFx1MDAwMlxcdTAwMDJcXHUwMjIwXFx1MDIyMVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMjIxXFx1MDIyMlxcdTAwMDd2XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDIyMjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIyM1xcdTAyMjRcXHUwMDA3aFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyMjRcXHUwMjI1XFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAyMjVcXHUwMjI2XFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAyMjZcIixcclxuICAgIFwiOlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjI3XFx1MDIyOFxcdTAwMDdpXFx1MDAwMlxcdTAwMDJcXHUwMjI4XFx1MDIyOVwiLFxyXG4gICAgXCJcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDIyOVxcdTAyMmFcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDIyYVxcdTAyMmJcXHUwMDA3XCIsXHJcbiAgICBcInFcXHUwMDAyXFx1MDAwMlxcdTAyMmI8XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMmNcXHUwMjJkXFx1MDAwN2tcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjJkXFx1MDIyZVxcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwMjJlPlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDIyZlxcdTAyMzBcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDIzMFxcdTAyMzFcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDIzMVwiLFxyXG4gICAgXCJcXHUwMjMyXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAyMzJcXHUwMjMzXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyMzNcXHUwMjM0XCIsXHJcbiAgICBcIlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMjM0XFx1MDIzNVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMjM1QFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDIzNlxcdTAyMzdcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDIzN1xcdTAyMzhcXHUwMDA3cFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyMzhcXHUwMjM5XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyMzlCXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjNhXFx1MDIzYlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMjNiXFx1MDIzY1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMjNjXCIsXHJcbiAgICBcIlxcdTAyM2RcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDIzZFxcdTAyM2VcXHUwMDA3aVxcdTAwMDJcXHUwMDAyXFx1MDIzZURcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyM2ZcXHUwMjQwXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAyNDBcXHUwMjQxXFx1MDAwN1wiLFxyXG4gICAgXCJnXFx1MDAwMlxcdTAwMDJcXHUwMjQxXFx1MDI0MlxcdTAwMDdpXFx1MDAwMlxcdTAwMDJcXHUwMjQyXFx1MDI0M1xcdTAwMDdrXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI0M1xcdTAyNDRcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDI0NFxcdTAyNDVcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyNDVcXHUwMjQ2XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyNDZcXHUwMjQ3XFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAyNDdcIixcclxuICAgIFwiRlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjQ4XFx1MDI0OVxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMjQ5XFx1MDI0YVwiLFxyXG4gICAgXCJcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDI0YVxcdTAyNGJcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDI0YlxcdTAyNGNcXHUwMDA3XCIsXHJcbiAgICBcInZcXHUwMDAyXFx1MDAwMlxcdTAyNGNcXHUwMjRkXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAyNGRcXHUwMjRlXFx1MDAwN2tcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjRlXFx1MDI0ZlxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMjRmXFx1MDI1MFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI1MEhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1MVxcdTAyNTJcXHUwMDA3dFxcdTAwMDJcXHUwMDAyXFx1MDI1MlwiLFxyXG4gICAgXCJcXHUwMjUzXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyNTNcXHUwMjU0XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyNTRcXHUwMjU1XCIsXHJcbiAgICBcIlxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMjU1XFx1MDI1NlxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMjU2XFx1MDI1N1xcdTAwMDdcIixcclxuICAgIFwicFxcdTAwMDJcXHUwMDAyXFx1MDI1N0pcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1OFxcdTAyNTlcXHUwMDA3dVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyNTlcXHUwMjVhXFx1MDAwN2pcXHUwMDAyXFx1MDAwMlxcdTAyNWFcXHUwMjViXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjViXFx1MDI1Y1xcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMjVjXFx1MDI1ZFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMjVkXCIsXHJcbiAgICBcIkxcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1ZVxcdTAyNWZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDI1ZlxcdTAyNjBcIixcclxuICAgIFwiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyNjBcXHUwMjYxXFx1MDAwN2lcXHUwMDAyXFx1MDAwMlxcdTAyNjFcXHUwMjYyXFx1MDAwN1wiLFxyXG4gICAgXCJwXFx1MDAwMlxcdTAwMDJcXHUwMjYyXFx1MDI2M1xcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMjYzXFx1MDI2NFxcdTAwMDdmXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI2NE5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2NVxcdTAyNjZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyNjZcXHUwMjY3XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyNjdcXHUwMjY4XFx1MDAwN3xcXHUwMDAyXFx1MDAwMlxcdTAyNjhcIixcclxuICAgIFwiXFx1MDI2OVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMjY5XFx1MDI2YVxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMjZhXFx1MDI2YlwiLFxyXG4gICAgXCJcXHUwMDA3aFxcdTAwMDJcXHUwMDAyXFx1MDI2YlBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2Y1xcdTAyNmRcXHUwMDA3XCIsXHJcbiAgICBcInVcXHUwMDAyXFx1MDAwMlxcdTAyNmRcXHUwMjZlXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyNmVcXHUwMjZmXFx1MDAwN2NcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjZmXFx1MDI3MFxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMjcwXFx1MDI3MVxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI3MVxcdTAyNzJcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDI3MlJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI3M1wiLFxyXG4gICAgXCJcXHUwMjc0XFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAyNzRcXHUwMjc1XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyNzVcXHUwMjc2XCIsXHJcbiAgICBcIlxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMjc2XFx1MDI3N1xcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMjc3XFx1MDI3OFxcdTAwMDdcIixcclxuICAgIFwiZVxcdTAwMDJcXHUwMDAyXFx1MDI3OFxcdTAyNzlcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDI3OVRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyN2FcXHUwMjdiXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAyN2JcXHUwMjdjXFx1MDAwN3lcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjdjXFx1MDI3ZFxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMjdkXFx1MDI3ZVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMjdlXCIsXHJcbiAgICBcIlxcdTAyN2ZcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDI3ZlxcdTAyODBcXHUwMDA3alxcdTAwMDJcXHUwMDAyXFx1MDI4MFZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyODFcXHUwMjgyXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyODJcXHUwMjgzXFx1MDAwN1wiLFxyXG4gICAgXCJ7XFx1MDAwMlxcdTAwMDJcXHUwMjgzXFx1MDI4NFxcdTAwMDdyXFx1MDAwMlxcdTAwMDJcXHUwMjg0XFx1MDI4NVxcdTAwMDdnXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI4NVxcdTAyODZcXHUwMDA3ZlxcdTAwMDJcXHUwMDAyXFx1MDI4NlxcdTAyODdcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyODdcXHUwMjg4XFx1MDAwN2hcXHUwMDAyXFx1MDAwMlxcdTAyODhYXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyODlcIixcclxuICAgIFwiXFx1MDI4YVxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMjhhXFx1MDI4YlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMjhiXFx1MDI4Y1wiLFxyXG4gICAgXCJcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDI4Y1xcdTAyOGRcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDI4ZFxcdTAyOGVcXHUwMDA3XCIsXHJcbiAgICBcInBcXHUwMDAyXFx1MDAwMlxcdTAyOGVaXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyOGZcXHUwMjkwXFx1MDAwN3dcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjkwXFx1MDI5MVxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMjkxXFx1MDI5MlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI5MlxcdTAyOTNcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDI5M1xcdTAyOTRcXHUwMDA3aVxcdTAwMDJcXHUwMDAyXFx1MDI5NFwiLFxyXG4gICAgXCJcXHUwMjk1XFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAyOTVcXHUwMjk2XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyOTZcXHUwMjk3XCIsXHJcbiAgICBcIlxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMjk3XFxcXFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjk4XFx1MDI5OVxcdTAwMDdcIixcclxuICAgIFwieFxcdTAwMDJcXHUwMDAyXFx1MDI5OVxcdTAyOWFcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDI5YVxcdTAyOWJcXHUwMDA3a1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyOWJcXHUwMjljXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAyOWNeXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjlkXFx1MDI5ZVxcdTAwMDd4XFx1MDAwMlxcdTAwMDJcXHUwMjllXFx1MDI5ZlxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMjlmXCIsXHJcbiAgICBcIlxcdTAyYTBcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDJhMFxcdTAyYTFcXHUwMDA3Y1xcdTAwMDJcXHUwMDAyXFx1MDJhMVxcdTAyYTJcIixcclxuICAgIFwiXFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyYTJcXHUwMmEzXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyYTNcXHUwMmE0XFx1MDAwN1wiLFxyXG4gICAgXCJuXFx1MDAwMlxcdTAwMDJcXHUwMmE0XFx1MDJhNVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMmE1YFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJhNlxcdTAyYTdcXHUwMDA3eVxcdTAwMDJcXHUwMDAyXFx1MDJhN1xcdTAyYThcXHUwMDA3alxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyYThcXHUwMmE5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyYTlcXHUwMmFhXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAyYWFcIixcclxuICAgIFwiXFx1MDJhYlxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMmFiYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmFjXFx1MDJhZFwiLFxyXG4gICAgXCJcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDJhZFxcdTAyYWVcXHUwMDA3Q1xcdTAwMDJcXHUwMDAyXFx1MDJhZVxcdTAyYWZcXHUwMDA3XCIsXHJcbiAgICBcIm5cXHUwMDAyXFx1MDAwMlxcdTAyYWZcXHUwMmIwXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyYjBcXHUwMmIxXFx1MDAwN2lcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmIxXFx1MDJiMlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMmIyXFx1MDJiM1xcdTAwMDdjXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJiM1xcdTAyYjRcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDJiNGRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJiNVwiLFxyXG4gICAgXCJcXHUwMmI2XFx1MDAwN2FcXHUwMDAyXFx1MDAwMlxcdTAyYjZcXHUwMmI3XFx1MDAwN0NcXHUwMDAyXFx1MDAwMlxcdTAyYjdcXHUwMmI4XCIsXHJcbiAgICBcIlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMmI4XFx1MDJiOVxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMmI5XFx1MDJiYVxcdTAwMDdcIixcclxuICAgIFwiaVxcdTAwMDJcXHUwMDAyXFx1MDJiYVxcdTAyYmJcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDJiYlxcdTAyYmNcXHUwMDA3cVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyYmNcXHUwMmJkXFx1MDAwN2hcXHUwMDAyXFx1MDAwMlxcdTAyYmRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmJlXFx1MDJiZlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMmJmXFx1MDJjMFxcdTAwMDdDXFx1MDAwMlxcdTAwMDJcXHUwMmMwXCIsXHJcbiAgICBcIlxcdTAyYzFcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDJjMVxcdTAyYzJcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDJjMlxcdTAyYzNcIixcclxuICAgIFwiXFx1MDAwN29cXHUwMDAyXFx1MDAwMlxcdTAyYzNcXHUwMmM0XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyYzRcXHUwMmM1XFx1MDAwN1wiLFxyXG4gICAgXCJlXFx1MDAwMlxcdTAwMDJcXHUwMmM1aFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmM2XFx1MDJjN1xcdTAwMDdhXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJjN1xcdTAyYzhcXHUwMDA3RFxcdTAwMDJcXHUwMDAyXFx1MDJjOFxcdTAyYzlcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyYzlcXHUwMmNhXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAyY2FcXHUwMmNiXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAyY2JcIixcclxuICAgIFwialxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmNjXFx1MDJjZFxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMmNkXFx1MDJjZVwiLFxyXG4gICAgXCJcXHUwMDA3RVxcdTAwMDJcXHUwMDAyXFx1MDJjZVxcdTAyY2ZcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDJjZlxcdTAyZDBcXHUwMDA3XCIsXHJcbiAgICBcIm9cXHUwMDAyXFx1MDAwMlxcdTAyZDBcXHUwMmQxXFx1MDAwN3JcXHUwMDAyXFx1MDAwMlxcdTAyZDFcXHUwMmQyXFx1MDAwN25cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmQyXFx1MDJkM1xcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMmQzXFx1MDJkNFxcdTAwMDd6XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJkNGxcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJkNVxcdTAyZDZcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDJkNlwiLFxyXG4gICAgXCJcXHUwMmQ3XFx1MDAwN0lcXHUwMDAyXFx1MDAwMlxcdTAyZDdcXHUwMmQ4XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyZDhcXHUwMmQ5XCIsXHJcbiAgICBcIlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMmQ5XFx1MDJkYVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMmRhXFx1MDJkYlxcdTAwMDdcIixcclxuICAgIFwidFxcdTAwMDJcXHUwMDAyXFx1MDJkYlxcdTAyZGNcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDJkY1xcdTAyZGRcXHUwMDA3ZVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyZGRuXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyZGVcXHUwMmRmXFx1MDAwN2FcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmRmXFx1MDJlMFxcdTAwMDdLXFx1MDAwMlxcdTAwMDJcXHUwMmUwXFx1MDJlMVxcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMmUxXCIsXHJcbiAgICBcIlxcdTAyZTJcXHUwMDA3Y1xcdTAwMDJcXHUwMDAyXFx1MDJlMlxcdTAyZTNcXHUwMDA3aVxcdTAwMDJcXHUwMDAyXFx1MDJlM1xcdTAyZTRcIixcclxuICAgIFwiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyZTRcXHUwMmU1XFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAyZTVcXHUwMmU2XFx1MDAwN1wiLFxyXG4gICAgXCJjXFx1MDAwMlxcdTAwMDJcXHUwMmU2XFx1MDJlN1xcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMmU3XFx1MDJlOFxcdTAwMDd7XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJlOHBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJlOVxcdTAyZWFcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyZWFcXHUwMmViXFx1MDAwN1BcXHUwMDAyXFx1MDAwMlxcdTAyZWJcXHUwMmVjXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAyZWNcIixcclxuICAgIFwiXFx1MDJlZFxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMmVkXFx1MDJlZVxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMmVlXFx1MDJlZlwiLFxyXG4gICAgXCJcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDJlZlxcdTAyZjBcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXFx1MDJmMFxcdTAyZjFcXHUwMDA3XCIsXHJcbiAgICBcInRcXHUwMDAyXFx1MDAwMlxcdTAyZjFcXHUwMmYyXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAyZjJyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmYzXFx1MDJmNFxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMmY0XFx1MDJmNVxcdTAwMDdVXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJmNVxcdTAyZjZcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDJmNlxcdTAyZjdcXHUwMDA3Y1xcdTAwMDJcXHUwMDAyXFx1MDJmN1wiLFxyXG4gICAgXCJcXHUwMmY4XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAyZjhcXHUwMmY5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyZjlcXHUwMmZhXCIsXHJcbiAgICBcIlxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMmZhXFx1MDJmYlxcdTAwMDdhXFx1MDAwMlxcdTAwMDJcXHUwMmZiXFx1MDJmY1xcdTAwMDdcIixcclxuICAgIFwiY1xcdTAwMDJcXHUwMDAyXFx1MDJmY1xcdTAyZmRcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDJmZFxcdTAyZmVcXHUwMDA3dVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyZmVcXHUwMmZmXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAyZmZcXHUwMzAwXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzAwXFx1MDMwMVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMzAxdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzAyXCIsXHJcbiAgICBcIlxcdTAzMDNcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDMwM1xcdTAzMDRcXHUwMDA3VlxcdTAwMDJcXHUwMDAyXFx1MDMwNFxcdTAzMDVcIixcclxuICAgIFwiXFx1MDAwN2pcXHUwMDAyXFx1MDAwMlxcdTAzMDVcXHUwMzA2XFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAzMDZcXHUwMzA3XFx1MDAwN1wiLFxyXG4gICAgXCJnXFx1MDAwMlxcdTAwMDJcXHUwMzA3XFx1MDMwOFxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMzA4XFx1MDMwOVxcdTAwMDdmXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDMwOVxcdTAzMGFcXHUwMDA3YVxcdTAwMDJcXHUwMDAyXFx1MDMwYVxcdTAzMGJcXHUwMDA3blxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzMGJcXHUwMzBjXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAzMGNcXHUwMzBkXFx1MDAwN2VcXHUwMDAyXFx1MDAwMlxcdTAzMGRcIixcclxuICAgIFwiXFx1MDMwZVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMzBlXFx1MDMwZlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMzBmdlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxMFxcdTAzMTFcXHUwMDA3KlxcdTAwMDJcXHUwMDAyXFx1MDMxMXhcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzMTJcXHUwMzEzXFx1MDAwNytcXHUwMDAyXFx1MDAwMlxcdTAzMTN6XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzE0XFx1MDMxNVxcdTAwMDddXFx1MDAwMlxcdTAwMDJcXHUwMzE1fFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDMxNlxcdTAzMTdcXHUwMDA3X1xcdTAwMDJcXHUwMDAyXFx1MDMxN35cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxOFwiLFxyXG4gICAgXCJcXHUwMzE5XFx1MDAwN31cXHUwMDAyXFx1MDAwMlxcdTAzMTlcXHUwMDgwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMWFcIixcclxuICAgIFwiXFx1MDMxYlxcdTAwMDdcXHUwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMzFiXFx1MDA4MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzFjXCIsXHJcbiAgICBcIlxcdTAzMWRcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDMxZFxcdTAwODRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxZVwiLFxyXG4gICAgXCJcXHUwMzFmXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAzMWZcXHUwMzIwXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzMjBcXHUwMDg2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzIxXFx1MDMyMlxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwMzIyXFx1MDA4OFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMyM1xcdTAzMjRcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDMyNFxcdTAzMjVcIixcclxuICAgIFwiXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzMjVcXHUwMDhhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMjZcXHUwMzI3XCIsXHJcbiAgICBcIlxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMzI3XFx1MDMyOFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMzI4XFx1MDA4Y1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMyOVxcdTAzMmFcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDMyYVxcdTAzMmJcXHUwMDA3XCIsXHJcbiAgICBcIkBcXHUwMDAyXFx1MDAwMlxcdTAzMmJcXHUwMDhlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMmNcXHUwMzJkXFx1MDAwN1wiLFxyXG4gICAgXCItXFx1MDAwMlxcdTAwMDJcXHUwMzJkXFx1MDA5MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzJlXFx1MDMyZlxcdTAwMDdcIixcclxuICAgIFwiLVxcdTAwMDJcXHUwMDAyXFx1MDMyZlxcdTAzMzBcXHUwMDA3LVxcdTAwMDJcXHUwMDAyXFx1MDMzMFxcdTAwOTJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzMzFcXHUwMzMyXFx1MDAwNy9cXHUwMDAyXFx1MDAwMlxcdTAzMzJcXHUwMDk0XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzMzXFx1MDMzNFxcdTAwMDcvXFx1MDAwMlxcdTAwMDJcXHUwMzM0XFx1MDMzNVxcdTAwMDcvXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDMzNVxcdTAwOTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMzNlxcdTAzMzdcXHUwMDA3LFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzMzdcXHUwMDk4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMzhcXHUwMzM5XFx1MDAwNzFcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzM5XFx1MDA5YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzNhXFx1MDMzYlxcdTAwMDdcXCdcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzNiXFx1MDA5Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzNjXFx1MDMzZFxcdTAwMDcoXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDMzZFxcdTAwOWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMzZVxcdTAzM2ZcXHUwMDA3flxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzM2ZcXHUwMGEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNDBcXHUwMzQxXFx1MDAwNyhcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzQxXFx1MDM0MlxcdTAwMDcoXFx1MDAwMlxcdTAwMDJcXHUwMzQyXFx1MDBhMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDM0M1xcdTAzNDRcXHUwMDA3flxcdTAwMDJcXHUwMDAyXFx1MDM0NFxcdTAzNDVcXHUwMDA3flxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNDVcXHUwMGE0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNDZcXHUwMzQ3XFx1MDAwN2BcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzQ3XFx1MDBhNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzQ4XFx1MDM0OVxcdTAwMDcjXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM0OVxcdTAwYThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM0YVxcdTAzNGJcXHUwMDA3XFx1MDA4MFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNGJcXHUwMGFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNGNcXHUwMzRkXFx1MDAwN0FcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzRkXFx1MDBhY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzRlXFx1MDM0ZlxcdTAwMDc8XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM0ZlxcdTAwYWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1MFxcdTAzNTFcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNTFcXHUwMGIwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNTJcXHUwMzUzXFx1MDAwNy5cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzUzXFx1MDBiMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzU0XFx1MDM1NVxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM1NVxcdTAwYjRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1NlxcdTAzNTdcXHUwMDA3LFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNTdcXHUwMzU4XFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzNThcXHUwMGI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzU5XFx1MDM1YVxcdTAwMDcxXFx1MDAwMlxcdTAwMDJcXHUwMzVhXFx1MDM1YlxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMzViXCIsXHJcbiAgICBcIlxcdTAwYjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1Y1xcdTAzNWRcXHUwMDA3XFwnXFx1MDAwMlxcdTAwMDJcXHUwMzVkXCIsXHJcbiAgICBcIlxcdTAzNWVcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDM1ZVxcdTAwYmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1ZlwiLFxyXG4gICAgXCJcXHUwMzYwXFx1MDAwNy1cXHUwMDAyXFx1MDAwMlxcdTAzNjBcXHUwMzYxXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzNjFcXHUwMGJjXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzYyXFx1MDM2M1xcdTAwMDcvXFx1MDAwMlxcdTAwMDJcXHUwMzYzXFx1MDM2NFwiLFxyXG4gICAgXCJcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDM2NFxcdTAwYmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM2NVxcdTAzNjZcIixcclxuICAgIFwiXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAzNjZcXHUwMzY3XFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAzNjdcXHUwMzY4XFx1MDAwN1wiLFxyXG4gICAgXCI/XFx1MDAwMlxcdTAwMDJcXHUwMzY4XFx1MDBjMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzY5XFx1MDM2YVxcdTAwMDdcIixcclxuICAgIFwiQFxcdTAwMDJcXHUwMDAyXFx1MDM2YVxcdTAzNmJcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDM2YlxcdTAzNmNcXHUwMDA3P1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzNmNcXHUwMGMyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNmRcXHUwMzZlXFx1MDAwNyhcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzZlXFx1MDM2ZlxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMzZmXFx1MDBjNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDM3MFxcdTAzNzFcXHUwMDA3YFxcdTAwMDJcXHUwMDAyXFx1MDM3MVxcdTAzNzJcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNzJcXHUwMGM2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNzNcXHUwMzc0XFx1MDAwN35cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzc0XFx1MDM3NVxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMzc1XFx1MDBjOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM3NlxcdTAzNzdcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDM3N1xcdTAzNzhcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDM3OFwiLFxyXG4gICAgXCJcXHUwMGNhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNzlcXHUwMzdhXFx1MDAwNyNcXHUwMDAyXFx1MDAwMlxcdTAzN2FcIixcclxuICAgIFwiXFx1MDM3YlxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMzdiXFx1MDBjY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzdjXCIsXHJcbiAgICBcIlxcdTAzN2RcXHUwMDA3L1xcdTAwMDJcXHUwMDAyXFx1MDM3ZFxcdTAzN2VcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDM3ZVxcdTAwY2VcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzN2ZcXHUwMzgwXFx1MDAwNzBcXHUwMDAyXFx1MDAwMlxcdTAzODBcXHUwMGQwXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzgxXFx1MDM4MlxcdTAwMDcwXFx1MDAwMlxcdTAwMDJcXHUwMzgyXFx1MDM4M1wiLFxyXG4gICAgXCJcXHUwMDA3MFxcdTAwMDJcXHUwMDAyXFx1MDM4M1xcdTAzODRcXHUwMDA3MFxcdTAwMDJcXHUwMDAyXFx1MDM4NFxcdTAwZDJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzODVcXHUwMzhhXFx1MDAwNVxcdTAwZDVrXFx1MDAwMlxcdTAzODZcXHUwMzg5XFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMGQ1a1xcdTAwMDJcXHUwMzg3XFx1MDM4OVxcdTAwMDVcXHUwMGQ5bVxcdTAwMDJcXHUwMzg4XFx1MDM4NlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDM4OFxcdTAzODdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM4OVxcdTAzOGNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzOGFcXHUwMzg4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOGFcXHUwMzhiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzhiXFx1MDBkNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzhjXFx1MDM4YVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDM4ZFxcdTAzOTBcXHUwMDA1XFx1MDBkN2xcXHUwMDAyXFx1MDM4ZVxcdTAzOTBcXHUwMDA1XFx1MDBkYlwiLFxyXG4gICAgXCJuXFx1MDAwMlxcdTAzOGZcXHUwMzhkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOGZcXHUwMzhlXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzkwXFx1MDBkNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzkxXFx1MDM5MlxcdFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzkyXFx1MDBkOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzkzXFx1MDM5NFxcdFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzk0XFx1MDBkYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzk1XFx1MDM5NlxcdTAwMDdeXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDM5NlxcdTAzOTdcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXFx1MDM5N1xcdTAzOThcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzOThcXHUwM2EwXFx1MDAwNVxcdTAwZGRvXFx1MDAwMlxcdTAzOTlcXHUwMzlhXFx1MDAwN15cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzlhXFx1MDM5YlxcdTAwMDdXXFx1MDAwMlxcdTAwMDJcXHUwMzliXFx1MDM5Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDM5Y1xcdTAzOWRcXHUwMDA1XFx1MDBkZG9cXHUwMDAyXFx1MDM5ZFxcdTAzOWVcXHUwMDA1XFx1MDBkZG9cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzOWVcXHUwM2EwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOWZcXHUwMzk1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzlmXFx1MDM5OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2EwXFx1MDBkY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDNhMVxcdTAzYTJcXHUwMDA1XFx1MDBmMXlcXHUwMDAyXFx1MDNhMlxcdTAzYTNcXHUwMDA1XFx1MDBmMXlcXHUwMDAyXFx1MDNhM1wiLFxyXG4gICAgXCJcXHUwM2E0XFx1MDAwNVxcdTAwZjF5XFx1MDAwMlxcdTAzYTRcXHUwM2E1XFx1MDAwNVxcdTAwZjF5XFx1MDAwMlxcdTAzYTVcXHUwMGRlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2E2XFx1MDNhYVxcdTAwMDVcXHUwMGUxcVxcdTAwMDJcXHUwM2E3XFx1MDNhYVwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDBmYn5cXHUwMDAyXFx1MDNhOFxcdTAzYWFcXHUwMDA1XFx1MDExMVxcdTAwODlcXHUwMDAyXFx1MDNhOVxcdTAzYTZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYTlcXHUwM2E3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYTlcXHUwM2E4XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2FhXFx1MDBlMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2FiXFx1MDNhZFwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDBlNXNcXHUwMDAyXFx1MDNhY1xcdTAzYWVcXHUwMDA1XFx1MDBmM3pcXHUwMDAyXFx1MDNhZFxcdTAzYWNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYWRcXHUwM2FlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYWVcXHUwM2I5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2FmXFx1MDNiMVxcdTAwMDVcXHUwMGU3dFxcdTAwMDJcXHUwM2IwXFx1MDNiMlxcdTAwMDVcIixcclxuICAgIFwiXFx1MDBmM3pcXHUwMDAyXFx1MDNiMVxcdTAzYjBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNiMVxcdTAzYjJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYjJcXHUwM2I5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYjNcXHUwM2I1XFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMGU5dVxcdTAwMDJcXHUwM2I0XFx1MDNiNlxcdTAwMDVcXHUwMGYzelxcdTAwMDJcXHUwM2I1XFx1MDNiNFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNiNVxcdTAzYjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNiNlxcdTAzYjlcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzYjdcXHUwM2I5XFx1MDAwNVxcdTAwZTNyXFx1MDAwMlxcdTAzYjhcXHUwM2FiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2I4XFx1MDNhZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2I4XFx1MDNiM1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNiOFxcdTAzYjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNiOVxcdTAwZTJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzYmFcXHUwM2JiXFx1MDAwNzJcXHUwMDAyXFx1MDAwMlxcdTAzYmJcXHUwM2JkXFx0XFx1MDAwNFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzYmNcXHUwM2JlXFx0XFx1MDAwNVxcdTAwMDJcXHUwMDAyXFx1MDNiZFxcdTAzYmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzYmVcXHUwM2JmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYmZcXHUwM2JkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2JmXFx1MDNjMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2MwXFx1MDBlNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDNjMVxcdTAzYzVcXHUwMDA1XFx1MDBlZHdcXHUwMDAyXFx1MDNjMlxcdTAzYzRcXHUwMDA1XFx1MDBkOW1cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzYzNcXHUwM2MyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYzRcXHUwM2M3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwM2M1XFx1MDNjM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2M1XFx1MDNjNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDNjNlxcdTAwZTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjN1xcdTAzYzVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzYzhcXHUwM2NjXFx1MDAwNzJcXHUwMDAyXFx1MDAwMlxcdTAzYzlcXHUwM2NiXFx1MDAwNVxcdTAwZWZ4XFx1MDAwMlxcdTAzY2FcIixcclxuICAgIFwiXFx1MDNjOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2NiXFx1MDNjZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2NjXCIsXHJcbiAgICBcIlxcdTAzY2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjY1xcdTAzY2RcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjZFwiLFxyXG4gICAgXCJcXHUwMGU4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzY2VcXHUwM2NjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzY2ZcIixcclxuICAgIFwiXFx1MDNkMVxcdTAwMDVcXHUwMGVidlxcdTAwMDJcXHUwM2QwXFx1MDNkMlxcdTAwMDVcXHUwMGYxeVxcdTAwMDJcXHUwM2QxXFx1MDNkMFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNkMlxcdTAzZDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNkM1xcdTAzZDFcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZDNcXHUwM2Q0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZDRcXHUwMGVhXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2Q1XFx1MDNkNlxcdTAwMDcyXFx1MDAwMlxcdTAwMDJcXHUwM2Q2XFx1MDNkN1wiLFxyXG4gICAgXCJcXHRcXHUwMDA2XFx1MDAwMlxcdTAwMDJcXHUwM2Q3XFx1MDBlY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2Q4XFx1MDNkOVwiLFxyXG4gICAgXCJcXHRcXHUwMDA3XFx1MDAwMlxcdTAwMDJcXHUwM2Q5XFx1MDBlZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2RhXFx1MDNkYlwiLFxyXG4gICAgXCJcXHRcXGJcXHUwMDAyXFx1MDAwMlxcdTAzZGJcXHUwMGYwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZGNcXHUwM2RkXFx0XFx0XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNkZFxcdTAwZjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNkZVxcdTAzZTBcXHUwMDA1XFx1MDBmNVwiLFxyXG4gICAgXCJ7XFx1MDAwMlxcdTAzZGZcXHUwM2UxXFx1MDAwNVxcdTAwZjd8XFx1MDAwMlxcdTAzZTBcXHUwM2RmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2UwXFx1MDNlMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2UxXFx1MDNlZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDNlMlxcdTAzZTNcXHUwMDA1XFx1MDBmNXtcXHUwMDAyXFx1MDNlM1xcdTAzZTRcXHUwMDA1XFx1MDBmOX1cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzZTRcXHUwM2VlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZTVcXHUwM2U3XFx1MDAwNVxcdTAwZjd8XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwM2U2XFx1MDNlOFxcdTAwMDVcXHUwMGY1e1xcdTAwMDJcXHUwM2U3XFx1MDNlNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDNlN1xcdTAzZThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlOFxcdTAzZWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzZTlcXHUwM2ViXFx1MDAwNVxcdTAwZjl9XFx1MDAwMlxcdTAzZWFcXHUwM2VjXFx1MDAwNVxcdTAwZjV7XFx1MDAwMlxcdTAzZWJcIixcclxuICAgIFwiXFx1MDNlYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2ViXFx1MDNlY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2VjXCIsXHJcbiAgICBcIlxcdTAzZWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlZFxcdTAzZGVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlZFwiLFxyXG4gICAgXCJcXHUwM2UyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZWRcXHUwM2U1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZWRcIixcclxuICAgIFwiXFx1MDNlOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2VlXFx1MDBmNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2VmXCIsXHJcbiAgICBcIlxcdTAzZjBcXHRcXG5cXHUwMDAyXFx1MDAwMlxcdTAzZjBcXHUwMGY2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZjFcXHUwM2YyXCIsXHJcbiAgICBcIlxcdFxcdTAwMGJcXHUwMDAyXFx1MDAwMlxcdTAzZjJcXHUwMGY4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZjNcXHUwM2Y0XCIsXHJcbiAgICBcIlxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwM2Y0XFx1MDNmOFxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwM2Y1XFx1MDNmNlxcdTAwMDdcIixcclxuICAgIFwiTlxcdTAwMDJcXHUwMDAyXFx1MDNmNlxcdTAzZjhcXHUwMDA3TlxcdTAwMDJcXHUwMDAyXFx1MDNmN1xcdTAzZjNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzZjdcXHUwM2Y1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZjhcXHUwMGZhXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2Y5XFx1MDNmY1xcdTAwMDVcXHUwMGZkXFx1MDA3ZlxcdTAwMDJcXHUwM2ZhXFx1MDNmY1xcdTAwMDVcXHUwMGZmXCIsXHJcbiAgICBcIlxcdTAwODBcXHUwMDAyXFx1MDNmYlxcdTAzZjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNmYlxcdTAzZmFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzZmNcXHUwMGZjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZmRcXHUwM2ZmXFx1MDAwNVxcdTAxMDFcIixcclxuICAgIFwiXFx1MDA4MVxcdTAwMDJcXHUwM2ZlXFx1MDQwMFxcdTAwMDVcXHUwMTAzXFx1MDA4MlxcdTAwMDJcXHUwM2ZmXFx1MDNmZVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNmZlxcdTA0MDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQwMFxcdTA0MDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MDFcXHUwNDAzXFx1MDAwNVxcdTAxMGZcXHUwMDg4XFx1MDAwMlxcdTA0MDJcXHUwNDAxXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDAyXFx1MDQwM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDAzXFx1MDQwYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQwNFxcdTA0MDVcXHUwMDA1XFx1MDEwN1xcdTAwODRcXHUwMDAyXFx1MDQwNVxcdTA0MDdcXHUwMDA1XFx1MDEwM1wiLFxyXG4gICAgXCJcXHUwMDgyXFx1MDAwMlxcdTA0MDZcXHUwNDA4XFx1MDAwNVxcdTAxMGZcXHUwMDg4XFx1MDAwMlxcdTA0MDdcXHUwNDA2XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDA3XFx1MDQwOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDA4XFx1MDQwYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQwOVxcdTAzZmRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQwOVxcdTA0MDRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MGFcXHUwMGZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MGJcXHUwNDBjXFx1MDAwNVxcdTAwZWJcIixcclxuICAgIFwidlxcdTAwMDJcXHUwNDBjXFx1MDQwZFxcdTAwMDVcXHUwMTA5XFx1MDA4NVxcdTAwMDJcXHUwNDBkXFx1MDQwZlxcdTAwMDVcXHUwMTBiXCIsXHJcbiAgICBcIlxcdTAwODZcXHUwMDAyXFx1MDQwZVxcdTA0MTBcXHUwMDA1XFx1MDEwZlxcdTAwODhcXHUwMDAyXFx1MDQwZlxcdTA0MGVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MGZcXHUwNDEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MTBcXHUwNDE4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDExXFx1MDQxMlxcdTAwMDVcXHUwMGVidlxcdTAwMDJcXHUwNDEyXFx1MDQxM1xcdTAwMDVcXHUwMTBkXCIsXHJcbiAgICBcIlxcdTAwODdcXHUwMDAyXFx1MDQxM1xcdTA0MTVcXHUwMDA1XFx1MDEwYlxcdTAwODZcXHUwMDAyXFx1MDQxNFxcdTA0MTZcXHUwMDA1XFx1MDEwZlwiLFxyXG4gICAgXCJcXHUwMDg4XFx1MDAwMlxcdTA0MTVcXHUwNDE0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MTVcXHUwNDE2XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDE2XFx1MDQxOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDE3XFx1MDQwYlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQxN1xcdTA0MTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQxOFxcdTAxMDBcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MTlcXHUwNDFiXFx1MDAwNVxcdTAxMDdcXHUwMDg0XFx1MDAwMlxcdTA0MWFcXHUwNDE5XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDFhXFx1MDQxYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDFiXFx1MDQxY1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQxY1xcdTA0MWRcXHUwMDA3MFxcdTAwMDJcXHUwMDAyXFx1MDQxZFxcdTA0MjJcXHUwMDA1XFx1MDEwN1wiLFxyXG4gICAgXCJcXHUwMDg0XFx1MDAwMlxcdTA0MWVcXHUwNDFmXFx1MDAwNVxcdTAxMDdcXHUwMDg0XFx1MDAwMlxcdTA0MWZcXHUwNDIwXFx1MDAwNzBcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDIwXFx1MDQyMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDIxXFx1MDQxYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQyMVxcdTA0MWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQyMlxcdTAxMDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MjNcXHUwNDI1XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTA0MjRcXHUwNDI2XFx1MDAwNVxcdTAxMDVcIixcclxuICAgIFwiXFx1MDA4M1xcdTAwMDJcXHUwNDI1XFx1MDQyNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDI1XFx1MDQyNlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQyNlxcdTA0MjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQyN1xcdTA0MmVcXHUwMDA1XFx1MDEwN1wiLFxyXG4gICAgXCJcXHUwMDg0XFx1MDAwMlxcdTA0MjhcXHUwNDJhXFx1MDAwN0dcXHUwMDAyXFx1MDAwMlxcdTA0MjlcXHUwNDJiXFx1MDAwNVxcdTAxMDVcIixcclxuICAgIFwiXFx1MDA4M1xcdTAwMDJcXHUwNDJhXFx1MDQyOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDJhXFx1MDQyYlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQyYlxcdTA0MmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQyY1xcdTA0MmVcXHUwMDA1XFx1MDEwN1wiLFxyXG4gICAgXCJcXHUwMDg0XFx1MDAwMlxcdTA0MmRcXHUwNDIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MmRcXHUwNDI4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDJlXFx1MDEwNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDJmXFx1MDQzMFxcdFxcZlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0MzBcXHUwMTA2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MzFcXHUwNDMzXFx1MDAwNVxcdTAwZDltXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDMyXFx1MDQzMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDMzXFx1MDQzNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQzNFxcdTA0MzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQzNFxcdTA0MzVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0MzVcXHUwMTA4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MzZcXHUwNDM4XFx1MDAwNVxcdTAxMGRcXHUwMDg3XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDM3XFx1MDQzNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDM3XFx1MDQzOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQzOFxcdTA0MzlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQzOVxcdTA0M2FcXHUwMDA3MFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0M2FcXHUwNDNmXFx1MDAwNVxcdTAxMGRcXHUwMDg3XFx1MDAwMlxcdTA0M2JcXHUwNDNjXFx1MDAwNVxcdTAxMGRcXHUwMDg3XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDNjXFx1MDQzZFxcdTAwMDcwXFx1MDAwMlxcdTAwMDJcXHUwNDNkXFx1MDQzZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQzZVxcdTA0MzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQzZVxcdTA0M2JcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0M2ZcXHUwMTBhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NDBcXHUwNDQyXFx1MDAwN3JcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDQxXFx1MDQ0M1xcdTAwMDVcXHUwMTA1XFx1MDA4M1xcdTAwMDJcXHUwNDQyXFx1MDQ0MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQ0MlxcdTA0NDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0M1xcdTA0NDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0NDRcXHUwNDRiXFx1MDAwNVxcdTAxMDdcXHUwMDg0XFx1MDAwMlxcdTA0NDVcXHUwNDQ3XFx1MDAwN1JcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDQ2XFx1MDQ0OFxcdTAwMDVcXHUwMTA1XFx1MDA4M1xcdTAwMDJcXHUwNDQ3XFx1MDQ0NlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQ0N1xcdTA0NDhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0OFxcdTA0NDlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0NDlcXHUwNDRiXFx1MDAwNVxcdTAxMDdcXHUwMDg0XFx1MDAwMlxcdTA0NGFcXHUwNDQwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDRhXFx1MDQ0NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDRiXFx1MDEwY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQ0Y1xcdTA0NGVcXHUwMDA1XFx1MDBmMXlcXHUwMDAyXFx1MDQ0ZFxcdTA0NGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0NGVcXHUwNDRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NGZcXHUwNDRkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDRmXFx1MDQ1MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDUwXFx1MDEwZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQ1MVxcdTA0NTJcXHRcXHJcXHUwMDAyXFx1MDAwMlxcdTA0NTJcXHUwMTEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDUzXFx1MDQ1NFxcdTAwMDcpXFx1MDAwMlxcdTAwMDJcXHUwNDU0XFx1MDQ1NVxcdTAwMDVcXHUwMTEzXFx1MDA4YVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ1NVxcdTA0NTZcXHUwMDA3KVxcdTAwMDJcXHUwMDAyXFx1MDQ1NlxcdTA0NmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NTdcXHUwNDU4XFx1MDAwN05cXHUwMDAyXFx1MDAwMlxcdTA0NThcXHUwNDU5XFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTA0NTlcIixcclxuICAgIFwiXFx1MDQ1YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDVhXFx1MDQ1YlxcdTAwMDVcXHUwMTEzXFx1MDA4YVxcdTAwMDJcXHUwNDViXCIsXHJcbiAgICBcIlxcdTA0NWNcXHUwMDA3KVxcdTAwMDJcXHUwMDAyXFx1MDQ1Y1xcdTA0NmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ1ZFwiLFxyXG4gICAgXCJcXHUwNDVlXFx1MDAwN3dcXHUwMDAyXFx1MDAwMlxcdTA0NWVcXHUwNDVmXFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTA0NWZcXHUwNDYwXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDYwXFx1MDQ2MVxcdTAwMDVcXHUwMTEzXFx1MDA4YVxcdTAwMDJcXHUwNDYxXFx1MDQ2MlwiLFxyXG4gICAgXCJcXHUwMDA3KVxcdTAwMDJcXHUwMDAyXFx1MDQ2MlxcdTA0NmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ2M1xcdTA0NjRcIixcclxuICAgIFwiXFx1MDAwN1dcXHUwMDAyXFx1MDAwMlxcdTA0NjRcXHUwNDY1XFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTA0NjVcXHUwNDY2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDY2XFx1MDQ2N1xcdTAwMDVcXHUwMTEzXFx1MDA4YVxcdTAwMDJcXHUwNDY3XFx1MDQ2OFxcdTAwMDdcIixcclxuICAgIFwiKVxcdTAwMDJcXHUwMDAyXFx1MDQ2OFxcdTA0NmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ2OVxcdTA0NTNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NjlcXHUwNDU3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NjlcXHUwNDVkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDY5XFx1MDQ2M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDZhXFx1MDExMlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ2YlxcdTA0NmRcXHUwMDA1XFx1MDExNVxcdTAwOGJcXHUwMDAyXFx1MDQ2Y1xcdTA0NmJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NmRcXHUwNDZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NmVcXHUwNDZjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDZlXFx1MDQ2ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDZmXFx1MDExNFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3MFxcdTA0NzNcXG5cXHUwMDBlXFx1MDAwMlxcdTAwMDJcXHUwNDcxXFx1MDQ3M1xcdTAwMDVcIixcclxuICAgIFwiXFx1MDExN1xcdTAwOGNcXHUwMDAyXFx1MDQ3MlxcdTA0NzBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3MlxcdTA0NzFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NzNcXHUwMTE2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NzRcXHUwNDc5XFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMTE5XFx1MDA4ZFxcdTAwMDJcXHUwNDc1XFx1MDQ3OVxcdTAwMDVcXHUwMTFiXFx1MDA4ZVxcdTAwMDJcXHUwNDc2XFx1MDQ3OVxcdTAwMDVcIixcclxuICAgIFwiXFx1MDExZFxcdTAwOGZcXHUwMDAyXFx1MDQ3N1xcdTA0NzlcXHUwMDA1XFx1MDBkYm5cXHUwMDAyXFx1MDQ3OFxcdTA0NzRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NzhcXHUwNDc1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NzhcXHUwNDc2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDc4XFx1MDQ3N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDc5XFx1MDExOFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3YVxcdTA0N2JcXHUwMDA3XlxcdTAwMDJcXHUwMDAyXFx1MDQ3YlxcdTA0N2NcXHRcXHUwMDBmXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ3Y1xcdTAxMWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3ZFxcdTA0N2VcXHUwMDA3XlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0N2VcXHUwNDg5XFx1MDAwNVxcdTAwZWZ4XFx1MDAwMlxcdTA0N2ZcXHUwNDgwXFx1MDAwN15cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDgwXFx1MDQ4MVxcdTAwMDVcXHUwMGVmeFxcdTAwMDJcXHUwNDgxXFx1MDQ4MlxcdTAwMDVcXHUwMGVmeFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ4MlxcdTA0ODlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ4M1xcdTA0ODRcXHUwMDA3XlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0ODRcXHUwNDg1XFx1MDAwNVxcdTAwZWZ4XFx1MDAwMlxcdTA0ODVcXHUwNDg2XFx1MDAwNVxcdTAwZWZ4XFx1MDAwMlxcdTA0ODZcIixcclxuICAgIFwiXFx1MDQ4N1xcdTAwMDVcXHUwMGVmeFxcdTAwMDJcXHUwNDg3XFx1MDQ4OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDg4XCIsXHJcbiAgICBcIlxcdTA0N2RcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ4OFxcdTA0N2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ4OFwiLFxyXG4gICAgXCJcXHUwNDgzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ODlcXHUwMTFjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OGFcIixcclxuICAgIFwiXFx1MDQ4YlxcdTAwMDdeXFx1MDAwMlxcdTAwMDJcXHUwNDhiXFx1MDQ4Y1xcdTAwMDd6XFx1MDAwMlxcdTAwMDJcXHUwNDhjXFx1MDQ4ZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ4ZFxcdTA0OGZcXHUwMDA1XFx1MDBmMXlcXHUwMDAyXFx1MDQ4ZVxcdTA0OGRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OGZcXHUwNDkwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OTBcXHUwNDhlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDkwXFx1MDQ5MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDkxXFx1MDExZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ5MlxcdTA0OTRcXHUwMDA1XFx1MDEyMVxcdTAwOTFcXHUwMDAyXFx1MDQ5M1xcdTA0OTJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OTNcXHUwNDk0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OTRcXHUwNDk1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDk1XFx1MDQ5N1xcdTAwMDckXFx1MDAwMlxcdTAwMDJcXHUwNDk2XFx1MDQ5OFwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDEyM1xcdTAwOTJcXHUwMDAyXFx1MDQ5N1xcdTA0OTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ5N1xcdTA0OThcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OThcXHUwNDk5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OTlcXHUwNDlhXCIsXHJcbiAgICBcIlxcdTAwMDckXFx1MDAwMlxcdTAwMDJcXHUwNDlhXFx1MDEyMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDliXFx1MDQ5Y1wiLFxyXG4gICAgXCJcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXFx1MDQ5Y1xcdTA0OWZcXHUwMDA3OlxcdTAwMDJcXHUwMDAyXFx1MDQ5ZFxcdTA0OWZcXHRcXHUwMDEwXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ5ZVxcdTA0OWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ5ZVxcdTA0OWRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0OWZcXHUwMTIyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YTBcXHUwNGEyXFx1MDAwNVxcdTAxMjVcIixcclxuICAgIFwiXFx1MDA5M1xcdTAwMDJcXHUwNGExXFx1MDRhMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGEyXFx1MDRhM1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRhM1xcdTA0YTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRhM1xcdTA0YTRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YTRcXHUwMTI0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YTVcXHUwNGFkXFxuXFx1MDAxMVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YTZcXHUwNGFkXFx1MDAwNVxcdTAxMTdcXHUwMDhjXFx1MDAwMlxcdTA0YTdcXHUwNGE4XFx1MDAwN15cIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGE4XFx1MDRhZFxcdTAwMDdcXGZcXHUwMDAyXFx1MDAwMlxcdTA0YTlcXHUwNGFhXFx1MDAwN15cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGFhXFx1MDRhYlxcdTAwMDdcXHUwMDBmXFx1MDAwMlxcdTAwMDJcXHUwNGFiXFx1MDRhZFxcdTAwMDdcXGZcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGFjXFx1MDRhNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGFjXFx1MDRhNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRhY1xcdTA0YTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRhY1xcdTA0YTlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0YWRcXHUwMTI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YWVcXHUwNGIwXFx1MDAwNyVcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGFmXFx1MDRiMVxcdTAwMDVcXHUwMTMxXFx1MDA5OVxcdTAwMDJcXHUwNGIwXFx1MDRhZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRiMFxcdTA0YjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRiMVxcdTA0YjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0YjJcXHUwNGIzXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTA0YjNcXHUwNGI0XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNGI0XFx1MDRiNVxcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwNGI1XFx1MDRiNlxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwNGI2XCIsXHJcbiAgICBcIlxcdTA0YjdcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDRiN1xcdTA0YjhcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDRiOFxcdTA0YmNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YjlcXHUwNGJiXFxuXFx1MDAxMlxcdTAwMDJcXHUwMDAyXFx1MDRiYVxcdTA0YjlcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YmJcXHUwNGJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YmNcXHUwNGJhXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGJjXFx1MDRiZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGJkXFx1MDRiZlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRiZVxcdTA0YmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRiZlxcdTA0YzBcIixcclxuICAgIFwiXFxiXFx1MDA5NFxcdTAwMDJcXHUwMDAyXFx1MDRjMFxcdTAxMjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjMVxcdTA0YzJcIixcclxuICAgIFwiXFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTA0YzJcXHUwNGMzXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTA0YzNcXHUwNGM0XFx1MDAwN1wiLFxyXG4gICAgXCJvXFx1MDAwMlxcdTAwMDJcXHUwNGM0XFx1MDRjOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGM1XFx1MDRjN1xcblxcdTAwMTNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGM2XFx1MDRjNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGM3XFx1MDRjYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRjOFxcdTA0YzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjOFxcdTA0YzlcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YzlcXHUwNGNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0Y2FcXHUwNGM4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGNiXFx1MDRjZlxcdTAwMDd9XFx1MDAwMlxcdTAwMDJcXHUwNGNjXFx1MDRjZVxcblxcdTAwMTRcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGNkXFx1MDRjY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGNlXFx1MDRkMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRjZlxcdTA0Y2RcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjZlxcdTA0ZDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0ZDBcXHUwNGQyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZDFcXHUwNGNmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGQyXFx1MDRkM1xcdTAwMDdcXHUwMDdmXFx1MDAwMlxcdTAwMDJcXHUwNGQzXFx1MDRkNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRkNFxcdTA0ZDVcXGJcXHUwMDk1XFx1MDAwMlxcdTAwMDJcXHUwNGQ1XFx1MDEyYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRkNlxcdTA0ZDdcXHUwMDA3JVxcdTAwMDJcXHUwMDAyXFx1MDRkN1xcdTA0ZDhcXHUwMDA3blxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0ZDhcXHUwNGQ5XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTA0ZDlcXHUwNGRhXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTA0ZGFcIixcclxuICAgIFwiXFx1MDRkYlxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwNGRiXFx1MDRkZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGRjXCIsXHJcbiAgICBcIlxcdTA0ZGVcXHUwMDA1XFx1MDEzMVxcdTAwOTlcXHUwMDAyXFx1MDRkZFxcdTA0ZGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkZVwiLFxyXG4gICAgXCJcXHUwNGUxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZGZcXHUwNGRkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZGZcIixcclxuICAgIFwiXFx1MDRlMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGUwXFx1MDRlNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGUxXCIsXHJcbiAgICBcIlxcdTA0ZGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRlMlxcdTA0ZTRcXG5cXHUwMDE1XFx1MDAwMlxcdTAwMDJcXHUwNGUzXCIsXHJcbiAgICBcIlxcdTA0ZTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRlNFxcdTA0ZTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRlNVwiLFxyXG4gICAgXCJcXHUwNGUzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZTVcXHUwNGU2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZTZcIixcclxuICAgIFwiXFx1MDRlOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGU3XFx1MDRlNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGU4XCIsXHJcbiAgICBcIlxcdTA0ZTlcXGJcXHUwMDk2XFx1MDAwMlxcdTAwMDJcXHUwNGU5XFx1MDEyY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGVhXCIsXHJcbiAgICBcIlxcdTA0ZWNcXHUwMDA3JVxcdTAwMDJcXHUwMDAyXFx1MDRlYlxcdTA0ZWRcXHUwMDA1XFx1MDEzMVxcdTAwOTlcXHUwMDAyXFx1MDRlY1wiLFxyXG4gICAgXCJcXHUwNGViXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZWNcXHUwNGVkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZWRcIixcclxuICAgIFwiXFx1MDRlZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGVlXFx1MDRmMFxcdTAwMDVcXHUwMGU1c1xcdTAwMDJcXHUwNGVmXCIsXHJcbiAgICBcIlxcdTA0ZjFcXHUwMDA1XFx1MDEzMVxcdTAwOTlcXHUwMDAyXFx1MDRmMFxcdTA0ZWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmMFwiLFxyXG4gICAgXCJcXHUwNGYxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjFcXHUwNGYyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjJcIixcclxuICAgIFwiXFx1MDRmNlxcdTAwMDVcXHUwMTFmXFx1MDA5MFxcdTAwMDJcXHUwNGYzXFx1MDRmNVxcblxcdTAwMTVcXHUwMDAyXFx1MDAwMlxcdTA0ZjRcIixcclxuICAgIFwiXFx1MDRmM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGY1XFx1MDRmOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGY2XCIsXHJcbiAgICBcIlxcdTA0ZjRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmNlxcdTA0ZjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmN1wiLFxyXG4gICAgXCJcXHUwNGY5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjhcXHUwNGY2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjlcIixcclxuICAgIFwiXFx1MDRmYVxcYlxcdTAwOTdcXHUwMDAyXFx1MDAwMlxcdTA0ZmFcXHUwMTJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZmJcIixcclxuICAgIFwiXFx1MDRmZFxcdTAwMDclXFx1MDAwMlxcdTAwMDJcXHUwNGZjXFx1MDRmZVxcdTAwMDVcXHUwMTMxXFx1MDA5OVxcdTAwMDJcXHUwNGZkXCIsXHJcbiAgICBcIlxcdTA0ZmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmZFxcdTA0ZmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmZVwiLFxyXG4gICAgXCJcXHUwNGZmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZmZcXHUwNTAwXFx1MDAwN3JcXHUwMDAyXFx1MDAwMlxcdTA1MDBcIixcclxuICAgIFwiXFx1MDUwMVxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwNTAxXFx1MDUwMlxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwNTAyXFx1MDUwM1wiLFxyXG4gICAgXCJcXHUwMDA3aVxcdTAwMDJcXHUwMDAyXFx1MDUwM1xcdTA1MDRcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXFx1MDUwNFxcdTA1MDVcXHUwMDA3XCIsXHJcbiAgICBcImNcXHUwMDAyXFx1MDAwMlxcdTA1MDVcXHUwNTA2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MDZcXHUwNTBhXFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMTMxXFx1MDA5OVxcdTAwMDJcXHUwNTA3XFx1MDUwOVxcblxcdTAwMTVcXHUwMDAyXFx1MDAwMlxcdTA1MDhcXHUwNTA3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTA5XFx1MDUwY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTBhXFx1MDUwOFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUwYVxcdTA1MGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUwYlxcdTA1MGRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MGNcXHUwNTBhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MGRcXHUwNTBlXFxiXCIsXHJcbiAgICBcIlxcdTAwOThcXHUwMDAyXFx1MDAwMlxcdTA1MGVcXHUwMTMwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MGZcXHUwNTExXFx0XCIsXHJcbiAgICBcIlxcdTAwMTZcXHUwMDAyXFx1MDAwMlxcdTA1MTBcXHUwNTBmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MTFcXHUwNTEyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTEyXFx1MDUxMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTEyXFx1MDUxM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUxM1xcdTA1MTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUxNFxcdTA1MTVcXGJcIixcclxuICAgIFwiXFx1MDA5OVxcdTAwMDJcXHUwMDAyXFx1MDUxNVxcdTAxMzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUxNlxcdTA1MThcXHUwMDA3XCIsXHJcbiAgICBcIlxcdTAwMGZcXHUwMDAyXFx1MDAwMlxcdTA1MTdcXHUwNTE5XFx1MDAwN1xcZlxcdTAwMDJcXHUwMDAyXFx1MDUxOFxcdTA1MTdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MThcXHUwNTE5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MTlcXHUwNTFjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTFhXFx1MDUxY1xcdTAwMDdcXGZcXHUwMDAyXFx1MDAwMlxcdTA1MWJcXHUwNTE2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTFiXFx1MDUxYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTFjXFx1MDUxZFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUxZFxcdTA1MWVcXGJcXHUwMDlhXFx1MDAwMlxcdTAwMDJcXHUwNTFlXFx1MDEzNFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUxZlxcdTA1MjBcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDUyMFxcdTA1MjFcXHUwMDA3XCIsXHJcbiAgICBcIixcXHUwMDAyXFx1MDAwMlxcdTA1MjFcXHUwNTI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MjJcXHUwNTI0XFx1MDAwYlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTIzXFx1MDUyMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTI0XFx1MDUyN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUyNVxcdTA1MjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUyNVxcdTA1MjNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MjZcXHUwNTI4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MjdcXHUwNTI1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTI4XFx1MDUyOVxcdTAwMDcsXFx1MDAwMlxcdTAwMDJcXHUwNTI5XFx1MDUyYVxcdTAwMDdcIixcclxuICAgIFwiMVxcdTAwMDJcXHUwMDAyXFx1MDUyYVxcdTA1MmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUyYlxcdTA1MmNcXGJcXHUwMDliXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDUyY1xcdTAxMzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUyZFxcdTA1MmVcXHUwMDA3MVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA1MmVcXHUwNTJmXFx1MDAwNzFcXHUwMDAyXFx1MDAwMlxcdTA1MmZcXHUwNTMzXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNTMwXFx1MDUzMlxcblxcdTAwMTVcXHUwMDAyXFx1MDAwMlxcdTA1MzFcXHUwNTMwXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNTMyXFx1MDUzNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNTMzXFx1MDUzMVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDUzM1xcdTA1MzRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUzNFxcdTA1MzZcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA1MzVcXHUwNTMzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MzZcXHUwNTM3XFxiXFx1MDA5Y1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA1MzdcXHUwMTM4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkRcXHUwMDAyXFx1MDM4OFxcdTAzOGFcIixcclxuICAgIFwiXFx1MDM4ZlxcdTAzOWZcXHUwM2E5XFx1MDNhZFxcdTAzYjFcXHUwM2I1XFx1MDNiOFxcdTAzYmZcXHUwM2M1XFx1MDNjY1xcdTAzZDNcXHUwM2UwXCIsXHJcbiAgICBcIlxcdTAzZTdcXHUwM2ViXFx1MDNlZFxcdTAzZjdcXHUwM2ZiXFx1MDNmZlxcdTA0MDJcXHUwNDA3XFx1MDQwOVxcdTA0MGZcXHUwNDE1XFx1MDQxN1wiLFxyXG4gICAgXCJcXHUwNDFhXFx1MDQyMVxcdTA0MjVcXHUwNDJhXFx1MDQyZFxcdTA0MzRcXHUwNDM3XFx1MDQzZVxcdTA0NDJcXHUwNDQ3XFx1MDQ0YVxcdTA0NGZcIixcclxuICAgIFwiXFx1MDQ2OVxcdTA0NmVcXHUwNDcyXFx1MDQ3OFxcdTA0ODhcXHUwNDkwXFx1MDQ5M1xcdTA0OTdcXHUwNDllXFx1MDRhM1xcdTA0YWNcXHUwNGIwXCIsXHJcbiAgICBcIlxcdTA0YmNcXHUwNGM4XFx1MDRjZlxcdTA0ZGZcXHUwNGU1XFx1MDRlY1xcdTA0ZjBcXHUwNGY2XFx1MDRmZFxcdTA1MGFcXHUwNTEyXFx1MDUxOFwiLFxyXG4gICAgXCJcXHUwNTFiXFx1MDUyNVxcdTA1MzNcXHUwMDAzXFxiXFx1MDAwMlxcdTAwMDJcIl0uam9pbihcIlwiKTtcclxuXHJcblxyXG52YXIgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XHJcblxyXG52YXIgZGVjaXNpb25zVG9ERkEgPSBhdG4uZGVjaXNpb25Ub1N0YXRlLm1hcCggZnVuY3Rpb24oZHMsIGluZGV4KSB7IHJldHVybiBuZXcgYW50bHI0LmRmYS5ERkEoZHMsIGluZGV4KTsgfSk7XHJcblxyXG5mdW5jdGlvbiBDTGV4ZXIoaW5wdXQpIHtcclxuXHRhbnRscjQuTGV4ZXIuY2FsbCh0aGlzLCBpbnB1dCk7XHJcbiAgICB0aGlzLl9pbnRlcnAgPSBuZXcgYW50bHI0LmF0bi5MZXhlckFUTlNpbXVsYXRvcih0aGlzLCBhdG4sIGRlY2lzaW9uc1RvREZBLCBuZXcgYW50bHI0LlByZWRpY3Rpb25Db250ZXh0Q2FjaGUoKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQ0xleGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LkxleGVyLnByb3RvdHlwZSk7XHJcbkNMZXhlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDTGV4ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ0xleGVyLnByb3RvdHlwZSwgXCJhdG5cIiwge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0bjtcclxuICAgICAgICB9XHJcbn0pO1xyXG5cclxuQ0xleGVyLkVPRiA9IGFudGxyNC5Ub2tlbi5FT0Y7XHJcbkNMZXhlci5UX18wID0gMTtcclxuQ0xleGVyLlRfXzEgPSAyO1xyXG5DTGV4ZXIuVF9fMiA9IDM7XHJcbkNMZXhlci5UX18zID0gNDtcclxuQ0xleGVyLlRfXzQgPSA1O1xyXG5DTGV4ZXIuVF9fNSA9IDY7XHJcbkNMZXhlci5UX182ID0gNztcclxuQ0xleGVyLlRfXzcgPSA4O1xyXG5DTGV4ZXIuVF9fOCA9IDk7XHJcbkNMZXhlci5UX185ID0gMTA7XHJcbkNMZXhlci5UX18xMCA9IDExO1xyXG5DTGV4ZXIuVF9fMTEgPSAxMjtcclxuQ0xleGVyLlRfXzEyID0gMTM7XHJcbkNMZXhlci5UX18xMyA9IDE0O1xyXG5DTGV4ZXIuQXV0byA9IDE1O1xyXG5DTGV4ZXIuQnJlYWsgPSAxNjtcclxuQ0xleGVyLkNhc2UgPSAxNztcclxuQ0xleGVyLkNoYXIgPSAxODtcclxuQ0xleGVyLkNvbnN0ID0gMTk7XHJcbkNMZXhlci5Db250aW51ZSA9IDIwO1xyXG5DTGV4ZXIuRGVmYXVsdCA9IDIxO1xyXG5DTGV4ZXIuRG8gPSAyMjtcclxuQ0xleGVyLkRvdWJsZSA9IDIzO1xyXG5DTGV4ZXIuRWxzZSA9IDI0O1xyXG5DTGV4ZXIuRW51bSA9IDI1O1xyXG5DTGV4ZXIuRXh0ZXJuID0gMjY7XHJcbkNMZXhlci5GbG9hdCA9IDI3O1xyXG5DTGV4ZXIuRm9yID0gMjg7XHJcbkNMZXhlci5Hb3RvID0gMjk7XHJcbkNMZXhlci5JZiA9IDMwO1xyXG5DTGV4ZXIuSW5saW5lID0gMzE7XHJcbkNMZXhlci5JbnQgPSAzMjtcclxuQ0xleGVyLkxvbmcgPSAzMztcclxuQ0xleGVyLlJlZ2lzdGVyID0gMzQ7XHJcbkNMZXhlci5SZXN0cmljdCA9IDM1O1xyXG5DTGV4ZXIuUmV0dXJuID0gMzY7XHJcbkNMZXhlci5TaG9ydCA9IDM3O1xyXG5DTGV4ZXIuU2lnbmVkID0gMzg7XHJcbkNMZXhlci5TaXplb2YgPSAzOTtcclxuQ0xleGVyLlN0YXRpYyA9IDQwO1xyXG5DTGV4ZXIuU3RydWN0ID0gNDE7XHJcbkNMZXhlci5Td2l0Y2ggPSA0MjtcclxuQ0xleGVyLlR5cGVkZWYgPSA0MztcclxuQ0xleGVyLlVuaW9uID0gNDQ7XHJcbkNMZXhlci5VbnNpZ25lZCA9IDQ1O1xyXG5DTGV4ZXIuVm9pZCA9IDQ2O1xyXG5DTGV4ZXIuVm9sYXRpbGUgPSA0NztcclxuQ0xleGVyLldoaWxlID0gNDg7XHJcbkNMZXhlci5BbGlnbmFzID0gNDk7XHJcbkNMZXhlci5BbGlnbm9mID0gNTA7XHJcbkNMZXhlci5BdG9taWMgPSA1MTtcclxuQ0xleGVyLkJvb2wgPSA1MjtcclxuQ0xleGVyLkNvbXBsZXggPSA1MztcclxuQ0xleGVyLkdlbmVyaWMgPSA1NDtcclxuQ0xleGVyLkltYWdpbmFyeSA9IDU1O1xyXG5DTGV4ZXIuTm9yZXR1cm4gPSA1NjtcclxuQ0xleGVyLlN0YXRpY0Fzc2VydCA9IDU3O1xyXG5DTGV4ZXIuVGhyZWFkTG9jYWwgPSA1ODtcclxuQ0xleGVyLkxlZnRQYXJlbiA9IDU5O1xyXG5DTGV4ZXIuUmlnaHRQYXJlbiA9IDYwO1xyXG5DTGV4ZXIuTGVmdEJyYWNrZXQgPSA2MTtcclxuQ0xleGVyLlJpZ2h0QnJhY2tldCA9IDYyO1xyXG5DTGV4ZXIuTGVmdEJyYWNlID0gNjM7XHJcbkNMZXhlci5SaWdodEJyYWNlID0gNjQ7XHJcbkNMZXhlci5MZXNzID0gNjU7XHJcbkNMZXhlci5MZXNzRXF1YWwgPSA2NjtcclxuQ0xleGVyLkdyZWF0ZXIgPSA2NztcclxuQ0xleGVyLkdyZWF0ZXJFcXVhbCA9IDY4O1xyXG5DTGV4ZXIuTGVmdFNoaWZ0ID0gNjk7XHJcbkNMZXhlci5SaWdodFNoaWZ0ID0gNzA7XHJcbkNMZXhlci5QbHVzID0gNzE7XHJcbkNMZXhlci5QbHVzUGx1cyA9IDcyO1xyXG5DTGV4ZXIuTWludXMgPSA3MztcclxuQ0xleGVyLk1pbnVzTWludXMgPSA3NDtcclxuQ0xleGVyLlN0YXIgPSA3NTtcclxuQ0xleGVyLkRpdiA9IDc2O1xyXG5DTGV4ZXIuTW9kID0gNzc7XHJcbkNMZXhlci5BbmQgPSA3ODtcclxuQ0xleGVyLk9yID0gNzk7XHJcbkNMZXhlci5BbmRBbmQgPSA4MDtcclxuQ0xleGVyLk9yT3IgPSA4MTtcclxuQ0xleGVyLkNhcmV0ID0gODI7XHJcbkNMZXhlci5Ob3QgPSA4MztcclxuQ0xleGVyLlRpbGRlID0gODQ7XHJcbkNMZXhlci5RdWVzdGlvbiA9IDg1O1xyXG5DTGV4ZXIuQ29sb24gPSA4NjtcclxuQ0xleGVyLlNlbWkgPSA4NztcclxuQ0xleGVyLkNvbW1hID0gODg7XHJcbkNMZXhlci5Bc3NpZ24gPSA4OTtcclxuQ0xleGVyLlN0YXJBc3NpZ24gPSA5MDtcclxuQ0xleGVyLkRpdkFzc2lnbiA9IDkxO1xyXG5DTGV4ZXIuTW9kQXNzaWduID0gOTI7XHJcbkNMZXhlci5QbHVzQXNzaWduID0gOTM7XHJcbkNMZXhlci5NaW51c0Fzc2lnbiA9IDk0O1xyXG5DTGV4ZXIuTGVmdFNoaWZ0QXNzaWduID0gOTU7XHJcbkNMZXhlci5SaWdodFNoaWZ0QXNzaWduID0gOTY7XHJcbkNMZXhlci5BbmRBc3NpZ24gPSA5NztcclxuQ0xleGVyLlhvckFzc2lnbiA9IDk4O1xyXG5DTGV4ZXIuT3JBc3NpZ24gPSA5OTtcclxuQ0xleGVyLkVxdWFsID0gMTAwO1xyXG5DTGV4ZXIuTm90RXF1YWwgPSAxMDE7XHJcbkNMZXhlci5BcnJvdyA9IDEwMjtcclxuQ0xleGVyLkRvdCA9IDEwMztcclxuQ0xleGVyLkVsbGlwc2lzID0gMTA0O1xyXG5DTGV4ZXIuSWRlbnRpZmllciA9IDEwNTtcclxuQ0xleGVyLkNvbnN0YW50ID0gMTA2O1xyXG5DTGV4ZXIuRGlnaXRTZXF1ZW5jZSA9IDEwNztcclxuQ0xleGVyLlN0cmluZ0xpdGVyYWwgPSAxMDg7XHJcbkNMZXhlci5Db21wbGV4RGVmaW5lID0gMTA5O1xyXG5DTGV4ZXIuQXNtQmxvY2sgPSAxMTA7XHJcbkNMZXhlci5MaW5lQWZ0ZXJQcmVwcm9jZXNzaW5nID0gMTExO1xyXG5DTGV4ZXIuTGluZURpcmVjdGl2ZSA9IDExMjtcclxuQ0xleGVyLlByYWdtYURpcmVjdGl2ZSA9IDExMztcclxuQ0xleGVyLldoaXRlc3BhY2UgPSAxMTQ7XHJcbkNMZXhlci5OZXdsaW5lID0gMTE1O1xyXG5DTGV4ZXIuQmxvY2tDb21tZW50ID0gMTE2O1xyXG5DTGV4ZXIuTGluZUNvbW1lbnQgPSAxMTc7XHJcblxyXG5DTGV4ZXIucHJvdG90eXBlLmNoYW5uZWxOYW1lcyA9IFsgXCJERUZBVUxUX1RPS0VOX0NIQU5ORUxcIiwgXCJISURERU5cIiBdO1xyXG5cclxuQ0xleGVyLnByb3RvdHlwZS5tb2RlTmFtZXMgPSBbIFwiREVGQVVMVF9NT0RFXCIgXTtcclxuXHJcbkNMZXhlci5wcm90b3R5cGUubGl0ZXJhbE5hbWVzID0gWyBudWxsLCBcIidfX2V4dGVuc2lvbl9fJ1wiLCBcIidfX2J1aWx0aW5fdmFfYXJnJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ19fYnVpbHRpbl9vZmZzZXRvZidcIiwgXCInX19tMTI4J1wiLCBcIidfX20xMjhkJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ19fbTEyOGknXCIsIFwiJ19fdHlwZW9mX18nXCIsIFwiJ19faW5saW5lX18nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInX19zdGRjYWxsJ1wiLCBcIidfX2RlY2xzcGVjJ1wiLCBcIidfX2FzbSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidfX2F0dHJpYnV0ZV9fJ1wiLCBcIidfX2FzbV9fJ1wiLCBcIidfX3ZvbGF0aWxlX18nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInYXV0bydcIiwgXCInYnJlYWsnXCIsIFwiJ2Nhc2UnXCIsIFwiJ2NoYXInXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInY29uc3QnXCIsIFwiJ2NvbnRpbnVlJ1wiLCBcIidkZWZhdWx0J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ2RvJ1wiLCBcIidkb3VibGUnXCIsIFwiJ2Vsc2UnXCIsIFwiJ2VudW0nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInZXh0ZXJuJ1wiLCBcIidmbG9hdCdcIiwgXCInZm9yJ1wiLCBcIidnb3RvJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ2lmJ1wiLCBcIidpbmxpbmUnXCIsIFwiJ2ludCdcIiwgXCInbG9uZydcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidyZWdpc3RlcidcIiwgXCIncmVzdHJpY3QnXCIsIFwiJ3JldHVybidcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidzaG9ydCdcIiwgXCInc2lnbmVkJ1wiLCBcIidzaXplb2YnXCIsIFwiJ3N0YXRpYydcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidzdHJ1Y3QnXCIsIFwiJ3N3aXRjaCdcIiwgXCIndHlwZWRlZidcIiwgXCIndW5pb24nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIndW5zaWduZWQnXCIsIFwiJ3ZvaWQnXCIsIFwiJ3ZvbGF0aWxlJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3doaWxlJ1wiLCBcIidfQWxpZ25hcydcIiwgXCInX0FsaWdub2YnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInX0F0b21pYydcIiwgXCInX0Jvb2wnXCIsIFwiJ19Db21wbGV4J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ19HZW5lcmljJ1wiLCBcIidfSW1hZ2luYXJ5J1wiLCBcIidfTm9yZXR1cm4nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInX1N0YXRpY19hc3NlcnQnXCIsIFwiJ19UaHJlYWRfbG9jYWwnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInKCdcIiwgXCInKSdcIiwgXCInWydcIiwgXCInXSdcIiwgXCIneydcIiwgXCInfSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIic8J1wiLCBcIic8PSdcIiwgXCInPidcIiwgXCInPj0nXCIsIFwiJzw8J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJz4+J1wiLCBcIicrJ1wiLCBcIicrKydcIiwgXCInLSdcIiwgXCInLS0nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInKidcIiwgXCInLydcIiwgXCInJSdcIiwgXCInJidcIiwgXCInfCdcIiwgXCInJiYnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInfHwnXCIsIFwiJ14nXCIsIFwiJyEnXCIsIFwiJ34nXCIsIFwiJz8nXCIsIFwiJzonXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInOydcIiwgXCInLCdcIiwgXCInPSdcIiwgXCInKj0nXCIsIFwiJy89J1wiLCBcIiclPSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicrPSdcIiwgXCInLT0nXCIsIFwiJzw8PSdcIiwgXCInPj49J1wiLCBcIicmPSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidePSdcIiwgXCInfD0nXCIsIFwiJz09J1wiLCBcIichPSdcIiwgXCInLT4nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInLidcIiwgXCInLi4uJ1wiIF07XHJcblxyXG5DTGV4ZXIucHJvdG90eXBlLnN5bWJvbGljTmFtZXMgPSBbIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIFwiQXV0b1wiLCBcIkJyZWFrXCIsIFwiQ2FzZVwiLCBcIkNoYXJcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb25zdFwiLCBcIkNvbnRpbnVlXCIsIFwiRGVmYXVsdFwiLCBcIkRvXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRG91YmxlXCIsIFwiRWxzZVwiLCBcIkVudW1cIiwgXCJFeHRlcm5cIiwgXCJGbG9hdFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkZvclwiLCBcIkdvdG9cIiwgXCJJZlwiLCBcIklubGluZVwiLCBcIkludFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxvbmdcIiwgXCJSZWdpc3RlclwiLCBcIlJlc3RyaWN0XCIsIFwiUmV0dXJuXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU2hvcnRcIiwgXCJTaWduZWRcIiwgXCJTaXplb2ZcIiwgXCJTdGF0aWNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTdHJ1Y3RcIiwgXCJTd2l0Y2hcIiwgXCJUeXBlZGVmXCIsIFwiVW5pb25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJVbnNpZ25lZFwiLCBcIlZvaWRcIiwgXCJWb2xhdGlsZVwiLCBcIldoaWxlXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQWxpZ25hc1wiLCBcIkFsaWdub2ZcIiwgXCJBdG9taWNcIiwgXCJCb29sXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29tcGxleFwiLCBcIkdlbmVyaWNcIiwgXCJJbWFnaW5hcnlcIiwgXCJOb3JldHVyblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0YXRpY0Fzc2VydFwiLCBcIlRocmVhZExvY2FsXCIsIFwiTGVmdFBhcmVuXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmlnaHRQYXJlblwiLCBcIkxlZnRCcmFja2V0XCIsIFwiUmlnaHRCcmFja2V0XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGVmdEJyYWNlXCIsIFwiUmlnaHRCcmFjZVwiLCBcIkxlc3NcIiwgXCJMZXNzRXF1YWxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJHcmVhdGVyXCIsIFwiR3JlYXRlckVxdWFsXCIsIFwiTGVmdFNoaWZ0XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmlnaHRTaGlmdFwiLCBcIlBsdXNcIiwgXCJQbHVzUGx1c1wiLCBcIk1pbnVzXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWludXNNaW51c1wiLCBcIlN0YXJcIiwgXCJEaXZcIiwgXCJNb2RcIiwgXCJBbmRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJPclwiLCBcIkFuZEFuZFwiLCBcIk9yT3JcIiwgXCJDYXJldFwiLCBcIk5vdFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRpbGRlXCIsIFwiUXVlc3Rpb25cIiwgXCJDb2xvblwiLCBcIlNlbWlcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb21tYVwiLCBcIkFzc2lnblwiLCBcIlN0YXJBc3NpZ25cIiwgXCJEaXZBc3NpZ25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNb2RBc3NpZ25cIiwgXCJQbHVzQXNzaWduXCIsIFwiTWludXNBc3NpZ25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJMZWZ0U2hpZnRBc3NpZ25cIiwgXCJSaWdodFNoaWZ0QXNzaWduXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQW5kQXNzaWduXCIsIFwiWG9yQXNzaWduXCIsIFwiT3JBc3NpZ25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFcXVhbFwiLCBcIk5vdEVxdWFsXCIsIFwiQXJyb3dcIiwgXCJEb3RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFbGxpcHNpc1wiLCBcIklkZW50aWZpZXJcIiwgXCJDb25zdGFudFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRpZ2l0U2VxdWVuY2VcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiQ29tcGxleERlZmluZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFzbUJsb2NrXCIsIFwiTGluZUFmdGVyUHJlcHJvY2Vzc2luZ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxpbmVEaXJlY3RpdmVcIiwgXCJQcmFnbWFEaXJlY3RpdmVcIiwgXCJXaGl0ZXNwYWNlXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTmV3bGluZVwiLCBcIkJsb2NrQ29tbWVudFwiLCBcIkxpbmVDb21tZW50XCIgXTtcclxuXHJcbkNMZXhlci5wcm90b3R5cGUucnVsZU5hbWVzID0gWyBcIlRfXzBcIiwgXCJUX18xXCIsIFwiVF9fMlwiLCBcIlRfXzNcIiwgXCJUX180XCIsIFwiVF9fNVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVF9fNlwiLCBcIlRfXzdcIiwgXCJUX184XCIsIFwiVF9fOVwiLCBcIlRfXzEwXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUX18xMVwiLCBcIlRfXzEyXCIsIFwiVF9fMTNcIiwgXCJBdXRvXCIsIFwiQnJlYWtcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNhc2VcIiwgXCJDaGFyXCIsIFwiQ29uc3RcIiwgXCJDb250aW51ZVwiLCBcIkRlZmF1bHRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRvXCIsIFwiRG91YmxlXCIsIFwiRWxzZVwiLCBcIkVudW1cIiwgXCJFeHRlcm5cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkZsb2F0XCIsIFwiRm9yXCIsIFwiR290b1wiLCBcIklmXCIsIFwiSW5saW5lXCIsIFwiSW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJMb25nXCIsIFwiUmVnaXN0ZXJcIiwgXCJSZXN0cmljdFwiLCBcIlJldHVyblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU2hvcnRcIiwgXCJTaWduZWRcIiwgXCJTaXplb2ZcIiwgXCJTdGF0aWNcIiwgXCJTdHJ1Y3RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN3aXRjaFwiLCBcIlR5cGVkZWZcIiwgXCJVbmlvblwiLCBcIlVuc2lnbmVkXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJWb2lkXCIsIFwiVm9sYXRpbGVcIiwgXCJXaGlsZVwiLCBcIkFsaWduYXNcIiwgXCJBbGlnbm9mXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBdG9taWNcIiwgXCJCb29sXCIsIFwiQ29tcGxleFwiLCBcIkdlbmVyaWNcIiwgXCJJbWFnaW5hcnlcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vcmV0dXJuXCIsIFwiU3RhdGljQXNzZXJ0XCIsIFwiVGhyZWFkTG9jYWxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxlZnRQYXJlblwiLCBcIlJpZ2h0UGFyZW5cIiwgXCJMZWZ0QnJhY2tldFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmlnaHRCcmFja2V0XCIsIFwiTGVmdEJyYWNlXCIsIFwiUmlnaHRCcmFjZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGVzc1wiLCBcIkxlc3NFcXVhbFwiLCBcIkdyZWF0ZXJcIiwgXCJHcmVhdGVyRXF1YWxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxlZnRTaGlmdFwiLCBcIlJpZ2h0U2hpZnRcIiwgXCJQbHVzXCIsIFwiUGx1c1BsdXNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1pbnVzXCIsIFwiTWludXNNaW51c1wiLCBcIlN0YXJcIiwgXCJEaXZcIiwgXCJNb2RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFuZFwiLCBcIk9yXCIsIFwiQW5kQW5kXCIsIFwiT3JPclwiLCBcIkNhcmV0XCIsIFwiTm90XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaWxkZVwiLCBcIlF1ZXN0aW9uXCIsIFwiQ29sb25cIiwgXCJTZW1pXCIsIFwiQ29tbWFcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFzc2lnblwiLCBcIlN0YXJBc3NpZ25cIiwgXCJEaXZBc3NpZ25cIiwgXCJNb2RBc3NpZ25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBsdXNBc3NpZ25cIiwgXCJNaW51c0Fzc2lnblwiLCBcIkxlZnRTaGlmdEFzc2lnblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmlnaHRTaGlmdEFzc2lnblwiLCBcIkFuZEFzc2lnblwiLCBcIlhvckFzc2lnblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT3JBc3NpZ25cIiwgXCJFcXVhbFwiLCBcIk5vdEVxdWFsXCIsIFwiQXJyb3dcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRvdFwiLCBcIkVsbGlwc2lzXCIsIFwiSWRlbnRpZmllclwiLCBcIklkZW50aWZpZXJOb25kaWdpdFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm9uZGlnaXRcIiwgXCJEaWdpdFwiLCBcIlVuaXZlcnNhbENoYXJhY3Rlck5hbWVcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkhleFF1YWRcIiwgXCJDb25zdGFudFwiLCBcIkludGVnZXJDb25zdGFudFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQmluYXJ5Q29uc3RhbnRcIiwgXCJEZWNpbWFsQ29uc3RhbnRcIiwgXCJPY3RhbENvbnN0YW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIZXhhZGVjaW1hbENvbnN0YW50XCIsIFwiSGV4YWRlY2ltYWxQcmVmaXhcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vbnplcm9EaWdpdFwiLCBcIk9jdGFsRGlnaXRcIiwgXCJIZXhhZGVjaW1hbERpZ2l0XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnRlZ2VyU3VmZml4XCIsIFwiVW5zaWduZWRTdWZmaXhcIiwgXCJMb25nU3VmZml4XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJMb25nTG9uZ1N1ZmZpeFwiLCBcIkZsb2F0aW5nQ29uc3RhbnRcIiwgXCJEZWNpbWFsRmxvYXRpbmdDb25zdGFudFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSGV4YWRlY2ltYWxGbG9hdGluZ0NvbnN0YW50XCIsIFwiRnJhY3Rpb25hbENvbnN0YW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBvbmVudFBhcnRcIiwgXCJTaWduXCIsIFwiRGlnaXRTZXF1ZW5jZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSGV4YWRlY2ltYWxGcmFjdGlvbmFsQ29uc3RhbnRcIiwgXCJCaW5hcnlFeHBvbmVudFBhcnRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkhleGFkZWNpbWFsRGlnaXRTZXF1ZW5jZVwiLCBcIkZsb2F0aW5nU3VmZml4XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDaGFyYWN0ZXJDb25zdGFudFwiLCBcIkNDaGFyU2VxdWVuY2VcIiwgXCJDQ2hhclwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRXNjYXBlU2VxdWVuY2VcIiwgXCJTaW1wbGVFc2NhcGVTZXF1ZW5jZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2N0YWxFc2NhcGVTZXF1ZW5jZVwiLCBcIkhleGFkZWNpbWFsRXNjYXBlU2VxdWVuY2VcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZ0xpdGVyYWxcIiwgXCJFbmNvZGluZ1ByZWZpeFwiLCBcIlNDaGFyU2VxdWVuY2VcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNDaGFyXCIsIFwiQ29tcGxleERlZmluZVwiLCBcIkFzbUJsb2NrXCIsIFwiTGluZUFmdGVyUHJlcHJvY2Vzc2luZ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGluZURpcmVjdGl2ZVwiLCBcIlByYWdtYURpcmVjdGl2ZVwiLCBcIldoaXRlc3BhY2VcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5ld2xpbmVcIiwgXCJCbG9ja0NvbW1lbnRcIiwgXCJMaW5lQ29tbWVudFwiIF07XHJcblxyXG5DTGV4ZXIucHJvdG90eXBlLmdyYW1tYXJGaWxlTmFtZSA9IFwiQy5nNFwiO1xyXG5cclxuXHJcblxyXG5leHBvcnRzLkNMZXhlciA9IENMZXhlcjtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hcHBlci9DTGV4ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiIsIi8vIEdlbmVyYXRlZCBmcm9tIEMuZzQgYnkgQU5UTFIgNC43LjFcclxuLy8ganNoaW50IGlnbm9yZTogc3RhcnRcclxudmFyIGFudGxyNCA9IHJlcXVpcmUoJ2FudGxyNC9pbmRleCcpO1xyXG52YXIgQ1Zpc2l0b3IgPSByZXF1aXJlKCcuL0NWaXNpdG9yJykuQ1Zpc2l0b3I7XHJcblxyXG52YXIgZ3JhbW1hckZpbGVOYW1lID0gXCJDLmc0XCI7XHJcblxyXG52YXIgc2VyaWFsaXplZEFUTiA9IFtcIlxcdTAwMDNcXHU2MDhiXFx1YTcyYVxcdTgxMzNcXHViOWVkXFx1NDE3Y1xcdTNiZTdcXHU3Nzg2XFx1NTk2NFwiLFxyXG4gICAgXCJcXHUwMDAzd1xcdTA1MDZcXHUwMDA0XFx1MDAwMlxcdFxcdTAwMDJcXHUwMDA0XFx1MDAwM1xcdFxcdTAwMDNcXHUwMDA0XFx1MDAwNFxcdFwiLFxyXG4gICAgXCJcXHUwMDA0XFx1MDAwNFxcdTAwMDVcXHRcXHUwMDA1XFx1MDAwNFxcdTAwMDZcXHRcXHUwMDA2XFx1MDAwNFxcdTAwMDdcXHRcXHUwMDA3XFx1MDAwNFwiLFxyXG4gICAgXCJcXGJcXHRcXGJcXHUwMDA0XFx0XFx0XFx0XFx1MDAwNFxcblxcdFxcblxcdTAwMDRcXHUwMDBiXFx0XFx1MDAwYlxcdTAwMDRcXGZcXHRcXGZcXHUwMDA0XCIsXHJcbiAgICBcIlxcclxcdFxcclxcdTAwMDRcXHUwMDBlXFx0XFx1MDAwZVxcdTAwMDRcXHUwMDBmXFx0XFx1MDAwZlxcdTAwMDRcXHUwMDEwXFx0XFx1MDAxMFxcdTAwMDRcIixcclxuICAgIFwiXFx1MDAxMVxcdFxcdTAwMTFcXHUwMDA0XFx1MDAxMlxcdFxcdTAwMTJcXHUwMDA0XFx1MDAxM1xcdFxcdTAwMTNcXHUwMDA0XFx1MDAxNFxcdFwiLFxyXG4gICAgXCJcXHUwMDE0XFx1MDAwNFxcdTAwMTVcXHRcXHUwMDE1XFx1MDAwNFxcdTAwMTZcXHRcXHUwMDE2XFx1MDAwNFxcdTAwMTdcXHRcXHUwMDE3XFx1MDAwNFwiLFxyXG4gICAgXCJcXHUwMDE4XFx0XFx1MDAxOFxcdTAwMDRcXHUwMDE5XFx0XFx1MDAxOVxcdTAwMDRcXHUwMDFhXFx0XFx1MDAxYVxcdTAwMDRcXHUwMDFiXFx0XCIsXHJcbiAgICBcIlxcdTAwMWJcXHUwMDA0XFx1MDAxY1xcdFxcdTAwMWNcXHUwMDA0XFx1MDAxZFxcdFxcdTAwMWRcXHUwMDA0XFx1MDAxZVxcdFxcdTAwMWVcXHUwMDA0XCIsXHJcbiAgICBcIlxcdTAwMWZcXHRcXHUwMDFmXFx1MDAwNCBcXHQgXFx1MDAwNCFcXHQhXFx1MDAwNFxcXCJcXHRcXFwiXFx1MDAwNCNcXHQjXFx1MDAwNCRcXHQkXFx1MDAwNFwiLFxyXG4gICAgXCIlXFx0JVxcdTAwMDQmXFx0JlxcdTAwMDRcXCdcXHRcXCdcXHUwMDA0KFxcdChcXHUwMDA0KVxcdClcXHUwMDA0KlxcdCpcXHUwMDA0K1xcdCtcXHUwMDA0XCIsXHJcbiAgICBcIixcXHQsXFx1MDAwNC1cXHQtXFx1MDAwNC5cXHQuXFx1MDAwNC9cXHQvXFx1MDAwNDBcXHQwXFx1MDAwNDFcXHQxXFx1MDAwNDJcXHQyXFx1MDAwNFwiLFxyXG4gICAgXCIzXFx0M1xcdTAwMDQ0XFx0NFxcdTAwMDQ1XFx0NVxcdTAwMDQ2XFx0NlxcdTAwMDQ3XFx0N1xcdTAwMDQ4XFx0OFxcdTAwMDQ5XFx0OVxcdTAwMDRcIixcclxuICAgIFwiOlxcdDpcXHUwMDA0O1xcdDtcXHUwMDA0PFxcdDxcXHUwMDA0PVxcdD1cXHUwMDA0PlxcdD5cXHUwMDA0P1xcdD9cXHUwMDA0QFxcdEBcXHUwMDA0XCIsXHJcbiAgICBcIkFcXHRBXFx1MDAwNEJcXHRCXFx1MDAwNENcXHRDXFx1MDAwNERcXHREXFx1MDAwNEVcXHRFXFx1MDAwNEZcXHRGXFx1MDAwNEdcXHRHXFx1MDAwNFwiLFxyXG4gICAgXCJIXFx0SFxcdTAwMDRJXFx0SVxcdTAwMDRKXFx0SlxcdTAwMDRLXFx0S1xcdTAwMDRMXFx0TFxcdTAwMDRNXFx0TVxcdTAwMDROXFx0TlxcdTAwMDRcIixcclxuICAgIFwiT1xcdE9cXHUwMDA0UFxcdFBcXHUwMDA0UVxcdFFcXHUwMDA0UlxcdFJcXHUwMDA0U1xcdFNcXHUwMDA0VFxcdFRcXHUwMDA0VVxcdFVcXHUwMDA0XCIsXHJcbiAgICBcIlZcXHRWXFx1MDAwNFdcXHRXXFx1MDAwNFhcXHRYXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwNlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBiNFxcblxcdTAwMDJcXHJcXHUwMDAyXFx1MDAwZVxcdTAwMDJcXHUwMGI1XFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDVcXHUwMDAyXFx1MDBiZVxcblxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDNcXHUwMDAyXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMDJcXHUwMGQyXFxuXFx1MDAwMlxcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA0XFx1MDAwM1xcdTAwMDRcXHUwMDA3XFx1MDAwNFxcdTAwZTFcXG5cXHUwMDA0XCIsXHJcbiAgICBcIlxcZlxcdTAwMDRcXHUwMDBlXFx1MDAwNFxcdTAwZTRcXHUwMDBiXFx1MDAwNFxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDVcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA1XFx1MDAwM1xcdTAwMDVcXHUwMDAzXFx1MDAwNVxcdTAwMDVcXHUwMDA1XFx1MDBlZFwiLFxyXG4gICAgXCJcXG5cXHUwMDA1XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDVcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAxMTFcXG5cXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDA1XFx1MDAwNlxcdTAxMWJcXG5cXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwN1xcdTAwMDZcIixcclxuICAgIFwiXFx1MDEyOFxcblxcdTAwMDZcXGZcXHUwMDA2XFx1MDAwZVxcdTAwMDZcXHUwMTJiXFx1MDAwYlxcdTAwMDZcXHUwMDAzXFx1MDAwN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwN1xcdTAwMDdcXHUwMTMzXCIsXHJcbiAgICBcIlxcblxcdTAwMDdcXGZcXHUwMDA3XFx1MDAwZVxcdTAwMDdcXHUwMTM2XFx1MDAwYlxcdTAwMDdcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcIixcclxuICAgIFwiXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXCIsXHJcbiAgICBcIlxcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1wiLFxyXG4gICAgXCJcXGJcXHUwMDAzXFxiXFx1MDAwNVxcYlxcdTAxNGVcXG5cXGJcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblwiLFxyXG4gICAgXCJcXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcIixcclxuICAgIFwiXFxuXFx1MDAwM1xcblxcdTAwMDVcXG5cXHUwMTVmXFxuXFxuXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDA3XFx1MDAwYlxcdTAxNmRcXG5cXHUwMDBiXFxmXFx1MDAwYlxcdTAwMGVcIixcclxuICAgIFwiXFx1MDAwYlxcdTAxNzBcXHUwMDBiXFx1MDAwYlxcdTAwMDNcXGZcXHUwMDAzXFxmXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXFxmXFx1MDAwM1wiLFxyXG4gICAgXCJcXGZcXHUwMDAzXFxmXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDA3XFxmXFx1MDE3YlxcblxcZlxcZlxcZlxcdTAwMGVcXGZcXHUwMTdlXFx1MDAwYlwiLFxyXG4gICAgXCJcXGZcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcIixcclxuICAgIFwiXFxyXFx1MDAwN1xcclxcdTAxODlcXG5cXHJcXGZcXHJcXHUwMDBlXFxyXFx1MDE4Y1xcdTAwMGJcXHJcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMGVcXHUwMDA3XFx1MDAwZVxcdTAxOWRcXG5cXHUwMDBlXFxmXFx1MDAwZVxcdTAwMGVcXHUwMDBlXFx1MDFhMFxcdTAwMGJcIixcclxuICAgIFwiXFx1MDAwZVxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDA3XFx1MDAwZlxcdTAxYWJcXG5cXHUwMDBmXCIsXHJcbiAgICBcIlxcZlxcdTAwMGZcXHUwMDBlXFx1MDAwZlxcdTAxYWVcXHUwMDBiXFx1MDAwZlxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTBcXHUwMDA3XFx1MDAxMFxcdTAxYjZcXG5cXHUwMDEwXCIsXHJcbiAgICBcIlxcZlxcdTAwMTBcXHUwMDBlXFx1MDAxMFxcdTAxYjlcXHUwMDBiXFx1MDAxMFxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTFcXHUwMDAzXFx1MDAxMVxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDA3XFx1MDAxMVxcdTAxYzFcXG5cXHUwMDExXCIsXHJcbiAgICBcIlxcZlxcdTAwMTFcXHUwMDBlXFx1MDAxMVxcdTAxYzRcXHUwMDBiXFx1MDAxMVxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTJcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTJcXHUwMDA3XFx1MDAxMlxcdTAxY2NcXG5cXHUwMDEyXCIsXHJcbiAgICBcIlxcZlxcdTAwMTJcXHUwMDBlXFx1MDAxMlxcdTAxY2ZcXHUwMDBiXFx1MDAxMlxcdTAwMDNcXHUwMDEzXFx1MDAwM1xcdTAwMTNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTNcXHUwMDAzXFx1MDAxM1xcdTAwMDNcXHUwMDEzXFx1MDAwM1xcdTAwMTNcXHUwMDA3XFx1MDAxM1xcdTAxZDdcXG5cXHUwMDEzXCIsXHJcbiAgICBcIlxcZlxcdTAwMTNcXHUwMDBlXFx1MDAxM1xcdTAxZGFcXHUwMDBiXFx1MDAxM1xcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDA3XFx1MDAxNFxcdTAxZTJcXG5cXHUwMDE0XCIsXHJcbiAgICBcIlxcZlxcdTAwMTRcXHUwMDBlXFx1MDAxNFxcdTAxZTVcXHUwMDBiXFx1MDAxNFxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDA1XFx1MDAxNVxcdTAxZWRcXG5cXHUwMDE1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDAxNlxcdTAxZjVcXG5cXHUwMDE2XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE4XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDA3XFx1MDAxOFxcdTAxZmZcIixcclxuICAgIFwiXFxuXFx1MDAxOFxcZlxcdTAwMThcXHUwMDBlXFx1MDAxOFxcdTAyMDJcXHUwMDBiXFx1MDAxOFxcdTAwMDNcXHUwMDE5XFx1MDAwM1xcdTAwMTlcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMWFcXHUwMDAzXFx1MDAxYVxcdTAwMDNcXHUwMDFhXFx1MDAwM1xcdTAwMWFcXHUwMDAzXFx1MDAxYVxcdTAwMDNcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDFhXFx1MDAwM1xcdTAwMWFcXHUwMDA1XFx1MDAxYVxcdTAyMGVcXG5cXHUwMDFhXFx1MDAwM1xcdTAwMWJcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMWJcXHUwMjExXFxuXFx1MDAxYlxcclxcdTAwMWJcXHUwMDBlXFx1MDAxYlxcdTAyMTJcXHUwMDAzXFx1MDAxY1xcdTAwMDZcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAyMTZcXG5cXHUwMDFjXFxyXFx1MDAxY1xcdTAwMGVcXHUwMDFjXFx1MDIxN1xcdTAwMDNcXHUwMDFkXFx1MDAwM1xcdTAwMWRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWRcXHUwMDAzXFx1MDAxZFxcdTAwMDNcXHUwMDFkXFx1MDAwNVxcdTAwMWRcXHUwMjFmXFxuXFx1MDAxZFxcdTAwMDNcXHUwMDFlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDFlXFx1MDAwM1xcdTAwMWVcXHUwMDAzXFx1MDAxZVxcdTAwMDNcXHUwMDFlXFx1MDAwM1xcdTAwMWVcXHUwMDA3XFx1MDAxZVwiLFxyXG4gICAgXCJcXHUwMjI3XFxuXFx1MDAxZVxcZlxcdTAwMWVcXHUwMDBlXFx1MDAxZVxcdTAyMmFcXHUwMDBiXFx1MDAxZVxcdTAwMDNcXHUwMDFmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDFmXFx1MDAwM1xcdTAwMWZcXHUwMDAzXFx1MDAxZlxcdTAwMDNcXHUwMDFmXFx1MDAwNVxcdTAwMWZcXHUwMjMxXFxuXFx1MDAxZlwiLFxyXG4gICAgXCJcXHUwMDAzIFxcdTAwMDMgXFx1MDAwMyFcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzXCIsXHJcbiAgICBcIiFcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzIVxcdTAwMDMhXFx1MDAwMyFcXHUwMDA1IVxcdTAyNDNcXG4hXFx1MDAwM1xcXCJcIixcclxuICAgIFwiXFx1MDAwM1xcXCJcXHUwMDA1XFxcIlxcdTAyNDdcXG5cXFwiXFx1MDAwM1xcXCJcXHUwMDAzXFxcIlxcdTAwMDNcXFwiXFx1MDAwM1xcXCJcXHUwMDAzXFxcIlxcdTAwMDNcIixcclxuICAgIFwiXFxcIlxcdTAwMDNcXFwiXFx1MDAwNVxcXCJcXHUwMjUwXFxuXFxcIlxcdTAwMDMjXFx1MDAwMyNcXHUwMDAzJFxcdTAwMDMkXFx1MDAwMyRcXHUwMDAzXCIsXHJcbiAgICBcIiRcXHUwMDAzJFxcdTAwMDckXFx1MDI1OVxcbiRcXGYkXFx1MDAwZSRcXHUwMjVjXFx1MDAwYiRcXHUwMDAzJVxcdTAwMDMlXFx1MDAwNVwiLFxyXG4gICAgXCIlXFx1MDI2MFxcbiVcXHUwMDAzJVxcdTAwMDMlXFx1MDAwMyVcXHUwMDA1JVxcdTAyNjVcXG4lXFx1MDAwMyZcXHUwMDAzJlxcdTAwMDVcIixcclxuICAgIFwiJlxcdTAyNjlcXG4mXFx1MDAwMyZcXHUwMDAzJlxcdTAwMDUmXFx1MDI2ZFxcbiZcXHUwMDA1JlxcdTAyNmZcXG4mXFx1MDAwM1xcJ1xcdTAwMDNcIixcclxuICAgIFwiXFwnXFx1MDAwM1xcJ1xcdTAwMDNcXCdcXHUwMDAzXFwnXFx1MDAwM1xcJ1xcdTAwMDdcXCdcXHUwMjc3XFxuXFwnXFxmXFwnXFx1MDAwZVxcJ1xcdTAyN2FcIixcclxuICAgIFwiXFx1MDAwYlxcJ1xcdTAwMDMoXFx1MDAwMyhcXHUwMDA1KFxcdTAyN2VcXG4oXFx1MDAwMyhcXHUwMDAzKFxcdTAwMDUoXFx1MDI4MlxcblwiLFxyXG4gICAgXCIoXFx1MDAwMylcXHUwMDAzKVxcdTAwMDUpXFx1MDI4NlxcbilcXHUwMDAzKVxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwM1wiLFxyXG4gICAgXCIpXFx1MDAwNSlcXHUwMjhlXFxuKVxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwMylcXHUwMDAzKVxcdTAwMDMpXFx1MDAwNVwiLFxyXG4gICAgXCIpXFx1MDI5N1xcbilcXHUwMDAzKlxcdTAwMDMqXFx1MDAwMypcXHUwMDAzKlxcdTAwMDMqXFx1MDAwMypcXHUwMDA3KlxcdTAyOWZcXG5cIixcclxuICAgIFwiKlxcZipcXHUwMDBlKlxcdTAyYTJcXHUwMDBiKlxcdTAwMDMrXFx1MDAwMytcXHUwMDAzK1xcdTAwMDMrXFx1MDAwMytcXHUwMDA1K1xcdTAyYTlcIixcclxuICAgIFwiXFxuK1xcdTAwMDMsXFx1MDAwMyxcXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy1cXHUwMDAzLVxcdTAwMDMtXFx1MDAwMy5cXHUwMDAzLlxcdTAwMDNcIixcclxuICAgIFwiL1xcdTAwMDMvXFx1MDAwMy9cXHUwMDAzL1xcdTAwMDMvXFx1MDAwMy9cXHUwMDA1L1xcdTAyYmFcXG4vXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDNcIixcclxuICAgIFwiMFxcdTAwMDMwXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDMwXFx1MDAwMzBcXHUwMDAzMFxcdTAwMDMwXFx1MDAwNTBcXHUwMmM2XFxuMFxcdTAwMDNcIixcclxuICAgIFwiMVxcdTAwMDUxXFx1MDJjOVxcbjFcXHUwMDAzMVxcdTAwMDMxXFx1MDAwNzFcXHUwMmNkXFxuMVxcZjFcXHUwMDBlMVxcdTAyZDBcXHUwMDBiXCIsXHJcbiAgICBcIjFcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDA1XCIsXHJcbiAgICBcIjJcXHUwMmRiXFxuMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDUyXFx1MDJlMFxcbjJcXHUwMDAzMlxcdTAwMDUyXFx1MDJlM1wiLFxyXG4gICAgXCJcXG4yXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDUyXFx1MDJlYVxcbjJcXHUwMDAzMlxcdTAwMDNcIixcclxuICAgIFwiMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDNcIixcclxuICAgIFwiMlxcdTAwMDMyXFx1MDAwNTJcXHUwMmY5XFxuMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDNcIixcclxuICAgIFwiMlxcdTAwMDMyXFx1MDAwMzJcXHUwMDAzMlxcdTAwMDUyXFx1MDMwNVxcbjJcXHUwMDAzMlxcdTAwMDcyXFx1MDMwOFxcbjJcXGYyXFx1MDAwZVwiLFxyXG4gICAgXCIyXFx1MDMwYlxcdTAwMGIyXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDMzXFx1MDAwNjNcXHUwMzEwXFxuM1xccjNcXHUwMDBlM1xcdTAzMTFcIixcclxuICAgIFwiXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDUzXFx1MDMxNlxcbjNcXHUwMDAzNFxcdTAwMDM0XFx1MDAwMzRcXHUwMDAzNFxcdTAwMDM0XFx1MDAwM1wiLFxyXG4gICAgXCI0XFx1MDAwMzRcXHUwMDAzNVxcdTAwMDM1XFx1MDAwMzVcXHUwMDA3NVxcdTAzMjJcXG41XFxmNVxcdTAwMGU1XFx1MDMyNVxcdTAwMGJcIixcclxuICAgIFwiNVxcdTAwMDM1XFx1MDAwNTVcXHUwMzI4XFxuNVxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDU2XFx1MDMyZFxcbjZcXHUwMDAzXCIsXHJcbiAgICBcIjZcXHUwMDA1NlxcdTAzMzBcXG42XFx1MDAwMzZcXHUwMDA1NlxcdTAzMzNcXG42XFx1MDAwMzdcXHUwMDAzN1xcdTAwMDM3XFx1MDAwM1wiLFxyXG4gICAgXCI3XFx1MDAwMzdcXHUwMDA3N1xcdTAzM2FcXG43XFxmN1xcdTAwMGU3XFx1MDMzZFxcdTAwMGI3XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDVcIixcclxuICAgIFwiOFxcdTAzNDFcXG44XFx1MDAwMzhcXHUwMDAzOFxcdTAwMDU4XFx1MDM0NVxcbjhcXHUwMDAzOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDA1XCIsXHJcbiAgICBcIjhcXHUwMzRhXFxuOFxcdTAwMDM4XFx1MDAwMzhcXHUwMDA1OFxcdTAzNGVcXG44XFx1MDAwMzhcXHUwMDA1OFxcdTAzNTFcXG44XFx1MDAwM1wiLFxyXG4gICAgXCI5XFx1MDAwMzlcXHUwMDAzOVxcdTAwMDM5XFx1MDAwMzlcXHUwMDA3OVxcdTAzNThcXG45XFxmOVxcdTAwMGU5XFx1MDM1YlxcdTAwMGJcIixcclxuICAgIFwiOVxcdTAwMDM6XFx1MDAwMzpcXHUwMDAzOlxcdTAwMDM6XFx1MDAwMzpcXHUwMDA1OlxcdTAzNjJcXG46XFx1MDAwMztcXHUwMDAzO1xcdTAwMDNcIixcclxuICAgIFwiO1xcdTAwMDM7XFx1MDAwMztcXHUwMDAzO1xcdTAwMDc7XFx1MDM2YVxcbjtcXGY7XFx1MDAwZTtcXHUwMzZkXFx1MDAwYjtcXHUwMDAzXCIsXHJcbiAgICBcIjxcXHUwMDAzPFxcdTAwMDM8XFx1MDAwMzxcXHUwMDAzPFxcdTAwMDU8XFx1MDM3NFxcbjxcXHUwMDA1PFxcdTAzNzZcXG48XFx1MDAwM1wiLFxyXG4gICAgXCI9XFx1MDAwMz1cXHUwMDAzPVxcdTAwMDM9XFx1MDAwMz1cXHUwMDAzPVxcdTAwMDc9XFx1MDM3ZVxcbj1cXGY9XFx1MDAwZT1cXHUwMzgxXCIsXHJcbiAgICBcIlxcdTAwMGI9XFx1MDAwMz5cXHUwMDAzPlxcdTAwMDU+XFx1MDM4NVxcbj5cXHUwMDAzP1xcdTAwMDM/XFx1MDAwNT9cXHUwMzg5XFxuP1wiLFxyXG4gICAgXCJcXHUwMDAzP1xcdTAwMDM/XFx1MDAwNz9cXHUwMzhkXFxuP1xcZj9cXHUwMDBlP1xcdTAzOTBcXHUwMDBiP1xcdTAwMDU/XFx1MDM5MlxcblwiLFxyXG4gICAgXCI/XFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDdAXFx1MDM5OVxcbkBcXGZAXFx1MDAwZUBcXHUwMzljXCIsXHJcbiAgICBcIlxcdTAwMGJAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDVAXFx1MDNhMFxcbkBcXHUwMDAzQFxcdTAwMDVAXFx1MDNhM1xcbkBcXHUwMDAzQFwiLFxyXG4gICAgXCJcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA1QFxcdTAzYTlcXG5AXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzXCIsXHJcbiAgICBcIkBcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA1XCIsXHJcbiAgICBcIkBcXHUwM2I5XFxuQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA3QFxcdTAzYmRcXG5AXFxmQFxcdTAwMGVAXFx1MDNjMFxcdTAwMGJAXFx1MDAwNVwiLFxyXG4gICAgXCJAXFx1MDNjMlxcbkBcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA1QFxcdTAzYzdcXG5AXFx1MDAwM0BcXHUwMDA1QFxcdTAzY2FcIixcclxuICAgIFwiXFxuQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA1QFxcdTAzZDFcXG5AXFx1MDAwM0BcXHUwMDAzXCIsXHJcbiAgICBcIkBcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzXCIsXHJcbiAgICBcIkBcXHUwMDAzQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDAzQFxcdTAwMDNAXFx1MDAwNUBcXHUwM2U0XFxuQFxcdTAwMDNAXFx1MDAwM0BcXHUwMDA3XCIsXHJcbiAgICBcIkBcXHUwM2U4XFxuQFxcZkBcXHUwMDBlQFxcdTAzZWJcXHUwMDBiQFxcdTAwMDdAXFx1MDNlZFxcbkBcXGZAXFx1MDAwZUBcXHUwM2YwXFx1MDAwYlwiLFxyXG4gICAgXCJAXFx1MDAwM0FcXHUwMDAzQVxcdTAwMDNCXFx1MDAwM0JcXHUwMDAzQlxcdTAwMDNCXFx1MDAwM0JcXHUwMDAzQlxcdTAwMDNCXFx1MDAwM1wiLFxyXG4gICAgXCJCXFx1MDAwM0JcXHUwMDAzQlxcdTAwMDVCXFx1MDNmZVxcbkJcXHUwMDAzQ1xcdTAwMDNDXFx1MDAwNUNcXHUwNDAyXFxuQ1xcdTAwMDNcIixcclxuICAgIFwiQ1xcdTAwMDNDXFx1MDAwM0NcXHUwMDAzQ1xcdTAwMDNDXFx1MDAwNUNcXHUwNDA5XFxuQ1xcdTAwMDNDXFx1MDAwN0NcXHUwNDBjXFxuXCIsXHJcbiAgICBcIkNcXGZDXFx1MDAwZUNcXHUwNDBmXFx1MDAwYkNcXHUwMDAzRFxcdTAwMDNEXFx1MDAwM0RcXHUwMDAzRVxcdTAwMDNFXFx1MDAwM0VcXHUwMDAzXCIsXHJcbiAgICBcIkVcXHUwMDAzRVxcdTAwMDdFXFx1MDQxOVxcbkVcXGZFXFx1MDAwZUVcXHUwNDFjXFx1MDAwYkVcXHUwMDAzRlxcdTAwMDNGXFx1MDAwM1wiLFxyXG4gICAgXCJGXFx1MDAwM0ZcXHUwMDAzRlxcdTAwMDNGXFx1MDAwNUZcXHUwNDI0XFxuRlxcdTAwMDNHXFx1MDAwM0dcXHUwMDAzR1xcdTAwMDNHXFx1MDAwM1wiLFxyXG4gICAgXCJHXFx1MDAwNkdcXHUwNDJiXFxuR1xcckdcXHUwMDBlR1xcdTA0MmNcXHUwMDAzR1xcdTAwMDNHXFx1MDAwM0dcXHUwMDAzSFxcdTAwMDNcIixcclxuICAgIFwiSFxcdTAwMDNIXFx1MDAwM0hcXHUwMDAzSFxcdTAwMDNIXFx1MDAwM0hcXHUwMDAzSFxcdTAwMDNIXFx1MDAwM0hcXHUwMDAzSFxcdTAwMDNcIixcclxuICAgIFwiSFxcdTAwMDdIXFx1MDQzZVxcbkhcXGZIXFx1MDAwZUhcXHUwNDQxXFx1MDAwYkhcXHUwMDA1SFxcdTA0NDNcXG5IXFx1MDAwM0hcXHUwMDAzXCIsXHJcbiAgICBcIkhcXHUwMDAzSFxcdTAwMDNIXFx1MDAwN0hcXHUwNDQ5XFxuSFxcZkhcXHUwMDBlSFxcdTA0NGNcXHUwMDBiSFxcdTAwMDVIXFx1MDQ0ZVwiLFxyXG4gICAgXCJcXG5IXFx1MDAwN0hcXHUwNDUwXFxuSFxcZkhcXHUwMDBlSFxcdTA0NTNcXHUwMDBiSFxcdTAwMDNIXFx1MDAwM0hcXHUwMDA1SFxcdTA0NTdcIixcclxuICAgIFwiXFxuSFxcdTAwMDNJXFx1MDAwM0lcXHUwMDAzSVxcdTAwMDNJXFx1MDAwM0lcXHUwMDAzSVxcdTAwMDNJXFx1MDAwM0lcXHUwMDAzSVxcdTAwMDNcIixcclxuICAgIFwiSVxcdTAwMDNJXFx1MDAwNUlcXHUwNDY0XFxuSVxcdTAwMDNKXFx1MDAwM0pcXHUwMDA1SlxcdTA0NjhcXG5KXFx1MDAwM0pcXHUwMDAzXCIsXHJcbiAgICBcIkpcXHUwMDAzS1xcdTAwMDNLXFx1MDAwM0tcXHUwMDAzS1xcdTAwMDNLXFx1MDAwN0tcXHUwNDcxXFxuS1xcZktcXHUwMDBlS1xcdTA0NzRcIixcclxuICAgIFwiXFx1MDAwYktcXHUwMDAzTFxcdTAwMDNMXFx1MDAwNUxcXHUwNDc4XFxuTFxcdTAwMDNNXFx1MDAwNU1cXHUwNDdiXFxuTVxcdTAwMDNNXCIsXHJcbiAgICBcIlxcdTAwMDNNXFx1MDAwM05cXHUwMDAzTlxcdTAwMDNOXFx1MDAwM05cXHUwMDAzTlxcdTAwMDNOXFx1MDAwM05cXHUwMDA1TlxcdTA0ODZcIixcclxuICAgIFwiXFxuTlxcdTAwMDNOXFx1MDAwM05cXHUwMDAzTlxcdTAwMDNOXFx1MDAwM05cXHUwMDAzTlxcdTAwMDVOXFx1MDQ4ZVxcbk5cXHUwMDAzXCIsXHJcbiAgICBcIk9cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDAzXCIsXHJcbiAgICBcIk9cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDAzT1xcdTAwMDNPXFx1MDAwM09cXHUwMDA1XCIsXHJcbiAgICBcIk9cXHUwNGE0XFxuT1xcdTAwMDNQXFx1MDAwM1BcXHUwMDAzUFxcdTAwMDVQXFx1MDRhOVxcblBcXHUwMDAzUFxcdTAwMDNQXFx1MDAwNVwiLFxyXG4gICAgXCJQXFx1MDRhZFxcblBcXHUwMDAzUFxcdTAwMDVQXFx1MDRiMFxcblBcXHUwMDAzUFxcdTAwMDNQXFx1MDAwNVBcXHUwNGI0XFxuUFxcdTAwMDNcIixcclxuICAgIFwiUFxcdTAwMDNQXFx1MDAwNVBcXHUwNGI4XFxuUFxcdTAwMDVQXFx1MDRiYVxcblBcXHUwMDAzUVxcdTAwMDNRXFx1MDAwM1FcXHUwMDAzXCIsXHJcbiAgICBcIlFcXHUwMDA1UVxcdTA0YzBcXG5RXFx1MDAwM1JcXHUwMDAzUlxcdTAwMDNSXFx1MDAwM1JcXHUwMDAzUlxcdTAwMDNSXFx1MDAwN1JcXHUwNGM4XCIsXHJcbiAgICBcIlxcblJcXGZSXFx1MDAwZVJcXHUwNGNiXFx1MDAwYlJcXHUwMDAzU1xcdTAwMDNTXFx1MDAwM1NcXHUwMDAzU1xcdTAwMDNTXFx1MDAwM1wiLFxyXG4gICAgXCJTXFx1MDAwM1NcXHUwMDAzU1xcdTAwMDNTXFx1MDAwNVNcXHUwNGQ2XFxuU1xcdTAwMDNTXFx1MDAwM1NcXHUwMDAzU1xcdTAwMDNTXFx1MDAwM1wiLFxyXG4gICAgXCJTXFx1MDAwNVNcXHUwNGRkXFxuU1xcdTAwMDNUXFx1MDAwNVRcXHUwNGUwXFxuVFxcdTAwMDNUXFx1MDAwM1RcXHUwMDAzVVxcdTAwMDNcIixcclxuICAgIFwiVVxcdTAwMDNVXFx1MDAwM1VcXHUwMDAzVVxcdTAwMDdVXFx1MDRlOVxcblVcXGZVXFx1MDAwZVVcXHUwNGVjXFx1MDAwYlVcXHUwMDAzXCIsXHJcbiAgICBcIlZcXHUwMDAzVlxcdTAwMDNWXFx1MDAwNVZcXHUwNGYxXFxuVlxcdTAwMDNXXFx1MDAwNVdcXHUwNGY0XFxuV1xcdTAwMDNXXFx1MDAwM1wiLFxyXG4gICAgXCJXXFx1MDAwNVdcXHUwNGY4XFxuV1xcdTAwMDNXXFx1MDAwM1dcXHUwMDAzWFxcdTAwMDNYXFx1MDAwM1hcXHUwMDAzWFxcdTAwMDNYXFx1MDAwN1wiLFxyXG4gICAgXCJYXFx1MDUwMVxcblhcXGZYXFx1MDAwZVhcXHUwNTA0XFx1MDAwYlhcXHUwMDAzWFxcdTAwMDJcXHUwMDFmXFx1MDAwNlxcblxcZlxcdTAwMTRcIixcclxuICAgIFwiXFx1MDAxNlxcdTAwMThcXHUwMDFhXFx1MDAxY1xcdTAwMWUgXFxcIiQmLjpGTFJicHR4flxcdTAwODRcXHUwMDg4XFx1MDA5NFxcdTAwYTJcIixcclxuICAgIFwiXFx1MDBhOFxcdTAwYWVZXFx1MDAwMlxcdTAwMDRcXHUwMDA2XFxiXFxuXFxmXFx1MDAwZVxcdTAwMTBcXHUwMDEyXFx1MDAxNFxcdTAwMTZcIixcclxuICAgIFwiXFx1MDAxOFxcdTAwMWFcXHUwMDFjXFx1MDAxZSBcXFwiJCYoKiwuMDI0Njg6PD5AQkRGSEpMTlBSVFZYWlxcXFxeYGJkZmhqbG5wXCIsXHJcbiAgICBcInJ0dnh6fH5cXHUwMDgwXFx1MDA4MlxcdTAwODRcXHUwMDg2XFx1MDA4OFxcdTAwOGFcXHUwMDhjXFx1MDA4ZVxcdTAwOTBcXHUwMDkyXCIsXHJcbiAgICBcIlxcdTAwOTRcXHUwMDk2XFx1MDA5OFxcdTAwOWFcXHUwMDljXFx1MDA5ZVxcdTAwYTBcXHUwMGEyXFx1MDBhNFxcdTAwYTZcXHUwMGE4XFx1MDBhYVwiLFxyXG4gICAgXCJcXHUwMGFjXFx1MDBhZVxcdTAwMDJcXHUwMDBlXFx1MDAwN1xcdTAwMDJJSUtLTU1QUFVWXFx1MDAwM1xcdTAwMDJbZVxcYlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAxMVxcdTAwMTFcXHUwMDFjXFx1MDAxYyQkKiotLTw8XFxuXFx1MDAwMlxcdTAwMDZcXGJcXHUwMDE0XFx1MDAxNFxcdTAwMTlcXHUwMDE5XCIsXHJcbiAgICBcIlxcdTAwMWRcXHUwMDFkXFxcIiNcXCcoLzA2N1xcdTAwMDNcXHUwMDAyXFx1MDAwNlxcYlxcdTAwMDRcXHUwMDAyKysuLlxcdTAwMDZcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMTVcXHUwMDE1JSUxMTU1XFx1MDAwNVxcdTAwMDJcXG5cXHUwMDBiISE6OlxcdTAwMDRcXHUwMDAyPT5aWlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIj0+XFx1MDAwNFxcdTAwMDJcXHJcXHJcXHUwMDBmXFx1MDAwZlxcdTAwMDRcXHUwMDAyXFx1MDAxMFxcdTAwMTAxMVxcdTAwMDJcXHUwNTc4XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGQxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDRcXHUwMGQzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDA2XFx1MDBkYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXGJcXHUwMGVjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXG5cXHUwMTEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcZlxcdTAxMmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwZVwiLFxyXG4gICAgXCJcXHUwMTRkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTBcXHUwMTRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTJcIixcclxuICAgIFwiXFx1MDE1ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE0XFx1MDE2MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE2XCIsXHJcbiAgICBcIlxcdTAxNzFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxOFxcdTAxN2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxYVwiLFxyXG4gICAgXCJcXHUwMThkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWNcXHUwMWExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWVcIixcclxuICAgIFwiXFx1MDFhZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIgXFx1MDFiYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXFwiXFx1MDFjNVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyJFxcdTAxZDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyJlxcdTAxZGJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMihcXHUwMWU2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMipcXHUwMWY0XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDIsXFx1MDFmNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIuXFx1MDFmOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyMFxcdTAyMDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyMlxcdTAyMGRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIjRcXHUwMjEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjZcXHUwMjE1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjhcXHUwMjFlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI6XFx1MDIyMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI8XFx1MDIzMFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyPlxcdTAyMzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyQFxcdTAyNDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMkJcXHUwMjRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMkRcXHUwMjUxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJGXFx1MDI1M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJIXFx1MDI2NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiSlxcdTAyNmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyTFxcdTAyNzBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyTlxcdTAyODFcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlBcXHUwMjk2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlJcXHUwMjk4XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJUXFx1MDJhOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJWXFx1MDJhYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyWFxcdTAyYWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyWlxcdTAyYjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcXFxcXHUwMmI5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMl5cXHUwMmM1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJgXFx1MDJjOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJiXFx1MDJkYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJkXFx1MDMxNVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyZlxcdTAzMTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyaFxcdTAzMjdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMmpcXHUwMzMyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmxcXHUwMzNiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJuXFx1MDM1MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJwXFx1MDM1MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyclxcdTAzNjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAydFxcdTAzNjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcInZcXHUwMzc1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMnhcXHUwMzc3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMnpcXHUwMzgyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJ8XFx1MDM5MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJ+XFx1MDNjMVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4MFxcdTAzZjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4MlxcdTAzZmRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODRcXHUwM2ZmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODZcXHUwNDEwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDg4XFx1MDQxM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhhXFx1MDQyM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4Y1xcdTA0MjVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4ZVxcdTA0NTZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTBcXHUwNDYzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTJcXHUwNDY1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk0XFx1MDQ2YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk2XFx1MDQ3N1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5OFxcdTA0N2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5YVxcdTA0OGRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOWNcXHUwNGEzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOWVcXHUwNGI5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGEwXFx1MDRiZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGEyXFx1MDRjMVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhNFxcdTA0ZGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBhNlxcdTA0ZGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYThcXHUwNGUzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYWFcXHUwNGYwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGFjXFx1MDRmM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGFlXFx1MDRmYlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiMFxcdTAwZDJcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDBiMVxcdTAwZDJcXHUwMDA3XCIsXHJcbiAgICBcImxcXHUwMDAyXFx1MDAwMlxcdTAwYjJcXHUwMGI0XFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAwYjNcXHUwMGIyXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGI0XFx1MDBiNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGI1XFx1MDBiM1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiNVxcdTAwYjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiNlxcdTAwZDJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYjdcXHUwMGI4XFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAwYjhcXHUwMGI5XFx1MDAwNS5cXHUwMDE4XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGI5XFx1MDBiYVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMGJhXFx1MDBkMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBiYlxcdTAwZDJcXHUwMDA1XFx1MDAwNFxcdTAwMDNcXHUwMDAyXFx1MDBiY1xcdTAwYmVcXHUwMDA3XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwYmRcXHUwMGJjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYmRcXHUwMGJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGJlXFx1MDBiZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJmXFx1MDBjMFxcdTAwMDc9XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBjMFxcdTAwYzFcXHUwMDA1XFx1MDA5MkpcXHUwMDAyXFx1MDBjMVxcdTAwYzJcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYzJcXHUwMGQyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYzNcXHUwMGM0XFx1MDAwN1xcdTAwMDRcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGM0XFx1MDBjNVxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMGM1XFx1MDBjNlxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlxcdTAwYzZcIixcclxuICAgIFwiXFx1MDBjN1xcdTAwMDdaXFx1MDAwMlxcdTAwMDJcXHUwMGM3XFx1MDBjOFxcdTAwMDV6PlxcdTAwMDJcXHUwMGM4XFx1MDBjOVxcdTAwMDdcIixcclxuICAgIFwiPlxcdTAwMDJcXHUwMDAyXFx1MDBjOVxcdTAwZDJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBjYVxcdTAwY2JcXHUwMDA3XCIsXHJcbiAgICBcIlxcdTAwMDVcXHUwMDAyXFx1MDAwMlxcdTAwY2JcXHUwMGNjXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAwY2NcXHUwMGNkXFx1MDAwNVwiLFxyXG4gICAgXCJ6PlxcdTAwMDJcXHUwMGNkXFx1MDBjZVxcdTAwMDdaXFx1MDAwMlxcdTAwMDJcXHUwMGNlXFx1MDBjZlxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGNmXFx1MDBkMFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMGQwXFx1MDBkMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBkMVxcdTAwYjBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkMVxcdTAwYjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwZDFcXHUwMGIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZDFcXHUwMGI3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGQxXFx1MDBiYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGQxXFx1MDBiZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBkMVxcdTAwYzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkMVxcdTAwY2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwZDJcXHUwMDAzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZDNcXHUwMGQ0XFx1MDAwNzhcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGQ0XFx1MDBkNVxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMGQ1XFx1MDBkNlxcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwMGQ2XCIsXHJcbiAgICBcIlxcdTAwZDdcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDBkN1xcdTAwZDhcXHUwMDA1XFx1MDAwNlxcdTAwMDRcXHUwMDAyXFx1MDBkOFwiLFxyXG4gICAgXCJcXHUwMGQ5XFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAwZDlcXHUwMDA1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGFcIixcclxuICAgIFwiXFx1MDBkYlxcYlxcdTAwMDRcXHUwMDAxXFx1MDAwMlxcdTAwZGJcXHUwMGRjXFx1MDAwNVxcYlxcdTAwMDVcXHUwMDAyXFx1MDBkY1xcdTAwZTJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGRcXHUwMGRlXFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDBkZVxcdTAwZGZcIixcclxuICAgIFwiXFx1MDAwN1pcXHUwMDAyXFx1MDAwMlxcdTAwZGZcXHUwMGUxXFx1MDAwNVxcYlxcdTAwMDVcXHUwMDAyXFx1MDBlMFxcdTAwZGRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTFcXHUwMGU0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTJcXHUwMGUwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGUyXFx1MDBlM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGUzXFx1MDAwN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlNFxcdTAwZTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlNVxcdTAwZTZcXHUwMDA1XCIsXHJcbiAgICBcIno+XFx1MDAwMlxcdTAwZTZcXHUwMGU3XFx1MDAwN1hcXHUwMDAyXFx1MDAwMlxcdTAwZTdcXHUwMGU4XFx1MDAwNSpcXHUwMDE2XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGU4XFx1MDBlZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGU5XFx1MDBlYVxcdTAwMDdcXHUwMDE3XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBlYVxcdTAwZWJcXHUwMDA3WFxcdTAwMDJcXHUwMDAyXFx1MDBlYlxcdTAwZWRcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDBlY1wiLFxyXG4gICAgXCJcXHUwMGU1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWNcXHUwMGU5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWRcIixcclxuICAgIFwiXFx0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWVcXHUwMGVmXFxiXFx1MDAwNlxcdTAwMDFcXHUwMDAyXFx1MDBlZlxcdTAxMTFcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjBcXHUwMGYxXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAwZjFcXHUwMGYyXCIsXHJcbiAgICBcIlxcdTAwMDV6PlxcdTAwMDJcXHUwMGYyXFx1MDBmM1xcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMGYzXFx1MDBmNFxcdTAwMDdBXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBmNFxcdTAwZjVcXHUwMDA1XFx1MDA4NENcXHUwMDAyXFx1MDBmNVxcdTAwZjZcXHUwMDA3QlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwZjZcXHUwMTExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjdcXHUwMGY4XFx1MDAwNz1cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGY4XFx1MDBmOVxcdTAwMDV6PlxcdTAwMDJcXHUwMGY5XFx1MDBmYVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMGZhXFx1MDBmYlwiLFxyXG4gICAgXCJcXHUwMDA3QVxcdTAwMDJcXHUwMDAyXFx1MDBmYlxcdTAwZmNcXHUwMDA1XFx1MDA4NENcXHUwMDAyXFx1MDBmY1xcdTAwZmRcXHUwMDA3XCIsXHJcbiAgICBcIlpcXHUwMDAyXFx1MDAwMlxcdTAwZmRcXHUwMGZlXFx1MDAwN0JcXHUwMDAyXFx1MDAwMlxcdTAwZmVcXHUwMTExXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGZmXFx1MDEwMFxcdTAwMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMTAwXFx1MDEwMVxcdTAwMDc9XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDEwMVxcdTAxMDJcXHUwMDA1ej5cXHUwMDAyXFx1MDEwMlxcdTAxMDNcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMDNcXHUwMTA0XFx1MDAwN0FcXHUwMDAyXFx1MDAwMlxcdTAxMDRcXHUwMTA1XFx1MDAwNVxcdTAwODRDXFx1MDAwMlxcdTAxMDVcIixcclxuICAgIFwiXFx1MDEwNlxcdTAwMDdCXFx1MDAwMlxcdTAwMDJcXHUwMTA2XFx1MDExMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTA3XCIsXHJcbiAgICBcIlxcdTAxMDhcXHUwMDA3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDEwOFxcdTAxMDlcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDEwOVwiLFxyXG4gICAgXCJcXHUwMTBhXFx1MDAwNXo+XFx1MDAwMlxcdTAxMGFcXHUwMTBiXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAxMGJcXHUwMTBjXFx1MDAwN1wiLFxyXG4gICAgXCJBXFx1MDAwMlxcdTAwMDJcXHUwMTBjXFx1MDEwZFxcdTAwMDVcXHUwMDg0Q1xcdTAwMDJcXHUwMTBkXFx1MDEwZVxcdTAwMDdaXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEwZVxcdTAxMGZcXHUwMDA3QlxcdTAwMDJcXHUwMDAyXFx1MDEwZlxcdTAxMTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMTBcXHUwMGVlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTBcXHUwMGYwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTEwXFx1MDBmN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTEwXFx1MDBmZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDExMFxcdTAxMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExMVxcdTAxMjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMTJcXHUwMTEzXFxmXFxmXFx1MDAwMlxcdTAwMDJcXHUwMTEzXFx1MDExNFxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMTE0XCIsXHJcbiAgICBcIlxcdTAxMTVcXHUwMDA1LlxcdTAwMThcXHUwMDAyXFx1MDExNVxcdTAxMTZcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDExNlxcdTAxMjhcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTdcXHUwMTE4XFxmXFx1MDAwYlxcdTAwMDJcXHUwMDAyXFx1MDExOFxcdTAxMWFcIixcclxuICAgIFwiXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAxMTlcXHUwMTFiXFx1MDAwNVxcZlxcdTAwMDdcXHUwMDAyXFx1MDExYVxcdTAxMTlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMWFcXHUwMTFiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMWJcXHUwMTFjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTFjXFx1MDEyOFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMTFkXFx1MDExZVxcZlxcblxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMWVcXHUwMTFmXFx1MDAwN2lcXHUwMDAyXFx1MDAwMlxcdTAxMWZcXHUwMTI4XFx1MDAwN2tcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTIwXFx1MDEyMVxcZlxcdFxcdTAwMDJcXHUwMDAyXFx1MDEyMVxcdTAxMjJcXHUwMDA3aFxcdTAwMDJcXHUwMDAyXFx1MDEyMlxcdTAxMjhcIixcclxuICAgIFwiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAxMjNcXHUwMTI0XFxmXFxiXFx1MDAwMlxcdTAwMDJcXHUwMTI0XFx1MDEyOFxcdTAwMDdKXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEyNVxcdTAxMjZcXGZcXHUwMDA3XFx1MDAwMlxcdTAwMDJcXHUwMTI2XFx1MDEyOFxcdTAwMDdMXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyN1xcdTAxMTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyN1xcdTAxMTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMjdcXHUwMTFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjdcXHUwMTIwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTI3XFx1MDEyM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTI3XFx1MDEyNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyOFxcdTAxMmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyOVxcdTAxMjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMjlcXHUwMTJhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmFcXHUwMDBiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTJiXFx1MDEyOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJjXFx1MDEyZFxcYlxcdTAwMDdcXHUwMDAxXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTJkXFx1MDEyZVxcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwMTJlXFx1MDEzNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyZlxcdTAxMzBcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMTMwXFx1MDEzMVxcdTAwMDdaXFx1MDAwMlxcdTAwMDJcXHUwMTMxXCIsXHJcbiAgICBcIlxcdTAxMzNcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDEzMlxcdTAxMmZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzM1wiLFxyXG4gICAgXCJcXHUwMTM2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzRcXHUwMTMyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzRcIixcclxuICAgIFwiXFx1MDEzNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTM1XFxyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzZcIixcclxuICAgIFwiXFx1MDEzNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTM3XFx1MDE0ZVxcdTAwMDVcXG5cXHUwMDA2XFx1MDAwMlxcdTAxMzhcIixcclxuICAgIFwiXFx1MDEzOVxcdTAwMDdKXFx1MDAwMlxcdTAwMDJcXHUwMTM5XFx1MDE0ZVxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlxcdTAxM2FcXHUwMTNiXCIsXHJcbiAgICBcIlxcdTAwMDdMXFx1MDAwMlxcdTAwMDJcXHUwMTNiXFx1MDE0ZVxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlxcdTAxM2NcXHUwMTNkXFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMDEwXFx0XFx1MDAwMlxcdTAxM2RcXHUwMTNlXFx1MDAwNVxcdTAwMTJcXG5cXHUwMDAyXFx1MDEzZVxcdTAxNGVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxM2ZcXHUwMTQwXFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTAxNDBcXHUwMTRlXFx1MDAwNVxcdTAwMGVcIixcclxuICAgIFwiXFxiXFx1MDAwMlxcdTAxNDFcXHUwMTQyXFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTAxNDJcXHUwMTQzXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTQzXFx1MDE0NFxcdTAwMDV6PlxcdTAwMDJcXHUwMTQ0XFx1MDE0NVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMTQ1XFx1MDE0ZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE0NlxcdTAxNDdcXHUwMDA3NFxcdTAwMDJcXHUwMDAyXFx1MDE0N1xcdTAxNDhcIixcclxuICAgIFwiXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAxNDhcXHUwMTQ5XFx1MDAwNXo+XFx1MDAwMlxcdTAxNDlcXHUwMTRhXFx1MDAwNz5cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTRhXFx1MDE0ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTRiXFx1MDE0Y1xcdTAwMDdSXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE0Y1xcdTAxNGVcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDE0ZFxcdTAxMzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNGRcXHUwMTM4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNGRcXHUwMTNhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTRkXFx1MDEzY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTRkXFx1MDEzZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE0ZFxcdTAxNDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE0ZFxcdTAxNDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNGRcXHUwMTRiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNGVcXHUwMDBmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTRmXFx1MDE1MFxcdFxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNTBcXHUwMDExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTUxXFx1MDE1ZlxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlxcdTAxNTJcXHUwMTUzXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTUzXFx1MDE1NFxcdTAwMDV6PlxcdTAwMDJcXHUwMTU0XFx1MDE1NVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMTU1XFx1MDE1NlwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDAxMlxcblxcdTAwMDJcXHUwMTU2XFx1MDE1ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTU3XFx1MDE1OFwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDE1OFxcdTAxNTlcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDE1OVxcdTAxNWFcIixcclxuICAgIFwiXFx1MDAwNXo+XFx1MDAwMlxcdTAxNWFcXHUwMTViXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAxNWJcXHUwMTVjXFx1MDAwNVxcdTAwMTJcIixcclxuICAgIFwiXFxuXFx1MDAwMlxcdTAxNWNcXHUwMTVmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNWRcXHUwMTVmXFx1MDAwN21cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTVlXFx1MDE1MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTVlXFx1MDE1MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE1ZVxcdTAxNTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE1ZVxcdTAxNWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNWZcXHUwMDEzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNjBcXHUwMTYxXFxiXFx1MDAwYlxcdTAwMDFcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNjFcXHUwMTYyXFx1MDAwNVxcdTAwMTJcXG5cXHUwMDAyXFx1MDE2MlxcdTAxNmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNjNcXHUwMTY0XFxmXFx1MDAwNVxcdTAwMDJcXHUwMDAyXFx1MDE2NFxcdTAxNjVcXHUwMDA3TVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNjVcXHUwMTZkXFx1MDAwNVxcdTAwMTJcXG5cXHUwMDAyXFx1MDE2NlxcdTAxNjdcXGZcXHUwMDA0XFx1MDAwMlxcdTAwMDJcXHUwMTY3XCIsXHJcbiAgICBcIlxcdTAxNjhcXHUwMDA3TlxcdTAwMDJcXHUwMDAyXFx1MDE2OFxcdTAxNmRcXHUwMDA1XFx1MDAxMlxcblxcdTAwMDJcXHUwMTY5XFx1MDE2YVwiLFxyXG4gICAgXCJcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMTZhXFx1MDE2YlxcdTAwMDdPXFx1MDAwMlxcdTAwMDJcXHUwMTZiXFx1MDE2ZFxcdTAwMDVcIixcclxuICAgIFwiXFx1MDAxMlxcblxcdTAwMDJcXHUwMTZjXFx1MDE2M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTZjXFx1MDE2NlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE2Y1xcdTAxNjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE2ZFxcdTAxNzBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNmVcXHUwMTZjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNmVcXHUwMTZmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTZmXFx1MDAxNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTcwXFx1MDE2ZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE3MVxcdTAxNzJcXGJcXGZcXHUwMDAxXFx1MDAwMlxcdTAxNzJcXHUwMTczXFx1MDAwNVxcdTAwMTRcIixcclxuICAgIFwiXFx1MDAwYlxcdTAwMDJcXHUwMTczXFx1MDE3Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTc0XFx1MDE3NVxcZlxcdTAwMDRcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMTc1XFx1MDE3NlxcdTAwMDdJXFx1MDAwMlxcdTAwMDJcXHUwMTc2XFx1MDE3YlxcdTAwMDVcXHUwMDE0XCIsXHJcbiAgICBcIlxcdTAwMGJcXHUwMDAyXFx1MDE3N1xcdTAxNzhcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMTc4XFx1MDE3OVxcdTAwMDdLXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE3OVxcdTAxN2JcXHUwMDA1XFx1MDAxNFxcdTAwMGJcXHUwMDAyXFx1MDE3YVxcdTAxNzRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxN2FcXHUwMTc3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxN2JcXHUwMTdlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTdjXFx1MDE3YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTdjXFx1MDE3ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE3ZFxcdTAwMTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE3ZVxcdTAxN2NcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxN2ZcXHUwMTgwXFxiXFxyXFx1MDAwMVxcdTAwMDJcXHUwMTgwXFx1MDE4MVxcdTAwMDVcXHUwMDE2XFxmXFx1MDAwMlxcdTAxODFcIixcclxuICAgIFwiXFx1MDE4YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTgyXFx1MDE4M1xcZlxcdTAwMDRcXHUwMDAyXFx1MDAwMlxcdTAxODNcIixcclxuICAgIFwiXFx1MDE4NFxcdTAwMDdHXFx1MDAwMlxcdTAwMDJcXHUwMTg0XFx1MDE4OVxcdTAwMDVcXHUwMDE2XFxmXFx1MDAwMlxcdTAxODVcXHUwMTg2XCIsXHJcbiAgICBcIlxcZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAxODZcXHUwMTg3XFx1MDAwN0hcXHUwMDAyXFx1MDAwMlxcdTAxODdcXHUwMTg5XFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMDE2XFxmXFx1MDAwMlxcdTAxODhcXHUwMTgyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODhcXHUwMTg1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTg5XFx1MDE4Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMThhXFx1MDE4OFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4YVxcdTAxOGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4YlxcdTAwMTlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOGNcXHUwMThhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOGRcXHUwMThlXFxiXCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDAxXFx1MDAwMlxcdTAxOGVcXHUwMThmXFx1MDAwNVxcdTAwMThcXHJcXHUwMDAyXFx1MDE4ZlxcdTAxOWVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOTBcXHUwMTkxXFxmXFx1MDAwNlxcdTAwMDJcXHUwMDAyXFx1MDE5MVxcdTAxOTJcXHUwMDA3XCIsXHJcbiAgICBcIkNcXHUwMDAyXFx1MDAwMlxcdTAxOTJcXHUwMTlkXFx1MDAwNVxcdTAwMThcXHJcXHUwMDAyXFx1MDE5M1xcdTAxOTRcXGZcXHUwMDA1XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE5NFxcdTAxOTVcXHUwMDA3RVxcdTAwMDJcXHUwMDAyXFx1MDE5NVxcdTAxOWRcXHUwMDA1XFx1MDAxOFxcclxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE5NlxcdTAxOTdcXGZcXHUwMDA0XFx1MDAwMlxcdTAwMDJcXHUwMTk3XFx1MDE5OFxcdTAwMDdEXFx1MDAwMlxcdTAwMDJcXHUwMTk4XCIsXHJcbiAgICBcIlxcdTAxOWRcXHUwMDA1XFx1MDAxOFxcclxcdTAwMDJcXHUwMTk5XFx1MDE5YVxcZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAxOWFcXHUwMTliXCIsXHJcbiAgICBcIlxcdTAwMDdGXFx1MDAwMlxcdTAwMDJcXHUwMTliXFx1MDE5ZFxcdTAwMDVcXHUwMDE4XFxyXFx1MDAwMlxcdTAxOWNcXHUwMTkwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTljXFx1MDE5M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTljXFx1MDE5NlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5Y1xcdTAxOTlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE5ZFxcdTAxYTBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOWVcXHUwMTljXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOWVcXHUwMTlmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTlmXFx1MDAxYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWEwXFx1MDE5ZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhMVxcdTAxYTJcXGJcXHUwMDBmXFx1MDAwMVxcdTAwMDJcXHUwMWEyXFx1MDFhM1xcdTAwMDVcIixcclxuICAgIFwiXFx1MDAxYVxcdTAwMGVcXHUwMDAyXFx1MDFhM1xcdTAxYWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhNFxcdTAxYTVcXGZcIixcclxuICAgIFwiXFx1MDAwNFxcdTAwMDJcXHUwMDAyXFx1MDFhNVxcdTAxYTZcXHUwMDA3ZlxcdTAwMDJcXHUwMDAyXFx1MDFhNlxcdTAxYWJcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwMWFcXHUwMDBlXFx1MDAwMlxcdTAxYTdcXHUwMWE4XFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDFhOFxcdTAxYTlcXHUwMDA3XCIsXHJcbiAgICBcImdcXHUwMDAyXFx1MDAwMlxcdTAxYTlcXHUwMWFiXFx1MDAwNVxcdTAwMWFcXHUwMDBlXFx1MDAwMlxcdTAxYWFcXHUwMWE0XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWFhXFx1MDFhN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWFiXFx1MDFhZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhY1xcdTAxYWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFhY1xcdTAxYWRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYWRcXHUwMDFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYWVcXHUwMWFjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWFmXFx1MDFiMFxcYlxcdTAwMTBcXHUwMDAxXFx1MDAwMlxcdTAxYjBcXHUwMWIxXFx1MDAwNVwiLFxyXG4gICAgXCJcXHUwMDFjXFx1MDAwZlxcdTAwMDJcXHUwMWIxXFx1MDFiN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWIyXFx1MDFiM1xcZlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMWIzXFx1MDFiNFxcdTAwMDdQXFx1MDAwMlxcdTAwMDJcXHUwMWI0XFx1MDFiNlxcdTAwMDVcIixcclxuICAgIFwiXFx1MDAxY1xcdTAwMGZcXHUwMDAyXFx1MDFiNVxcdTAxYjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiNlxcdTAxYjlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYjdcXHUwMWI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYjdcXHUwMWI4XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWI4XFx1MDAxZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWI5XFx1MDFiN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiYVxcdTAxYmJcXGJcXHUwMDExXFx1MDAwMVxcdTAwMDJcXHUwMWJiXFx1MDFiY1xcdTAwMDVcIixcclxuICAgIFwiXFx1MDAxZVxcdTAwMTBcXHUwMDAyXFx1MDFiY1xcdTAxYzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFiZFxcdTAxYmVcXGZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDFiZVxcdTAxYmZcXHUwMDA3VFxcdTAwMDJcXHUwMDAyXFx1MDFiZlxcdTAxYzFcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwMWVcXHUwMDEwXFx1MDAwMlxcdTAxYzBcXHUwMWJkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzFcXHUwMWM0XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWMyXFx1MDFjMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWMyXFx1MDFjM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjMyFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjNFxcdTAxYzJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzVcXHUwMWM2XFxiXFx1MDAxMlxcdTAwMDFcXHUwMDAyXFx1MDFjNlxcdTAxYzdcXHUwMDA1XCIsXHJcbiAgICBcIiBcXHUwMDExXFx1MDAwMlxcdTAxYzdcXHUwMWNkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxYzhcXHUwMWM5XFxmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxYzlcXHUwMWNhXFx1MDAwN1FcXHUwMDAyXFx1MDAwMlxcdTAxY2FcXHUwMWNjXFx1MDAwNSBcXHUwMDExXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMWNiXFx1MDFjOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWNjXFx1MDFjZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFjZFxcdTAxY2JcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFjZFxcdTAxY2VcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxY2UjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxY2ZcXHUwMWNkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMWQwXFx1MDFkMVxcYlxcdTAwMTNcXHUwMDAxXFx1MDAwMlxcdTAxZDFcXHUwMWQyXFx1MDAwNVxcXCJcXHUwMDEyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWQyXFx1MDFkOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWQzXFx1MDFkNFxcZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWQ0XFx1MDFkNVxcdTAwMDdSXFx1MDAwMlxcdTAwMDJcXHUwMWQ1XFx1MDFkN1xcdTAwMDVcXFwiXFx1MDAxMlxcdTAwMDJcXHUwMWQ2XCIsXHJcbiAgICBcIlxcdTAxZDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkN1xcdTAxZGFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkOFwiLFxyXG4gICAgXCJcXHUwMWQ2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDhcXHUwMWQ5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZDlcIixcclxuICAgIFwiJVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWRhXFx1MDFkOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWRiXCIsXHJcbiAgICBcIlxcdTAxZGNcXGJcXHUwMDE0XFx1MDAwMVxcdTAwMDJcXHUwMWRjXFx1MDFkZFxcdTAwMDUkXFx1MDAxM1xcdTAwMDJcXHUwMWRkXFx1MDFlM1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFkZVxcdTAxZGZcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMWRmXFx1MDFlMFwiLFxyXG4gICAgXCJcXHUwMDA3U1xcdTAwMDJcXHUwMDAyXFx1MDFlMFxcdTAxZTJcXHUwMDA1JFxcdTAwMTNcXHUwMDAyXFx1MDFlMVxcdTAxZGVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZTJcXHUwMWU1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZTNcXHUwMWUxXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWUzXFx1MDFlNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU0XFwnXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU1XFx1MDFlM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWU2XFx1MDFlY1xcdTAwMDVcIixcclxuICAgIFwiJlxcdTAwMTRcXHUwMDAyXFx1MDFlN1xcdTAxZThcXHUwMDA3V1xcdTAwMDJcXHUwMDAyXFx1MDFlOFxcdTAxZTlcXHUwMDA1LlxcdTAwMThcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxZTlcXHUwMWVhXFx1MDAwN1hcXHUwMDAyXFx1MDAwMlxcdTAxZWFcXHUwMWViXFx1MDAwNShcXHUwMDE1XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMWViXFx1MDFlZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWVjXFx1MDFlN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDFlY1xcdTAxZWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFlZClcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxZWVcXHUwMWY1XFx1MDAwNShcXHUwMDE1XFx1MDAwMlxcdTAxZWZcXHUwMWYwXFx1MDAwNVxcdTAwMGVcXGJcXHUwMDAyXFx1MDFmMFwiLFxyXG4gICAgXCJcXHUwMWYxXFx1MDAwNSxcXHUwMDE3XFx1MDAwMlxcdTAxZjFcXHUwMWYyXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAxZjJcXHUwMWY1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMWYzXFx1MDFmNVxcdTAwMDdtXFx1MDAwMlxcdTAwMDJcXHUwMWY0XFx1MDFlZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFmNFxcdTAxZWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDFmNFxcdTAxZjNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjUrXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjZcXHUwMWY3XCIsXHJcbiAgICBcIlxcdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAxZjctXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxZjhcXHUwMWY5XFxiXFx1MDAxOFwiLFxyXG4gICAgXCJcXHUwMDAxXFx1MDAwMlxcdTAxZjlcXHUwMWZhXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAxZmFcXHUwMjAwXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMWZiXFx1MDFmY1xcZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAxZmNcXHUwMWZkXFx1MDAwN1pcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMWZkXFx1MDFmZlxcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwMWZlXFx1MDFmYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDFmZlxcdTAyMDJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIwMFxcdTAxZmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyMDBcXHUwMjAxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMDEvXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjAyXFx1MDIwMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjAzXFx1MDIwNFxcdTAwMDUoXFx1MDAxNVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDIwNDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIwNVxcdTAyMDZcXHUwMDA1NFxcdTAwMWJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyMDZcXHUwMjA3XFx1MDAwNTpcXHUwMDFlXFx1MDAwMlxcdTAyMDdcXHUwMjA4XFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTAyMDhcIixcclxuICAgIFwiXFx1MDIwZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjA5XFx1MDIwYVxcdTAwMDU0XFx1MDAxYlxcdTAwMDJcXHUwMjBhXCIsXHJcbiAgICBcIlxcdTAyMGJcXHUwMDA3WVxcdTAwMDJcXHUwMDAyXFx1MDIwYlxcdTAyMGVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIwY1wiLFxyXG4gICAgXCJcXHUwMjBlXFx1MDAwNVxcdTAwOGNHXFx1MDAwMlxcdTAyMGRcXHUwMjA1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMGRcIixcclxuICAgIFwiXFx1MDIwOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjBkXFx1MDIwY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjBlXCIsXHJcbiAgICBcIjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIwZlxcdTAyMTFcXHUwMDA1OFxcdTAwMWRcXHUwMDAyXFx1MDIxMFxcdTAyMGZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMTFcXHUwMjEyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMTJcXHUwMjEwXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjEyXFx1MDIxM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjEzNVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxNFxcdTAyMTZcXHUwMDA1OFxcdTAwMWRcXHUwMDAyXFx1MDIxNVxcdTAyMTRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMTZcXHUwMjE3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMTdcXHUwMjE1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjE3XFx1MDIxOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjE4N1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxOVxcdTAyMWZcXHUwMDA1PiBcXHUwMDAyXFx1MDIxYVxcdTAyMWZcXHUwMDA1XCIsXHJcbiAgICBcIkAhXFx1MDAwMlxcdTAyMWJcXHUwMjFmXFx1MDAwNVouXFx1MDAwMlxcdTAyMWNcXHUwMjFmXFx1MDAwNVxcXFwvXFx1MDAwMlxcdTAyMWRcIixcclxuICAgIFwiXFx1MDIxZlxcdTAwMDVeMFxcdTAwMDJcXHUwMjFlXFx1MDIxOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjFlXFx1MDIxYVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxZVxcdTAyMWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIxZVxcdTAyMWNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMWVcXHUwMjFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMWY5XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjIwXFx1MDIyMVxcYlxcdTAwMWVcXHUwMDAxXFx1MDAwMlxcdTAyMjFcXHUwMjIyXCIsXHJcbiAgICBcIlxcdTAwMDU8XFx1MDAxZlxcdTAwMDJcXHUwMjIyXFx1MDIyOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjIzXFx1MDIyNFwiLFxyXG4gICAgXCJcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMjI0XFx1MDIyNVxcdTAwMDdaXFx1MDAwMlxcdTAwMDJcXHUwMjI1XFx1MDIyN1xcdTAwMDVcIixcclxuICAgIFwiPFxcdTAwMWZcXHUwMDAyXFx1MDIyNlxcdTAyMjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIyN1xcdTAyMmFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMjhcXHUwMjI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyMjhcXHUwMjI5XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjI5O1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjJhXFx1MDIyOFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIyYlxcdTAyMzFcXHUwMDA1YDFcXHUwMDAyXFx1MDIyY1xcdTAyMmRcXHUwMDA1YDFcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyMmRcXHUwMjJlXFx1MDAwN1tcXHUwMDAyXFx1MDAwMlxcdTAyMmVcXHUwMjJmXFx1MDAwNVxcdTAwODJCXFx1MDAwMlxcdTAyMmZcIixcclxuICAgIFwiXFx1MDIzMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjMwXFx1MDIyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjMwXCIsXHJcbiAgICBcIlxcdTAyMmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIzMT1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIzMlwiLFxyXG4gICAgXCJcXHUwMjMzXFx0XFx1MDAwNFxcdTAwMDJcXHUwMDAyXFx1MDIzMz9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDIzNFxcdTAyNDNcIixcclxuICAgIFwiXFx0XFx1MDAwNVxcdTAwMDJcXHUwMDAyXFx1MDIzNVxcdTAyMzZcXHUwMDA3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDIzNlxcdTAyMzdcIixcclxuICAgIFwiXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAyMzdcXHUwMjM4XFx0XFx1MDAwNlxcdTAwMDJcXHUwMDAyXFx1MDIzOFxcdTAyNDNcXHUwMDA3XCIsXHJcbiAgICBcIj5cXHUwMDAyXFx1MDAwMlxcdTAyMzlcXHUwMjQzXFx1MDAwNVgtXFx1MDAwMlxcdTAyM2FcXHUwMjQzXFx1MDAwNUJcXFwiXFx1MDAwMlxcdTAyM2JcIixcclxuICAgIFwiXFx1MDI0M1xcdTAwMDVQKVxcdTAwMDJcXHUwMjNjXFx1MDI0M1xcdTAwMDVcXHUwMDgwQVxcdTAwMDJcXHUwMjNkXFx1MDIzZVxcdTAwMDdcIixcclxuICAgIFwiXFx0XFx1MDAwMlxcdTAwMDJcXHUwMjNlXFx1MDIzZlxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMjNmXFx1MDI0MFxcdTAwMDUwXFx1MDAxOVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI0MFxcdTAyNDFcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDI0MVxcdTAyNDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyNDJcXHUwMjM0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNDJcXHUwMjM1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjQyXFx1MDIzOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjQyXFx1MDIzYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI0MlxcdTAyM2JcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI0MlxcdTAyM2NcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyNDJcXHUwMjNkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNDNBXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjQ0XFx1MDI0NlxcdTAwMDVEI1xcdTAwMDJcXHUwMjQ1XFx1MDI0N1xcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMjQ2XCIsXHJcbiAgICBcIlxcdTAyNDVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI0NlxcdTAyNDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI0N1wiLFxyXG4gICAgXCJcXHUwMjQ4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNDhcXHUwMjQ5XFx1MDAwN0FcXHUwMDAyXFx1MDAwMlxcdTAyNDlcIixcclxuICAgIFwiXFx1MDI0YVxcdTAwMDVGJFxcdTAwMDJcXHUwMjRhXFx1MDI0YlxcdTAwMDdCXFx1MDAwMlxcdTAwMDJcXHUwMjRiXFx1MDI1MFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI0Y1xcdTAyNGRcXHUwMDA1RCNcXHUwMDAyXFx1MDI0ZFxcdTAyNGVcXHUwMDA3a1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyNGVcXHUwMjUwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNGZcXHUwMjQ0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjRmXFx1MDI0Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjUwQ1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI1MVxcdTAyNTJcXHRcXHUwMDA3XFx1MDAwMlxcdTAwMDJcXHUwMjUyRVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI1M1xcdTAyNTRcXGIkXFx1MDAwMVxcdTAwMDJcXHUwMjU0XFx1MDI1NVxcdTAwMDVIJVxcdTAwMDJcXHUwMjU1XFx1MDI1YVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1NlxcdTAyNTdcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMjU3XFx1MDI1OVxcdTAwMDVcIixcclxuICAgIFwiSCVcXHUwMDAyXFx1MDI1OFxcdTAyNTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1OVxcdTAyNWNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAyNWFcXHUwMjU4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNWFcXHUwMjViXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMjViR1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjVjXFx1MDI1YVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDI1ZFxcdTAyNWZcXHUwMDA1SiZcXHUwMDAyXFx1MDI1ZVxcdTAyNjBcXHUwMDA1TFxcJ1xcdTAwMDJcXHUwMjVmXCIsXHJcbiAgICBcIlxcdTAyNWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI1ZlxcdTAyNjBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2MFwiLFxyXG4gICAgXCJcXHUwMjYxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNjFcXHUwMjYyXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTAyNjJcIixcclxuICAgIFwiXFx1MDI2NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjYzXFx1MDI2NVxcdTAwMDVcXHUwMDhjR1xcdTAwMDJcXHUwMjY0XCIsXHJcbiAgICBcIlxcdTAyNWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2NFxcdTAyNjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2NVwiLFxyXG4gICAgXCJJXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNjZcXHUwMjY4XFx1MDAwNUAhXFx1MDAwMlxcdTAyNjdcXHUwMjY5XFx1MDAwNVwiLFxyXG4gICAgXCJKJlxcdTAwMDJcXHUwMjY4XFx1MDI2N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjY4XFx1MDI2OVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDI2OVxcdTAyNmZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2YVxcdTAyNmNcXHUwMDA1WlwiLFxyXG4gICAgXCIuXFx1MDAwMlxcdTAyNmJcXHUwMjZkXFx1MDAwNUomXFx1MDAwMlxcdTAyNmNcXHUwMjZiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjZjXFx1MDI2ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjZkXFx1MDI2ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI2ZVxcdTAyNjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI2ZVxcdTAyNmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyNmZLXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNzBcXHUwMjcxXFxiXFwnXFx1MDAwMVxcdTAwMDJcXHUwMjcxXFx1MDI3MlwiLFxyXG4gICAgXCJcXHUwMDA1TihcXHUwMDAyXFx1MDI3MlxcdTAyNzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI3M1xcdTAyNzRcXGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDI3NFxcdTAyNzVcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDI3NVxcdTAyNzdcXHUwMDA1TihcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyNzZcXHUwMjczXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyNzdcXHUwMjdhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMjc4XFx1MDI3NlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjc4XFx1MDI3OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDI3OU1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI3YVxcdTAyNzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyN2JcXHUwMjgyXFx1MDAwNWAxXFx1MDAwMlxcdTAyN2NcXHUwMjdlXFx1MDAwNWAxXFx1MDAwMlxcdTAyN2RcXHUwMjdjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjdkXFx1MDI3ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjdlXFx1MDI3ZlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI3ZlxcdTAyODBcXHUwMDA3WFxcdTAwMDJcXHUwMDAyXFx1MDI4MFxcdTAyODJcXHUwMDA1XCIsXHJcbiAgICBcIjBcXHUwMDE5XFx1MDAwMlxcdTAyODFcXHUwMjdiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyODFcXHUwMjdkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjgyT1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjgzXFx1MDI4NVxcdTAwMDdcIixcclxuICAgIFwiXFx1MDAxYlxcdTAwMDJcXHUwMDAyXFx1MDI4NFxcdTAyODZcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDI4NVxcdTAyODRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyODVcXHUwMjg2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyODZcXHUwMjg3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjg3XFx1MDI4OFxcdTAwMDdBXFx1MDAwMlxcdTAwMDJcXHUwMjg4XFx1MDI4OVxcdTAwMDVcIixcclxuICAgIFwiUipcXHUwMDAyXFx1MDI4OVxcdTAyOGFcXHUwMDA3QlxcdTAwMDJcXHUwMDAyXFx1MDI4YVxcdTAyOTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyOGJcXHUwMjhkXFx1MDAwN1xcdTAwMWJcXHUwMDAyXFx1MDAwMlxcdTAyOGNcXHUwMjhlXFx1MDAwN2tcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMjhkXFx1MDI4Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjhkXFx1MDI4ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI4ZVxcdTAyOGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDI4ZlxcdTAyOTBcXHUwMDA3QVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyOTBcXHUwMjkxXFx1MDAwNVIqXFx1MDAwMlxcdTAyOTFcXHUwMjkyXFx1MDAwN1pcXHUwMDAyXFx1MDAwMlxcdTAyOTJcIixcclxuICAgIFwiXFx1MDI5M1xcdTAwMDdCXFx1MDAwMlxcdTAwMDJcXHUwMjkzXFx1MDI5N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjk0XCIsXHJcbiAgICBcIlxcdTAyOTVcXHUwMDA3XFx1MDAxYlxcdTAwMDJcXHUwMDAyXFx1MDI5NVxcdTAyOTdcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDI5NlwiLFxyXG4gICAgXCJcXHUwMjgzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyOTZcXHUwMjhiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyOTZcIixcclxuICAgIFwiXFx1MDI5NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjk3UVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMjk4XCIsXHJcbiAgICBcIlxcdTAyOTlcXGIqXFx1MDAwMVxcdTAwMDJcXHUwMjk5XFx1MDI5YVxcdTAwMDVUK1xcdTAwMDJcXHUwMjlhXFx1MDJhMFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDI5YlxcdTAyOWNcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMjljXFx1MDI5ZFxcdTAwMDdaXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDI5ZFxcdTAyOWZcXHUwMDA1VCtcXHUwMDAyXFx1MDI5ZVxcdTAyOWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyOWZcXHUwMmEyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYTBcXHUwMjllXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmEwXFx1MDJhMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmExU1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJhMlxcdTAyYTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJhM1xcdTAyYTlcXHUwMDA1VixcXHUwMDAyXFx1MDJhNFwiLFxyXG4gICAgXCJcXHUwMmE1XFx1MDAwNVYsXFx1MDAwMlxcdTAyYTVcXHUwMmE2XFx1MDAwN1tcXHUwMDAyXFx1MDAwMlxcdTAyYTZcXHUwMmE3XFx1MDAwNVwiLFxyXG4gICAgXCIwXFx1MDAxOVxcdTAwMDJcXHUwMmE3XFx1MDJhOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmE4XFx1MDJhM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJhOFxcdTAyYTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJhOVVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYWFcXHUwMmFiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyYWJXXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMmFjXFx1MDJhZFxcdTAwMDc1XFx1MDAwMlxcdTAwMDJcXHUwMmFkXFx1MDJhZVxcdTAwMDc9XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJhZVxcdTAyYWZcXHUwMDA1ej5cXHUwMDAyXFx1MDJhZlxcdTAyYjBcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDJiMFwiLFxyXG4gICAgXCJZXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYjFcXHUwMmIyXFx0XFxiXFx1MDAwMlxcdTAwMDJcXHUwMmIyW1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDJiM1xcdTAyYmFcXHRcXHRcXHUwMDAyXFx1MDAwMlxcdTAyYjRcXHUwMmJhXFx1MDAwNWY0XFx1MDAwMlxcdTAyYjVcIixcclxuICAgIFwiXFx1MDJiNlxcdTAwMDdcXGZcXHUwMDAyXFx1MDAwMlxcdTAyYjZcXHUwMmI3XFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAyYjdcXHUwMmI4XCIsXHJcbiAgICBcIlxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMmI4XFx1MDJiYVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMmI5XFx1MDJiM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJiOVxcdTAyYjRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJiOVxcdTAyYjVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYmFdXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYmJcXHUwMmJjXFx1MDAwN1wiLFxyXG4gICAgXCIzXFx1MDAwMlxcdTAwMDJcXHUwMmJjXFx1MDJiZFxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMmJkXFx1MDJiZVxcdTAwMDV6PlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJiZVxcdTAyYmZcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDJiZlxcdTAyYzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyYzBcXHUwMmMxXFx1MDAwNzNcXHUwMDAyXFx1MDAwMlxcdTAyYzFcXHUwMmMyXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAyYzJcIixcclxuICAgIFwiXFx1MDJjM1xcdTAwMDUwXFx1MDAxOVxcdTAwMDJcXHUwMmMzXFx1MDJjNFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMmM0XFx1MDJjNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJjNVxcdTAyYmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJjNVxcdTAyYzBcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYzZfXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyYzdcXHUwMmM5XCIsXHJcbiAgICBcIlxcdTAwMDVuOFxcdTAwMDJcXHUwMmM4XFx1MDJjN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmM4XFx1MDJjOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJjOVxcdTAyY2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJjYVxcdTAyY2VcXHUwMDA1XCIsXHJcbiAgICBcImIyXFx1MDAwMlxcdTAyY2JcXHUwMmNkXFx1MDAwNWQzXFx1MDAwMlxcdTAyY2NcXHUwMmNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmNkXFx1MDJkMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmNlXFx1MDJjY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDJjZVxcdTAyY2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJjZmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyZDBcXHUwMmNlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyZDFcXHUwMmQyXFxiMlxcdTAwMDFcXHUwMDAyXFx1MDJkMlwiLFxyXG4gICAgXCJcXHUwMmRiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTAyZDNcXHUwMmQ0XFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAyZDRcXHUwMmQ1XCIsXHJcbiAgICBcIlxcdTAwMDVgMVxcdTAwMDJcXHUwMmQ1XFx1MDJkNlxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMmQ2XFx1MDJkYlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDJkN1xcdTAyZDhcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDJkOFxcdTAyZDlcXHUwMDA3WFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAyZDlcXHUwMmRiXFx1MDAwN21cXHUwMDAyXFx1MDAwMlxcdTAyZGFcXHUwMmQxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmRhXFx1MDJkM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmRhXFx1MDJkN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJkYlxcdTAzMDlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJkY1xcdTAyZGRcXGZcXHRcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmRkXFx1MDJkZlxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMmRlXFx1MDJlMFxcdTAwMDVwOVxcdTAwMDJcXHUwMmRmXFx1MDJkZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJkZlxcdTAyZTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJlMFxcdTAyZTJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyZTFcXHUwMmUzXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAyZTJcXHUwMmUxXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmUyXFx1MDJlM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmUzXFx1MDJlNFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJlNFxcdTAzMDhcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDJlNVxcdTAyZTZcIixcclxuICAgIFwiXFxmXFxiXFx1MDAwMlxcdTAwMDJcXHUwMmU2XFx1MDJlN1xcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMmU3XFx1MDJlOVxcdTAwMDcqXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDJlOFxcdTAyZWFcXHUwMDA1cDlcXHUwMDAyXFx1MDJlOVxcdTAyZThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAyZTlcXHUwMmVhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyZWFcXHUwMmViXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMmViXFx1MDJlY1xcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwMmVjXFx1MDJlZFxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwMmVkXCIsXHJcbiAgICBcIlxcdTAzMDhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJlZVxcdTAyZWZcXGZcXHUwMDA3XFx1MDAwMlxcdTAwMDJcXHUwMmVmXCIsXHJcbiAgICBcIlxcdTAyZjBcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDJmMFxcdTAyZjFcXHUwMDA1cDlcXHUwMDAyXFx1MDJmMVxcdTAyZjJcXHUwMDA3XCIsXHJcbiAgICBcIipcXHUwMDAyXFx1MDAwMlxcdTAyZjJcXHUwMmYzXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAyZjNcXHUwMmY0XFx1MDAwN0BcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmY0XFx1MDMwOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMmY1XFx1MDJmNlxcZlxcdTAwMDZcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMmY2XFx1MDJmOFxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMmY3XFx1MDJmOVxcdTAwMDVwOVxcdTAwMDJcXHUwMmY4XCIsXHJcbiAgICBcIlxcdTAyZjdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJmOFxcdTAyZjlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDJmOVwiLFxyXG4gICAgXCJcXHUwMmZhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAyZmFcXHUwMmZiXFx1MDAwN01cXHUwMDAyXFx1MDAwMlxcdTAyZmJcIixcclxuICAgIFwiXFx1MDMwOFxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwMmZjXFx1MDJmZFxcZlxcdTAwMDVcXHUwMDAyXFx1MDAwMlxcdTAyZmRcXHUwMmZlXCIsXHJcbiAgICBcIlxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMmZlXFx1MDJmZlxcdTAwMDVyOlxcdTAwMDJcXHUwMmZmXFx1MDMwMFxcdTAwMDc+XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDMwMFxcdTAzMDhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMwMVxcdTAzMDJcXGZcXHUwMDA0XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDMwMlxcdTAzMDRcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDMwM1xcdTAzMDVcXHUwMDA1eD1cXHUwMDAyXFx1MDMwNFwiLFxyXG4gICAgXCJcXHUwMzAzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMDRcXHUwMzA1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMDVcIixcclxuICAgIFwiXFx1MDMwNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzA2XFx1MDMwOFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMzA3XCIsXHJcbiAgICBcIlxcdTAyZGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMwN1xcdTAyZTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMwN1wiLFxyXG4gICAgXCJcXHUwMmVlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMDdcXHUwMmY1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMDdcIixcclxuICAgIFwiXFx1MDJmY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzA3XFx1MDMwMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzA4XCIsXHJcbiAgICBcIlxcdTAzMGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMwOVxcdTAzMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMwOVwiLFxyXG4gICAgXCJcXHUwMzBhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMGFjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMGJcIixcclxuICAgIFwiXFx1MDMwOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzBjXFx1MDMwZFxcdTAwMDdcXHJcXHUwMDAyXFx1MDAwMlxcdTAzMGRcIixcclxuICAgIFwiXFx1MDMwZlxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMzBlXFx1MDMxMFxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMzBmXFx1MDMwZVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxMFxcdTAzMTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxMVxcdTAzMGZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMTFcXHUwMzEyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMTJcXHUwMzEzXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzEzXFx1MDMxNlxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMzE0XFx1MDMxNlwiLFxyXG4gICAgXCJcXHUwMDA1ZjRcXHUwMDAyXFx1MDMxNVxcdTAzMGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMxNVxcdTAzMTRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMTZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMTdcXHUwMzE4XFx1MDAwN1wiLFxyXG4gICAgXCJcXHUwMDBlXFx1MDAwMlxcdTAwMDJcXHUwMzE4XFx1MDMxOVxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMzE5XFx1MDMxYVxcdTAwMDdcIixcclxuICAgIFwiPVxcdTAwMDJcXHUwMDAyXFx1MDMxYVxcdTAzMWJcXHUwMDA1aDVcXHUwMDAyXFx1MDMxYlxcdTAzMWNcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzMWNcXHUwMzFkXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAzMWRnXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMWVcIixcclxuICAgIFwiXFx1MDMyM1xcdTAwMDVqNlxcdTAwMDJcXHUwMzFmXFx1MDMyMFxcdTAwMDdaXFx1MDAwMlxcdTAwMDJcXHUwMzIwXFx1MDMyMlxcdTAwMDVcIixcclxuICAgIFwiajZcXHUwMDAyXFx1MDMyMVxcdTAzMWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMyMlxcdTAzMjVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzMjNcXHUwMzIxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMjNcXHUwMzI0XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzI0XFx1MDMyOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzI1XFx1MDMyM1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDMyNlxcdTAzMjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMyN1xcdTAzMWVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzMjdcXHUwMzI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMjhpXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzI5XFx1MDMyZlxcblxcblxcdTAwMDJcXHUwMDAyXFx1MDMyYVxcdTAzMmNcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzMmJcXHUwMzJkXFx1MDAwNVxcZlxcdTAwMDdcXHUwMDAyXFx1MDMyY1xcdTAzMmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzMmNcXHUwMzJkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMmRcXHUwMzJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzJlXFx1MDMzMFxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwMzJmXFx1MDMyYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDMyZlxcdTAzMzBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMzMFxcdTAzMzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzMzFcXHUwMzMzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMzJcXHUwMzI5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzMyXFx1MDMzMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzMza1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDMzNFxcdTAzM2FcXG5cXHUwMDBiXFx1MDAwMlxcdTAwMDJcXHUwMzM1XFx1MDMzNlxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwMzM2XCIsXHJcbiAgICBcIlxcdTAzMzdcXHUwMDA1bDdcXHUwMDAyXFx1MDMzN1xcdTAzMzhcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDMzOFxcdTAzM2FcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMzlcXHUwMzM0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzMzlcXHUwMzM1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzNhXFx1MDMzZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzNiXFx1MDMzOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMzYlxcdTAzM2NcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDMzY21cXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzM2RcXHUwMzNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzM2VcXHUwMzQwXFx1MDAwN1wiLFxyXG4gICAgXCJNXFx1MDAwMlxcdTAwMDJcXHUwMzNmXFx1MDM0MVxcdTAwMDVwOVxcdTAwMDJcXHUwMzQwXFx1MDMzZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDM0MFxcdTAzNDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM0MVxcdTAzNTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzNDJcXHUwMzQ0XFx1MDAwN01cXHUwMDAyXFx1MDAwMlxcdTAzNDNcXHUwMzQ1XFx1MDAwNXA5XFx1MDAwMlxcdTAzNDRcIixcclxuICAgIFwiXFx1MDM0M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzQ0XFx1MDM0NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzQ1XCIsXHJcbiAgICBcIlxcdTAzNDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM0NlxcdTAzNTFcXHUwMDA1bjhcXHUwMDAyXFx1MDM0N1xcdTAzNDlcIixcclxuICAgIFwiXFx1MDAwN1RcXHUwMDAyXFx1MDAwMlxcdTAzNDhcXHUwMzRhXFx1MDAwNXA5XFx1MDAwMlxcdTAzNDlcXHUwMzQ4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzQ5XFx1MDM0YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzRhXFx1MDM1MVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDM0YlxcdTAzNGRcXHUwMDA3VFxcdTAwMDJcXHUwMDAyXFx1MDM0Y1xcdTAzNGVcXHUwMDA1cDlcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNGRcXHUwMzRjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNGRcXHUwMzRlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzRlXFx1MDM0ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzRmXFx1MDM1MVxcdTAwMDVuOFxcdTAwMDJcXHUwMzUwXCIsXHJcbiAgICBcIlxcdTAzM2VcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1MFxcdTAzNDJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1MFwiLFxyXG4gICAgXCJcXHUwMzQ3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNTBcXHUwMzRiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNTFcIixcclxuICAgIFwib1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzUyXFx1MDM1M1xcYjlcXHUwMDAxXFx1MDAwMlxcdTAzNTNcXHUwMzU0XFx1MDAwNVwiLFxyXG4gICAgXCJaLlxcdTAwMDJcXHUwMzU0XFx1MDM1OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzU1XFx1MDM1NlxcZlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzU2XFx1MDM1OFxcdTAwMDVaLlxcdTAwMDJcXHUwMzU3XFx1MDM1NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM1OFxcdTAzNWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM1OVxcdTAzNTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNTlcXHUwMzVhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNWFxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzViXFx1MDM1OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzVjXFx1MDM2MlxcdTAwMDV0O1xcdTAwMDJcXHUwMzVkXCIsXHJcbiAgICBcIlxcdTAzNWVcXHUwMDA1dDtcXHUwMDAyXFx1MDM1ZVxcdTAzNWZcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDM1ZlxcdTAzNjBcXHUwMDA3XCIsXHJcbiAgICBcImpcXHUwMDAyXFx1MDAwMlxcdTAzNjBcXHUwMzYyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNjFcXHUwMzVjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzYxXFx1MDM1ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzYyc1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM2M1xcdTAzNjRcXGI7XFx1MDAwMVxcdTAwMDJcXHUwMzY0XFx1MDM2NVxcdTAwMDV2PFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM2NVxcdTAzNmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM2NlxcdTAzNjdcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM2N1xcdTAzNjhcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDM2OFxcdTAzNmFcXHUwMDA1djxcXHUwMDAyXFx1MDM2OVxcdTAzNjZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNmFcXHUwMzZkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNmJcXHUwMzY5XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzZiXFx1MDM2Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzZjdVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM2ZFxcdTAzNmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM2ZVxcdTAzNmZcIixcclxuICAgIFwiXFx1MDAwNTRcXHUwMDFiXFx1MDAwMlxcdTAzNmZcXHUwMzcwXFx1MDAwNWAxXFx1MDAwMlxcdTAzNzBcXHUwMzc2XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMzcxXFx1MDM3M1xcdTAwMDU2XFx1MDAxY1xcdTAwMDJcXHUwMzcyXFx1MDM3NFxcdTAwMDV8P1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDM3M1xcdTAzNzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM3M1xcdTAzNzRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzNzRcXHUwMzc2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzNzVcXHUwMzZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzc1XFx1MDM3MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzc2d1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM3N1xcdTAzNzhcXGI9XFx1MDAwMVxcdTAwMDJcXHUwMzc4XFx1MDM3OVxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwMzc5XFx1MDM3ZlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM3YVxcdTAzN2JcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMzdiXFx1MDM3Y1wiLFxyXG4gICAgXCJcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDM3Y1xcdTAzN2VcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDM3ZFxcdTAzN2FcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzN2VcXHUwMzgxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzN2ZcXHUwMzdkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzdmXFx1MDM4MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzgweVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM4MVxcdTAzN2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM4MlxcdTAzODRcXHUwMDA1XCIsXHJcbiAgICBcIkomXFx1MDAwMlxcdTAzODNcXHUwMzg1XFx1MDAwNXw/XFx1MDAwMlxcdTAzODRcXHUwMzgzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzg0XFx1MDM4NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzg1e1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM4NlxcdTAzOTJcXHUwMDA1bjhcXHUwMDAyXFx1MDM4N1xcdTAzODlcXHUwMDA1bjhcXHUwMDAyXFx1MDM4OFxcdTAzODdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzODhcXHUwMzg5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzODlcXHUwMzhhXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzhhXFx1MDM4ZVxcdTAwMDV+QFxcdTAwMDJcXHUwMzhiXFx1MDM4ZFxcdTAwMDVkM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDM4Y1xcdTAzOGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM4ZFxcdTAzOTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzOGVcXHUwMzhjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOGVcXHUwMzhmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzhmXFx1MDM5MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzkwXFx1MDM4ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM5MVxcdTAzODZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM5MVxcdTAzODhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzOTJ9XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOTNcXHUwMzk0XFxiQFxcdTAwMDFcXHUwMDAyXFx1MDM5NFxcdTAzOTVcIixcclxuICAgIFwiXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTAzOTVcXHUwMzk2XFx1MDAwNXw/XFx1MDAwMlxcdTAzOTZcXHUwMzlhXFx1MDAwNz5cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMzk3XFx1MDM5OVxcdTAwMDVkM1xcdTAwMDJcXHUwMzk4XFx1MDM5N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM5OVxcdTAzOWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM5YVxcdTAzOThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzOWFcXHUwMzliXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzOWJcXHUwM2MyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMzljXFx1MDM5YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMzlkXFx1MDM5ZlxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDM5ZVxcdTAzYTBcXHUwMDA1cDlcXHUwMDAyXFx1MDM5ZlxcdTAzOWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDM5ZlwiLFxyXG4gICAgXCJcXHUwM2EwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYTBcXHUwM2EyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYTFcIixcclxuICAgIFwiXFx1MDNhM1xcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwM2EyXFx1MDNhMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2EyXCIsXHJcbiAgICBcIlxcdTAzYTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNhM1xcdTAzYTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNhNFwiLFxyXG4gICAgXCJcXHUwM2MyXFx1MDAwN0BcXHUwMDAyXFx1MDAwMlxcdTAzYTVcXHUwM2E2XFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzYTZcXHUwM2E4XCIsXHJcbiAgICBcIlxcdTAwMDcqXFx1MDAwMlxcdTAwMDJcXHUwM2E3XFx1MDNhOVxcdTAwMDVwOVxcdTAwMDJcXHUwM2E4XFx1MDNhN1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNhOFxcdTAzYTlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNhOVxcdTAzYWFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzYWFcXHUwM2FiXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAzYWJcXHUwM2FjXFx1MDAwN0BcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2FjXFx1MDNjMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2FkXFx1MDNhZVxcdTAwMDc/XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDNhZVxcdTAzYWZcXHUwMDA1cDlcXHUwMDAyXFx1MDNhZlxcdTAzYjBcXHUwMDA3KlxcdTAwMDJcXHUwMDAyXFx1MDNiMFwiLFxyXG4gICAgXCJcXHUwM2IxXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAzYjFcXHUwM2IyXFx1MDAwN0BcXHUwMDAyXFx1MDAwMlxcdTAzYjJcXHUwM2MyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2IzXFx1MDNiNFxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwM2I0XFx1MDNiNVwiLFxyXG4gICAgXCJcXHUwMDA3TVxcdTAwMDJcXHUwMDAyXFx1MDNiNVxcdTAzYzJcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDNiNlxcdTAzYjhcXHUwMDA3XCIsXHJcbiAgICBcIj1cXHUwMDAyXFx1MDAwMlxcdTAzYjdcXHUwM2I5XFx1MDAwNXI6XFx1MDAwMlxcdTAzYjhcXHUwM2I3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2I4XFx1MDNiOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2I5XFx1MDNiYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDNiYVxcdTAzYmVcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDNiYlxcdTAzYmRcXHUwMDA1ZDNcXHUwMDAyXFx1MDNiY1wiLFxyXG4gICAgXCJcXHUwM2JiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYmRcXHUwM2MwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYmVcIixcclxuICAgIFwiXFx1MDNiY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2JlXFx1MDNiZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2JmXCIsXHJcbiAgICBcIlxcdTAzYzJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjMFxcdTAzYmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjMVwiLFxyXG4gICAgXCJcXHUwMzkzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYzFcXHUwMzlkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYzFcIixcclxuICAgIFwiXFx1MDNhNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2MxXFx1MDNhZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2MxXCIsXHJcbiAgICBcIlxcdTAzYjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjMVxcdTAzYjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjMlwiLFxyXG4gICAgXCJcXHUwM2VlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYzNcXHUwM2M0XFxmXFx1MDAwN1xcdTAwMDJcXHUwMDAyXFx1MDNjNFwiLFxyXG4gICAgXCJcXHUwM2M2XFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTAzYzVcXHUwM2M3XFx1MDAwNXA5XFx1MDAwMlxcdTAzYzZcXHUwM2M1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2M2XFx1MDNjN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2M3XFx1MDNjOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNjOFxcdTAzY2FcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDNjOVxcdTAzYzhcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzYzlcXHUwM2NhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzY2FcXHUwM2NiXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2NiXFx1MDNlZFxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwM2NjXFx1MDNjZFxcZlxcdTAwMDZcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2NkXFx1MDNjZVxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwM2NlXFx1MDNkMFxcdTAwMDcqXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDNjZlxcdTAzZDFcXHUwMDA1cDlcXHUwMDAyXFx1MDNkMFxcdTAzY2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAzZDBcXHUwM2QxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZDFcXHUwM2QyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwM2QyXFx1MDNkM1xcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwM2QzXFx1MDNkNFxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwM2Q0XCIsXHJcbiAgICBcIlxcdTAzZWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNkNVxcdTAzZDZcXGZcXHUwMDA1XFx1MDAwMlxcdTAwMDJcXHUwM2Q2XCIsXHJcbiAgICBcIlxcdTAzZDdcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDNkN1xcdTAzZDhcXHUwMDA1cDlcXHUwMDAyXFx1MDNkOFxcdTAzZDlcXHUwMDA3XCIsXHJcbiAgICBcIipcXHUwMDAyXFx1MDAwMlxcdTAzZDlcXHUwM2RhXFx1MDAwNSpcXHUwMDE2XFx1MDAwMlxcdTAzZGFcXHUwM2RiXFx1MDAwN0BcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2RiXFx1MDNlZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2RjXFx1MDNkZFxcZlxcdTAwMDRcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwM2RkXFx1MDNkZVxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwM2RlXFx1MDNkZlxcdTAwMDdNXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDNkZlxcdTAzZWRcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDNlMFxcdTAzZTFcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwM2UxXCIsXHJcbiAgICBcIlxcdTAzZTNcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDNlMlxcdTAzZTRcXHUwMDA1cjpcXHUwMDAyXFx1MDNlM1xcdTAzZTJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZTNcXHUwM2U0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZTRcXHUwM2U1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2U1XFx1MDNlOVxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwM2U2XFx1MDNlOFxcdTAwMDVcIixcclxuICAgIFwiZDNcXHUwMDAyXFx1MDNlN1xcdTAzZTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlOFxcdTAzZWJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzZTlcXHUwM2U3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZTlcXHUwM2VhXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2VhXFx1MDNlZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2ViXFx1MDNlOVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNlY1xcdTAzYzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlY1xcdTAzY2NcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzZWNcXHUwM2Q1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZWNcXHUwM2RjXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2VjXFx1MDNlMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2VkXFx1MDNmMFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNlZVxcdTAzZWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNlZVxcdTAzZWZcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAzZWZcXHUwMDdmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZjBcXHUwM2VlXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwM2YxXFx1MDNmMlxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwM2YyXFx1MDA4MVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDNmM1xcdTAzZmVcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDNmNFxcdTAzZjVcXHUwMDA3QVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAzZjVcXHUwM2Y2XFx1MDAwNVxcdTAwODRDXFx1MDAwMlxcdTAzZjZcXHUwM2Y3XFx1MDAwN0JcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwM2Y3XFx1MDNmZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2Y4XFx1MDNmOVxcdTAwMDdBXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDNmOVxcdTAzZmFcXHUwMDA1XFx1MDA4NENcXHUwMDAyXFx1MDNmYVxcdTAzZmJcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDNmYlwiLFxyXG4gICAgXCJcXHUwM2ZjXFx1MDAwN0JcXHUwMDAyXFx1MDAwMlxcdTAzZmNcXHUwM2ZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAzZmRcIixcclxuICAgIFwiXFx1MDNmM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2ZkXFx1MDNmNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwM2ZkXCIsXHJcbiAgICBcIlxcdTAzZjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNmZVxcdTAwODNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDNmZlwiLFxyXG4gICAgXCJcXHUwNDAxXFxiQ1xcdTAwMDFcXHUwMDAyXFx1MDQwMFxcdTA0MDJcXHUwMDA1XFx1MDA4NkRcXHUwMDAyXFx1MDQwMVxcdTA0MDBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MDFcXHUwNDAyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MDJcXHUwNDAzXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDAzXFx1MDQwNFxcdTAwMDVcXHUwMDgyQlxcdTAwMDJcXHUwNDA0XFx1MDQwZFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQwNVxcdTA0MDZcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwNDA2XFx1MDQwOFxcdTAwMDdcIixcclxuICAgIFwiWlxcdTAwMDJcXHUwMDAyXFx1MDQwN1xcdTA0MDlcXHUwMDA1XFx1MDA4NkRcXHUwMDAyXFx1MDQwOFxcdTA0MDdcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MDhcXHUwNDA5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MDlcXHUwNDBhXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDBhXFx1MDQwY1xcdTAwMDVcXHUwMDgyQlxcdTAwMDJcXHUwNDBiXFx1MDQwNVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQwY1xcdTA0MGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQwZFxcdTA0MGJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0MGRcXHUwNDBlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MGVcXHUwMDg1XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDBmXFx1MDQwZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDEwXFx1MDQxMVxcdTAwMDVcXHUwMDg4XCIsXHJcbiAgICBcIkVcXHUwMDAyXFx1MDQxMVxcdTA0MTJcXHUwMDA3W1xcdTAwMDJcXHUwMDAyXFx1MDQxMlxcdTAwODdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0MTNcXHUwNDE0XFxiRVxcdTAwMDFcXHUwMDAyXFx1MDQxNFxcdTA0MTVcXHUwMDA1XFx1MDA4YUZcXHUwMDAyXFx1MDQxNVwiLFxyXG4gICAgXCJcXHUwNDFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MTZcXHUwNDE3XFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDQxN1wiLFxyXG4gICAgXCJcXHUwNDE5XFx1MDAwNVxcdTAwOGFGXFx1MDAwMlxcdTA0MThcXHUwNDE2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MTlcIixcclxuICAgIFwiXFx1MDQxY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDFhXFx1MDQxOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDFhXCIsXHJcbiAgICBcIlxcdTA0MWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQxYlxcdTAwODlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQxY1wiLFxyXG4gICAgXCJcXHUwNDFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MWRcXHUwNDFlXFx1MDAwNz9cXHUwMDAyXFx1MDAwMlxcdTA0MWVcIixcclxuICAgIFwiXFx1MDQxZlxcdTAwMDUwXFx1MDAxOVxcdTAwMDJcXHUwNDFmXFx1MDQyMFxcdTAwMDdAXFx1MDAwMlxcdTAwMDJcXHUwNDIwXFx1MDQyNFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQyMVxcdTA0MjJcXHUwMDA3aVxcdTAwMDJcXHUwMDAyXFx1MDQyMlxcdTA0MjRcIixcclxuICAgIFwiXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTA0MjNcXHUwNDFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MjNcXHUwNDIxXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDI0XFx1MDA4YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDI1XFx1MDQyNlwiLFxyXG4gICAgXCJcXHUwMDA3O1xcdTAwMDJcXHUwMDAyXFx1MDQyNlxcdTA0MjdcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDQyN1xcdTA0MjhcXHUwMDA1XCIsXHJcbiAgICBcIjBcXHUwMDE5XFx1MDAwMlxcdTA0MjhcXHUwNDJhXFx1MDAwN1pcXHUwMDAyXFx1MDAwMlxcdTA0MjlcXHUwNDJiXFx1MDAwN25cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDJhXFx1MDQyOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDJiXFx1MDQyY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQyY1xcdTA0MmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQyY1xcdTA0MmRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0MmRcXHUwNDJlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0MmVcXHUwNDJmXFx1MDAwNz5cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDJmXFx1MDQzMFxcdTAwMDdZXFx1MDAwMlxcdTAwMDJcXHUwNDMwXFx1MDA4ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQzMVxcdTA0NTdcXHUwMDA1XFx1MDA5MElcXHUwMDAyXFx1MDQzMlxcdTA0NTdcXHUwMDA1XFx1MDA5MkpcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0MzNcXHUwNDU3XFx1MDAwNVxcdTAwOThNXFx1MDAwMlxcdTA0MzRcXHUwNDU3XFx1MDAwNVxcdTAwOWFOXFx1MDAwMlxcdTA0MzVcIixcclxuICAgIFwiXFx1MDQ1N1xcdTAwMDVcXHUwMDljT1xcdTAwMDJcXHUwNDM2XFx1MDQ1N1xcdTAwMDVcXHUwMGE0U1xcdTAwMDJcXHUwNDM3XFx1MDQzOFwiLFxyXG4gICAgXCJcXHRcXGZcXHUwMDAyXFx1MDAwMlxcdTA0MzhcXHUwNDM5XFx0XFxyXFx1MDAwMlxcdTAwMDJcXHUwNDM5XFx1MDQ0MlxcdTAwMDc9XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDQzYVxcdTA0M2ZcXHUwMDA1JlxcdTAwMTRcXHUwMDAyXFx1MDQzYlxcdTA0M2NcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0M2NcXHUwNDNlXFx1MDAwNSZcXHUwMDE0XFx1MDAwMlxcdTA0M2RcXHUwNDNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDNlXFx1MDQ0MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDNmXFx1MDQzZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQzZlxcdTA0NDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0MFxcdTA0NDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NDFcXHUwNDNmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NDJcXHUwNDNhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDQyXFx1MDQ0M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDQzXFx1MDQ1MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ0NFxcdTA0NGRcXHUwMDA3WFxcdTAwMDJcXHUwMDAyXFx1MDQ0NVxcdTA0NGFcXHUwMDA1JlxcdTAwMTRcXHUwMDAyXFx1MDQ0NlwiLFxyXG4gICAgXCJcXHUwNDQ3XFx1MDAwN1pcXHUwMDAyXFx1MDAwMlxcdTA0NDdcXHUwNDQ5XFx1MDAwNSZcXHUwMDE0XFx1MDAwMlxcdTA0NDhcXHUwNDQ2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDQ5XFx1MDQ0Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDRhXFx1MDQ0OFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0YVxcdTA0NGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0YlxcdTA0NGVcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NGNcXHUwNDRhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NGRcXHUwNDQ1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDRkXFx1MDQ0ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDRlXFx1MDQ1MFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ0ZlxcdTA0NDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ1MFxcdTA0NTNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NTFcXHUwNDRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NTFcXHUwNDUyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDUyXFx1MDQ1NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDUzXFx1MDQ1MVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ1NFxcdTA0NTVcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDQ1NVxcdTA0NTdcIixcclxuICAgIFwiXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0NTZcXHUwNDMxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NTZcXHUwNDMyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDU2XFx1MDQzM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDU2XFx1MDQzNFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ1NlxcdTA0MzVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ1NlxcdTA0MzZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NTZcXHUwNDM3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NTdcXHUwMDhmXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDU4XFx1MDQ1OVxcdTAwMDdrXFx1MDAwMlxcdTAwMDJcXHUwNDU5XFx1MDQ1YVwiLFxyXG4gICAgXCJcXHUwMDA3WFxcdTAwMDJcXHUwMDAyXFx1MDQ1YVxcdTA0NjRcXHUwMDA1XFx1MDA4ZUhcXHUwMDAyXFx1MDQ1YlxcdTA0NWNcXHUwMDA3XCIsXHJcbiAgICBcIlxcdTAwMTNcXHUwMDAyXFx1MDAwMlxcdTA0NWNcXHUwNDVkXFx1MDAwNTBcXHUwMDE5XFx1MDAwMlxcdTA0NWRcXHUwNDVlXFx1MDAwN1wiLFxyXG4gICAgXCJYXFx1MDAwMlxcdTAwMDJcXHUwNDVlXFx1MDQ1ZlxcdTAwMDVcXHUwMDhlSFxcdTAwMDJcXHUwNDVmXFx1MDQ2NFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ2MFxcdTA0NjFcXHUwMDA3XFx1MDAxN1xcdTAwMDJcXHUwMDAyXFx1MDQ2MVxcdTA0NjJcXHUwMDA3WFwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0NjJcXHUwNDY0XFx1MDAwNVxcdTAwOGVIXFx1MDAwMlxcdTA0NjNcXHUwNDU4XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDYzXFx1MDQ1YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDYzXFx1MDQ2MFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ2NFxcdTAwOTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ2NVxcdTA0NjdcXHUwMDA3QVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0NjZcXHUwNDY4XFx1MDAwNVxcdTAwOTRLXFx1MDAwMlxcdTA0NjdcXHUwNDY2XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNDY3XFx1MDQ2OFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDY4XFx1MDQ2OVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ2OVxcdTA0NmFcXHUwMDA3QlxcdTAwMDJcXHUwMDAyXFx1MDQ2YVxcdTAwOTNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0NmJcXHUwNDZjXFxiS1xcdTAwMDFcXHUwMDAyXFx1MDQ2Y1xcdTA0NmRcXHUwMDA1XFx1MDA5NkxcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NmRcXHUwNDcyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NmVcXHUwNDZmXFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NmZcXHUwNDcxXFx1MDAwNVxcdTAwOTZMXFx1MDAwMlxcdTA0NzBcXHUwNDZlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDcxXFx1MDQ3NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDcyXFx1MDQ3MFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ3MlxcdTA0NzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3M1xcdTAwOTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NzRcXHUwNDcyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0NzVcXHUwNDc4XFx1MDAwNTJcXHUwMDFhXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDc2XFx1MDQ3OFxcdTAwMDVcXHUwMDhlSFxcdTAwMDJcXHUwNDc3XFx1MDQ3NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ3N1xcdTA0NzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ3OFxcdTAwOTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0NzlcXHUwNDdiXFx1MDAwNS5cXHUwMDE4XFx1MDAwMlxcdTA0N2FcXHUwNDc5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDdhXFx1MDQ3YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDdiXFx1MDQ3Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ3Y1xcdTA0N2RcXHUwMDA3WVxcdTAwMDJcXHUwMDAyXFx1MDQ3ZFxcdTAwOTlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0N2VcXHUwNDdmXFx1MDAwNyBcXHUwMDAyXFx1MDAwMlxcdTA0N2ZcXHUwNDgwXFx1MDAwNz1cXHUwMDAyXFx1MDAwMlxcdTA0ODBcIixcclxuICAgIFwiXFx1MDQ4MVxcdTAwMDUuXFx1MDAxOFxcdTAwMDJcXHUwNDgxXFx1MDQ4MlxcdTAwMDc+XFx1MDAwMlxcdTAwMDJcXHUwNDgyXFx1MDQ4NVwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDA4ZUhcXHUwMDAyXFx1MDQ4M1xcdTA0ODRcXHUwMDA3XFx1MDAxYVxcdTAwMDJcXHUwMDAyXFx1MDQ4NFxcdTA0ODZcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwOGVIXFx1MDAwMlxcdTA0ODVcXHUwNDgzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ODVcXHUwNDg2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDg2XFx1MDQ4ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDg3XFx1MDQ4OFwiLFxyXG4gICAgXCJcXHUwMDA3LFxcdTAwMDJcXHUwMDAyXFx1MDQ4OFxcdTA0ODlcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDQ4OVxcdTA0OGFcXHUwMDA1XCIsXHJcbiAgICBcIi5cXHUwMDE4XFx1MDAwMlxcdTA0OGFcXHUwNDhiXFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTA0OGJcXHUwNDhjXFx1MDAwNVxcdTAwOGVcIixcclxuICAgIFwiSFxcdTAwMDJcXHUwNDhjXFx1MDQ4ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNDhkXFx1MDQ3ZVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDQ4ZFxcdTA0ODdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDQ4ZVxcdTAwOWJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0OGZcXHUwNDkwXFx1MDAwNzJcXHUwMDAyXFx1MDAwMlxcdTA0OTBcXHUwNDkxXFx1MDAwNz1cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNDkxXFx1MDQ5MlxcdTAwMDUuXFx1MDAxOFxcdTAwMDJcXHUwNDkyXFx1MDQ5M1xcdTAwMDc+XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDQ5M1xcdTA0OTRcXHUwMDA1XFx1MDA4ZUhcXHUwMDAyXFx1MDQ5NFxcdTA0YTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0OTVcXHUwNDk2XFx1MDAwN1xcdTAwMThcXHUwMDAyXFx1MDAwMlxcdTA0OTZcXHUwNDk3XFx1MDAwNVxcdTAwOGVIXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNDk3XFx1MDQ5OFxcdTAwMDcyXFx1MDAwMlxcdTAwMDJcXHUwNDk4XFx1MDQ5OVxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwNDk5XCIsXHJcbiAgICBcIlxcdTA0OWFcXHUwMDA1LlxcdTAwMThcXHUwMDAyXFx1MDQ5YVxcdTA0OWJcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDQ5YlxcdTA0OWNcIixcclxuICAgIFwiXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0OWNcXHUwNGE0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0OWRcXHUwNDllXCIsXHJcbiAgICBcIlxcdTAwMDdcXHUwMDFlXFx1MDAwMlxcdTAwMDJcXHUwNDllXFx1MDQ5ZlxcdTAwMDc9XFx1MDAwMlxcdTAwMDJcXHUwNDlmXFx1MDRhMFwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDA5ZVBcXHUwMDAyXFx1MDRhMFxcdTA0YTFcXHUwMDA3PlxcdTAwMDJcXHUwMDAyXFx1MDRhMVxcdTA0YTJcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwOGVIXFx1MDAwMlxcdTA0YTJcXHUwNGE0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YTNcXHUwNDhmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGEzXFx1MDQ5NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGEzXFx1MDQ5ZFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRhNFxcdTAwOWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRhNVxcdTA0YTZcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwYTBRXFx1MDAwMlxcdTA0YTZcXHUwNGE4XFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0YTdcXHUwNGE5XFx1MDAwNVxcdTAwYTJcIixcclxuICAgIFwiUlxcdTAwMDJcXHUwNGE4XFx1MDRhN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGE4XFx1MDRhOVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRhOVxcdTA0YWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRhYVxcdTA0YWNcXHUwMDA3WVwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YWJcXHUwNGFkXFx1MDAwNVxcdTAwYTJSXFx1MDAwMlxcdTA0YWNcXHUwNGFiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGFjXFx1MDRhZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGFkXFx1MDRiYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRhZVxcdTA0YjBcXHUwMDA1LlxcdTAwMThcXHUwMDAyXFx1MDRhZlxcdTA0YWVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YWZcXHUwNGIwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YjBcXHUwNGIxXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGIxXFx1MDRiM1xcdTAwMDdZXFx1MDAwMlxcdTAwMDJcXHUwNGIyXFx1MDRiNFxcdTAwMDVcXHUwMGEyXCIsXHJcbiAgICBcIlJcXHUwMDAyXFx1MDRiM1xcdTA0YjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRiM1xcdTA0YjRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YjRcXHUwNGI1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YjVcXHUwNGI3XFx1MDAwN1lcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGI2XFx1MDRiOFxcdTAwMDVcXHUwMGEyUlxcdTAwMDJcXHUwNGI3XFx1MDRiNlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRiN1xcdTA0YjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRiOFxcdTA0YmFcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YjlcXHUwNGE1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YjlcXHUwNGFmXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGJhXFx1MDA5ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGJiXFx1MDRiY1xcdTAwMDU0XCIsXHJcbiAgICBcIlxcdTAwMWJcXHUwMDAyXFx1MDRiY1xcdTA0YmRcXHUwMDA1OlxcdTAwMWVcXHUwMDAyXFx1MDRiZFxcdTA0YzBcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA0YmVcXHUwNGMwXFx1MDAwNTRcXHUwMDFiXFx1MDAwMlxcdTA0YmZcXHUwNGJiXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGJmXFx1MDRiZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGMwXFx1MDBhMVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDRjMVxcdTA0YzJcXGJSXFx1MDAwMVxcdTAwMDJcXHUwNGMyXFx1MDRjM1xcdTAwMDUqXFx1MDAxNlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDRjM1xcdTA0YzlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjNFxcdTA0YzVcXGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDRjNVxcdTA0YzZcXHUwMDA3WlxcdTAwMDJcXHUwMDAyXFx1MDRjNlxcdTA0YzhcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDRjN1wiLFxyXG4gICAgXCJcXHUwNGM0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YzhcXHUwNGNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0YzlcIixcclxuICAgIFwiXFx1MDRjN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGM5XFx1MDRjYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGNhXCIsXHJcbiAgICBcIlxcdTAwYTNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjYlxcdTA0YzlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRjY1wiLFxyXG4gICAgXCJcXHUwNGNkXFx1MDAwN1xcdTAwMWZcXHUwMDAyXFx1MDAwMlxcdTA0Y2RcXHUwNGNlXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlxcdTA0Y2VcIixcclxuICAgIFwiXFx1MDRkZFxcdTAwMDdZXFx1MDAwMlxcdTAwMDJcXHUwNGNmXFx1MDRkMFxcdTAwMDdcXHUwMDE2XFx1MDAwMlxcdTAwMDJcXHUwNGQwXCIsXHJcbiAgICBcIlxcdTA0ZGRcXHUwMDA3WVxcdTAwMDJcXHUwMDAyXFx1MDRkMVxcdTA0ZDJcXHUwMDA3XFx1MDAxMlxcdTAwMDJcXHUwMDAyXFx1MDRkMlwiLFxyXG4gICAgXCJcXHUwNGRkXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0ZDNcXHUwNGQ1XFx1MDAwNyZcXHUwMDAyXFx1MDAwMlxcdTA0ZDRcXHUwNGQ2XCIsXHJcbiAgICBcIlxcdTAwMDUuXFx1MDAxOFxcdTAwMDJcXHUwNGQ1XFx1MDRkNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGQ1XFx1MDRkNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkNlxcdTA0ZDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkN1xcdTA0ZGRcIixcclxuICAgIFwiXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0ZDhcXHUwNGQ5XFx1MDAwN1xcdTAwMWZcXHUwMDAyXFx1MDAwMlxcdTA0ZDlcXHUwNGRhXCIsXHJcbiAgICBcIlxcdTAwMDVcXHUwMDBlXFxiXFx1MDAwMlxcdTA0ZGFcXHUwNGRiXFx1MDAwN1lcXHUwMDAyXFx1MDAwMlxcdTA0ZGJcXHUwNGRkXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGRjXFx1MDRjY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGRjXFx1MDRjZlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkY1xcdTA0ZDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkY1xcdTA0ZDNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZGNcXHUwNGQ4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZGRcXHUwMGE1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGRlXFx1MDRlMFxcdTAwMDVcXHUwMGE4VVxcdTAwMDJcXHUwNGRmXFx1MDRkZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRkZlxcdTA0ZTBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRlMFxcdTA0ZTFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZTFcXHUwNGUyXFx1MDAwN1xcdTAwMDJcXHUwMDAyXFx1MDAwM1xcdTA0ZTJcXHUwMGE3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGUzXFx1MDRlNFxcYlVcXHUwMDAxXFx1MDAwMlxcdTA0ZTRcXHUwNGU1XFx1MDAwNVxcdTAwYWFcIixcclxuICAgIFwiVlxcdTAwMDJcXHUwNGU1XFx1MDRlYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGU2XFx1MDRlN1xcZlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGU3XFx1MDRlOVxcdTAwMDVcXHUwMGFhVlxcdTAwMDJcXHUwNGU4XFx1MDRlNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRlOVxcdTA0ZWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRlYVxcdTA0ZThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTA0ZWFcXHUwNGViXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZWJcXHUwMGE5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwNGVjXFx1MDRlYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGVkXFx1MDRmMVxcdTAwMDVcXHUwMGFjV1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDRlZVxcdTA0ZjFcXHUwMDA1MlxcdTAwMWFcXHUwMDAyXFx1MDRlZlxcdTA0ZjFcXHUwMDA3WVxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0ZjBcXHUwNGVkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjBcXHUwNGVlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNGYwXFx1MDRlZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGYxXFx1MDBhYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDRmMlxcdTA0ZjRcXHUwMDA1NFxcdTAwMWJcXHUwMDAyXFx1MDRmM1xcdTA0ZjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTA0ZjNcXHUwNGY0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjRcXHUwNGY1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwNGY1XFx1MDRmN1xcdTAwMDVgMVxcdTAwMDJcXHUwNGY2XFx1MDRmOFxcdTAwMDVcXHUwMGFlWFxcdTAwMDJcXHUwNGY3XFx1MDRmNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmN1xcdTA0ZjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDRmOFxcdTA0ZjlcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA0ZjlcXHUwNGZhXFx1MDAwNVxcdTAwOTJKXFx1MDAwMlxcdTA0ZmFcXHUwMGFkXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGZiXFx1MDRmY1xcYlhcXHUwMDAxXFx1MDAwMlxcdTA0ZmNcXHUwNGZkXFx1MDAwNVwiLFxyXG4gICAgXCIyXFx1MDAxYVxcdTAwMDJcXHUwNGZkXFx1MDUwMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwNGZlXFx1MDRmZlxcZlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNGZmXFx1MDUwMVxcdTAwMDUyXFx1MDAxYVxcdTAwMDJcXHUwNTAwXFx1MDRmZVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDUwMVxcdTA1MDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDUwMlxcdTA1MDBcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTA1MDJcXHUwNTAzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTA1MDNcXHUwMGFmXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwNTA0XFx1MDUwMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhlXFx1MDBiNVxcdTAwYmRcXHUwMGQxXCIsXHJcbiAgICBcIlxcdTAwZTJcXHUwMGVjXFx1MDExMFxcdTAxMWFcXHUwMTI3XFx1MDEyOVxcdTAxMzRcXHUwMTRkXFx1MDE1ZVxcdTAxNmNcXHUwMTZlXFx1MDE3YVwiLFxyXG4gICAgXCJcXHUwMTdjXFx1MDE4OFxcdTAxOGFcXHUwMTljXFx1MDE5ZVxcdTAxYWFcXHUwMWFjXFx1MDFiN1xcdTAxYzJcXHUwMWNkXFx1MDFkOFxcdTAxZTNcIixcclxuICAgIFwiXFx1MDFlY1xcdTAxZjRcXHUwMjAwXFx1MDIwZFxcdTAyMTJcXHUwMjE3XFx1MDIxZVxcdTAyMjhcXHUwMjMwXFx1MDI0MlxcdTAyNDZcXHUwMjRmXCIsXHJcbiAgICBcIlxcdTAyNWFcXHUwMjVmXFx1MDI2NFxcdTAyNjhcXHUwMjZjXFx1MDI2ZVxcdTAyNzhcXHUwMjdkXFx1MDI4MVxcdTAyODVcXHUwMjhkXFx1MDI5NlwiLFxyXG4gICAgXCJcXHUwMmEwXFx1MDJhOFxcdTAyYjlcXHUwMmM1XFx1MDJjOFxcdTAyY2VcXHUwMmRhXFx1MDJkZlxcdTAyZTJcXHUwMmU5XFx1MDJmOFxcdTAzMDRcIixcclxuICAgIFwiXFx1MDMwN1xcdTAzMDlcXHUwMzExXFx1MDMxNVxcdTAzMjNcXHUwMzI3XFx1MDMyY1xcdTAzMmZcXHUwMzMyXFx1MDMzOVxcdTAzM2JcXHUwMzQwXCIsXHJcbiAgICBcIlxcdTAzNDRcXHUwMzQ5XFx1MDM0ZFxcdTAzNTBcXHUwMzU5XFx1MDM2MVxcdTAzNmJcXHUwMzczXFx1MDM3NVxcdTAzN2ZcXHUwMzg0XFx1MDM4OFwiLFxyXG4gICAgXCJcXHUwMzhlXFx1MDM5MVxcdTAzOWFcXHUwMzlmXFx1MDNhMlxcdTAzYThcXHUwM2I4XFx1MDNiZVxcdTAzYzFcXHUwM2M2XFx1MDNjOVxcdTAzZDBcIixcclxuICAgIFwiXFx1MDNlM1xcdTAzZTlcXHUwM2VjXFx1MDNlZVxcdTAzZmRcXHUwNDAxXFx1MDQwOFxcdTA0MGRcXHUwNDFhXFx1MDQyM1xcdTA0MmNcXHUwNDNmXCIsXHJcbiAgICBcIlxcdTA0NDJcXHUwNDRhXFx1MDQ0ZFxcdTA0NTFcXHUwNDU2XFx1MDQ2M1xcdTA0NjdcXHUwNDcyXFx1MDQ3N1xcdTA0N2FcXHUwNDg1XFx1MDQ4ZFwiLFxyXG4gICAgXCJcXHUwNGEzXFx1MDRhOFxcdTA0YWNcXHUwNGFmXFx1MDRiM1xcdTA0YjdcXHUwNGI5XFx1MDRiZlxcdTA0YzlcXHUwNGQ1XFx1MDRkY1xcdTA0ZGZcIixcclxuICAgIFwiXFx1MDRlYVxcdTA0ZjBcXHUwNGYzXFx1MDRmN1xcdTA1MDJcIl0uam9pbihcIlwiKTtcclxuXHJcblxyXG52YXIgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XHJcblxyXG52YXIgZGVjaXNpb25zVG9ERkEgPSBhdG4uZGVjaXNpb25Ub1N0YXRlLm1hcCggZnVuY3Rpb24oZHMsIGluZGV4KSB7IHJldHVybiBuZXcgYW50bHI0LmRmYS5ERkEoZHMsIGluZGV4KTsgfSk7XHJcblxyXG52YXIgc2hhcmVkQ29udGV4dENhY2hlID0gbmV3IGFudGxyNC5QcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XHJcblxyXG52YXIgbGl0ZXJhbE5hbWVzID0gWyBudWxsLCBcIidfX2V4dGVuc2lvbl9fJ1wiLCBcIidfX2J1aWx0aW5fdmFfYXJnJ1wiLCBcIidfX2J1aWx0aW5fb2Zmc2V0b2YnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidfX20xMjgnXCIsIFwiJ19fbTEyOGQnXCIsIFwiJ19fbTEyOGknXCIsIFwiJ19fdHlwZW9mX18nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidfX2lubGluZV9fJ1wiLCBcIidfX3N0ZGNhbGwnXCIsIFwiJ19fZGVjbHNwZWMnXCIsIFwiJ19fYXNtJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInX19hdHRyaWJ1dGVfXydcIiwgXCInX19hc21fXydcIiwgXCInX192b2xhdGlsZV9fJ1wiLCBcIidhdXRvJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInYnJlYWsnXCIsIFwiJ2Nhc2UnXCIsIFwiJ2NoYXInXCIsIFwiJ2NvbnN0J1wiLCBcIidjb250aW51ZSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJ2RlZmF1bHQnXCIsIFwiJ2RvJ1wiLCBcIidkb3VibGUnXCIsIFwiJ2Vsc2UnXCIsIFwiJ2VudW0nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidleHRlcm4nXCIsIFwiJ2Zsb2F0J1wiLCBcIidmb3InXCIsIFwiJ2dvdG8nXCIsIFwiJ2lmJ1wiLCBcIidpbmxpbmUnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidpbnQnXCIsIFwiJ2xvbmcnXCIsIFwiJ3JlZ2lzdGVyJ1wiLCBcIidyZXN0cmljdCdcIiwgXCIncmV0dXJuJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInc2hvcnQnXCIsIFwiJ3NpZ25lZCdcIiwgXCInc2l6ZW9mJ1wiLCBcIidzdGF0aWMnXCIsIFwiJ3N0cnVjdCdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJ3N3aXRjaCdcIiwgXCIndHlwZWRlZidcIiwgXCIndW5pb24nXCIsIFwiJ3Vuc2lnbmVkJ1wiLCBcIid2b2lkJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCIndm9sYXRpbGUnXCIsIFwiJ3doaWxlJ1wiLCBcIidfQWxpZ25hcydcIiwgXCInX0FsaWdub2YnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidfQXRvbWljJ1wiLCBcIidfQm9vbCdcIiwgXCInX0NvbXBsZXgnXCIsIFwiJ19HZW5lcmljJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInX0ltYWdpbmFyeSdcIiwgXCInX05vcmV0dXJuJ1wiLCBcIidfU3RhdGljX2Fzc2VydCdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJ19UaHJlYWRfbG9jYWwnXCIsIFwiJygnXCIsIFwiJyknXCIsIFwiJ1snXCIsIFwiJ10nXCIsIFwiJ3snXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIid9J1wiLCBcIic8J1wiLCBcIic8PSdcIiwgXCInPidcIiwgXCInPj0nXCIsIFwiJzw8J1wiLCBcIic+PidcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJysnXCIsIFwiJysrJ1wiLCBcIictJ1wiLCBcIictLSdcIiwgXCInKidcIiwgXCInLydcIiwgXCInJSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJyYnXCIsIFwiJ3wnXCIsIFwiJyYmJ1wiLCBcIid8fCdcIiwgXCInXidcIiwgXCInISdcIiwgXCInfidcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJz8nXCIsIFwiJzonXCIsIFwiJzsnXCIsIFwiJywnXCIsIFwiJz0nXCIsIFwiJyo9J1wiLCBcIicvPSdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiJyU9J1wiLCBcIicrPSdcIiwgXCInLT0nXCIsIFwiJzw8PSdcIiwgXCInPj49J1wiLCBcIicmPSdcIiwgXCInXj0nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIid8PSdcIiwgXCInPT0nXCIsIFwiJyE9J1wiLCBcIictPidcIiwgXCInLidcIiwgXCInLi4uJ1wiIF07XHJcblxyXG52YXIgc3ltYm9saWNOYW1lcyA9IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBcIkF1dG9cIiwgXCJCcmVha1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2FzZVwiLCBcIkNoYXJcIiwgXCJDb25zdFwiLCBcIkNvbnRpbnVlXCIsIFwiRGVmYXVsdFwiLCBcIkRvXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJEb3VibGVcIiwgXCJFbHNlXCIsIFwiRW51bVwiLCBcIkV4dGVyblwiLCBcIkZsb2F0XCIsIFwiRm9yXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJHb3RvXCIsIFwiSWZcIiwgXCJJbmxpbmVcIiwgXCJJbnRcIiwgXCJMb25nXCIsIFwiUmVnaXN0ZXJcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlJlc3RyaWN0XCIsIFwiUmV0dXJuXCIsIFwiU2hvcnRcIiwgXCJTaWduZWRcIiwgXCJTaXplb2ZcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXRpY1wiLCBcIlN0cnVjdFwiLCBcIlN3aXRjaFwiLCBcIlR5cGVkZWZcIiwgXCJVbmlvblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5zaWduZWRcIiwgXCJWb2lkXCIsIFwiVm9sYXRpbGVcIiwgXCJXaGlsZVwiLCBcIkFsaWduYXNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkFsaWdub2ZcIiwgXCJBdG9taWNcIiwgXCJCb29sXCIsIFwiQ29tcGxleFwiLCBcIkdlbmVyaWNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkltYWdpbmFyeVwiLCBcIk5vcmV0dXJuXCIsIFwiU3RhdGljQXNzZXJ0XCIsIFwiVGhyZWFkTG9jYWxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkxlZnRQYXJlblwiLCBcIlJpZ2h0UGFyZW5cIiwgXCJMZWZ0QnJhY2tldFwiLCBcIlJpZ2h0QnJhY2tldFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiTGVmdEJyYWNlXCIsIFwiUmlnaHRCcmFjZVwiLCBcIkxlc3NcIiwgXCJMZXNzRXF1YWxcIiwgXCJHcmVhdGVyXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJHcmVhdGVyRXF1YWxcIiwgXCJMZWZ0U2hpZnRcIiwgXCJSaWdodFNoaWZ0XCIsIFwiUGx1c1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiUGx1c1BsdXNcIiwgXCJNaW51c1wiLCBcIk1pbnVzTWludXNcIiwgXCJTdGFyXCIsIFwiRGl2XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJNb2RcIiwgXCJBbmRcIiwgXCJPclwiLCBcIkFuZEFuZFwiLCBcIk9yT3JcIiwgXCJDYXJldFwiLCBcIk5vdFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiVGlsZGVcIiwgXCJRdWVzdGlvblwiLCBcIkNvbG9uXCIsIFwiU2VtaVwiLCBcIkNvbW1hXCIsIFwiQXNzaWduXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGFyQXNzaWduXCIsIFwiRGl2QXNzaWduXCIsIFwiTW9kQXNzaWduXCIsIFwiUGx1c0Fzc2lnblwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiTWludXNBc3NpZ25cIiwgXCJMZWZ0U2hpZnRBc3NpZ25cIiwgXCJSaWdodFNoaWZ0QXNzaWduXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbmRBc3NpZ25cIiwgXCJYb3JBc3NpZ25cIiwgXCJPckFzc2lnblwiLCBcIkVxdWFsXCIsIFwiTm90RXF1YWxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkFycm93XCIsIFwiRG90XCIsIFwiRWxsaXBzaXNcIiwgXCJJZGVudGlmaWVyXCIsIFwiQ29uc3RhbnRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkRpZ2l0U2VxdWVuY2VcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiQ29tcGxleERlZmluZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNtQmxvY2tcIiwgXCJMaW5lQWZ0ZXJQcmVwcm9jZXNzaW5nXCIsIFwiTGluZURpcmVjdGl2ZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiUHJhZ21hRGlyZWN0aXZlXCIsIFwiV2hpdGVzcGFjZVwiLCBcIk5ld2xpbmVcIiwgXCJCbG9ja0NvbW1lbnRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkxpbmVDb21tZW50XCIgXTtcclxuXHJcbnZhciBydWxlTmFtZXMgPSAgWyBcInByaW1hcnlFeHByZXNzaW9uXCIsIFwiZ2VuZXJpY1NlbGVjdGlvblwiLCBcImdlbmVyaWNBc3NvY0xpc3RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcImdlbmVyaWNBc3NvY2lhdGlvblwiLCBcInBvc3RmaXhFeHByZXNzaW9uXCIsIFwiYXJndW1lbnRFeHByZXNzaW9uTGlzdFwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwidW5hcnlFeHByZXNzaW9uXCIsIFwidW5hcnlPcGVyYXRvclwiLCBcImNhc3RFeHByZXNzaW9uXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJtdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25cIiwgXCJhZGRpdGl2ZUV4cHJlc3Npb25cIiwgXCJzaGlmdEV4cHJlc3Npb25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcInJlbGF0aW9uYWxFeHByZXNzaW9uXCIsIFwiZXF1YWxpdHlFeHByZXNzaW9uXCIsIFwiYW5kRXhwcmVzc2lvblwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaXZlT3JFeHByZXNzaW9uXCIsIFwiaW5jbHVzaXZlT3JFeHByZXNzaW9uXCIsIFwibG9naWNhbEFuZEV4cHJlc3Npb25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcImxvZ2ljYWxPckV4cHJlc3Npb25cIiwgXCJjb25kaXRpb25hbEV4cHJlc3Npb25cIiwgXCJhc3NpZ25tZW50RXhwcmVzc2lvblwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiYXNzaWdubWVudE9wZXJhdG9yXCIsIFwiZXhwcmVzc2lvblwiLCBcImNvbnN0YW50RXhwcmVzc2lvblwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZGVjbGFyYXRpb25cIiwgXCJkZWNsYXJhdGlvblNwZWNpZmllcnNcIiwgXCJkZWNsYXJhdGlvblNwZWNpZmllcnMyXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJkZWNsYXJhdGlvblNwZWNpZmllclwiLCBcImluaXREZWNsYXJhdG9yTGlzdFwiLCBcImluaXREZWNsYXJhdG9yXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJzdG9yYWdlQ2xhc3NTcGVjaWZpZXJcIiwgXCJ0eXBlU3BlY2lmaWVyXCIsIFwic3RydWN0T3JVbmlvblNwZWNpZmllclwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwic3RydWN0T3JVbmlvblwiLCBcInN0cnVjdERlY2xhcmF0aW9uTGlzdFwiLCBcInN0cnVjdERlY2xhcmF0aW9uXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJzcGVjaWZpZXJRdWFsaWZpZXJMaXN0XCIsIFwic3RydWN0RGVjbGFyYXRvckxpc3RcIiwgXCJzdHJ1Y3REZWNsYXJhdG9yXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJlbnVtU3BlY2lmaWVyXCIsIFwiZW51bWVyYXRvckxpc3RcIiwgXCJlbnVtZXJhdG9yXCIsIFwiZW51bWVyYXRpb25Db25zdGFudFwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiYXRvbWljVHlwZVNwZWNpZmllclwiLCBcInR5cGVRdWFsaWZpZXJcIiwgXCJmdW5jdGlvblNwZWNpZmllclwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiYWxpZ25tZW50U3BlY2lmaWVyXCIsIFwiZGVjbGFyYXRvclwiLCBcImRpcmVjdERlY2xhcmF0b3JcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcImdjY0RlY2xhcmF0b3JFeHRlbnNpb25cIiwgXCJnY2NBdHRyaWJ1dGVTcGVjaWZpZXJcIiwgXCJnY2NBdHRyaWJ1dGVMaXN0XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJnY2NBdHRyaWJ1dGVcIiwgXCJuZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrXCIsIFwicG9pbnRlclwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwidHlwZVF1YWxpZmllckxpc3RcIiwgXCJwYXJhbWV0ZXJUeXBlTGlzdFwiLCBcInBhcmFtZXRlckxpc3RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcInBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiaWRlbnRpZmllckxpc3RcIiwgXCJ0eXBlTmFtZVwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiYWJzdHJhY3REZWNsYXJhdG9yXCIsIFwiZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yXCIsIFwidHlwZWRlZk5hbWVcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcImluaXRpYWxpemVyXCIsIFwiaW5pdGlhbGl6ZXJMaXN0XCIsIFwiZGVzaWduYXRpb25cIiwgXCJkZXNpZ25hdG9yTGlzdFwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZGVzaWduYXRvclwiLCBcInN0YXRpY0Fzc2VydERlY2xhcmF0aW9uXCIsIFwic3RhdGVtZW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJsYWJlbGVkU3RhdGVtZW50XCIsIFwiY29tcG91bmRTdGF0ZW1lbnRcIiwgXCJibG9ja0l0ZW1MaXN0XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJibG9ja0l0ZW1cIiwgXCJleHByZXNzaW9uU3RhdGVtZW50XCIsIFwic2VsZWN0aW9uU3RhdGVtZW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJpdGVyYXRpb25TdGF0ZW1lbnRcIiwgXCJmb3JDb25kaXRpb25cIiwgXCJmb3JEZWNsYXJhdGlvblwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZm9yRXhwcmVzc2lvblwiLCBcImp1bXBTdGF0ZW1lbnRcIiwgXCJjb21waWxhdGlvblVuaXRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uVW5pdFwiLCBcImV4dGVybmFsRGVjbGFyYXRpb25cIiwgXCJmdW5jdGlvbkRlZmluaXRpb25cIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcImRlY2xhcmF0aW9uTGlzdFwiIF07XHJcblxyXG5mdW5jdGlvbiBDUGFyc2VyIChpbnB1dCkge1xyXG5cdGFudGxyNC5QYXJzZXIuY2FsbCh0aGlzLCBpbnB1dCk7XHJcbiAgICB0aGlzLl9pbnRlcnAgPSBuZXcgYW50bHI0LmF0bi5QYXJzZXJBVE5TaW11bGF0b3IodGhpcywgYXRuLCBkZWNpc2lvbnNUb0RGQSwgc2hhcmVkQ29udGV4dENhY2hlKTtcclxuICAgIHRoaXMucnVsZU5hbWVzID0gcnVsZU5hbWVzO1xyXG4gICAgdGhpcy5saXRlcmFsTmFtZXMgPSBsaXRlcmFsTmFtZXM7XHJcbiAgICB0aGlzLnN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyLnByb3RvdHlwZSk7XHJcbkNQYXJzZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BhcnNlcjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDUGFyc2VyLnByb3RvdHlwZSwgXCJhdG5cIiwge1xyXG5cdGdldCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGF0bjtcclxuXHR9XHJcbn0pO1xyXG5cclxuQ1BhcnNlci5FT0YgPSBhbnRscjQuVG9rZW4uRU9GO1xyXG5DUGFyc2VyLlRfXzAgPSAxO1xyXG5DUGFyc2VyLlRfXzEgPSAyO1xyXG5DUGFyc2VyLlRfXzIgPSAzO1xyXG5DUGFyc2VyLlRfXzMgPSA0O1xyXG5DUGFyc2VyLlRfXzQgPSA1O1xyXG5DUGFyc2VyLlRfXzUgPSA2O1xyXG5DUGFyc2VyLlRfXzYgPSA3O1xyXG5DUGFyc2VyLlRfXzcgPSA4O1xyXG5DUGFyc2VyLlRfXzggPSA5O1xyXG5DUGFyc2VyLlRfXzkgPSAxMDtcclxuQ1BhcnNlci5UX18xMCA9IDExO1xyXG5DUGFyc2VyLlRfXzExID0gMTI7XHJcbkNQYXJzZXIuVF9fMTIgPSAxMztcclxuQ1BhcnNlci5UX18xMyA9IDE0O1xyXG5DUGFyc2VyLkF1dG8gPSAxNTtcclxuQ1BhcnNlci5CcmVhayA9IDE2O1xyXG5DUGFyc2VyLkNhc2UgPSAxNztcclxuQ1BhcnNlci5DaGFyID0gMTg7XHJcbkNQYXJzZXIuQ29uc3QgPSAxOTtcclxuQ1BhcnNlci5Db250aW51ZSA9IDIwO1xyXG5DUGFyc2VyLkRlZmF1bHQgPSAyMTtcclxuQ1BhcnNlci5EbyA9IDIyO1xyXG5DUGFyc2VyLkRvdWJsZSA9IDIzO1xyXG5DUGFyc2VyLkVsc2UgPSAyNDtcclxuQ1BhcnNlci5FbnVtID0gMjU7XHJcbkNQYXJzZXIuRXh0ZXJuID0gMjY7XHJcbkNQYXJzZXIuRmxvYXQgPSAyNztcclxuQ1BhcnNlci5Gb3IgPSAyODtcclxuQ1BhcnNlci5Hb3RvID0gMjk7XHJcbkNQYXJzZXIuSWYgPSAzMDtcclxuQ1BhcnNlci5JbmxpbmUgPSAzMTtcclxuQ1BhcnNlci5JbnQgPSAzMjtcclxuQ1BhcnNlci5Mb25nID0gMzM7XHJcbkNQYXJzZXIuUmVnaXN0ZXIgPSAzNDtcclxuQ1BhcnNlci5SZXN0cmljdCA9IDM1O1xyXG5DUGFyc2VyLlJldHVybiA9IDM2O1xyXG5DUGFyc2VyLlNob3J0ID0gMzc7XHJcbkNQYXJzZXIuU2lnbmVkID0gMzg7XHJcbkNQYXJzZXIuU2l6ZW9mID0gMzk7XHJcbkNQYXJzZXIuU3RhdGljID0gNDA7XHJcbkNQYXJzZXIuU3RydWN0ID0gNDE7XHJcbkNQYXJzZXIuU3dpdGNoID0gNDI7XHJcbkNQYXJzZXIuVHlwZWRlZiA9IDQzO1xyXG5DUGFyc2VyLlVuaW9uID0gNDQ7XHJcbkNQYXJzZXIuVW5zaWduZWQgPSA0NTtcclxuQ1BhcnNlci5Wb2lkID0gNDY7XHJcbkNQYXJzZXIuVm9sYXRpbGUgPSA0NztcclxuQ1BhcnNlci5XaGlsZSA9IDQ4O1xyXG5DUGFyc2VyLkFsaWduYXMgPSA0OTtcclxuQ1BhcnNlci5BbGlnbm9mID0gNTA7XHJcbkNQYXJzZXIuQXRvbWljID0gNTE7XHJcbkNQYXJzZXIuQm9vbCA9IDUyO1xyXG5DUGFyc2VyLkNvbXBsZXggPSA1MztcclxuQ1BhcnNlci5HZW5lcmljID0gNTQ7XHJcbkNQYXJzZXIuSW1hZ2luYXJ5ID0gNTU7XHJcbkNQYXJzZXIuTm9yZXR1cm4gPSA1NjtcclxuQ1BhcnNlci5TdGF0aWNBc3NlcnQgPSA1NztcclxuQ1BhcnNlci5UaHJlYWRMb2NhbCA9IDU4O1xyXG5DUGFyc2VyLkxlZnRQYXJlbiA9IDU5O1xyXG5DUGFyc2VyLlJpZ2h0UGFyZW4gPSA2MDtcclxuQ1BhcnNlci5MZWZ0QnJhY2tldCA9IDYxO1xyXG5DUGFyc2VyLlJpZ2h0QnJhY2tldCA9IDYyO1xyXG5DUGFyc2VyLkxlZnRCcmFjZSA9IDYzO1xyXG5DUGFyc2VyLlJpZ2h0QnJhY2UgPSA2NDtcclxuQ1BhcnNlci5MZXNzID0gNjU7XHJcbkNQYXJzZXIuTGVzc0VxdWFsID0gNjY7XHJcbkNQYXJzZXIuR3JlYXRlciA9IDY3O1xyXG5DUGFyc2VyLkdyZWF0ZXJFcXVhbCA9IDY4O1xyXG5DUGFyc2VyLkxlZnRTaGlmdCA9IDY5O1xyXG5DUGFyc2VyLlJpZ2h0U2hpZnQgPSA3MDtcclxuQ1BhcnNlci5QbHVzID0gNzE7XHJcbkNQYXJzZXIuUGx1c1BsdXMgPSA3MjtcclxuQ1BhcnNlci5NaW51cyA9IDczO1xyXG5DUGFyc2VyLk1pbnVzTWludXMgPSA3NDtcclxuQ1BhcnNlci5TdGFyID0gNzU7XHJcbkNQYXJzZXIuRGl2ID0gNzY7XHJcbkNQYXJzZXIuTW9kID0gNzc7XHJcbkNQYXJzZXIuQW5kID0gNzg7XHJcbkNQYXJzZXIuT3IgPSA3OTtcclxuQ1BhcnNlci5BbmRBbmQgPSA4MDtcclxuQ1BhcnNlci5Pck9yID0gODE7XHJcbkNQYXJzZXIuQ2FyZXQgPSA4MjtcclxuQ1BhcnNlci5Ob3QgPSA4MztcclxuQ1BhcnNlci5UaWxkZSA9IDg0O1xyXG5DUGFyc2VyLlF1ZXN0aW9uID0gODU7XHJcbkNQYXJzZXIuQ29sb24gPSA4NjtcclxuQ1BhcnNlci5TZW1pID0gODc7XHJcbkNQYXJzZXIuQ29tbWEgPSA4ODtcclxuQ1BhcnNlci5Bc3NpZ24gPSA4OTtcclxuQ1BhcnNlci5TdGFyQXNzaWduID0gOTA7XHJcbkNQYXJzZXIuRGl2QXNzaWduID0gOTE7XHJcbkNQYXJzZXIuTW9kQXNzaWduID0gOTI7XHJcbkNQYXJzZXIuUGx1c0Fzc2lnbiA9IDkzO1xyXG5DUGFyc2VyLk1pbnVzQXNzaWduID0gOTQ7XHJcbkNQYXJzZXIuTGVmdFNoaWZ0QXNzaWduID0gOTU7XHJcbkNQYXJzZXIuUmlnaHRTaGlmdEFzc2lnbiA9IDk2O1xyXG5DUGFyc2VyLkFuZEFzc2lnbiA9IDk3O1xyXG5DUGFyc2VyLlhvckFzc2lnbiA9IDk4O1xyXG5DUGFyc2VyLk9yQXNzaWduID0gOTk7XHJcbkNQYXJzZXIuRXF1YWwgPSAxMDA7XHJcbkNQYXJzZXIuTm90RXF1YWwgPSAxMDE7XHJcbkNQYXJzZXIuQXJyb3cgPSAxMDI7XHJcbkNQYXJzZXIuRG90ID0gMTAzO1xyXG5DUGFyc2VyLkVsbGlwc2lzID0gMTA0O1xyXG5DUGFyc2VyLklkZW50aWZpZXIgPSAxMDU7XHJcbkNQYXJzZXIuQ29uc3RhbnQgPSAxMDY7XHJcbkNQYXJzZXIuRGlnaXRTZXF1ZW5jZSA9IDEwNztcclxuQ1BhcnNlci5TdHJpbmdMaXRlcmFsID0gMTA4O1xyXG5DUGFyc2VyLkNvbXBsZXhEZWZpbmUgPSAxMDk7XHJcbkNQYXJzZXIuQXNtQmxvY2sgPSAxMTA7XHJcbkNQYXJzZXIuTGluZUFmdGVyUHJlcHJvY2Vzc2luZyA9IDExMTtcclxuQ1BhcnNlci5MaW5lRGlyZWN0aXZlID0gMTEyO1xyXG5DUGFyc2VyLlByYWdtYURpcmVjdGl2ZSA9IDExMztcclxuQ1BhcnNlci5XaGl0ZXNwYWNlID0gMTE0O1xyXG5DUGFyc2VyLk5ld2xpbmUgPSAxMTU7XHJcbkNQYXJzZXIuQmxvY2tDb21tZW50ID0gMTE2O1xyXG5DUGFyc2VyLkxpbmVDb21tZW50ID0gMTE3O1xyXG5cclxuQ1BhcnNlci5SVUxFX3ByaW1hcnlFeHByZXNzaW9uID0gMDtcclxuQ1BhcnNlci5SVUxFX2dlbmVyaWNTZWxlY3Rpb24gPSAxO1xyXG5DUGFyc2VyLlJVTEVfZ2VuZXJpY0Fzc29jTGlzdCA9IDI7XHJcbkNQYXJzZXIuUlVMRV9nZW5lcmljQXNzb2NpYXRpb24gPSAzO1xyXG5DUGFyc2VyLlJVTEVfcG9zdGZpeEV4cHJlc3Npb24gPSA0O1xyXG5DUGFyc2VyLlJVTEVfYXJndW1lbnRFeHByZXNzaW9uTGlzdCA9IDU7XHJcbkNQYXJzZXIuUlVMRV91bmFyeUV4cHJlc3Npb24gPSA2O1xyXG5DUGFyc2VyLlJVTEVfdW5hcnlPcGVyYXRvciA9IDc7XHJcbkNQYXJzZXIuUlVMRV9jYXN0RXhwcmVzc2lvbiA9IDg7XHJcbkNQYXJzZXIuUlVMRV9tdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gPSA5O1xyXG5DUGFyc2VyLlJVTEVfYWRkaXRpdmVFeHByZXNzaW9uID0gMTA7XHJcbkNQYXJzZXIuUlVMRV9zaGlmdEV4cHJlc3Npb24gPSAxMTtcclxuQ1BhcnNlci5SVUxFX3JlbGF0aW9uYWxFeHByZXNzaW9uID0gMTI7XHJcbkNQYXJzZXIuUlVMRV9lcXVhbGl0eUV4cHJlc3Npb24gPSAxMztcclxuQ1BhcnNlci5SVUxFX2FuZEV4cHJlc3Npb24gPSAxNDtcclxuQ1BhcnNlci5SVUxFX2V4Y2x1c2l2ZU9yRXhwcmVzc2lvbiA9IDE1O1xyXG5DUGFyc2VyLlJVTEVfaW5jbHVzaXZlT3JFeHByZXNzaW9uID0gMTY7XHJcbkNQYXJzZXIuUlVMRV9sb2dpY2FsQW5kRXhwcmVzc2lvbiA9IDE3O1xyXG5DUGFyc2VyLlJVTEVfbG9naWNhbE9yRXhwcmVzc2lvbiA9IDE4O1xyXG5DUGFyc2VyLlJVTEVfY29uZGl0aW9uYWxFeHByZXNzaW9uID0gMTk7XHJcbkNQYXJzZXIuUlVMRV9hc3NpZ25tZW50RXhwcmVzc2lvbiA9IDIwO1xyXG5DUGFyc2VyLlJVTEVfYXNzaWdubWVudE9wZXJhdG9yID0gMjE7XHJcbkNQYXJzZXIuUlVMRV9leHByZXNzaW9uID0gMjI7XHJcbkNQYXJzZXIuUlVMRV9jb25zdGFudEV4cHJlc3Npb24gPSAyMztcclxuQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uID0gMjQ7XHJcbkNQYXJzZXIuUlVMRV9kZWNsYXJhdGlvblNwZWNpZmllcnMgPSAyNTtcclxuQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uU3BlY2lmaWVyczIgPSAyNjtcclxuQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uU3BlY2lmaWVyID0gMjc7XHJcbkNQYXJzZXIuUlVMRV9pbml0RGVjbGFyYXRvckxpc3QgPSAyODtcclxuQ1BhcnNlci5SVUxFX2luaXREZWNsYXJhdG9yID0gMjk7XHJcbkNQYXJzZXIuUlVMRV9zdG9yYWdlQ2xhc3NTcGVjaWZpZXIgPSAzMDtcclxuQ1BhcnNlci5SVUxFX3R5cGVTcGVjaWZpZXIgPSAzMTtcclxuQ1BhcnNlci5SVUxFX3N0cnVjdE9yVW5pb25TcGVjaWZpZXIgPSAzMjtcclxuQ1BhcnNlci5SVUxFX3N0cnVjdE9yVW5pb24gPSAzMztcclxuQ1BhcnNlci5SVUxFX3N0cnVjdERlY2xhcmF0aW9uTGlzdCA9IDM0O1xyXG5DUGFyc2VyLlJVTEVfc3RydWN0RGVjbGFyYXRpb24gPSAzNTtcclxuQ1BhcnNlci5SVUxFX3NwZWNpZmllclF1YWxpZmllckxpc3QgPSAzNjtcclxuQ1BhcnNlci5SVUxFX3N0cnVjdERlY2xhcmF0b3JMaXN0ID0gMzc7XHJcbkNQYXJzZXIuUlVMRV9zdHJ1Y3REZWNsYXJhdG9yID0gMzg7XHJcbkNQYXJzZXIuUlVMRV9lbnVtU3BlY2lmaWVyID0gMzk7XHJcbkNQYXJzZXIuUlVMRV9lbnVtZXJhdG9yTGlzdCA9IDQwO1xyXG5DUGFyc2VyLlJVTEVfZW51bWVyYXRvciA9IDQxO1xyXG5DUGFyc2VyLlJVTEVfZW51bWVyYXRpb25Db25zdGFudCA9IDQyO1xyXG5DUGFyc2VyLlJVTEVfYXRvbWljVHlwZVNwZWNpZmllciA9IDQzO1xyXG5DUGFyc2VyLlJVTEVfdHlwZVF1YWxpZmllciA9IDQ0O1xyXG5DUGFyc2VyLlJVTEVfZnVuY3Rpb25TcGVjaWZpZXIgPSA0NTtcclxuQ1BhcnNlci5SVUxFX2FsaWdubWVudFNwZWNpZmllciA9IDQ2O1xyXG5DUGFyc2VyLlJVTEVfZGVjbGFyYXRvciA9IDQ3O1xyXG5DUGFyc2VyLlJVTEVfZGlyZWN0RGVjbGFyYXRvciA9IDQ4O1xyXG5DUGFyc2VyLlJVTEVfZ2NjRGVjbGFyYXRvckV4dGVuc2lvbiA9IDQ5O1xyXG5DUGFyc2VyLlJVTEVfZ2NjQXR0cmlidXRlU3BlY2lmaWVyID0gNTA7XHJcbkNQYXJzZXIuUlVMRV9nY2NBdHRyaWJ1dGVMaXN0ID0gNTE7XHJcbkNQYXJzZXIuUlVMRV9nY2NBdHRyaWJ1dGUgPSA1MjtcclxuQ1BhcnNlci5SVUxFX25lc3RlZFBhcmVudGhlc2VzQmxvY2sgPSA1MztcclxuQ1BhcnNlci5SVUxFX3BvaW50ZXIgPSA1NDtcclxuQ1BhcnNlci5SVUxFX3R5cGVRdWFsaWZpZXJMaXN0ID0gNTU7XHJcbkNQYXJzZXIuUlVMRV9wYXJhbWV0ZXJUeXBlTGlzdCA9IDU2O1xyXG5DUGFyc2VyLlJVTEVfcGFyYW1ldGVyTGlzdCA9IDU3O1xyXG5DUGFyc2VyLlJVTEVfcGFyYW1ldGVyRGVjbGFyYXRpb24gPSA1ODtcclxuQ1BhcnNlci5SVUxFX2lkZW50aWZpZXJMaXN0ID0gNTk7XHJcbkNQYXJzZXIuUlVMRV90eXBlTmFtZSA9IDYwO1xyXG5DUGFyc2VyLlJVTEVfYWJzdHJhY3REZWNsYXJhdG9yID0gNjE7XHJcbkNQYXJzZXIuUlVMRV9kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IgPSA2MjtcclxuQ1BhcnNlci5SVUxFX3R5cGVkZWZOYW1lID0gNjM7XHJcbkNQYXJzZXIuUlVMRV9pbml0aWFsaXplciA9IDY0O1xyXG5DUGFyc2VyLlJVTEVfaW5pdGlhbGl6ZXJMaXN0ID0gNjU7XHJcbkNQYXJzZXIuUlVMRV9kZXNpZ25hdGlvbiA9IDY2O1xyXG5DUGFyc2VyLlJVTEVfZGVzaWduYXRvckxpc3QgPSA2NztcclxuQ1BhcnNlci5SVUxFX2Rlc2lnbmF0b3IgPSA2ODtcclxuQ1BhcnNlci5SVUxFX3N0YXRpY0Fzc2VydERlY2xhcmF0aW9uID0gNjk7XHJcbkNQYXJzZXIuUlVMRV9zdGF0ZW1lbnQgPSA3MDtcclxuQ1BhcnNlci5SVUxFX2xhYmVsZWRTdGF0ZW1lbnQgPSA3MTtcclxuQ1BhcnNlci5SVUxFX2NvbXBvdW5kU3RhdGVtZW50ID0gNzI7XHJcbkNQYXJzZXIuUlVMRV9ibG9ja0l0ZW1MaXN0ID0gNzM7XHJcbkNQYXJzZXIuUlVMRV9ibG9ja0l0ZW0gPSA3NDtcclxuQ1BhcnNlci5SVUxFX2V4cHJlc3Npb25TdGF0ZW1lbnQgPSA3NTtcclxuQ1BhcnNlci5SVUxFX3NlbGVjdGlvblN0YXRlbWVudCA9IDc2O1xyXG5DUGFyc2VyLlJVTEVfaXRlcmF0aW9uU3RhdGVtZW50ID0gNzc7XHJcbkNQYXJzZXIuUlVMRV9mb3JDb25kaXRpb24gPSA3ODtcclxuQ1BhcnNlci5SVUxFX2ZvckRlY2xhcmF0aW9uID0gNzk7XHJcbkNQYXJzZXIuUlVMRV9mb3JFeHByZXNzaW9uID0gODA7XHJcbkNQYXJzZXIuUlVMRV9qdW1wU3RhdGVtZW50ID0gODE7XHJcbkNQYXJzZXIuUlVMRV9jb21waWxhdGlvblVuaXQgPSA4MjtcclxuQ1BhcnNlci5SVUxFX3RyYW5zbGF0aW9uVW5pdCA9IDgzO1xyXG5DUGFyc2VyLlJVTEVfZXh0ZXJuYWxEZWNsYXJhdGlvbiA9IDg0O1xyXG5DUGFyc2VyLlJVTEVfZnVuY3Rpb25EZWZpbml0aW9uID0gODU7XHJcbkNQYXJzZXIuUlVMRV9kZWNsYXJhdGlvbkxpc3QgPSA4NjtcclxuXHJcbmZ1bmN0aW9uIFByaW1hcnlFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3ByaW1hcnlFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblByaW1hcnlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5JZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLklkZW50aWZpZXIsIDApO1xyXG59O1xyXG5cclxuUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5Db25zdGFudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5Db25zdGFudCwgMCk7XHJcbn07XHJcblxyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLlN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbihpKSB7XHJcblx0aWYoaT09PXVuZGVmaW5lZCkge1xyXG5cdFx0aSA9IG51bGw7XHJcblx0fVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoQ1BhcnNlci5TdHJpbmdMaXRlcmFsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5TdHJpbmdMaXRlcmFsLCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmdlbmVyaWNTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoR2VuZXJpY1NlbGVjdGlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbXBvdW5kU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbXBvdW5kU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcblByaW1hcnlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUudW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFVuYXJ5RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFR5cGVOYW1lQ29udGV4dCwwKTtcclxufTtcclxuXHJcblByaW1hcnlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmltYXJ5RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0ID0gUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUucHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgUHJpbWFyeUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMCwgQ1BhcnNlci5SVUxFX3ByaW1hcnlFeHByZXNzaW9uKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMDc7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDIsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTc0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNzU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db25zdGFudCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNzc7IFxyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBfYWx0ID0gMTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBcdHN3aXRjaCAoX2FsdCkge1xyXG4gICAgICAgICAgICBcdGNhc2UgMTpcclxuICAgICAgICAgICAgXHRcdHRoaXMuc3RhdGUgPSAxNzY7XHJcbiAgICAgICAgICAgIFx0XHR0aGlzLm1hdGNoKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICAgICAgICAgIFx0XHRicmVhaztcclxuICAgICAgICAgICAgXHRkZWZhdWx0OlxyXG4gICAgICAgICAgICBcdFx0dGhyb3cgbmV3IGFudGxyNC5lcnJvci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgIFx0dGhpcy5zdGF0ZSA9IDE3OTsgXHJcbiAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBcdF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDAsIHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKCBfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUiApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTgxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE4MjtcclxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTgzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxODU7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJpY1NlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTg3O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZihfbGE9PT1DUGFyc2VyLlRfXzApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxODY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuVF9fMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxODk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTkwO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvdW5kU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxOTE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA3KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5MztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlRfXzEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTk0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5NTtcclxuICAgICAgICAgICAgdGhpcy51bmFyeUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5NjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5NztcclxuICAgICAgICAgICAgdGhpcy50eXBlTmFtZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTk4O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgOCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMDA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX18yKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwMTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMDI7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwMztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwNDtcclxuICAgICAgICAgICAgdGhpcy51bmFyeUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwNTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEdlbmVyaWNTZWxlY3Rpb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZ2VuZXJpY1NlbGVjdGlvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5HZW5lcmljU2VsZWN0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5HZW5lcmljU2VsZWN0aW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmljU2VsZWN0aW9uQ29udGV4dDtcclxuXHJcbkdlbmVyaWNTZWxlY3Rpb25Db250ZXh0LnByb3RvdHlwZS5hc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5HZW5lcmljU2VsZWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2VuZXJpY0Fzc29jTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChHZW5lcmljQXNzb2NMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkdlbmVyaWNTZWxlY3Rpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEdlbmVyaWNTZWxlY3Rpb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkdlbmVyaWNTZWxlY3Rpb25Db250ZXh0ID0gR2VuZXJpY1NlbGVjdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5nZW5lcmljU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEdlbmVyaWNTZWxlY3Rpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMiwgQ1BhcnNlci5SVUxFX2dlbmVyaWNTZWxlY3Rpb24pO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMDk7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkdlbmVyaWMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMTA7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIxMTtcclxuICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIxMjtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMTM7XHJcbiAgICAgICAgdGhpcy5nZW5lcmljQXNzb2NMaXN0KDApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMTQ7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEdlbmVyaWNBc3NvY0xpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZ2VuZXJpY0Fzc29jTGlzdDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5HZW5lcmljQXNzb2NMaXN0Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5HZW5lcmljQXNzb2NMaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmljQXNzb2NMaXN0Q29udGV4dDtcclxuXHJcbkdlbmVyaWNBc3NvY0xpc3RDb250ZXh0LnByb3RvdHlwZS5nZW5lcmljQXNzb2NpYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoR2VuZXJpY0Fzc29jaWF0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkdlbmVyaWNBc3NvY0xpc3RDb250ZXh0LnByb3RvdHlwZS5nZW5lcmljQXNzb2NMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEdlbmVyaWNBc3NvY0xpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuR2VuZXJpY0Fzc29jTGlzdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R2VuZXJpY0Fzc29jTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZ2VuZXJpY0Fzc29jTGlzdCA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgR2VuZXJpY0Fzc29jTGlzdENvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSA0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDQsIENQYXJzZXIuUlVMRV9nZW5lcmljQXNzb2NMaXN0LCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIxNztcclxuICAgICAgICB0aGlzLmdlbmVyaWNBc3NvY2lhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMjQ7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzLHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEdlbmVyaWNBc3NvY0xpc3RDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2dlbmVyaWNBc3NvY0xpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIxOTtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjIwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyaWNBc3NvY2lhdGlvbigpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjI2O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDMsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gR2VuZXJpY0Fzc29jaWF0aW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2dlbmVyaWNBc3NvY2lhdGlvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5HZW5lcmljQXNzb2NpYXRpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkdlbmVyaWNBc3NvY2lhdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJpY0Fzc29jaWF0aW9uQ29udGV4dDtcclxuXHJcbkdlbmVyaWNBc3NvY2lhdGlvbkNvbnRleHQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFR5cGVOYW1lQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkdlbmVyaWNBc3NvY2lhdGlvbkNvbnRleHQucHJvdG90eXBlLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkdlbmVyaWNBc3NvY2lhdGlvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R2VuZXJpY0Fzc29jaWF0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5HZW5lcmljQXNzb2NpYXRpb25Db250ZXh0ID0gR2VuZXJpY0Fzc29jaWF0aW9uQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmdlbmVyaWNBc3NvY2lhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBHZW5lcmljQXNzb2NpYXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNiwgQ1BhcnNlci5SVUxFX2dlbmVyaWNBc3NvY2lhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMzQ7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLl9pbnB1dC5MQSgxKSkge1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX18wOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX18zOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX180OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX181OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX182OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5DaGFyOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db25zdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRG91YmxlOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5FbnVtOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5GbG9hdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuSW50OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Mb25nOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5SZXN0cmljdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU2hvcnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlNpZ25lZDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU3RydWN0OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5VbmlvbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVW5zaWduZWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlZvaWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlZvbGF0aWxlOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5BdG9taWM6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkJvb2w6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkNvbXBsZXg6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjc7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIyODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbG9uKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIyOTtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENQYXJzZXIuRGVmYXVsdDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIzMTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkRlZmF1bHQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjMyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29sb24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjMzO1xyXG4gICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBvc3RmaXhFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3Bvc3RmaXhFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Qb3N0Zml4RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9zdGZpeEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuUG9zdGZpeEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5wcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Qb3N0Zml4RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFR5cGVOYW1lQ29udGV4dCwwKTtcclxufTtcclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuaW5pdGlhbGl6ZXJMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEluaXRpYWxpemVyTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Qb3N0Zml4RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnBvc3RmaXhFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFBvc3RmaXhFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYXJndW1lbnRFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBcmd1bWVudEV4cHJlc3Npb25MaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5JZGVudGlmaWVyLCAwKTtcclxufTtcclxuXHJcblBvc3RmaXhFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQb3N0Zml4RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUucG9zdGZpeEV4cHJlc3Npb24gPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFBvc3RmaXhFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDg7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgOCwgQ1BhcnNlci5SVUxFX3Bvc3RmaXhFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyNzA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDUsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjM3O1xyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjM5O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVOYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0MTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDI7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFjZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQ2O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVOYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjUwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjUxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFjZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX18wKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1NDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTU7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1NjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjU3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1ODtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplckxpc3QoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2MTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlRfXzApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjYyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2MztcclxuICAgICAgICAgICAgdGhpcy50eXBlTmFtZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNjU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2UpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY2O1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyTGlzdCgwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2NztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0QnJhY2UpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAyOTU7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw4LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyOTM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw3LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUG9zdGZpeEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9wb3N0Zml4RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3MjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEwKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTApXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjczO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2tldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUG9zdGZpeEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9wb3N0Zml4RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA5KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3ODtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzOSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzOSkpICYgKCgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkdlbmVyaWMgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzkpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNzEpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNzEpKSAmICgoMSA8PCAoQ1BhcnNlci5QbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXNQbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU3RhciAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRFeHByZXNzaW9uTGlzdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBQb3N0Zml4RXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX3Bvc3RmaXhFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjgzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDgpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjg0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Eb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBQb3N0Zml4RXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX3Bvc3RmaXhFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjg2O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjg3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5BcnJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4ODtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFBvc3RmaXhFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfcG9zdGZpeEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA2KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyOTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlBsdXNQbHVzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUG9zdGZpeEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9wb3N0Zml4RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5MTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTWludXNNaW51cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjk3O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDgsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQXJndW1lbnRFeHByZXNzaW9uTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9hcmd1bWVudEV4cHJlc3Npb25MaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkFyZ3VtZW50RXhwcmVzc2lvbkxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkFyZ3VtZW50RXhwcmVzc2lvbkxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFyZ3VtZW50RXhwcmVzc2lvbkxpc3RDb250ZXh0O1xyXG5cclxuQXJndW1lbnRFeHByZXNzaW9uTGlzdENvbnRleHQucHJvdG90eXBlLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFyZ3VtZW50RXhwcmVzc2lvbkxpc3RDb250ZXh0LnByb3RvdHlwZS5hcmd1bWVudEV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFyZ3VtZW50RXhwcmVzc2lvbkxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuQXJndW1lbnRFeHByZXNzaW9uTGlzdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJndW1lbnRFeHByZXNzaW9uTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuYXJndW1lbnRFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQXJndW1lbnRFeHByZXNzaW9uTGlzdENvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSAxMDtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAxMCwgQ1BhcnNlci5SVUxFX2FyZ3VtZW50RXhwcmVzc2lvbkxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMjk5O1xyXG4gICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzA2O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsOSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBBcmd1bWVudEV4cHJlc3Npb25MaXN0Q29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9hcmd1bWVudEV4cHJlc3Npb25MaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwMjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db21tYSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzAzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzA4O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDksdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3VuYXJ5RXhwcmVzc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5VbmFyeUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnBvc3RmaXhFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFBvc3RmaXhFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChVbmFyeUV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuVW5hcnlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUudW5hcnlPcGVyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChVbmFyeU9wZXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNhc3RFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENhc3RFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFR5cGVOYW1lQ29udGV4dCwwKTtcclxufTtcclxuXHJcblVuYXJ5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuSWRlbnRpZmllciwgMCk7XHJcbn07XHJcblxyXG5VbmFyeUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFVuYXJ5RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuVW5hcnlFeHByZXNzaW9uQ29udGV4dCA9IFVuYXJ5RXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS51bmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVW5hcnlFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEyLCBDUGFyc2VyLlJVTEVfdW5hcnlFeHByZXNzaW9uKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDMzMTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTAsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzA5O1xyXG4gICAgICAgICAgICB0aGlzLnBvc3RmaXhFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzEwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUGx1c1BsdXMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzExO1xyXG4gICAgICAgICAgICB0aGlzLnVuYXJ5RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzEyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTWludXNNaW51cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTM7XHJcbiAgICAgICAgICAgIHRoaXMudW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTQ7XHJcbiAgICAgICAgICAgIHRoaXMudW5hcnlPcGVyYXRvcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzE1O1xyXG4gICAgICAgICAgICB0aGlzLmNhc3RFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TaXplb2YpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzE4O1xyXG4gICAgICAgICAgICB0aGlzLnVuYXJ5RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzE5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU2l6ZW9mKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyMDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMjE7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyMjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDcpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzI0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQWxpZ25vZik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMjU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzI2O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVOYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMjc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA4KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyOTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkFuZEFuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMzA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBVbmFyeU9wZXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3VuYXJ5T3BlcmF0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuVW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuVW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlPcGVyYXRvckNvbnRleHQ7XHJcblxyXG5cclxuVW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VW5hcnlPcGVyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuVW5hcnlPcGVyYXRvckNvbnRleHQgPSBVbmFyeU9wZXJhdG9yQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnVuYXJ5T3BlcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVW5hcnlPcGVyYXRvckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNCwgQ1BhcnNlci5SVUxFX3VuYXJ5T3BlcmF0b3IpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzMzO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCEoKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpKSkgIT09IDApKSkge1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ2FzdEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfY2FzdEV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQ2FzdEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkNhc3RFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXN0RXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5DYXN0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLnVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChVbmFyeUV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQ2FzdEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUeXBlTmFtZUNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5DYXN0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNhc3RFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENhc3RFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkNhc3RFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuRGlnaXRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5EaWdpdFNlcXVlbmNlLCAwKTtcclxufTtcclxuXHJcbkNhc3RFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYXN0RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuQ2FzdEV4cHJlc3Npb25Db250ZXh0ID0gQ2FzdEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuY2FzdEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQ2FzdEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTYsIENQYXJzZXIuUlVMRV9jYXN0RXhwcmVzc2lvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNDg7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDExLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzNTtcclxuICAgICAgICAgICAgdGhpcy51bmFyeUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzNjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMzc7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzM5O1xyXG4gICAgICAgICAgICB0aGlzLmNhc3RFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX18wKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM0MjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDM7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM0NDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzQ1O1xyXG4gICAgICAgICAgICB0aGlzLmNhc3RFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5EaWdpdFNlcXVlbmNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfbXVsdGlwbGljYXRpdmVFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbk11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY2FzdEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQ2FzdEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUubXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5NdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMTg7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMTgsIENQYXJzZXIuUlVMRV9tdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24sIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzUxO1xyXG4gICAgICAgIHRoaXMuY2FzdEV4cHJlc3Npb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzY0O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTMsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM2MjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEyLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfbXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzUzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzU0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TdGFyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzU1O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzdEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfbXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzU2O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzU3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5EaXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNTg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXN0RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9tdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNTk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLk1vZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM2MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhc3RFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzY2O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEzLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEFkZGl0aXZlRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9hZGRpdGl2ZUV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5BZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFkZGl0aXZlRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5BZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5tdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFkZGl0aXZlRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFkZGl0aXZlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBZGRpdGl2ZUV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmFkZGl0aXZlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDIwO1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDIwLCBDUGFyc2VyLlJVTEVfYWRkaXRpdmVFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM2ODtcclxuICAgICAgICB0aGlzLm11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzc4O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTUsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM3NjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE0LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQWRkaXRpdmVFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfYWRkaXRpdmVFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzcwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzcxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5QbHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzcyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBBZGRpdGl2ZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9hZGRpdGl2ZUV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNzM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNzQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLk1pbnVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzc1O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM4MDtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxNSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTaGlmdEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfc2hpZnRFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblNoaWZ0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU2hpZnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGlmdEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuU2hpZnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWRkaXRpdmVFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFkZGl0aXZlRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TaGlmdEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5zaGlmdEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU2hpZnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblNoaWZ0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2hpZnRFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zaGlmdEV4cHJlc3Npb24gPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFNoaWZ0RXhwcmVzc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSAyMjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAyMiwgQ1BhcnNlci5SVUxFX3NoaWZ0RXhwcmVzc2lvbiwgX3ApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAzODI7XHJcbiAgICAgICAgdGhpcy5hZGRpdGl2ZUV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM5MjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE3LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzOTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxNix0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFNoaWZ0RXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX3NoaWZ0RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM4NDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM4NTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFNoaWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzg2O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkaXRpdmVFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBTaGlmdEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9zaGlmdEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzODc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzODg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0U2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzODk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRpdGl2ZUV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzk0O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE3LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3JlbGF0aW9uYWxFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5SZWxhdGlvbmFsRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5zaGlmdEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU2hpZnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUucmVsYXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlbGF0aW9uYWxFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5yZWxhdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMjQ7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMjQsIENQYXJzZXIuUlVMRV9yZWxhdGlvbmFsRXhwcmVzc2lvbiwgX3ApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAzOTY7XHJcbiAgICAgICAgdGhpcy5zaGlmdEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQxMjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE5LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxOCx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfcmVsYXRpb25hbEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzOTg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzOTk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfcmVsYXRpb25hbEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkdyZWF0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGlmdEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFJlbGF0aW9uYWxFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfcmVsYXRpb25hbEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlc3NFcXVhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwNjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0RXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9yZWxhdGlvbmFsRXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwNztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwODtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuR3JlYXRlckVxdWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDA5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQxNDtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxOSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZXF1YWxpdHlFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRXF1YWxpdHlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuRXF1YWxpdHlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUucmVsYXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUmVsYXRpb25hbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRXF1YWxpdHlFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuZXF1YWxpdHlFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5FcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVxdWFsaXR5RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZXF1YWxpdHlFeHByZXNzaW9uID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBFcXVhbGl0eUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMjY7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMjYsIENQYXJzZXIuUlVMRV9lcXVhbGl0eUV4cHJlc3Npb24sIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDE2O1xyXG4gICAgICAgIHRoaXMucmVsYXRpb25hbEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQyNjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDIxLHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MjQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyMCx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2VxdWFsaXR5RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQxODtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQxOTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuRXF1YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MjA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbmFsRXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRXF1YWxpdHlFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfZXF1YWxpdHlFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDIxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDIyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Ob3RFcXVhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQyMztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uYWxFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQyODtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyMSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBBbmRFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2FuZEV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQW5kRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuQW5kRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5kRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5BbmRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuZXF1YWxpdHlFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEVxdWFsaXR5RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5BbmRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBbmRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFuZEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuZEV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmFuZEV4cHJlc3Npb24gPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEFuZEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMjg7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMjgsIENQYXJzZXIuUlVMRV9hbmRFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQzMDtcclxuICAgICAgICB0aGlzLmVxdWFsaXR5RXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDM3O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjIsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQW5kRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfYW5kRXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDMyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MzM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MzQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWFsaXR5RXhwcmVzc2lvbigwKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQzOTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyMix0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFeGNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZXhjbHVzaXZlT3JFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkV4Y2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRXhjbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeGNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuRXhjbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBbmRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkV4Y2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeGNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRXhjbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeGNsdXNpdmVPckV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRXhjbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDMwO1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDMwLCBDUGFyc2VyLlJVTEVfZXhjbHVzaXZlT3JFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ0MTtcclxuICAgICAgICB0aGlzLmFuZEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ0ODtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDIzLHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEV4Y2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfZXhjbHVzaXZlT3JFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NDM7XHJcbiAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ0NDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5DYXJldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDQ1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmRFeHByZXNzaW9uKDApOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDUwO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDIzLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEluY2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9pbmNsdXNpdmVPckV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSW5jbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5JbmNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluY2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5JbmNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leGNsdXNpdmVPckV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhjbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkluY2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmluY2x1c2l2ZU9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbmNsdXNpdmVPckV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuSW5jbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbmNsdXNpdmVPckV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmluY2x1c2l2ZU9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgSW5jbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDMyO1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDMyLCBDUGFyc2VyLlJVTEVfaW5jbHVzaXZlT3JFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ1MjtcclxuICAgICAgICB0aGlzLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDU5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjQsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgSW5jbHVzaXZlT3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9pbmNsdXNpdmVPckV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ1NDtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDU1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLk9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NTY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbigwKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2MTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyNCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBMb2dpY2FsQW5kRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9sb2dpY2FsQW5kRXhwcmVzc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Mb2dpY2FsQW5kRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuTG9naWNhbEFuZEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbkxvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuaW5jbHVzaXZlT3JFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEluY2x1c2l2ZU9yRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Mb2dpY2FsQW5kRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmxvZ2ljYWxBbmRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KExvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkxvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMb2dpY2FsQW5kRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubG9naWNhbEFuZEV4cHJlc3Npb24gPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IExvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDM0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDM0LCBDUGFyc2VyLlJVTEVfbG9naWNhbEFuZEV4cHJlc3Npb24sIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDYzO1xyXG4gICAgICAgIHRoaXMuaW5jbHVzaXZlT3JFeHByZXNzaW9uKDApO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NzA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyNSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBMb2dpY2FsQW5kRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfbG9naWNhbEFuZEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2NTtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDY2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkFuZEFuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDY3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNsdXNpdmVPckV4cHJlc3Npb24oMCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NzI7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjUsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gTG9naWNhbE9yRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9sb2dpY2FsT3JFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkxvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkxvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuTG9naWNhbE9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmxvZ2ljYWxBbmRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KExvZ2ljYWxBbmRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkxvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5sb2dpY2FsT3JFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KExvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuTG9naWNhbE9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TG9naWNhbE9yRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubG9naWNhbE9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgTG9naWNhbE9yRXhwcmVzc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSAzNjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAzNiwgQ1BhcnNlci5SVUxFX2xvZ2ljYWxPckV4cHJlc3Npb24sIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDc0O1xyXG4gICAgICAgIHRoaXMubG9naWNhbEFuZEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4MTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDI2LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IExvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2xvZ2ljYWxPckV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ3NjtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDc3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLk9yT3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ3ODtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9naWNhbEFuZEV4cHJlc3Npb24oMCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0ODM7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjYsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2NvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Db25kaXRpb25hbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkNvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbkNvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmxvZ2ljYWxPckV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9naWNhbE9yRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Db25kaXRpb25hbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Db25kaXRpb25hbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29udGV4dCA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5jb25kaXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDM4LCBDUGFyc2VyLlJVTEVfY29uZGl0aW9uYWxFeHByZXNzaW9uKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDg0O1xyXG4gICAgICAgIHRoaXMubG9naWNhbE9yRXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNDkwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyNyx0aGlzLl9jdHgpO1xyXG4gICAgICAgIGlmKGxhXz09PTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4NTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlF1ZXN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4NjtcclxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDg3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29sb24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDg4O1xyXG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfYXNzaWdubWVudEV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5Bc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChDb25kaXRpb25hbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS51bmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVW5hcnlFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYXNzaWdubWVudE9wZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFzc2lnbm1lbnRPcGVyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Bc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuRGlnaXRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5EaWdpdFNlcXVlbmNlLCAwKTtcclxufTtcclxuXHJcbkFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NpZ25tZW50RXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0ID0gQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuYXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNDAsIENQYXJzZXIuUlVMRV9hc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA0OTg7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDI4LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5MjtcclxuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25hbEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5MztcclxuICAgICAgICAgICAgdGhpcy51bmFyeUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5NDtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50T3BlcmF0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5NTtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDk3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQXNzaWdubWVudE9wZXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2Fzc2lnbm1lbnRPcGVyYXRvcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Bc3NpZ25tZW50T3BlcmF0b3JDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkFzc2lnbm1lbnRPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzaWdubWVudE9wZXJhdG9yQ29udGV4dDtcclxuXHJcblxyXG5Bc3NpZ25tZW50T3BlcmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2lnbm1lbnRPcGVyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuQXNzaWdubWVudE9wZXJhdG9yQ29udGV4dCA9IEFzc2lnbm1lbnRPcGVyYXRvckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5hc3NpZ25tZW50T3BlcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQXNzaWdubWVudE9wZXJhdG9yQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDQyLCBDUGFyc2VyLlJVTEVfYXNzaWdubWVudE9wZXJhdG9yKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUwMDtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZighKCgoKChfbGEgLSA4OSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA4OSkpICYgKCgxIDw8IChDUGFyc2VyLkFzc2lnbiAtIDg5KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyQXNzaWduIC0gODkpKSB8ICgxIDw8IChDUGFyc2VyLkRpdkFzc2lnbiAtIDg5KSkgfCAoMSA8PCAoQ1BhcnNlci5Nb2RBc3NpZ24gLSA4OSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c0Fzc2lnbiAtIDg5KSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c0Fzc2lnbiAtIDg5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0U2hpZnRBc3NpZ24gLSA4OSkpIHwgKDEgPDwgKENQYXJzZXIuUmlnaHRTaGlmdEFzc2lnbiAtIDg5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBc3NpZ24gLSA4OSkpIHwgKDEgPDwgKENQYXJzZXIuWG9yQXNzaWduIC0gODkpKSB8ICgxIDw8IChDUGFyc2VyLk9yQXNzaWduIC0gODkpKSkpICE9PSAwKSkpIHtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZXhwcmVzc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gNDQ7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgNDQsIENQYXJzZXIuUlVMRV9leHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUwMztcclxuICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUxMDtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDI5LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUwNTtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTA2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MDc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MTI7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjksdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2NvbnN0YW50RXhwcmVzc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Db25zdGFudEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkNvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbkNvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChDb25kaXRpb25hbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25zdGFudEV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkNvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQgPSBDb25zdGFudEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuY29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA0NiwgQ1BhcnNlci5SVUxFX2NvbnN0YW50RXhwcmVzc2lvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUxMztcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIERlY2xhcmF0aW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkRlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5EZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5kZWNsYXJhdGlvblNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVjbGFyYXRpb25TcGVjaWZpZXJzQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuaW5pdERlY2xhcmF0b3JMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEluaXREZWNsYXJhdG9yTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLnN0YXRpY0Fzc2VydERlY2xhcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRGVjbGFyYXRpb25Db250ZXh0ID0gRGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGVjbGFyYXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNDgsIENQYXJzZXIuUlVMRV9kZWNsYXJhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MjM7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDMwLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUxNTtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblNwZWNpZmllcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUxNjtcclxuICAgICAgICAgICAgdGhpcy5pbml0RGVjbGFyYXRvckxpc3QoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MTc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUxOTtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblNwZWNpZmllcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUyMDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTIyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRpY0Fzc2VydERlY2xhcmF0aW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gRGVjbGFyYXRpb25TcGVjaWZpZXJzQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uU3BlY2lmaWVycztcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllcnNDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkRlY2xhcmF0aW9uU3BlY2lmaWVyc0NvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVjbGFyYXRpb25TcGVjaWZpZXJzQ29udGV4dDtcclxuXHJcbkRlY2xhcmF0aW9uU3BlY2lmaWVyc0NvbnRleHQucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhEZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRlY2xhcmF0aW9uU3BlY2lmaWVyc0NvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb25TcGVjaWZpZXJzKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5EZWNsYXJhdGlvblNwZWNpZmllcnNDb250ZXh0ID0gRGVjbGFyYXRpb25TcGVjaWZpZXJzQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBEZWNsYXJhdGlvblNwZWNpZmllcnNDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNTAsIENQYXJzZXIuUlVMRV9kZWNsYXJhdGlvblNwZWNpZmllcnMpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MjY7IFxyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IDE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgIFx0c3dpdGNoIChfYWx0KSB7XHJcbiAgICAgICAgXHRjYXNlIDE6XHJcbiAgICAgICAgXHRcdHRoaXMuc3RhdGUgPSA1MjU7XHJcbiAgICAgICAgXHRcdHRoaXMuZGVjbGFyYXRpb25TcGVjaWZpZXIoKTtcclxuICAgICAgICBcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRkZWZhdWx0OlxyXG4gICAgICAgIFx0XHR0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0dGhpcy5zdGF0ZSA9IDUyODsgXHJcbiAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgXHRfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzMSwgdGhpcy5fY3R4KTtcclxuICAgICAgICB9IHdoaWxlICggX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIgKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZWNsYXJhdGlvblNwZWNpZmllcnMyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uU3BlY2lmaWVyczI7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQ7XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllcnMyQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb25TcGVjaWZpZXIgPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKERlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVjbGFyYXRpb25TcGVjaWZpZXJDb250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb25TcGVjaWZpZXJzMih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQgPSBEZWNsYXJhdGlvblNwZWNpZmllcnMyQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVyczIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA1MiwgQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uU3BlY2lmaWVyczIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MzE7IFxyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IDE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgIFx0c3dpdGNoIChfYWx0KSB7XHJcbiAgICAgICAgXHRjYXNlIDE6XHJcbiAgICAgICAgXHRcdHRoaXMuc3RhdGUgPSA1MzA7XHJcbiAgICAgICAgXHRcdHRoaXMuZGVjbGFyYXRpb25TcGVjaWZpZXIoKTtcclxuICAgICAgICBcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRkZWZhdWx0OlxyXG4gICAgICAgIFx0XHR0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0dGhpcy5zdGF0ZSA9IDUzMzsgXHJcbiAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgXHRfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzMiwgdGhpcy5fY3R4KTtcclxuICAgICAgICB9IHdoaWxlICggX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIgKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9kZWNsYXJhdGlvblNwZWNpZmllcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVjbGFyYXRpb25TcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkRlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuc3RvcmFnZUNsYXNzU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0b3JhZ2VDbGFzc1NwZWNpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLnR5cGVTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVNwZWNpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLnR5cGVRdWFsaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVF1YWxpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmZ1bmN0aW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuYWxpZ25tZW50U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFsaWdubWVudFNwZWNpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb25TcGVjaWZpZXIodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkRlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dCA9IERlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IERlY2xhcmF0aW9uU3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDU0LCBDUGFyc2VyLlJVTEVfZGVjbGFyYXRpb25TcGVjaWZpZXIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNTQwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzMyx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MzU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUNsYXNzU3BlY2lmaWVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MzY7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZVNwZWNpZmllcigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTM3O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUzODtcclxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblNwZWNpZmllcigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTM5O1xyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudFNwZWNpZmllcigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEluaXREZWNsYXJhdG9yTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9pbml0RGVjbGFyYXRvckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSW5pdERlY2xhcmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Jbml0RGVjbGFyYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluaXREZWNsYXJhdG9yTGlzdENvbnRleHQ7XHJcblxyXG5Jbml0RGVjbGFyYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZS5pbml0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0RGVjbGFyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Jbml0RGVjbGFyYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZS5pbml0RGVjbGFyYXRvckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSW5pdERlY2xhcmF0b3JMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkluaXREZWNsYXJhdG9yTGlzdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5pdERlY2xhcmF0b3JMaXN0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5pbml0RGVjbGFyYXRvckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEluaXREZWNsYXJhdG9yTGlzdENvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSA1NjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCA1NiwgQ1BhcnNlci5SVUxFX2luaXREZWNsYXJhdG9yTGlzdCwgX3ApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1NDM7XHJcbiAgICAgICAgdGhpcy5pbml0RGVjbGFyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1NTA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzNCx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBJbml0RGVjbGFyYXRvckxpc3RDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2luaXREZWNsYXJhdG9yTGlzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTQ1O1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NDY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU0NztcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdERlY2xhcmF0b3IoKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU1MjtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwzNCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBJbml0RGVjbGFyYXRvckNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9pbml0RGVjbGFyYXRvcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Jbml0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSW5pdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluaXREZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkluaXREZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkluaXREZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuaW5pdGlhbGl6ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSW5pdGlhbGl6ZXJDb250ZXh0LDApO1xyXG59O1xyXG5cclxuSW5pdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluaXREZWNsYXJhdG9yKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Jbml0RGVjbGFyYXRvckNvbnRleHQgPSBJbml0RGVjbGFyYXRvckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5pbml0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBJbml0RGVjbGFyYXRvckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA1OCwgQ1BhcnNlci5SVUxFX2luaXREZWNsYXJhdG9yKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU1ODtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMzUsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTUzO1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0b3IoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU1NDtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NTU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Bc3NpZ24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTU2O1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU3RvcmFnZUNsYXNzU3BlY2lmaWVyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3N0b3JhZ2VDbGFzc1NwZWNpZmllcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5TdG9yYWdlQ2xhc3NTcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblN0b3JhZ2VDbGFzc1NwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RvcmFnZUNsYXNzU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcblxyXG5TdG9yYWdlQ2xhc3NTcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0b3JhZ2VDbGFzc1NwZWNpZmllcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuU3RvcmFnZUNsYXNzU3BlY2lmaWVyQ29udGV4dCA9IFN0b3JhZ2VDbGFzc1NwZWNpZmllckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdG9yYWdlQ2xhc3NTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgU3RvcmFnZUNsYXNzU3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDYwLCBDUGFyc2VyLlJVTEVfc3RvcmFnZUNsYXNzU3BlY2lmaWVyKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU2MDtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZighKF9sYT09PUNQYXJzZXIuQXV0byB8fCBfbGE9PT1DUGFyc2VyLkV4dGVybiB8fCAoKCgoX2xhIC0gMzQpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzQpKSAmICgoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDM0KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGF0aWMgLSAzNCkpIHwgKDEgPDwgKENQYXJzZXIuVHlwZWRlZiAtIDM0KSkgfCAoMSA8PCAoQ1BhcnNlci5UaHJlYWRMb2NhbCAtIDM0KSkpKSAhPT0gMCkpKSB7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBUeXBlU3BlY2lmaWVyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3R5cGVTcGVjaWZpZXI7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuVHlwZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuVHlwZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZVNwZWNpZmllckNvbnRleHQ7XHJcblxyXG5UeXBlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuYXRvbWljVHlwZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcblR5cGVTcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5zdHJ1Y3RPclVuaW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0LDApO1xyXG59O1xyXG5cclxuVHlwZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmVudW1TcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRW51bVNwZWNpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5UeXBlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUudHlwZWRlZk5hbWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZWRlZk5hbWVDb250ZXh0LDApO1xyXG59O1xyXG5cclxuVHlwZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmNvbnN0YW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChDb25zdGFudEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuVHlwZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHlwZVNwZWNpZmllcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuVHlwZVNwZWNpZmllckNvbnRleHQgPSBUeXBlU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnR5cGVTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVHlwZVNwZWNpZmllckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA2MiwgQ1BhcnNlci5SVUxFX3R5cGVTcGVjaWZpZXIpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU3NjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzM6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzU6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkNoYXI6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkRvdWJsZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRmxvYXQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkludDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTG9uZzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU2hvcnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlNpZ25lZDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVW5zaWduZWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlZvaWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkJvb2w6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkNvbXBsZXg6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NjI7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzMpIHwgKDEgPDwgQ1BhcnNlci5UX180KSB8ICgxIDw8IENQYXJzZXIuVF9fNSkgfCAoMSA8PCBDUGFyc2VyLkNoYXIpIHwgKDEgPDwgQ1BhcnNlci5Eb3VibGUpIHwgKDEgPDwgQ1BhcnNlci5GbG9hdCkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDMyKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDMyKSkgJiAoKDEgPDwgKENQYXJzZXIuSW50IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkxvbmcgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2hvcnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQm9vbCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Db21wbGV4IC0gMzIpKSkpICE9PSAwKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2MztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlRfXzApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2NTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCEoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMykgfCAoMSA8PCBDUGFyc2VyLlRfXzQpIHwgKDEgPDwgQ1BhcnNlci5UX181KSkpICE9PSAwKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5BdG9taWM6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1Njc7XHJcbiAgICAgICAgICAgIHRoaXMuYXRvbWljVHlwZVNwZWNpZmllcigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENQYXJzZXIuU3RydWN0OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5VbmlvbjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2ODtcclxuICAgICAgICAgICAgdGhpcy5zdHJ1Y3RPclVuaW9uU3BlY2lmaWVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5FbnVtOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY5O1xyXG4gICAgICAgICAgICB0aGlzLmVudW1TcGVjaWZpZXIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NzA7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZWRlZk5hbWUoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzY6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NzE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX182KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU3MjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NzM7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NzQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU3RydWN0T3JVbmlvblNwZWNpZmllckNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9zdHJ1Y3RPclVuaW9uU3BlY2lmaWVyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0O1xyXG5cclxuU3RydWN0T3JVbmlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLnN0cnVjdE9yVW5pb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU3RydWN0T3JVbmlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdHJ1Y3RPclVuaW9uU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0cnVjdERlY2xhcmF0aW9uTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdHJ1Y3RPclVuaW9uU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5JZGVudGlmaWVyLCAwKTtcclxufTtcclxuXHJcblN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0cnVjdE9yVW5pb25TcGVjaWZpZXIodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLlN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0ID0gU3RydWN0T3JVbmlvblNwZWNpZmllckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdHJ1Y3RPclVuaW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0cnVjdE9yVW5pb25TcGVjaWZpZXJDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNjQsIENQYXJzZXIuUlVMRV9zdHJ1Y3RPclVuaW9uU3BlY2lmaWVyKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1ODk7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDM4LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU3ODtcclxuICAgICAgICAgICAgdGhpcy5zdHJ1Y3RPclVuaW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1ODA7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU3OTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU4MjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1ODM7XHJcbiAgICAgICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25MaXN0KDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTg0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFjZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1ODY7XHJcbiAgICAgICAgICAgIHRoaXMuc3RydWN0T3JVbmlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTg3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU3RydWN0T3JVbmlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9zdHJ1Y3RPclVuaW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0cnVjdE9yVW5pb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblN0cnVjdE9yVW5pb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cnVjdE9yVW5pb25Db250ZXh0O1xyXG5cclxuXHJcblN0cnVjdE9yVW5pb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0cnVjdE9yVW5pb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLlN0cnVjdE9yVW5pb25Db250ZXh0ID0gU3RydWN0T3JVbmlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdHJ1Y3RPclVuaW9uID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0cnVjdE9yVW5pb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNjYsIENQYXJzZXIuUlVMRV9zdHJ1Y3RPclVuaW9uKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU5MTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZighKF9sYT09PUNQYXJzZXIuU3RydWN0IHx8IF9sYT09PUNQYXJzZXIuVW5pb24pKSB7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTdHJ1Y3REZWNsYXJhdGlvbkxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfc3RydWN0RGVjbGFyYXRpb25MaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0cnVjdERlY2xhcmF0aW9uTGlzdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3RydWN0RGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJ1Y3REZWNsYXJhdGlvbkxpc3RDb250ZXh0O1xyXG5cclxuU3RydWN0RGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU3RydWN0RGVjbGFyYXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RydWN0RGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0cnVjdERlY2xhcmF0aW9uTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdHJ1Y3REZWNsYXJhdGlvbkxpc3RDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0cnVjdERlY2xhcmF0aW9uTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBTdHJ1Y3REZWNsYXJhdGlvbkxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gNjg7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgNjgsIENQYXJzZXIuUlVMRV9zdHJ1Y3REZWNsYXJhdGlvbkxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNTk0O1xyXG4gICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjAwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMzksdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgU3RydWN0RGVjbGFyYXRpb25MaXN0Q29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9zdHJ1Y3REZWNsYXJhdGlvbkxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU5NjtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTk3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJ1Y3REZWNsYXJhdGlvbigpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjAyO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDM5LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFN0cnVjdERlY2xhcmF0aW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3N0cnVjdERlY2xhcmF0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0cnVjdERlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5TdHJ1Y3REZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RydWN0RGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuU3RydWN0RGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5zcGVjaWZpZXJRdWFsaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFNwZWNpZmllclF1YWxpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RydWN0RGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5zdHJ1Y3REZWNsYXJhdG9yTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChTdHJ1Y3REZWNsYXJhdG9yTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdHJ1Y3REZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLnN0YXRpY0Fzc2VydERlY2xhcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0cnVjdERlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJ1Y3REZWNsYXJhdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuU3RydWN0RGVjbGFyYXRpb25Db250ZXh0ID0gU3RydWN0RGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgU3RydWN0RGVjbGFyYXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNzAsIENQYXJzZXIuUlVMRV9zdHJ1Y3REZWNsYXJhdGlvbik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjEwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQ2hhcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQ29uc3Q6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkRvdWJsZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRW51bTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRmxvYXQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkludDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTG9uZzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuUmVzdHJpY3Q6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlNob3J0OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5TaWduZWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlN0cnVjdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVW5pb246XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlVuc2lnbmVkOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Wb2lkOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Wb2xhdGlsZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQXRvbWljOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Cb29sOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db21wbGV4OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5JZGVudGlmaWVyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjAzO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllclF1YWxpZmllckxpc3QoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYwNTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoKCgoKF9sYSAtIDU5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDU5KSkgJiAoKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gNTkpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA1OSkpIHwgKDEgPDwgKENQYXJzZXIuQ2FyZXQgLSA1OSkpIHwgKDEgPDwgKENQYXJzZXIuQ29sb24gLSA1OSkpKSkgIT09IDApIHx8IF9sYT09PUNQYXJzZXIuSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYwNDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRvckxpc3QoMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MDc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlN0YXRpY0Fzc2VydDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYwOTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0aWNBc3NlcnREZWNsYXJhdGlvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTcGVjaWZpZXJRdWFsaWZpZXJMaXN0Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3NwZWNpZmllclF1YWxpZmllckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuU3BlY2lmaWVyUXVhbGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3BlY2lmaWVyUXVhbGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BlY2lmaWVyUXVhbGlmaWVyTGlzdENvbnRleHQ7XHJcblxyXG5TcGVjaWZpZXJRdWFsaWZpZXJMaXN0Q29udGV4dC5wcm90b3R5cGUudHlwZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUeXBlU3BlY2lmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcblNwZWNpZmllclF1YWxpZmllckxpc3RDb250ZXh0LnByb3RvdHlwZS5zcGVjaWZpZXJRdWFsaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFNwZWNpZmllclF1YWxpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuU3BlY2lmaWVyUXVhbGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLnR5cGVRdWFsaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVF1YWxpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TcGVjaWZpZXJRdWFsaWZpZXJMaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTcGVjaWZpZXJRdWFsaWZpZXJMaXN0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5TcGVjaWZpZXJRdWFsaWZpZXJMaXN0Q29udGV4dCA9IFNwZWNpZmllclF1YWxpZmllckxpc3RDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuc3BlY2lmaWVyUXVhbGlmaWVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBTcGVjaWZpZXJRdWFsaWZpZXJMaXN0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDcyLCBDUGFyc2VyLlJVTEVfc3BlY2lmaWVyUXVhbGlmaWVyTGlzdCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2MjA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDQ0LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYxMjtcclxuICAgICAgICAgICAgdGhpcy50eXBlU3BlY2lmaWVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MTQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNDIsdGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgaWYobGFfPT09MSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYxMztcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVyUXVhbGlmaWVyTGlzdCgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjE2O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYxODtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw0Myx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjE3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWZpZXJRdWFsaWZpZXJMaXN0KCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU3RydWN0RGVjbGFyYXRvckxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfc3RydWN0RGVjbGFyYXRvckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuU3RydWN0RGVjbGFyYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblN0cnVjdERlY2xhcmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJ1Y3REZWNsYXJhdG9yTGlzdENvbnRleHQ7XHJcblxyXG5TdHJ1Y3REZWNsYXJhdG9yTGlzdENvbnRleHQucHJvdG90eXBlLnN0cnVjdERlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU3RydWN0RGVjbGFyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdHJ1Y3REZWNsYXJhdG9yTGlzdENvbnRleHQucHJvdG90eXBlLnN0cnVjdERlY2xhcmF0b3JMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0cnVjdERlY2xhcmF0b3JMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcblN0cnVjdERlY2xhcmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJ1Y3REZWNsYXJhdG9yTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuc3RydWN0RGVjbGFyYXRvckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0cnVjdERlY2xhcmF0b3JMaXN0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDc0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDc0LCBDUGFyc2VyLlJVTEVfc3RydWN0RGVjbGFyYXRvckxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjIzO1xyXG4gICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2MzA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw0NSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBTdHJ1Y3REZWNsYXJhdG9yTGlzdENvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfc3RydWN0RGVjbGFyYXRvckxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYyNTtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjI2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Mjc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cnVjdERlY2xhcmF0b3IoKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzMjtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw0NSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTdHJ1Y3REZWNsYXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3N0cnVjdERlY2xhcmF0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuU3RydWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3RydWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RydWN0RGVjbGFyYXRvckNvbnRleHQ7XHJcblxyXG5TdHJ1Y3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0cnVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5jb25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0cnVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0cnVjdERlY2xhcmF0b3IodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLlN0cnVjdERlY2xhcmF0b3JDb250ZXh0ID0gU3RydWN0RGVjbGFyYXRvckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdHJ1Y3REZWNsYXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0cnVjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNzYsIENQYXJzZXIuUlVMRV9zdHJ1Y3REZWNsYXJhdG9yKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2Mzk7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDQ3LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzMztcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdG9yKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MzU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCgoKChfbGEgLSA1OSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA1OSkpICYgKCgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDU5KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNTkpKSB8ICgxIDw8IChDUGFyc2VyLkNhcmV0IC0gNTkpKSkpICE9PSAwKSB8fCBfbGE9PT1DUGFyc2VyLklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MzQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0b3IoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzNztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbG9uKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzODtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFbnVtU3BlY2lmaWVyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2VudW1TcGVjaWZpZXI7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRW51bVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRW51bVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW51bVNwZWNpZmllckNvbnRleHQ7XHJcblxyXG5FbnVtU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuZW51bWVyYXRvckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRW51bWVyYXRvckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRW51bVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuSWRlbnRpZmllciwgMCk7XHJcbn07XHJcblxyXG5FbnVtU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbnVtU3BlY2lmaWVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5FbnVtU3BlY2lmaWVyQ29udGV4dCA9IEVudW1TcGVjaWZpZXJDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZW51bVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBFbnVtU3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDc4LCBDUGFyc2VyLlJVTEVfZW51bVNwZWNpZmllcik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjYwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw1MCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NDE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5FbnVtKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY0MztcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoX2xhPT09Q1BhcnNlci5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjQyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjQ1O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY0NjtcclxuICAgICAgICAgICAgdGhpcy5lbnVtZXJhdG9yTGlzdCgwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY0NztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0QnJhY2UpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjQ5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuRW51bSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NTE7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY1MDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY1MztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NTQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW51bWVyYXRvckxpc3QoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NTU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db21tYSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NTY7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY1ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkVudW0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjU5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gRW51bWVyYXRvckxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZW51bWVyYXRvckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRW51bWVyYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkVudW1lcmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbnVtZXJhdG9yTGlzdENvbnRleHQ7XHJcblxyXG5FbnVtZXJhdG9yTGlzdENvbnRleHQucHJvdG90eXBlLmVudW1lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRW51bWVyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5FbnVtZXJhdG9yTGlzdENvbnRleHQucHJvdG90eXBlLmVudW1lcmF0b3JMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEVudW1lcmF0b3JMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkVudW1lcmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbnVtZXJhdG9yTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZW51bWVyYXRvckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEVudW1lcmF0b3JMaXN0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDgwO1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDgwLCBDUGFyc2VyLlJVTEVfZW51bWVyYXRvckxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjYzO1xyXG4gICAgICAgIHRoaXMuZW51bWVyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NzA7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw1MSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBFbnVtZXJhdG9yTGlzdENvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfZW51bWVyYXRvckxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY2NTtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjY2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Njc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVudW1lcmF0b3IoKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY3MjtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw1MSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFbnVtZXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2VudW1lcmF0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRW51bWVyYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRW51bWVyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW51bWVyYXRvckNvbnRleHQ7XHJcblxyXG5FbnVtZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZW51bWVyYXRpb25Db25zdGFudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFbnVtZXJhdGlvbkNvbnN0YW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkVudW1lcmF0b3JDb250ZXh0LnByb3RvdHlwZS5jb25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkVudW1lcmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVudW1lcmF0b3IodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkVudW1lcmF0b3JDb250ZXh0ID0gRW51bWVyYXRvckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5lbnVtZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEVudW1lcmF0b3JDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgODIsIENQYXJzZXIuUlVMRV9lbnVtZXJhdG9yKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY3ODtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNTIsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjczO1xyXG4gICAgICAgICAgICB0aGlzLmVudW1lcmF0aW9uQ29uc3RhbnQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY3NDtcclxuICAgICAgICAgICAgdGhpcy5lbnVtZXJhdGlvbkNvbnN0YW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NzU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Bc3NpZ24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjc2O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEVudW1lcmF0aW9uQ29uc3RhbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZW51bWVyYXRpb25Db25zdGFudDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5FbnVtZXJhdGlvbkNvbnN0YW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5FbnVtZXJhdGlvbkNvbnN0YW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbnVtZXJhdGlvbkNvbnN0YW50Q29udGV4dDtcclxuXHJcbkVudW1lcmF0aW9uQ29uc3RhbnRDb250ZXh0LnByb3RvdHlwZS5JZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLklkZW50aWZpZXIsIDApO1xyXG59O1xyXG5cclxuRW51bWVyYXRpb25Db25zdGFudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW51bWVyYXRpb25Db25zdGFudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRW51bWVyYXRpb25Db25zdGFudENvbnRleHQgPSBFbnVtZXJhdGlvbkNvbnN0YW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmVudW1lcmF0aW9uQ29uc3RhbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRW51bWVyYXRpb25Db25zdGFudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA4NCwgQ1BhcnNlci5SVUxFX2VudW1lcmF0aW9uQ29uc3RhbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2ODA7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEF0b21pY1R5cGVTcGVjaWZpZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfYXRvbWljVHlwZVNwZWNpZmllcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5BdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5BdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkF0b21pY1R5cGVTcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUeXBlTmFtZUNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5BdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBdG9taWNUeXBlU3BlY2lmaWVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5BdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dCA9IEF0b21pY1R5cGVTcGVjaWZpZXJDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuYXRvbWljVHlwZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBBdG9taWNUeXBlU3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDg2LCBDUGFyc2VyLlJVTEVfYXRvbWljVHlwZVNwZWNpZmllcik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY4MjtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQXRvbWljKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjgzO1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2ODQ7XHJcbiAgICAgICAgdGhpcy50eXBlTmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2ODU7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFR5cGVRdWFsaWZpZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfdHlwZVF1YWxpZmllcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5UeXBlUXVhbGlmaWVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5UeXBlUXVhbGlmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlUXVhbGlmaWVyQ29udGV4dDtcclxuXHJcblxyXG5UeXBlUXVhbGlmaWVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUeXBlUXVhbGlmaWVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5UeXBlUXVhbGlmaWVyQ29udGV4dCA9IFR5cGVRdWFsaWZpZXJDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUudHlwZVF1YWxpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBUeXBlUXVhbGlmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDg4LCBDUGFyc2VyLlJVTEVfdHlwZVF1YWxpZmllcik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2ODc7XHJcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgaWYoIShfbGE9PT1DUGFyc2VyLkNvbnN0IHx8ICgoKChfbGEgLSAzNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzNSkpICYgKCgxIDw8IChDUGFyc2VyLlJlc3RyaWN0IC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLlZvbGF0aWxlIC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDM1KSkpKSAhPT0gMCkpKSB7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvblNwZWNpZmllckNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9mdW5jdGlvblNwZWNpZmllcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5GdW5jdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRnVuY3Rpb25TcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuZ2NjQXR0cmlidXRlU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEdjY0F0dHJpYnV0ZVNwZWNpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuSWRlbnRpZmllciwgMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvblNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25TcGVjaWZpZXIodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dCA9IEZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmZ1bmN0aW9uU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEZ1bmN0aW9uU3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDkwLCBDUGFyc2VyLlJVTEVfZnVuY3Rpb25TcGVjaWZpZXIpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY5NTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzc6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzg6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLklubGluZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTm9yZXR1cm46XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2ODk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzcpIHwgKDEgPDwgQ1BhcnNlci5UX184KSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCBfbGE9PT1DUGFyc2VyLk5vcmV0dXJuKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX18xMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5MDtcclxuICAgICAgICAgICAgdGhpcy5nY2NBdHRyaWJ1dGVTcGVjaWZpZXIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzk6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2OTE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX185KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5MjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2OTM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5NDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBBbGlnbm1lbnRTcGVjaWZpZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfYWxpZ25tZW50U3BlY2lmaWVyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkFsaWdubWVudFNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuQWxpZ25tZW50U3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbGlnbm1lbnRTcGVjaWZpZXJDb250ZXh0O1xyXG5cclxuQWxpZ25tZW50U3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZU5hbWVDb250ZXh0LDApO1xyXG59O1xyXG5cclxuQWxpZ25tZW50U3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5BbGlnbm1lbnRTcGVjaWZpZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFsaWdubWVudFNwZWNpZmllcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuQWxpZ25tZW50U3BlY2lmaWVyQ29udGV4dCA9IEFsaWdubWVudFNwZWNpZmllckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5hbGlnbm1lbnRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQWxpZ25tZW50U3BlY2lmaWVyQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDkyLCBDUGFyc2VyLlJVTEVfYWxpZ25tZW50U3BlY2lmaWVyKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcwNztcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNTQsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjk3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQWxpZ25hcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2OTg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjk5O1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVOYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MDA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcwMjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkFsaWduYXMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzAzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcwNDtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcwNTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIERlY2xhcmF0b3JDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZGVjbGFyYXRvcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5EZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkRlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5kaXJlY3REZWNsYXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERpcmVjdERlY2xhcmF0b3JDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUG9pbnRlckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2NjRGVjbGFyYXRvckV4dGVuc2lvbiA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEdjY0RlY2xhcmF0b3JFeHRlbnNpb25Db250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRGVjbGFyYXRvckNvbnRleHQgPSBEZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmRlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGVjbGFyYXRvckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA5NCwgQ1BhcnNlci5SVUxFX2RlY2xhcmF0b3IpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzEwO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZihfbGE9PT1DUGFyc2VyLlN0YXIgfHwgX2xhPT09Q1BhcnNlci5DYXJldCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzA5O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MTI7XHJcbiAgICAgICAgdGhpcy5kaXJlY3REZWNsYXJhdG9yKDApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MTY7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw1Nix0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MTM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdjY0RlY2xhcmF0b3JFeHRlbnNpb24oKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcxODtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw1Nix0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gRGlyZWN0RGVjbGFyYXRvckNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9kaXJlY3REZWNsYXJhdG9yO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkRpcmVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkRpcmVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdERlY2xhcmF0b3JDb250ZXh0O1xyXG5cclxuRGlyZWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuSWRlbnRpZmllciwgMCk7XHJcbn07XHJcblxyXG5EaXJlY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRpcmVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5EaWdpdFNlcXVlbmNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLkRpZ2l0U2VxdWVuY2UsIDApO1xyXG59O1xyXG5cclxuRGlyZWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmRpcmVjdERlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGlyZWN0RGVjbGFyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EaXJlY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUudHlwZVF1YWxpZmllckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVF1YWxpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEFzc2lnbm1lbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRpcmVjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5wYXJhbWV0ZXJUeXBlTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQYXJhbWV0ZXJUeXBlTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EaXJlY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuaWRlbnRpZmllckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSWRlbnRpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0RGVjbGFyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGlyZWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGlyZWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSA5NjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCA5NiwgQ1BhcnNlci5SVUxFX2RpcmVjdERlY2xhcmF0b3IsIF9wKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcyODtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNTcsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzIwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MjE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzIyO1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcyMztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzI1O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MjY7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db2xvbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3Mjc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5EaWdpdFNlcXVlbmNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzc1O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNjQsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc3MztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDYzLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGlyZWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RpcmVjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MzA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA3KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MzE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzMzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihfbGE9PT1DUGFyc2VyLkNvbnN0IHx8ICgoKChfbGEgLSAzNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzNSkpICYgKCgxIDw8IChDUGFyc2VyLlJlc3RyaWN0IC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLlZvbGF0aWxlIC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDM1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDczMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyTGlzdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MzY7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18xKSB8ICgxIDw8IENQYXJzZXIuVF9fMikpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDM5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM5KSkgJiAoKDEgPDwgKENQYXJzZXIuU2l6ZW9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkFsaWdub2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzOSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3MSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3MSkpICYgKCgxIDw8IChDUGFyc2VyLlBsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTm90IC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlRpbGRlIC0gNzEpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMTA1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDEwNSkpICYgKCgxIDw8IChDUGFyc2VyLklkZW50aWZpZXIgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkNvbnN0YW50IC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5TdHJpbmdMaXRlcmFsIC0gMTA1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDczNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDczODtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGlyZWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RpcmVjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3Mzk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA2KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzQxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TdGF0aWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuQ29uc3QgfHwgKCgoKF9sYSAtIDM1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM1KSkgJiAoKDEgPDwgKENQYXJzZXIuUmVzdHJpY3QgLSAzNSkpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzNSkpIHwgKDEgPDwgKENQYXJzZXIuQXRvbWljIC0gMzUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzQyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc0NTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc0NjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGlyZWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RpcmVjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NDg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NDk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzUwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZVF1YWxpZmllckxpc3QoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc1MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RhdGljKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzUyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzUzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBEaXJlY3REZWNsYXJhdG9yQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfZGlyZWN0RGVjbGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc1NTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc1NjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NTg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuQ29uc3QgfHwgKCgoKF9sYSAtIDM1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM1KSkgJiAoKDEgPDwgKENQYXJzZXIuUmVzdHJpY3QgLSAzNSkpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzNSkpIHwgKDEgPDwgKENQYXJzZXIuQXRvbWljIC0gMzUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzU3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc2MDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3Rhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc2MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGlyZWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RpcmVjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NjI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NjM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc2NDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlclR5cGVMaXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc2NTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IERpcmVjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9kaXJlY3REZWNsYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzY3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzY4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NzA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzY5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc3MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzc3O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDY0LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEdjY0RlY2xhcmF0b3JFeHRlbnNpb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZ2NjRGVjbGFyYXRvckV4dGVuc2lvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5HY2NEZWNsYXJhdG9yRXh0ZW5zaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5HY2NEZWNsYXJhdG9yRXh0ZW5zaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHY2NEZWNsYXJhdG9yRXh0ZW5zaW9uQ29udGV4dDtcclxuXHJcbkdjY0RlY2xhcmF0b3JFeHRlbnNpb25Db250ZXh0LnByb3RvdHlwZS5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmKGk9PT11bmRlZmluZWQpIHtcclxuXHRcdGkgPSBudWxsO1xyXG5cdH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCwgaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQucHJvdG90eXBlLmdjY0F0dHJpYnV0ZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChHY2NBdHRyaWJ1dGVTcGVjaWZpZXJDb250ZXh0LDApO1xyXG59O1xyXG5cclxuR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R2NjRGVjbGFyYXRvckV4dGVuc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQgPSBHY2NEZWNsYXJhdG9yRXh0ZW5zaW9uQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmdjY0RlY2xhcmF0b3JFeHRlbnNpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA5OCwgQ1BhcnNlci5SVUxFX2djY0RlY2xhcmF0b3JFeHRlbnNpb24pO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc4NztcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzEwOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzc4O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuVF9fMTApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzc5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc4MTsgXHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3ODA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzgzOyBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICB9IHdoaWxlKF9sYT09PUNQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3ODU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzExOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzg2O1xyXG4gICAgICAgICAgICB0aGlzLmdjY0F0dHJpYnV0ZVNwZWNpZmllcigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBHY2NBdHRyaWJ1dGVTcGVjaWZpZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZ2NjQXR0cmlidXRlU3BlY2lmaWVyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkdjY0F0dHJpYnV0ZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuR2NjQXR0cmlidXRlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHY2NBdHRyaWJ1dGVTcGVjaWZpZXJDb250ZXh0O1xyXG5cclxuR2NjQXR0cmlidXRlU3BlY2lmaWVyQ29udGV4dC5wcm90b3R5cGUuZ2NjQXR0cmlidXRlTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChHY2NBdHRyaWJ1dGVMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkdjY0F0dHJpYnV0ZVNwZWNpZmllckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R2NjQXR0cmlidXRlU3BlY2lmaWVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5HY2NBdHRyaWJ1dGVTcGVjaWZpZXJDb250ZXh0ID0gR2NjQXR0cmlidXRlU3BlY2lmaWVyQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmdjY0F0dHJpYnV0ZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBHY2NBdHRyaWJ1dGVTcGVjaWZpZXJDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTAwLCBDUGFyc2VyLlJVTEVfZ2NjQXR0cmlidXRlU3BlY2lmaWVyKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzg5O1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5UX18xMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc5MDtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzkxO1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA3OTI7XHJcbiAgICAgICAgdGhpcy5nY2NBdHRyaWJ1dGVMaXN0KCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc5MztcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc5NDtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gR2NjQXR0cmlidXRlTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9nY2NBdHRyaWJ1dGVMaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0O1xyXG5cclxuR2NjQXR0cmlidXRlTGlzdENvbnRleHQucHJvdG90eXBlLmdjY0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoR2NjQXR0cmlidXRlQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoR2NjQXR0cmlidXRlQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEdjY0F0dHJpYnV0ZUxpc3QodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0ID0gR2NjQXR0cmlidXRlTGlzdENvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5nY2NBdHRyaWJ1dGVMaXN0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEdjY0F0dHJpYnV0ZUxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTAyLCBDUGFyc2VyLlJVTEVfZ2NjQXR0cmlidXRlTGlzdCk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODA1O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw2OCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3OTY7XHJcbiAgICAgICAgICAgIHRoaXMuZ2NjQXR0cmlidXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIHdoaWxlKF9sYT09PUNQYXJzZXIuQ29tbWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3OTc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc5ODtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2NjQXR0cmlidXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODAzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gR2NjQXR0cmlidXRlQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2djY0F0dHJpYnV0ZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5HY2NBdHRyaWJ1dGVDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkdjY0F0dHJpYnV0ZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2NjQXR0cmlidXRlQ29udGV4dDtcclxuXHJcbkdjY0F0dHJpYnV0ZUNvbnRleHQucHJvdG90eXBlLmFyZ3VtZW50RXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQXJndW1lbnRFeHByZXNzaW9uTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5HY2NBdHRyaWJ1dGVDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEdjY0F0dHJpYnV0ZSh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuR2NjQXR0cmlidXRlQ29udGV4dCA9IEdjY0F0dHJpYnV0ZUNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5nY2NBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgR2NjQXR0cmlidXRlQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEwNCwgQ1BhcnNlci5SVUxFX2djY0F0dHJpYnV0ZSk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODE2O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fNzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fODpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fOTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTA6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzExOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UX18xMjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTM6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkF1dG86XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkJyZWFrOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5DYXNlOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5DaGFyOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db25zdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQ29udGludWU6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkRlZmF1bHQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkRvOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Eb3VibGU6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkVsc2U6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkVudW06XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkV4dGVybjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRmxvYXQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkZvcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuR290bzpcclxuICAgICAgICBjYXNlIENQYXJzZXIuSWY6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLklubGluZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuSW50OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Mb25nOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5SZWdpc3RlcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuUmVzdHJpY3Q6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlJldHVybjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU2hvcnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlNpZ25lZDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU2l6ZW9mOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5TdGF0aWM6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlN0cnVjdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU3dpdGNoOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5UeXBlZGVmOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5VbmlvbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVW5zaWduZWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlZvaWQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlZvbGF0aWxlOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5XaGlsZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQWxpZ25hczpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQWxpZ25vZjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQXRvbWljOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Cb29sOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db21wbGV4OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5HZW5lcmljOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5JbWFnaW5hcnk6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLk5vcmV0dXJuOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5TdGF0aWNBc3NlcnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlRocmVhZExvY2FsOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5MZWZ0QnJhY2tldDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuUmlnaHRCcmFja2V0OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5MZWZ0QnJhY2U6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlJpZ2h0QnJhY2U6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkxlc3M6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkxlc3NFcXVhbDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuR3JlYXRlcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuR3JlYXRlckVxdWFsOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5MZWZ0U2hpZnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlJpZ2h0U2hpZnQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlBsdXM6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlBsdXNQbHVzOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5NaW51czpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTWludXNNaW51czpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU3RhcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRGl2OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Nb2Q6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkFuZDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuT3I6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkFuZEFuZDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuT3JPcjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQ2FyZXQ6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLk5vdDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuVGlsZGU6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlF1ZXN0aW9uOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db2xvbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU2VtaTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQXNzaWduOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5TdGFyQXNzaWduOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5EaXZBc3NpZ246XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLk1vZEFzc2lnbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuUGx1c0Fzc2lnbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTWludXNBc3NpZ246XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkxlZnRTaGlmdEFzc2lnbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuUmlnaHRTaGlmdEFzc2lnbjpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQW5kQXNzaWduOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Yb3JBc3NpZ246XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLk9yQXNzaWduOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5FcXVhbDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTm90RXF1YWw6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkFycm93OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Eb3Q6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkVsbGlwc2lzOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5JZGVudGlmaWVyOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db25zdGFudDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuRGlnaXRTZXF1ZW5jZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuU3RyaW5nTGl0ZXJhbDpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQ29tcGxleERlZmluZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQXNtQmxvY2s6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkxpbmVBZnRlclByZXByb2Nlc3Npbmc6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkxpbmVEaXJlY3RpdmU6XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlByYWdtYURpcmVjdGl2ZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuV2hpdGVzcGFjZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuTmV3bGluZTpcclxuICAgICAgICBjYXNlIENQYXJzZXIuQmxvY2tDb21tZW50OlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5MaW5lQ29tbWVudDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgwNztcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKF9sYTw9MCB8fCAoKCgoX2xhIC0gNTkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNTkpKSAmICgoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSA1OSkpIHwgKDEgPDwgKENQYXJzZXIuUmlnaHRQYXJlbiAtIDU5KSkgfCAoMSA8PCAoQ1BhcnNlci5Db21tYSAtIDU5KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODEzO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZihfbGE9PT1DUGFyc2VyLkxlZnRQYXJlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgwODtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgxMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMCkgfCAoMSA8PCBDUGFyc2VyLlRfXzEpIHwgKDEgPDwgQ1BhcnNlci5UX18yKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzkpKSAmICgoMSA8PCAoQ1BhcnNlci5TaXplb2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25vZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5HZW5lcmljIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDM5KSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5QbHVzUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c01pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSAxMDUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMTA1KSkgJiAoKDEgPDwgKENQYXJzZXIuSWRlbnRpZmllciAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuQ29uc3RhbnQgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkRpZ2l0U2VxdWVuY2UgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLlN0cmluZ0xpdGVyYWwgLSAxMDUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudEV4cHJlc3Npb25MaXN0KDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MTI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5SaWdodFBhcmVuOlxyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5Db21tYTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIE5lc3RlZFBhcmVudGhlc2VzQmxvY2tDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfbmVzdGVkUGFyZW50aGVzZXNCbG9jaztcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5OZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5OZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dDtcclxuXHJcbk5lc3RlZFBhcmVudGhlc2VzQmxvY2tDb250ZXh0LnByb3RvdHlwZS5uZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhOZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTmVzdGVkUGFyZW50aGVzZXNCbG9ja0NvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5OZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5OZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dCA9IE5lc3RlZFBhcmVudGhlc2VzQmxvY2tDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubmVzdGVkUGFyZW50aGVzZXNCbG9jayA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBOZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEwNiwgQ1BhcnNlci5SVUxFX25lc3RlZFBhcmVudGhlc2VzQmxvY2spO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODI1O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB3aGlsZSgoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpIHwgKDEgPDwgQ1BhcnNlci5UX18zKSB8ICgxIDw8IENQYXJzZXIuVF9fNCkgfCAoMSA8PCBDUGFyc2VyLlRfXzUpIHwgKDEgPDwgQ1BhcnNlci5UX182KSB8ICgxIDw8IENQYXJzZXIuVF9fNykgfCAoMSA8PCBDUGFyc2VyLlRfXzgpIHwgKDEgPDwgQ1BhcnNlci5UX185KSB8ICgxIDw8IENQYXJzZXIuVF9fMTApIHwgKDEgPDwgQ1BhcnNlci5UX18xMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzEyKSB8ICgxIDw8IENQYXJzZXIuVF9fMTMpIHwgKDEgPDwgQ1BhcnNlci5BdXRvKSB8ICgxIDw8IENQYXJzZXIuQnJlYWspIHwgKDEgPDwgQ1BhcnNlci5DYXNlKSB8ICgxIDw8IENQYXJzZXIuQ2hhcikgfCAoMSA8PCBDUGFyc2VyLkNvbnN0KSB8ICgxIDw8IENQYXJzZXIuQ29udGludWUpIHwgKDEgPDwgQ1BhcnNlci5EZWZhdWx0KSB8ICgxIDw8IENQYXJzZXIuRG8pIHwgKDEgPDwgQ1BhcnNlci5Eb3VibGUpIHwgKDEgPDwgQ1BhcnNlci5FbHNlKSB8ICgxIDw8IENQYXJzZXIuRW51bSkgfCAoMSA8PCBDUGFyc2VyLkV4dGVybikgfCAoMSA8PCBDUGFyc2VyLkZsb2F0KSB8ICgxIDw8IENQYXJzZXIuRm9yKSB8ICgxIDw8IENQYXJzZXIuR290bykgfCAoMSA8PCBDUGFyc2VyLklmKSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoQ1BhcnNlci5JbnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTG9uZyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXR1cm4gLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2hvcnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGF0aWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RydWN0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN3aXRjaCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UeXBlZGVmIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuaW9uIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuV2hpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25hcyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Cb29sIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkNvbXBsZXggLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5JbWFnaW5hcnkgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTm9yZXR1cm4gLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RhdGljQXNzZXJ0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlRocmVhZExvY2FsIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0QnJhY2tldCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SaWdodEJyYWNrZXQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTGVmdEJyYWNlIC0gMzIpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNjQpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNjQpKSAmICgoMSA8PCAoQ1BhcnNlci5SaWdodEJyYWNlIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkxlc3MgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuTGVzc0VxdWFsIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkdyZWF0ZXIgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuR3JlYXRlckVxdWFsIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRTaGlmdCAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5SaWdodFNoaWZ0IC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXMgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkRpdiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5Nb2QgLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLk9yIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5Pck9yIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkNhcmV0IC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5RdWVzdGlvbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5Db2xvbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5TZW1pIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkNvbW1hIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkFzc2lnbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyQXNzaWduIC0gNjQpKSB8ICgxIDw8IChDUGFyc2VyLkRpdkFzc2lnbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5Nb2RBc3NpZ24gLSA2NCkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c0Fzc2lnbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c0Fzc2lnbiAtIDY0KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0U2hpZnRBc3NpZ24gLSA2NCkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA5NikpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA5NikpICYgKCgxIDw8IChDUGFyc2VyLlJpZ2h0U2hpZnRBc3NpZ24gLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuQW5kQXNzaWduIC0gOTYpKSB8ICgxIDw8IChDUGFyc2VyLlhvckFzc2lnbiAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5PckFzc2lnbiAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5FcXVhbCAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3RFcXVhbCAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5BcnJvdyAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5Eb3QgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuRWxsaXBzaXMgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuSWRlbnRpZmllciAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gOTYpKSB8ICgxIDw8IChDUGFyc2VyLlN0cmluZ0xpdGVyYWwgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuQ29tcGxleERlZmluZSAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5Bc21CbG9jayAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5MaW5lQWZ0ZXJQcmVwcm9jZXNzaW5nIC0gOTYpKSB8ICgxIDw8IChDUGFyc2VyLkxpbmVEaXJlY3RpdmUgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuUHJhZ21hRGlyZWN0aXZlIC0gOTYpKSB8ICgxIDw8IChDUGFyc2VyLldoaXRlc3BhY2UgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuTmV3bGluZSAtIDk2KSkgfCAoMSA8PCAoQ1BhcnNlci5CbG9ja0NvbW1lbnQgLSA5NikpIHwgKDEgPDwgKENQYXJzZXIuTGluZUNvbW1lbnQgLSA5NikpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MjM7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UX18wOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzI6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UX18zOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVF9fNDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UX182OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVF9fNzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzg6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UX185OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTA6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UX18xMTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlRfXzEyOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVF9fMTM6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5BdXRvOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQnJlYWs6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5DYXNlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ2hhcjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkNvbnN0OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ29udGludWU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5EZWZhdWx0OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRG86XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Eb3VibGU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5FbHNlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRW51bTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkV4dGVybjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkZsb2F0OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRm9yOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuR290bzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLklmOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuSW5saW5lOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuSW50OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuTG9uZzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlJlZ2lzdGVyOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuUmVzdHJpY3Q6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5SZXR1cm46XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5TaG9ydDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlNpZ25lZDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlNpemVvZjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlN0YXRpYzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlN0cnVjdDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlN3aXRjaDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlR5cGVkZWY6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5VbmlvbjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlVuc2lnbmVkOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVm9pZDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlZvbGF0aWxlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuV2hpbGU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5BbGlnbmFzOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQWxpZ25vZjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkF0b21pYzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkJvb2w6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Db21wbGV4OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuR2VuZXJpYzpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkltYWdpbmFyeTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLk5vcmV0dXJuOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuU3RhdGljQXNzZXJ0OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuVGhyZWFkTG9jYWw6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5MZWZ0QnJhY2tldDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlJpZ2h0QnJhY2tldDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkxlZnRCcmFjZTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlJpZ2h0QnJhY2U6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5MZXNzOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuTGVzc0VxdWFsOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuR3JlYXRlcjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkdyZWF0ZXJFcXVhbDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkxlZnRTaGlmdDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlJpZ2h0U2hpZnQ6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5QbHVzOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuUGx1c1BsdXM6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5NaW51czpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLk1pbnVzTWludXM6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5TdGFyOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRGl2OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuTW9kOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQW5kOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuT3I6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5BbmRBbmQ6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Pck9yOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ2FyZXQ6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Ob3Q6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5UaWxkZTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlF1ZXN0aW9uOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ29sb246XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5TZW1pOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ29tbWE6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Bc3NpZ246XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5TdGFyQXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRGl2QXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuTW9kQXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuUGx1c0Fzc2lnbjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLk1pbnVzQXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuTGVmdFNoaWZ0QXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuUmlnaHRTaGlmdEFzc2lnbjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkFuZEFzc2lnbjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLlhvckFzc2lnbjpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLk9yQXNzaWduOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRXF1YWw6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Ob3RFcXVhbDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkFycm93OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRG90OlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuRWxsaXBzaXM6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5JZGVudGlmaWVyOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuQ29uc3RhbnQ6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5EaWdpdFNlcXVlbmNlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuU3RyaW5nTGl0ZXJhbDpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkNvbXBsZXhEZWZpbmU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5Bc21CbG9jazpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLkxpbmVBZnRlclByZXByb2Nlc3Npbmc6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5MaW5lRGlyZWN0aXZlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuUHJhZ21hRGlyZWN0aXZlOlxyXG4gICAgICAgICAgICBjYXNlIENQYXJzZXIuV2hpdGVzcGFjZTpcclxuICAgICAgICAgICAgY2FzZSBDUGFyc2VyLk5ld2xpbmU6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5CbG9ja0NvbW1lbnQ6XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5MaW5lQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MTg7XHJcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgIGlmKF9sYTw9MCB8fCBfbGE9PT1DUGFyc2VyLkxlZnRQYXJlbiB8fCBfbGE9PT1DUGFyc2VyLlJpZ2h0UGFyZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ1BhcnNlci5MZWZ0UGFyZW46XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODE5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODIwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRQYXJlbnRoZXNlc0Jsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODIxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Mjc7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBvaW50ZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfcG9pbnRlcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Qb2ludGVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Qb2ludGVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludGVyQ29udGV4dDtcclxuXHJcblBvaW50ZXJDb250ZXh0LnByb3RvdHlwZS50eXBlUXVhbGlmaWVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUeXBlUXVhbGlmaWVyTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Qb2ludGVyQ29udGV4dC5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQb2ludGVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcblBvaW50ZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBvaW50ZXIodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLlBvaW50ZXJDb250ZXh0ID0gUG9pbnRlckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFBvaW50ZXJDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTA4LCBDUGFyc2VyLlJVTEVfcG9pbnRlcik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODQ2O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw3OCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Mjg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TdGFyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzMDtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw3NCx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODI5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyTGlzdCgwKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzMjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlN0YXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODM0O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZihfbGE9PT1DUGFyc2VyLkNvbnN0IHx8ICgoKChfbGEgLSAzNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzNSkpICYgKCgxIDw8IChDUGFyc2VyLlJlc3RyaWN0IC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLlZvbGF0aWxlIC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDM1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MzM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODM2O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzNztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNhcmV0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzOTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw3Nix0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODM4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyTGlzdCgwKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0MTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNhcmV0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0MztcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoX2xhPT09Q1BhcnNlci5Db25zdCB8fCAoKCgoX2xhIC0gMzUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzUpKSAmICgoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5Wb2xhdGlsZSAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyTGlzdCgwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0NTtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVHlwZVF1YWxpZmllckxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfdHlwZVF1YWxpZmllckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuVHlwZVF1YWxpZmllckxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblR5cGVRdWFsaWZpZXJMaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlUXVhbGlmaWVyTGlzdENvbnRleHQ7XHJcblxyXG5UeXBlUXVhbGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLnR5cGVRdWFsaWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVF1YWxpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5UeXBlUXVhbGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLnR5cGVRdWFsaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFR5cGVRdWFsaWZpZXJMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcblR5cGVRdWFsaWZpZXJMaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUeXBlUXVhbGlmaWVyTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUudHlwZVF1YWxpZmllckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFR5cGVRdWFsaWZpZXJMaXN0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDExMDtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAxMTAsIENQYXJzZXIuUlVMRV90eXBlUXVhbGlmaWVyTGlzdCwgX3ApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA4NDk7XHJcbiAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDg1NTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDc5LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFR5cGVRdWFsaWZpZXJMaXN0Q29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV90eXBlUXVhbGlmaWVyTGlzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODUxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NTI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXIoKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1NztcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw3OSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBQYXJhbWV0ZXJUeXBlTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9wYXJhbWV0ZXJUeXBlTGlzdDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5QYXJhbWV0ZXJUeXBlTGlzdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuUGFyYW1ldGVyVHlwZUxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRlclR5cGVMaXN0Q29udGV4dDtcclxuXHJcblBhcmFtZXRlclR5cGVMaXN0Q29udGV4dC5wcm90b3R5cGUucGFyYW1ldGVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQYXJhbWV0ZXJMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcblBhcmFtZXRlclR5cGVMaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQYXJhbWV0ZXJUeXBlTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuUGFyYW1ldGVyVHlwZUxpc3RDb250ZXh0ID0gUGFyYW1ldGVyVHlwZUxpc3RDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUucGFyYW1ldGVyVHlwZUxpc3QgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgUGFyYW1ldGVyVHlwZUxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTEyLCBDUGFyc2VyLlJVTEVfcGFyYW1ldGVyVHlwZUxpc3QpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODYzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw4MCx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NTg7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCgwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1OTtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODYwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODYxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuRWxsaXBzaXMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBhcmFtZXRlckxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfcGFyYW1ldGVyTGlzdDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5QYXJhbWV0ZXJMaXN0Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5QYXJhbWV0ZXJMaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJhbWV0ZXJMaXN0Q29udGV4dDtcclxuXHJcblBhcmFtZXRlckxpc3RDb250ZXh0LnByb3RvdHlwZS5wYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QYXJhbWV0ZXJMaXN0Q29udGV4dC5wcm90b3R5cGUucGFyYW1ldGVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChQYXJhbWV0ZXJMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcblBhcmFtZXRlckxpc3RDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBhcmFtZXRlckxpc3QodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnBhcmFtZXRlckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFBhcmFtZXRlckxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMTE0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDExNCwgQ1BhcnNlci5SVUxFX3BhcmFtZXRlckxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODY2O1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODczO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsODEsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgUGFyYW1ldGVyTGlzdENvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfcGFyYW1ldGVyTGlzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODY4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Njk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3MDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyRGVjbGFyYXRpb24oKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3NTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw4MSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBQYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9wYXJhbWV0ZXJEZWNsYXJhdGlvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5QYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuUGFyYW1ldGVyRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRlckRlY2xhcmF0aW9uQ29udGV4dDtcclxuXHJcblBhcmFtZXRlckRlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb25TcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uU3BlY2lmaWVyc0NvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmRlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVjbGFyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVyczIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVjbGFyYXRpb25TcGVjaWZpZXJzMkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5QYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmFic3RyYWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LDApO1xyXG59O1xyXG5cclxuUGFyYW1ldGVyRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBhcmFtZXRlckRlY2xhcmF0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5QYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQgPSBQYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5wYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBQYXJhbWV0ZXJEZWNsYXJhdGlvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxMTYsIENQYXJzZXIuUlVMRV9wYXJhbWV0ZXJEZWNsYXJhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA4ODM7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDgzLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3NjtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblNwZWNpZmllcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3NztcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdG9yKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Nzk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25TcGVjaWZpZXJzMigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODgxO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDgyLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIGlmKGxhXz09PTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4ODA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFic3RyYWN0RGVjbGFyYXRvcigpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIElkZW50aWZpZXJMaXN0Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2lkZW50aWZpZXJMaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbklkZW50aWZpZXJMaXN0Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5JZGVudGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWRlbnRpZmllckxpc3RDb250ZXh0O1xyXG5cclxuSWRlbnRpZmllckxpc3RDb250ZXh0LnByb3RvdHlwZS5JZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLklkZW50aWZpZXIsIDApO1xyXG59O1xyXG5cclxuSWRlbnRpZmllckxpc3RDb250ZXh0LnByb3RvdHlwZS5pZGVudGlmaWVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJZGVudGlmaWVyTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5JZGVudGlmaWVyTGlzdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWRlbnRpZmllckxpc3QodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmlkZW50aWZpZXJMaXN0ID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBJZGVudGlmaWVyTGlzdENvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSAxMTg7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMTE4LCBDUGFyc2VyLlJVTEVfaWRlbnRpZmllckxpc3QsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODg2O1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODkzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsODQsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgSWRlbnRpZmllckxpc3RDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2lkZW50aWZpZXJMaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4ODg7XHJcbiAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg4OTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db21tYSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODkwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODk1O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDg0LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFR5cGVOYW1lQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3R5cGVOYW1lO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblR5cGVOYW1lQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5UeXBlTmFtZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZU5hbWVDb250ZXh0O1xyXG5cclxuVHlwZU5hbWVDb250ZXh0LnByb3RvdHlwZS5zcGVjaWZpZXJRdWFsaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFNwZWNpZmllclF1YWxpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuVHlwZU5hbWVDb250ZXh0LnByb3RvdHlwZS5hYnN0cmFjdERlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcblR5cGVOYW1lQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUeXBlTmFtZSh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuVHlwZU5hbWVDb250ZXh0ID0gVHlwZU5hbWVDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVHlwZU5hbWVDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTIwLCBDUGFyc2VyLlJVTEVfdHlwZU5hbWUpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gODk2O1xyXG4gICAgICAgIHRoaXMuc3BlY2lmaWVyUXVhbGlmaWVyTGlzdCgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA4OTg7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCgoKChfbGEgLSA1OSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA1OSkpICYgKCgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDU5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0QnJhY2tldCAtIDU5KSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNTkpKSB8ICgxIDw8IChDUGFyc2VyLkNhcmV0IC0gNTkpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODk3O1xyXG4gICAgICAgICAgICB0aGlzLmFic3RyYWN0RGVjbGFyYXRvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2Fic3RyYWN0RGVjbGFyYXRvcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5BYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUG9pbnRlckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmdjY0RlY2xhcmF0b3JFeHRlbnNpb24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEdjY0RlY2xhcmF0b3JFeHRlbnNpb25Db250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChHY2NEZWNsYXJhdG9yRXh0ZW5zaW9uQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QWJzdHJhY3REZWNsYXJhdG9yKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5BYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0ID0gQWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmFic3RyYWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTIyLCBDUGFyc2VyLlJVTEVfYWJzdHJhY3REZWNsYXJhdG9yKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA5MTE7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDg4LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkwMDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MDI7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuU3RhciB8fCBfbGE9PT1DUGFyc2VyLkNhcmV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MDQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTA4O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw4Nyx0aGlzLl9jdHgpXHJcbiAgICAgICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MDU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY2NEZWNsYXJhdG9yRXh0ZW5zaW9uKCk7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkxMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDg3LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2RpcmVjdEFic3RyYWN0RGVjbGFyYXRvcjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkRpcmVjdEFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dDtcclxuXHJcbkRpcmVjdEFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQucHJvdG90eXBlLmFic3RyYWN0RGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2NjRGVjbGFyYXRvckV4dGVuc2lvbiA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoR2NjRGVjbGFyYXRvckV4dGVuc2lvbkNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEdjY0RlY2xhcmF0b3JFeHRlbnNpb25Db250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUudHlwZVF1YWxpZmllckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHlwZVF1YWxpZmllckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuYXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUucGFyYW1ldGVyVHlwZUxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoUGFyYW1ldGVyVHlwZUxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERpcmVjdEFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdEFic3RyYWN0RGVjbGFyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBEaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMTI0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDEyNCwgQ1BhcnNlci5SVUxFX2RpcmVjdEFic3RyYWN0RGVjbGFyYXRvciwgX3ApO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gOTU5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw5NSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MTQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTE1O1xyXG4gICAgICAgICAgICB0aGlzLmFic3RyYWN0RGVjbGFyYXRvcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTE2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MjA7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDg5LHRoaXMuX2N0eClcclxuICAgICAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkxNztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjY0RlY2xhcmF0b3JFeHRlbnNpb24oKTsgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTIyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsODksdGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkyMztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkyNTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoX2xhPT09Q1BhcnNlci5Db25zdCB8fCAoKCgoX2xhIC0gMzUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzUpKSAmICgoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5Wb2xhdGlsZSAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTI0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlUXVhbGlmaWVyTGlzdCgwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkyODtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMCkgfCAoMSA8PCBDUGFyc2VyLlRfXzEpIHwgKDEgPDwgQ1BhcnNlci5UX18yKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzkpKSAmICgoMSA8PCAoQ1BhcnNlci5TaXplb2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25vZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5HZW5lcmljIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDM5KSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5QbHVzUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c01pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSAxMDUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMTA1KSkgJiAoKDEgPDwgKENQYXJzZXIuSWRlbnRpZmllciAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuQ29uc3RhbnQgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkRpZ2l0U2VxdWVuY2UgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLlN0cmluZ0xpdGVyYWwgLSAxMDUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkyNztcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkzMDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0QnJhY2tldCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MzE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2tldCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MzI7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TdGF0aWMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTM0O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZihfbGE9PT1DUGFyc2VyLkNvbnN0IHx8ICgoKChfbGEgLSAzNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzNSkpICYgKCgxIDw8IChDUGFyc2VyLlJlc3RyaWN0IC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLlZvbGF0aWxlIC0gMzUpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDM1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MzM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTM2O1xyXG4gICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Mzc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTM5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNrZXQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTQwO1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0KDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTQxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RhdGljKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0MjtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTQzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0NTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0NjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlN0YXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTQ3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFja2V0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTA7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18zKSB8ICgxIDw8IENQYXJzZXIuVF9fNCkgfCAoMSA8PCBDUGFyc2VyLlRfXzUpIHwgKDEgPDwgQ1BhcnNlci5UX182KSB8ICgxIDw8IENQYXJzZXIuVF9fNykgfCAoMSA8PCBDUGFyc2VyLlRfXzgpIHwgKDEgPDwgQ1BhcnNlci5UX185KSB8ICgxIDw8IENQYXJzZXIuVF9fMTEpIHwgKDEgPDwgQ1BhcnNlci5BdXRvKSB8ICgxIDw8IENQYXJzZXIuQ2hhcikgfCAoMSA8PCBDUGFyc2VyLkNvbnN0KSB8ICgxIDw8IENQYXJzZXIuRG91YmxlKSB8ICgxIDw8IENQYXJzZXIuRW51bSkgfCAoMSA8PCBDUGFyc2VyLkV4dGVybikgfCAoMSA8PCBDUGFyc2VyLkZsb2F0KSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoQ1BhcnNlci5JbnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTG9uZyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaG9ydCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaWduZWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RhdGljIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN0cnVjdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UeXBlZGVmIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuaW9uIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25hcyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQm9vbCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Db21wbGV4IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLk5vcmV0dXJuIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlRocmVhZExvY2FsIC0gMzIpKSkpICE9PSAwKSB8fCBfbGE9PT1DUGFyc2VyLklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NDk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlclR5cGVMaXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTI7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk1NjtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsOTQsdGhpcy5fY3R4KVxyXG4gICAgICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTUzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NjRGVjbGFyYXRvckV4dGVuc2lvbigpOyBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCw5NCx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDA0O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTAyLHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDAyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTAxLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBDUGFyc2VyLlJVTEVfZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTYxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDUpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTYyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2tldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk2NDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoX2xhPT09Q1BhcnNlci5Db25zdCB8fCAoKCgoX2xhIC0gMzUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzUpKSAmICgoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5Wb2xhdGlsZSAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NjM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZVF1YWxpZmllckxpc3QoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTY3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzOSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzOSkpICYgKCgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkdlbmVyaWMgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzkpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNzEpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNzEpKSAmICgoMSA8PCAoQ1BhcnNlci5QbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXNQbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU3RhciAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NjY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Njk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0QnJhY2tldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IERpcmVjdEFic3RyYWN0RGVjbGFyYXRvckNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RpcmVjdEFic3RyYWN0RGVjbGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk3MDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk3MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NzI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlN0YXRpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk3NDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoX2xhPT09Q1BhcnNlci5Db25zdCB8fCAoKCgoX2xhIC0gMzUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzUpKSAmICgoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5Wb2xhdGlsZSAtIDM1KSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NzM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZVF1YWxpZmllckxpc3QoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTc2O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTc3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBEaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Nzk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZVF1YWxpZmllckxpc3QoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk4MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RhdGljKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTgzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTg0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBEaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODY7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTg4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TdGFyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTg5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBEaXJlY3RBYnN0cmFjdERlY2xhcmF0b3JDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5OTA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5OTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk5MztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMCkgfCAoMSA8PCBDUGFyc2VyLlRfXzMpIHwgKDEgPDwgQ1BhcnNlci5UX180KSB8ICgxIDw8IENQYXJzZXIuVF9fNSkgfCAoMSA8PCBDUGFyc2VyLlRfXzYpIHwgKDEgPDwgQ1BhcnNlci5UX183KSB8ICgxIDw8IENQYXJzZXIuVF9fOCkgfCAoMSA8PCBDUGFyc2VyLlRfXzkpIHwgKDEgPDwgQ1BhcnNlci5UX18xMSkgfCAoMSA8PCBDUGFyc2VyLkF1dG8pIHwgKDEgPDwgQ1BhcnNlci5DaGFyKSB8ICgxIDw8IENQYXJzZXIuQ29uc3QpIHwgKDEgPDwgQ1BhcnNlci5Eb3VibGUpIHwgKDEgPDwgQ1BhcnNlci5FbnVtKSB8ICgxIDw8IENQYXJzZXIuRXh0ZXJuKSB8ICgxIDw8IENQYXJzZXIuRmxvYXQpIHwgKDEgPDwgQ1BhcnNlci5JbmxpbmUpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzMikpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzMikpICYgKCgxIDw8IChDUGFyc2VyLkludCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Mb25nIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlJlZ2lzdGVyIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlJlc3RyaWN0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlNob3J0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlNpZ25lZCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGF0aWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RydWN0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlR5cGVkZWYgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVW5pb24gLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVW5zaWduZWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9pZCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Wb2xhdGlsZSAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbmFzIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Cb29sIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkNvbXBsZXggLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTm9yZXR1cm4gLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVGhyZWFkTG9jYWwgLSAzMikpKSkgIT09IDApIHx8IF9sYT09PUNQYXJzZXIuSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlclR5cGVMaXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTk1O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTk5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTAwLHRoaXMuX2N0eClcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk5NjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NjRGVjbGFyYXRvckV4dGVuc2lvbigpOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAwMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMDAsdGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDY7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTAyLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFR5cGVkZWZOYW1lQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3R5cGVkZWZOYW1lO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblR5cGVkZWZOYW1lQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5UeXBlZGVmTmFtZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRlZk5hbWVDb250ZXh0O1xyXG5cclxuVHlwZWRlZk5hbWVDb250ZXh0LnByb3RvdHlwZS5JZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLklkZW50aWZpZXIsIDApO1xyXG59O1xyXG5cclxuVHlwZWRlZk5hbWVDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFR5cGVkZWZOYW1lKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5UeXBlZGVmTmFtZUNvbnRleHQgPSBUeXBlZGVmTmFtZUNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS50eXBlZGVmTmFtZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBUeXBlZGVmTmFtZUNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxMjYsIENQYXJzZXIuUlVMRV90eXBlZGVmTmFtZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDc7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEluaXRpYWxpemVyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2luaXRpYWxpemVyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkluaXRpYWxpemVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Jbml0aWFsaXplckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5pdGlhbGl6ZXJDb250ZXh0O1xyXG5cclxuSW5pdGlhbGl6ZXJDb250ZXh0LnByb3RvdHlwZS5hc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChBc3NpZ25tZW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Jbml0aWFsaXplckNvbnRleHQucHJvdG90eXBlLmluaXRpYWxpemVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0aWFsaXplckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuSW5pdGlhbGl6ZXJDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluaXRpYWxpemVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Jbml0aWFsaXplckNvbnRleHQgPSBJbml0aWFsaXplckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5pbml0aWFsaXplciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBJbml0aWFsaXplckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxMjgsIENQYXJzZXIuUlVMRV9pbml0aWFsaXplcik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDE5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMDMsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAwOTtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAxMDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRCcmFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDExO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyTGlzdCgwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTI7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2UpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAxNTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplckxpc3QoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDE2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAxNztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0QnJhY2UpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEluaXRpYWxpemVyTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9pbml0aWFsaXplckxpc3Q7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSW5pdGlhbGl6ZXJMaXN0Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Jbml0aWFsaXplckxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluaXRpYWxpemVyTGlzdENvbnRleHQ7XHJcblxyXG5Jbml0aWFsaXplckxpc3RDb250ZXh0LnByb3RvdHlwZS5pbml0aWFsaXplciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0aWFsaXplckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Jbml0aWFsaXplckxpc3RDb250ZXh0LnByb3RvdHlwZS5kZXNpZ25hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZXNpZ25hdGlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Jbml0aWFsaXplckxpc3RDb250ZXh0LnByb3RvdHlwZS5pbml0aWFsaXplckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSW5pdGlhbGl6ZXJMaXN0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkluaXRpYWxpemVyTGlzdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5pdGlhbGl6ZXJMaXN0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5pbml0aWFsaXplckxpc3QgPSBmdW5jdGlvbihfcCkge1xyXG5cdGlmKF9wPT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIF9wID0gMDtcclxuXHR9XHJcbiAgICB2YXIgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIHZhciBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEluaXRpYWxpemVyTGlzdENvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSAxMzA7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgMTMwLCBDUGFyc2VyLlJVTEVfaW5pdGlhbGl6ZXJMaXN0LCBfcCk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDIzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZihfbGE9PT1DUGFyc2VyLkxlZnRCcmFja2V0IHx8IF9sYT09PUNQYXJzZXIuRG90KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDIyO1xyXG4gICAgICAgICAgICB0aGlzLmRlc2lnbmF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gMTAyNTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVyKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzU7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMDYsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgSW5pdGlhbGl6ZXJMaXN0Q29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9pbml0aWFsaXplckxpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMjc7XHJcbiAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMjg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgIGlmKF9sYT09PUNQYXJzZXIuTGVmdEJyYWNrZXQgfHwgX2xhPT09Q1BhcnNlci5Eb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAyOTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2lnbmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyKCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDM3O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEwNix0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZXNpZ25hdGlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9kZXNpZ25hdGlvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EZXNpZ25hdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVzaWduYXRpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlc2lnbmF0aW9uQ29udGV4dDtcclxuXHJcbkRlc2lnbmF0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVzaWduYXRvckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVzaWduYXRvckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGVzaWduYXRpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlc2lnbmF0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5EZXNpZ25hdGlvbkNvbnRleHQgPSBEZXNpZ25hdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5kZXNpZ25hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBEZXNpZ25hdGlvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxMzIsIENQYXJzZXIuUlVMRV9kZXNpZ25hdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzg7XHJcbiAgICAgICAgdGhpcy5kZXNpZ25hdG9yTGlzdCgwKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTAzOTtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQXNzaWduKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZXNpZ25hdG9yTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9kZXNpZ25hdG9yTGlzdDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EZXNpZ25hdG9yTGlzdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVzaWduYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlc2lnbmF0b3JMaXN0Q29udGV4dDtcclxuXHJcbkRlc2lnbmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuZGVzaWduYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZXNpZ25hdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRlc2lnbmF0b3JMaXN0Q29udGV4dC5wcm90b3R5cGUuZGVzaWduYXRvckxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVzaWduYXRvckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRGVzaWduYXRvckxpc3RDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlc2lnbmF0b3JMaXN0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5kZXNpZ25hdG9yTGlzdCA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGVzaWduYXRvckxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMTM0O1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDEzNCwgQ1BhcnNlci5SVUxFX2Rlc2lnbmF0b3JMaXN0LCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDI7XHJcbiAgICAgICAgdGhpcy5kZXNpZ25hdG9yKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDg7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMDcsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgRGVzaWduYXRvckxpc3RDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2Rlc2lnbmF0b3JMaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDQ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDQ1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXNpZ25hdG9yKCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDUwO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEwNyx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZXNpZ25hdG9yQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2Rlc2lnbmF0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRGVzaWduYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVzaWduYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVzaWduYXRvckNvbnRleHQ7XHJcblxyXG5EZXNpZ25hdG9yQ29udGV4dC5wcm90b3R5cGUuY29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZXNpZ25hdG9yQ29udGV4dC5wcm90b3R5cGUuSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5JZGVudGlmaWVyLCAwKTtcclxufTtcclxuXHJcbkRlc2lnbmF0b3JDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlc2lnbmF0b3IodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkRlc2lnbmF0b3JDb250ZXh0ID0gRGVzaWduYXRvckNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5kZXNpZ25hdG9yID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IERlc2lnbmF0b3JDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTM2LCBDUGFyc2VyLlJVTEVfZGVzaWduYXRvcik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDU3O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcclxuICAgICAgICBjYXNlIENQYXJzZXIuTGVmdEJyYWNrZXQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDUxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdEJyYWNrZXQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA1MjtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodEJyYWNrZXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENQYXJzZXIuRG90OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA1NTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkRvdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDU2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX3N0YXRpY0Fzc2VydERlY2xhcmF0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5TdGF0aWNBc3NlcnREZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGljQXNzZXJ0RGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuU3RhdGljQXNzZXJ0RGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKGkpIHtcclxuXHRpZihpPT09dW5kZWZpbmVkKSB7XHJcblx0XHRpID0gbnVsbDtcclxuXHR9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VucyhDUGFyc2VyLlN0cmluZ0xpdGVyYWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLlN0cmluZ0xpdGVyYWwsIGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblN0YXRpY0Fzc2VydERlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGF0aWNBc3NlcnREZWNsYXJhdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuU3RhdGljQXNzZXJ0RGVjbGFyYXRpb25Db250ZXh0ID0gU3RhdGljQXNzZXJ0RGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuc3RhdGljQXNzZXJ0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgU3RhdGljQXNzZXJ0RGVjbGFyYXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTM4LCBDUGFyc2VyLlJVTEVfc3RhdGljQXNzZXJ0RGVjbGFyYXRpb24pO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTA1OTtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RhdGljQXNzZXJ0KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTA2MDtcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTA2MTtcclxuICAgICAgICB0aGlzLmNvbnN0YW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDYyO1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db21tYSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNjQ7IFxyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDYzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDY2OyBcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB9IHdoaWxlKF9sYT09PUNQYXJzZXIuU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNjg7XHJcbiAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDY5O1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfc3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUubGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChMYWJlbGVkU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbXBvdW5kU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbXBvdW5kU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5zZWxlY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU2VsZWN0aW9uU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLml0ZXJhdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuanVtcFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChKdW1wU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmxvZ2ljYWxPckV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKExvZ2ljYWxPckV4cHJlc3Npb25Db250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChMb2dpY2FsT3JFeHByZXNzaW9uQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5TdGF0ZW1lbnRDb250ZXh0ID0gU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBTdGF0ZW1lbnRDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTQwLCBDUGFyc2VyLlJVTEVfc3RhdGVtZW50KTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTA4O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMTUsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA3MTtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbGVkU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDcyO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvdW5kU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDczO1xyXG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCA0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNzQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDc1O1xyXG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvblN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA3NjtcclxuICAgICAgICAgICAgdGhpcy5qdW1wU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDc3O1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoIShfbGE9PT1DUGFyc2VyLlRfXzEwIHx8IF9sYT09PUNQYXJzZXIuVF9fMTIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNzg7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKF9sYT09PUNQYXJzZXIuVF9fMTMgfHwgX2xhPT09Q1BhcnNlci5Wb2xhdGlsZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA3OTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDg4O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzOSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzOSkpICYgKCgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkdlbmVyaWMgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzkpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNzEpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNzEpKSAmICgoMSA8PCAoQ1BhcnNlci5QbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXNQbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU3RhciAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA4MDtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9naWNhbE9yRXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDg1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShfbGE9PT1DUGFyc2VyLkNvbW1hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbW1hKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA4MjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2ljYWxPckV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEwMztcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgd2hpbGUoX2xhPT09Q1BhcnNlci5Db2xvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29sb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18xKSB8ICgxIDw8IENQYXJzZXIuVF9fMikpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDM5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM5KSkgJiAoKDEgPDwgKENQYXJzZXIuU2l6ZW9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkFsaWdub2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzOSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3MSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3MSkpICYgKCgxIDw8IChDUGFyc2VyLlBsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTm90IC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlRpbGRlIC0gNzEpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMTA1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDEwNSkpICYgKCgxIDw8IChDUGFyc2VyLklkZW50aWZpZXIgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkNvbnN0YW50IC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5TdHJpbmdMaXRlcmFsIC0gMTA1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA5MTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2ljYWxPckV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTY7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKF9sYT09PUNQYXJzZXIuQ29tbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Db21tYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDkzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2ljYWxPckV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDk4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEwNTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTA2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTA3O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU2VtaSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gTGFiZWxlZFN0YXRlbWVudENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9sYWJlbGVkU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkxhYmVsZWRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkxhYmVsZWRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhYmVsZWRTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuTGFiZWxlZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuSWRlbnRpZmllciwgMCk7XHJcbn07XHJcblxyXG5MYWJlbGVkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuc3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0YXRlbWVudENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5MYWJlbGVkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5MYWJlbGVkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMYWJlbGVkU3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5MYWJlbGVkU3RhdGVtZW50Q29udGV4dCA9IExhYmVsZWRTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBMYWJlbGVkU3RhdGVtZW50Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDE0MiwgQ1BhcnNlci5SVUxFX2xhYmVsZWRTdGF0ZW1lbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTEyMTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTEwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTExO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29sb24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTExMjtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLkNhc2U6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTEzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ2FzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTE0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTExNTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbG9uKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMTY7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5EZWZhdWx0OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTExODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkRlZmF1bHQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTExOTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbG9uKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjA7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIENvbXBvdW5kU3RhdGVtZW50Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2NvbXBvdW5kU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkNvbXBvdW5kU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Db21wb3VuZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcG91bmRTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuQ29tcG91bmRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5ibG9ja0l0ZW1MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEJsb2NrSXRlbUxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuQ29tcG91bmRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbXBvdW5kU3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Db21wb3VuZFN0YXRlbWVudENvbnRleHQgPSBDb21wb3VuZFN0YXRlbWVudENvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5jb21wb3VuZFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBDb21wb3VuZFN0YXRlbWVudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNDQsIENQYXJzZXIuUlVMRV9jb21wb3VuZFN0YXRlbWVudCk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTIzO1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0QnJhY2UpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTI1O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpIHwgKDEgPDwgQ1BhcnNlci5UX18zKSB8ICgxIDw8IENQYXJzZXIuVF9fNCkgfCAoMSA8PCBDUGFyc2VyLlRfXzUpIHwgKDEgPDwgQ1BhcnNlci5UX182KSB8ICgxIDw8IENQYXJzZXIuVF9fNykgfCAoMSA8PCBDUGFyc2VyLlRfXzgpIHwgKDEgPDwgQ1BhcnNlci5UX185KSB8ICgxIDw8IENQYXJzZXIuVF9fMTApIHwgKDEgPDwgQ1BhcnNlci5UX18xMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzEyKSB8ICgxIDw8IENQYXJzZXIuQXV0bykgfCAoMSA8PCBDUGFyc2VyLkJyZWFrKSB8ICgxIDw8IENQYXJzZXIuQ2FzZSkgfCAoMSA8PCBDUGFyc2VyLkNoYXIpIHwgKDEgPDwgQ1BhcnNlci5Db25zdCkgfCAoMSA8PCBDUGFyc2VyLkNvbnRpbnVlKSB8ICgxIDw8IENQYXJzZXIuRGVmYXVsdCkgfCAoMSA8PCBDUGFyc2VyLkRvKSB8ICgxIDw8IENQYXJzZXIuRG91YmxlKSB8ICgxIDw8IENQYXJzZXIuRW51bSkgfCAoMSA8PCBDUGFyc2VyLkV4dGVybikgfCAoMSA8PCBDUGFyc2VyLkZsb2F0KSB8ICgxIDw8IENQYXJzZXIuRm9yKSB8ICgxIDw8IENQYXJzZXIuR290bykgfCAoMSA8PCBDUGFyc2VyLklmKSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoQ1BhcnNlci5JbnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTG9uZyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXR1cm4gLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2hvcnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGF0aWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RydWN0IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN3aXRjaCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UeXBlZGVmIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuaW9uIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuV2hpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25hcyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkF0b21pYyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Cb29sIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkNvbXBsZXggLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3JldHVybiAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGF0aWNBc3NlcnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVGhyZWFkTG9jYWwgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRCcmFjZSAtIDMyKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5QbHVzUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c01pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU2VtaSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTI0O1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrSXRlbUxpc3QoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gMTEyNztcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRCcmFjZSk7XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQmxvY2tJdGVtTGlzdENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9ibG9ja0l0ZW1MaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkJsb2NrSXRlbUxpc3RDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkJsb2NrSXRlbUxpc3RDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2NrSXRlbUxpc3RDb250ZXh0O1xyXG5cclxuQmxvY2tJdGVtTGlzdENvbnRleHQucHJvdG90eXBlLmJsb2NrSXRlbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChCbG9ja0l0ZW1Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQmxvY2tJdGVtTGlzdENvbnRleHQucHJvdG90eXBlLmJsb2NrSXRlbUxpc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQmxvY2tJdGVtTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5CbG9ja0l0ZW1MaXN0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCbG9ja0l0ZW1MaXN0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5ibG9ja0l0ZW1MaXN0ID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBCbG9ja0l0ZW1MaXN0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDE0NjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAxNDYsIENQYXJzZXIuUlVMRV9ibG9ja0l0ZW1MaXN0LCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExMzA7XHJcbiAgICAgICAgdGhpcy5ibG9ja0l0ZW0oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTEzNjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDExOCx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBCbG9ja0l0ZW1MaXN0Q29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIENQYXJzZXIuUlVMRV9ibG9ja0l0ZW1MaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTMyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTMzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0l0ZW0oKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMzg7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTE4LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2NrSXRlbUNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9ibG9ja0l0ZW07XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQmxvY2tJdGVtQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5CbG9ja0l0ZW1Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2NrSXRlbUNvbnRleHQ7XHJcblxyXG5CbG9ja0l0ZW1Db250ZXh0LnByb3RvdHlwZS5kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdGlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5CbG9ja0l0ZW1Db250ZXh0LnByb3RvdHlwZS5zdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkJsb2NrSXRlbUNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmxvY2tJdGVtKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5CbG9ja0l0ZW1Db250ZXh0ID0gQmxvY2tJdGVtQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmJsb2NrSXRlbSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBCbG9ja0l0ZW1Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTQ4LCBDUGFyc2VyLlJVTEVfYmxvY2tJdGVtKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDE7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDExOSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTM5O1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTQwO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZXhwcmVzc2lvblN0YXRlbWVudDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5FeHByZXNzaW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5FeHByZXNzaW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHByZXNzaW9uU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkV4cHJlc3Npb25TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQgPSBFeHByZXNzaW9uU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNTAsIENQYXJzZXIuUlVMRV9leHByZXNzaW9uU3RhdGVtZW50KTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDQ7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18xKSB8ICgxIDw8IENQYXJzZXIuVF9fMikpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDM5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM5KSkgJiAoKDEgPDwgKENQYXJzZXIuU2l6ZW9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkFsaWdub2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzOSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3MSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3MSkpICYgKCgxIDw8IChDUGFyc2VyLlBsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTm90IC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlRpbGRlIC0gNzEpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMTA1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDEwNSkpICYgKCgxIDw8IChDUGFyc2VyLklkZW50aWZpZXIgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkNvbnN0YW50IC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5TdHJpbmdMaXRlcmFsIC0gMTA1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDM7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTQ2O1xyXG4gICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTZWxlY3Rpb25TdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfc2VsZWN0aW9uU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblNlbGVjdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU2VsZWN0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWxlY3Rpb25TdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuU2VsZWN0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblNlbGVjdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLnN0YXRlbWVudCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoU3RhdGVtZW50Q29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU3RhdGVtZW50Q29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2VsZWN0aW9uU3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5TZWxlY3Rpb25TdGF0ZW1lbnRDb250ZXh0ID0gU2VsZWN0aW9uU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnNlbGVjdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBTZWxlY3Rpb25TdGF0ZW1lbnRDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTUyLCBDUGFyc2VyLlJVTEVfc2VsZWN0aW9uU3RhdGVtZW50KTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExNjM7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLl9pbnB1dC5MQSgxKSkge1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5JZjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5JZik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTQ5O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNTA7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNTE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNTI7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTU1O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEyMSx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE1MztcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5FbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTU0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDUGFyc2VyLlN3aXRjaDpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNTc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Td2l0Y2gpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE1ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkxlZnRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTU5O1xyXG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTYwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTYxO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBJdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfaXRlcmF0aW9uU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkl0ZXJhdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuV2hpbGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuV2hpbGUsIDApO1xyXG59O1xyXG5cclxuSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkl0ZXJhdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLnN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChTdGF0ZW1lbnRDb250ZXh0LDApO1xyXG59O1xyXG5cclxuSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuRG8gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKENQYXJzZXIuRG8sIDApO1xyXG59O1xyXG5cclxuSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuRm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLkZvciwgMCk7XHJcbn07XHJcblxyXG5JdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5mb3JDb25kaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRm9yQ29uZGl0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkl0ZXJhdGlvblN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SXRlcmF0aW9uU3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5JdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0ID0gSXRlcmF0aW9uU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLml0ZXJhdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBJdGVyYXRpb25TdGF0ZW1lbnRDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTU0LCBDUGFyc2VyLlJVTEVfaXRlcmF0aW9uU3RhdGVtZW50KTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExODU7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLl9pbnB1dC5MQSgxKSkge1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5XaGlsZTpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNjU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5XaGlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTY2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNjc7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNjg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5SaWdodFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNjk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ1BhcnNlci5EbzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNzE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5Ebyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTcyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE3MztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLldoaWxlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNzQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5MZWZ0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE3NTtcclxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE3NjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlJpZ2h0UGFyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE3NztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENQYXJzZXIuRm9yOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE3OTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkZvcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTgwO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuTGVmdFBhcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExODE7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yQ29uZGl0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTgyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmlnaHRQYXJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTgzO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBGb3JDb25kaXRpb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZm9yQ29uZGl0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkZvckNvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRm9yQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb3JDb25kaXRpb25Db250ZXh0O1xyXG5cclxuRm9yQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuZm9yRGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRm9yRGVjbGFyYXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRm9yQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuZm9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRm9yRXhwcmVzc2lvbkNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEZvckV4cHJlc3Npb25Db250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRm9yQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkZvckNvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Rm9yQ29uZGl0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Gb3JDb25kaXRpb25Db250ZXh0ID0gRm9yQ29uZGl0aW9uQ29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmZvckNvbmRpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBGb3JDb25kaXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTU2LCBDUGFyc2VyLlJVTEVfZm9yQ29uZGl0aW9uKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjA3O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMjksdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE4NztcclxuICAgICAgICAgICAgdGhpcy5mb3JEZWNsYXJhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE4ODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE5MDtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMCkgfCAoMSA8PCBDUGFyc2VyLlRfXzEpIHwgKDEgPDwgQ1BhcnNlci5UX18yKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzkpKSAmICgoMSA8PCAoQ1BhcnNlci5TaXplb2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25vZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5HZW5lcmljIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDM5KSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5QbHVzUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c01pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSAxMDUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMTA1KSkgJiAoKDEgPDwgKENQYXJzZXIuSWRlbnRpZmllciAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuQ29uc3RhbnQgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkRpZ2l0U2VxdWVuY2UgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLlN0cmluZ0xpdGVyYWwgLSAxMDUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExODk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvckV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTkyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU2VtaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTk0O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzOSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzOSkpICYgKCgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkdlbmVyaWMgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzkpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNzEpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNzEpKSAmICgoMSA8PCAoQ1BhcnNlci5QbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXNQbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU3RhciAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE5MztcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9yRXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExOTc7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18xKSB8ICgxIDw8IENQYXJzZXIuVF9fMikpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDM5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM5KSkgJiAoKDEgPDwgKENQYXJzZXIuU2l6ZW9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkFsaWdub2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzOSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3MSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3MSkpICYgKCgxIDw8IChDUGFyc2VyLlBsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTm90IC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlRpbGRlIC0gNzEpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMTA1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDEwNSkpICYgKCgxIDw8IChDUGFyc2VyLklkZW50aWZpZXIgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkNvbnN0YW50IC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5TdHJpbmdMaXRlcmFsIC0gMTA1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTk2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE5OTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIwMTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgaWYoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IENQYXJzZXIuVF9fMCkgfCAoMSA8PCBDUGFyc2VyLlRfXzEpIHwgKDEgPDwgQ1BhcnNlci5UX18yKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzkpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzkpKSAmICgoMSA8PCAoQ1BhcnNlci5TaXplb2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25vZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5HZW5lcmljIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkxlZnRQYXJlbiAtIDM5KSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDcxKSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDcxKSkgJiAoKDEgPDwgKENQYXJzZXIuUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5QbHVzUGx1cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5NaW51c01pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXIgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZEFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5Ob3QgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuVGlsZGUgLSA3MSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSAxMDUpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMTA1KSkgJiAoKDEgPDwgKENQYXJzZXIuSWRlbnRpZmllciAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuQ29uc3RhbnQgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkRpZ2l0U2VxdWVuY2UgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLlN0cmluZ0xpdGVyYWwgLSAxMDUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvckV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjAzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU2VtaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjA1O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZigoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgQ1BhcnNlci5UX18wKSB8ICgxIDw8IENQYXJzZXIuVF9fMSkgfCAoMSA8PCBDUGFyc2VyLlRfXzIpKSkgIT09IDApIHx8ICgoKChfbGEgLSAzOSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzOSkpICYgKCgxIDw8IChDUGFyc2VyLlNpemVvZiAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5BbGlnbm9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkdlbmVyaWMgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuTGVmdFBhcmVuIC0gMzkpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gNzEpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gNzEpKSAmICgoMSA8PCAoQ1BhcnNlci5QbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlBsdXNQbHVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk1pbnVzTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuU3RhciAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuQW5kQW5kIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLk5vdCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5UaWxkZSAtIDcxKSkpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDEwNSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAxMDUpKSAmICgoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5Db25zdGFudCAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuRGlnaXRTZXF1ZW5jZSAtIDEwNSkpIHwgKDEgPDwgKENQYXJzZXIuU3RyaW5nTGl0ZXJhbCAtIDEwNSkpKSkgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIwNDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9yRXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBGb3JEZWNsYXJhdGlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9mb3JEZWNsYXJhdGlvbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Gb3JEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRm9yRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZvckRlY2xhcmF0aW9uQ29udGV4dDtcclxuXHJcbkZvckRlY2xhcmF0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb25TcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uU3BlY2lmaWVyc0NvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Gb3JEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmluaXREZWNsYXJhdG9yTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0RGVjbGFyYXRvckxpc3RDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRm9yRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZvckRlY2xhcmF0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Gb3JEZWNsYXJhdGlvbkNvbnRleHQgPSBGb3JEZWNsYXJhdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5mb3JEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBGb3JEZWNsYXJhdGlvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNTgsIENQYXJzZXIuUlVMRV9mb3JEZWNsYXJhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjEzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMzAsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIwOTtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblNwZWNpZmllcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdERlY2xhcmF0b3JMaXN0KDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIxMjtcclxuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblNwZWNpZmllcnMoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBGb3JFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2ZvckV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRm9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRm9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9yRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5Gb3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQXNzaWdubWVudEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRm9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmZvckV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRm9yRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Gb3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGb3JFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5mb3JFeHByZXNzaW9uID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBGb3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDE2MDtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAxNjAsIENQYXJzZXIuUlVMRV9mb3JFeHByZXNzaW9uLCBfcCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTY7XHJcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjIzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTMxLHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEZvckV4cHJlc3Npb25Db250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2ZvckV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTg7XHJcbiAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhbnRscjQuZXJyb3IuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuQ29tbWEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRFeHByZXNzaW9uKCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjI1O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEzMSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBKdW1wU3RhdGVtZW50Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gQ1BhcnNlci5SVUxFX2p1bXBTdGF0ZW1lbnQ7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSnVtcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSnVtcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSnVtcFN0YXRlbWVudENvbnRleHQ7XHJcblxyXG5KdW1wU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oQ1BhcnNlci5JZGVudGlmaWVyLCAwKTtcclxufTtcclxuXHJcbkp1bXBTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuSnVtcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLnVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChVbmFyeUV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuSnVtcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SnVtcFN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuSnVtcFN0YXRlbWVudENvbnRleHQgPSBKdW1wU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmp1bXBTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgSnVtcFN0YXRlbWVudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNjIsIENQYXJzZXIuUlVMRV9qdW1wU3RhdGVtZW50KTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjQyO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMzMsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIyNjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkdvdG8pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIyNztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLklkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIyODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIyOTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkNvbnRpbnVlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMzA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMzE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5CcmVhayk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjMyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuU2VtaSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjMzO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuUmV0dXJuKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMzU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18xKSB8ICgxIDw8IENQYXJzZXIuVF9fMikpKSAhPT0gMCkgfHwgKCgoKF9sYSAtIDM5KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDM5KSkgJiAoKDEgPDwgKENQYXJzZXIuU2l6ZW9mIC0gMzkpKSB8ICgxIDw8IChDUGFyc2VyLkFsaWdub2YgLSAzOSkpIHwgKDEgPDwgKENQYXJzZXIuR2VuZXJpYyAtIDM5KSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzOSkpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3MSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3MSkpICYgKCgxIDw8IChDUGFyc2VyLlBsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuUGx1c1BsdXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXMgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTWludXNNaW51cyAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5TdGFyIC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLkFuZCAtIDcxKSkgfCAoMSA8PCAoQ1BhcnNlci5BbmRBbmQgLSA3MSkpIHwgKDEgPDwgKENQYXJzZXIuTm90IC0gNzEpKSB8ICgxIDw8IChDUGFyc2VyLlRpbGRlIC0gNzEpKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMTA1KSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgKF9sYSAtIDEwNSkpICYgKCgxIDw8IChDUGFyc2VyLklkZW50aWZpZXIgLSAxMDUpKSB8ICgxIDw8IChDUGFyc2VyLkNvbnN0YW50IC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5EaWdpdFNlcXVlbmNlIC0gMTA1KSkgfCAoMSA8PCAoQ1BhcnNlci5TdHJpbmdMaXRlcmFsIC0gMTA1KSkpKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjM0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIzNztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLlNlbWkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIzODtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChDUGFyc2VyLkdvdG8pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTIzOTtcclxuICAgICAgICAgICAgdGhpcy51bmFyeUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNDA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBDb21waWxhdGlvblVuaXRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfY29tcGlsYXRpb25Vbml0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkNvbXBpbGF0aW9uVW5pdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuQ29tcGlsYXRpb25Vbml0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21waWxhdGlvblVuaXRDb250ZXh0O1xyXG5cclxuQ29tcGlsYXRpb25Vbml0Q29udGV4dC5wcm90b3R5cGUuRU9GID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihDUGFyc2VyLkVPRiwgMCk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvblVuaXRDb250ZXh0LnByb3RvdHlwZS50cmFuc2xhdGlvblVuaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVHJhbnNsYXRpb25Vbml0Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uVW5pdENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIENWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tcGlsYXRpb25Vbml0KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuQ1BhcnNlci5Db21waWxhdGlvblVuaXRDb250ZXh0ID0gQ29tcGlsYXRpb25Vbml0Q29udGV4dDtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmNvbXBpbGF0aW9uVW5pdCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBDb21waWxhdGlvblVuaXRDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTY0LCBDUGFyc2VyLlJVTEVfY29tcGlsYXRpb25Vbml0KTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNDU7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18zKSB8ICgxIDw8IENQYXJzZXIuVF9fNCkgfCAoMSA8PCBDUGFyc2VyLlRfXzUpIHwgKDEgPDwgQ1BhcnNlci5UX182KSB8ICgxIDw8IENQYXJzZXIuVF9fNykgfCAoMSA8PCBDUGFyc2VyLlRfXzgpIHwgKDEgPDwgQ1BhcnNlci5UX185KSB8ICgxIDw8IENQYXJzZXIuVF9fMTEpIHwgKDEgPDwgQ1BhcnNlci5BdXRvKSB8ICgxIDw8IENQYXJzZXIuQ2hhcikgfCAoMSA8PCBDUGFyc2VyLkNvbnN0KSB8ICgxIDw8IENQYXJzZXIuRG91YmxlKSB8ICgxIDw8IENQYXJzZXIuRW51bSkgfCAoMSA8PCBDUGFyc2VyLkV4dGVybikgfCAoMSA8PCBDUGFyc2VyLkZsb2F0KSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoQ1BhcnNlci5JbnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTG9uZyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaG9ydCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaWduZWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RhdGljIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN0cnVjdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UeXBlZGVmIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuaW9uIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25hcyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQm9vbCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Db21wbGV4IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLk5vcmV0dXJuIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXRpY0Fzc2VydCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UaHJlYWRMb2NhbCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5MZWZ0UGFyZW4gLSAzMikpKSkgIT09IDApIHx8ICgoKChfbGEgLSA3NSkpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSA3NSkpICYgKCgxIDw8IChDUGFyc2VyLlN0YXIgLSA3NSkpIHwgKDEgPDwgKENQYXJzZXIuQ2FyZXQgLSA3NSkpIHwgKDEgPDwgKENQYXJzZXIuU2VtaSAtIDc1KSkgfCAoMSA8PCAoQ1BhcnNlci5JZGVudGlmaWVyIC0gNzUpKSkpICE9PSAwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI0NDtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvblVuaXQoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gMTI0NztcclxuICAgICAgICB0aGlzLm1hdGNoKENQYXJzZXIuRU9GKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBUcmFuc2xhdGlvblVuaXRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfdHJhbnNsYXRpb25Vbml0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblRyYW5zbGF0aW9uVW5pdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuVHJhbnNsYXRpb25Vbml0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2xhdGlvblVuaXRDb250ZXh0O1xyXG5cclxuVHJhbnNsYXRpb25Vbml0Q29udGV4dC5wcm90b3R5cGUuZXh0ZXJuYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHRlcm5hbERlY2xhcmF0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcblRyYW5zbGF0aW9uVW5pdENvbnRleHQucHJvdG90eXBlLnRyYW5zbGF0aW9uVW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChUcmFuc2xhdGlvblVuaXRDb250ZXh0LDApO1xyXG59O1xyXG5cclxuVHJhbnNsYXRpb25Vbml0Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2YgQ1Zpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2xhdGlvblVuaXQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnRyYW5zbGF0aW9uVW5pdCA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVHJhbnNsYXRpb25Vbml0Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICB2YXIgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgIHZhciBfc3RhcnRTdGF0ZSA9IDE2NjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCAxNjYsIENQYXJzZXIuUlVMRV90cmFuc2xhdGlvblVuaXQsIF9wKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTI1MDtcclxuICAgICAgICB0aGlzLmV4dGVybmFsRGVjbGFyYXRpb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTI1NjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEzNSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBUcmFuc2xhdGlvblVuaXRDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX3RyYW5zbGF0aW9uVW5pdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI1MjtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI1MztcclxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEZWNsYXJhdGlvbigpOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI1ODtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMzUsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCggZXJyb3IpIHtcclxuICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gZXJyb3I7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIGVycm9yKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCBlcnJvcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgZXJyb3I7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnJvbGxSZWN1cnNpb25Db250ZXh0cyhfcGFyZW50Y3R4KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gRXh0ZXJuYWxEZWNsYXJhdGlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IENQYXJzZXIuUlVMRV9leHRlcm5hbERlY2xhcmF0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0O1xyXG5cclxuRXh0ZXJuYWxEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmZ1bmN0aW9uRGVmaW5pdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChGdW5jdGlvbkRlZmluaXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRXh0ZXJuYWxEZWNsYXJhdGlvbkNvbnRleHQucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRGVjbGFyYXRpb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5DUGFyc2VyLkV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0ID0gRXh0ZXJuYWxEZWNsYXJhdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5leHRlcm5hbERlY2xhcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEV4dGVybmFsRGVjbGFyYXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMTY4LCBDUGFyc2VyLlJVTEVfZXh0ZXJuYWxEZWNsYXJhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjYyO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMzYsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI1OTtcclxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbkRlZmluaXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNjA7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNjE7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2goQ1BhcnNlci5TZW1pKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvbkRlZmluaXRpb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZnVuY3Rpb25EZWZpbml0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkZ1bmN0aW9uRGVmaW5pdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbkRlZmluaXRpb25Db250ZXh0O1xyXG5cclxuRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdG9yQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uRGVmaW5pdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbXBvdW5kU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbXBvdW5kU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uRGVmaW5pdGlvbkNvbnRleHQucHJvdG90eXBlLmRlY2xhcmF0aW9uU3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChEZWNsYXJhdGlvblNwZWNpZmllcnNDb250ZXh0LDApO1xyXG59O1xyXG5cclxuRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbkRlZmluaXRpb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRGVmaW5pdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbkNQYXJzZXIuRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCA9IEZ1bmN0aW9uRGVmaW5pdGlvbkNvbnRleHQ7XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5mdW5jdGlvbkRlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDE3MCwgQ1BhcnNlci5SVUxFX2Z1bmN0aW9uRGVmaW5pdGlvbik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjY1O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxMzcsdGhpcy5fY3R4KTtcclxuICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjY0O1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uU3BlY2lmaWVycygpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNjc7XHJcbiAgICAgICAgdGhpcy5kZWNsYXJhdG9yKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNjk7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBDUGFyc2VyLlRfXzApIHwgKDEgPDwgQ1BhcnNlci5UX18zKSB8ICgxIDw8IENQYXJzZXIuVF9fNCkgfCAoMSA8PCBDUGFyc2VyLlRfXzUpIHwgKDEgPDwgQ1BhcnNlci5UX182KSB8ICgxIDw8IENQYXJzZXIuVF9fNykgfCAoMSA8PCBDUGFyc2VyLlRfXzgpIHwgKDEgPDwgQ1BhcnNlci5UX185KSB8ICgxIDw8IENQYXJzZXIuVF9fMTEpIHwgKDEgPDwgQ1BhcnNlci5BdXRvKSB8ICgxIDw8IENQYXJzZXIuQ2hhcikgfCAoMSA8PCBDUGFyc2VyLkNvbnN0KSB8ICgxIDw8IENQYXJzZXIuRG91YmxlKSB8ICgxIDw8IENQYXJzZXIuRW51bSkgfCAoMSA8PCBDUGFyc2VyLkV4dGVybikgfCAoMSA8PCBDUGFyc2VyLkZsb2F0KSB8ICgxIDw8IENQYXJzZXIuSW5saW5lKSkpICE9PSAwKSB8fCAoKCgoX2xhIC0gMzIpKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCAoX2xhIC0gMzIpKSAmICgoMSA8PCAoQ1BhcnNlci5JbnQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuTG9uZyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZWdpc3RlciAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5SZXN0cmljdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaG9ydCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5TaWduZWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuU3RhdGljIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN0cnVjdCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UeXBlZGVmIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuaW9uIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlVuc2lnbmVkIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlZvaWQgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuVm9sYXRpbGUgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQWxpZ25hcyAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5BdG9taWMgLSAzMikpIHwgKDEgPDwgKENQYXJzZXIuQm9vbCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5Db21wbGV4IC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLk5vcmV0dXJuIC0gMzIpKSB8ICgxIDw8IChDUGFyc2VyLlN0YXRpY0Fzc2VydCAtIDMyKSkgfCAoMSA8PCAoQ1BhcnNlci5UaHJlYWRMb2NhbCAtIDMyKSkpKSAhPT0gMCkgfHwgX2xhPT09Q1BhcnNlci5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMjY4O1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uTGlzdCgwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjcxO1xyXG4gICAgICAgIHRoaXMuY29tcG91bmRTdGF0ZW1lbnQoKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBEZWNsYXJhdGlvbkxpc3RDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBDUGFyc2VyLlJVTEVfZGVjbGFyYXRpb25MaXN0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkRlY2xhcmF0aW9uTGlzdENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWNsYXJhdGlvbkxpc3RDb250ZXh0O1xyXG5cclxuRGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGVjbGFyYXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRGVjbGFyYXRpb25MaXN0Q29udGV4dC5wcm90b3R5cGUuZGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KERlY2xhcmF0aW9uTGlzdENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EZWNsYXJhdGlvbkxpc3RDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBDVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmF0aW9uTGlzdCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24oX3ApIHtcclxuXHRpZihfcD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBfcCA9IDA7XHJcblx0fVxyXG4gICAgdmFyIF9wYXJlbnRjdHggPSB0aGlzLl9jdHg7XHJcbiAgICB2YXIgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBEZWNsYXJhdGlvbkxpc3RDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gMTcyO1xyXG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIDE3MiwgQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uTGlzdCwgX3ApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjc0O1xyXG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24oKTtcclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTI4MDtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEzOSx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BhcnNlTGlzdGVuZXJzIT09bnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBEZWNsYXJhdGlvbkxpc3RDb250ZXh0KHRoaXMsIF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgQ1BhcnNlci5SVUxFX2RlY2xhcmF0aW9uTGlzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI3NjtcclxuICAgICAgICAgICAgICAgIGlmICghKCB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTI3NztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24oKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyODI7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTM5LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHJ1bGVJbmRleCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHJ1bGVJbmRleCkge1xyXG5cdGNhc2UgMjpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2VuZXJpY0Fzc29jTGlzdF9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgNDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucG9zdGZpeEV4cHJlc3Npb25fc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDU6XHJcblx0XHRcdHJldHVybiB0aGlzLmFyZ3VtZW50RXhwcmVzc2lvbkxpc3Rfc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDk6XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTA6XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZGl0aXZlRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTE6XHJcblx0XHRcdHJldHVybiB0aGlzLnNoaWZ0RXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTI6XHJcblx0XHRcdHJldHVybiB0aGlzLnJlbGF0aW9uYWxFeHByZXNzaW9uX3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSAxMzpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXF1YWxpdHlFeHByZXNzaW9uX3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSAxNDpcclxuXHRcdFx0cmV0dXJuIHRoaXMuYW5kRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTU6XHJcblx0XHRcdHJldHVybiB0aGlzLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTY6XHJcblx0XHRcdHJldHVybiB0aGlzLmluY2x1c2l2ZU9yRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMTc6XHJcblx0XHRcdHJldHVybiB0aGlzLmxvZ2ljYWxBbmRFeHByZXNzaW9uX3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSAxODpcclxuXHRcdFx0cmV0dXJuIHRoaXMubG9naWNhbE9yRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgMjI6XHJcblx0XHRcdHJldHVybiB0aGlzLmV4cHJlc3Npb25fc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDI4OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbml0RGVjbGFyYXRvckxpc3Rfc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDM0OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3REZWNsYXJhdGlvbkxpc3Rfc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDM3OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3REZWNsYXJhdG9yTGlzdF9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgNDA6XHJcblx0XHRcdHJldHVybiB0aGlzLmVudW1lcmF0b3JMaXN0X3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA0ODpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGlyZWN0RGVjbGFyYXRvcl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgNTU6XHJcblx0XHRcdHJldHVybiB0aGlzLnR5cGVRdWFsaWZpZXJMaXN0X3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA1NzpcclxuXHRcdFx0cmV0dXJuIHRoaXMucGFyYW1ldGVyTGlzdF9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgNTk6XHJcblx0XHRcdHJldHVybiB0aGlzLmlkZW50aWZpZXJMaXN0X3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA2MjpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGlyZWN0QWJzdHJhY3REZWNsYXJhdG9yX3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA2NTpcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJMaXN0X3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA2NzpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGVzaWduYXRvckxpc3Rfc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDczOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ibG9ja0l0ZW1MaXN0X3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcblx0Y2FzZSA4MDpcclxuXHRcdFx0cmV0dXJuIHRoaXMuZm9yRXhwcmVzc2lvbl9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgODM6XHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0aW9uVW5pdF9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG5cdGNhc2UgODY6XHJcblx0XHRcdHJldHVybiB0aGlzLmRlY2xhcmF0aW9uTGlzdF9zZW1wcmVkKGxvY2FsY3R4LCBwcmVkSW5kZXgpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcnVsZUluZGV4O1xyXG4gICB9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5nZW5lcmljQXNzb2NMaXN0X3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAwOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5wb3N0Zml4RXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMCk7XHJcblx0XHRjYXNlIDI6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOSk7XHJcblx0XHRjYXNlIDM6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOCk7XHJcblx0XHRjYXNlIDQ6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNyk7XHJcblx0XHRjYXNlIDU6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNik7XHJcblx0XHRjYXNlIDY6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmFyZ3VtZW50RXhwcmVzc2lvbkxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDc6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLm11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgODpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKTtcclxuXHRcdGNhc2UgOTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKTtcclxuXHRcdGNhc2UgMTA6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmFkZGl0aXZlRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMTE6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMik7XHJcblx0XHRjYXNlIDEyOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zaGlmdEV4cHJlc3Npb25fc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDEzOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpO1xyXG5cdFx0Y2FzZSAxNDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUucmVsYXRpb25hbEV4cHJlc3Npb25fc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDE1OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDQpO1xyXG5cdFx0Y2FzZSAxNjpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKTtcclxuXHRcdGNhc2UgMTc6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMik7XHJcblx0XHRjYXNlIDE4OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5lcXVhbGl0eUV4cHJlc3Npb25fc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDE5OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpO1xyXG5cdFx0Y2FzZSAyMDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuYW5kRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMjE6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmV4Y2x1c2l2ZU9yRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMjI6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmluY2x1c2l2ZU9yRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMjM6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmxvZ2ljYWxBbmRFeHByZXNzaW9uX3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAyNDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUubG9naWNhbE9yRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMjU6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmV4cHJlc3Npb25fc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDI2OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5pbml0RGVjbGFyYXRvckxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDI3OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdHJ1Y3REZWNsYXJhdGlvbkxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDI4OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5zdHJ1Y3REZWNsYXJhdG9yTGlzdF9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMjk6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmVudW1lcmF0b3JMaXN0X3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAzMDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGlyZWN0RGVjbGFyYXRvcl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgMzE6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNyk7XHJcblx0XHRjYXNlIDMyOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDYpO1xyXG5cdFx0Y2FzZSAzMzpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KTtcclxuXHRcdGNhc2UgMzQ6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNCk7XHJcblx0XHRjYXNlIDM1OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpO1xyXG5cdFx0Y2FzZSAzNjpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUudHlwZVF1YWxpZmllckxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDM3OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5wYXJhbWV0ZXJMaXN0X3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAzODpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuaWRlbnRpZmllckxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDM5OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5kaXJlY3RBYnN0cmFjdERlY2xhcmF0b3Jfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDQwOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDUpO1xyXG5cdFx0Y2FzZSA0MTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KTtcclxuXHRcdGNhc2UgNDI6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMyk7XHJcblx0XHRjYXNlIDQzOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpO1xyXG5cdFx0Y2FzZSA0NDpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuaW5pdGlhbGl6ZXJMaXN0X3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSA0NTpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZGVzaWduYXRvckxpc3Rfc2VtcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocHJlZEluZGV4KSB7XHJcblx0XHRjYXNlIDQ2OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5DUGFyc2VyLnByb3RvdHlwZS5ibG9ja0l0ZW1MaXN0X3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSA0NzpcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBwcmVkSW5kZXg7XHJcblx0fVxyXG59O1xyXG5cclxuQ1BhcnNlci5wcm90b3R5cGUuZm9yRXhwcmVzc2lvbl9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgNDg6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLnRyYW5zbGF0aW9uVW5pdF9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgNDk6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcbkNQYXJzZXIucHJvdG90eXBlLmRlY2xhcmF0aW9uTGlzdF9zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHByZWRJbmRleCkge1xyXG5cdHN3aXRjaChwcmVkSW5kZXgpIHtcclxuXHRcdGNhc2UgNTA6XHJcblx0XHRcdHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMSk7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBcIk5vIHByZWRpY2F0ZSB3aXRoIGluZGV4OlwiICsgcHJlZEluZGV4O1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5leHBvcnRzLkNQYXJzZXIgPSBDUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYXBwZXIvQ1BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIl0sInNvdXJjZVJvb3QiOiIifQ==